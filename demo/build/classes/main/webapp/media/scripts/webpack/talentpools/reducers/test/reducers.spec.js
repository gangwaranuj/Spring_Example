/* global Application */
import { List, Map } from 'immutable';
import { initialState, rootData, formData, requirementsData } from '../index';
import * as types from '../../constants/actionTypes';

describe('Talent Pool Reducers', () => {
	describe('main reducer', () => {
		let state;

		beforeEach(() => {
			state = Map(initialState.get('rootData'));
		});

		it('should return the initial state', () => {
			expect(rootData(undefined, {})).toEqual(state);
		});

		it('should handle `MANAGE_GROUP` action', () => {
			const action = {
				type: types.MANAGE_GROUP,
				group: {
					id: 123,
					name: 'foo',
					industry: 111,
					owner_id: 222,
					description: 'unit test',
					requires_approval: false,
					searchable: false,
					open_membership: false,
					members: [],
					isActive: false,
					auto_generated: false,
					autoEnforce: false
				},
				memberTabMode: 'all'
			};
			state = state.merge({
				drawerIsOpen: true,
				id: 123,
				name: 'foo',
				industryId: 111,
				groupOwner: 222,
				description: 'unit test',
				requiresApproval: false,
				searchable: false,
				openMembership: 'false',
				members: [],
				autoEnforce: 'false',
				isActive: false,
				autoGenerated: false,
				memberTabMode: 'all'
			});

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `CHANGE_TAB` action', () => {
			const action = {
				type: types.CHANGE_TAB,
				tab: 'tabby'
			};
			state = state.set('activeTab', 'tabby');

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `CLOSE_DRAWER` action', () => {
			const action = {
				type: types.CLOSE_DRAWER
			};
			state = state.set('drawerIsOpen', false);

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `UPDATE_FILTERS` action', () => {
			const action = {
				type: types.UPDATE_FILTERS,
				filters: {
					foo: 'bar'
				}
			};
			state = state.merge({
				filters: {
					foo: 'bar'
				}
			});

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `FETCH_TALENT_POOLS_SUCCESS` action', () => {
			const action = {
				type: types.FETCH_TALENT_POOLS_SUCCESS,
				readOnly: false,
				response: [
					{
						foo: 'bar'
					}
				]
			};
			state = state.merge({
				talentPools: [
					{
						foo: 'bar'
					}
				],
				isFetchingTalentPools: false
			});

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `FETCH_TALENT_POOLS_FAIL` action', () => {
			const action = {
				type: types.FETCH_TALENT_POOLS_FAIL,
				error: {
					foo: 'bar'
				}
			};
			state = state.merge({
				error: { foo: 'bar' },
				isFetchingTalentPools: false
			});

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `SUBMIT_TALENT_POOL_FORM_SUCCESS` action', () => {
			const action = {
				type: types.SUBMIT_TALENT_POOL_FORM_SUCCESS,
				updatedTalentPool: {
					id: 123,
					name: 'hi there'
				}
			};
			state = state.merge({
				id: 123,
				name: 'hi there'
			});

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle `GET_MEMBERS_SUCCESS` action', () => {
			const action = {
				type: types.GET_MEMBERS_SUCCESS,
				count: 1,
				response: [
					{
						foo: 'bar'
					}
				]
			};
			state = state.merge({
				members: [
					{
						foo: 'bar',
						selected: false,
						actionMenuIsOpen: false
					}
				],
				memberResultsCount: 1
			});

			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle the `SHOW_INVITE_FLOW` action', () => {
			const action = {
				type: types.SHOW_INVITE_FLOW,
				inviting: true
			};
			state = state.merge({
				inviting: true
			});
			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle the `INVITE_MEMBERS_SUCCESS` action', () => {
			const action = {
				type: types.INVITE_MEMBERS_SUCCESS,
				response: {
					successful: true,
					messages: [
						'Test Message'
					]
				},
				id: 123
			};

			state = state.merge({
				inviting: false,
				filters: []
			});
			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle the `TALENT_POOL_SORT_CHANGED` action', () => {
			const action = {
				type: types.TALENT_POOL_SORT_CHANGED,
				sortedTalentPools: [
					{
						name: 'aaa',
						count: '3'
					}
				],
				fieldName: 'count',
				sortDirection: 'asc'
			};

			const talentPools = [
				{
					name: 'aaa',
					count: '3'
				}
			];

			state = state.merge({
				talentPools,
				talentPoolSortField: 'count',
				talentPoolSortDirection: 'asc'
			});
			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle the `OPEN_BULK_ACTION_MENU` action', () => {
			const action = {
				type: types.OPEN_BULK_ACTION_MENU,
				isOpen: true
			};
			state = state.merge({
				bulkMenuIsOpen: true
			});
			expect(rootData(undefined, action)).toEqual(state);
		});

		it('should handle the `OPEN_MEMBER_ACTION_MENU` action', () => {
			const action = {
				type: types.OPEN_MEMBER_ACTION_MENU,
				id: 123,
				isOpen: true
			};
			const testInitialState = state.merge({
				members: [
					{
						id: 123,
						actionMenuIsOpen: false
					}
				]
			});
			state = state.merge({
				members: [
					{
						id: 123,
						actionMenuIsOpen: true
					}
				]
			});
			expect(rootData(testInitialState, action)).toEqual(state);
		});

		it('should handle the `MEMBER_PAGINATION_CHANGED` action', () => {
			const action = {
				type: types.MEMBER_PAGINATION_CHANGED,
				page: 2
			};
			state = state.merge({
				memberResultPage: 2
			});
			expect(rootData(undefined, action)).toEqual(state);
		});
	});

	describe('requirements reducer', () => {
		let state;

		beforeEach(() => {
			state = Map(initialState.get('requirementsData'));
		});

		it('should return the initial state', () => {
			expect(requirementsData(undefined, {})).toEqual(state);
		});

		it('should handle `ADD_REQUIREMENT` action', () => {
			const action = {
				type: types.ADD_REQUIREMENT,
				requirement: {
					key: 'minSatisfactionRating',
					name: 'foobar',
					value: 123
				}
			};
			state = state.merge({
				requirements: [
					{
						key: 'minSatisfactionRating',
						name: 'foobar',
						value: 123
					}
				]
			});

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `REMOVE_REQUIREMENT` action', () => {
			const action = {
				type: types.REMOVE_REQUIREMENT,
				requirementKey: 'minSatisfactionRating',
				requirementValue: 123
			};
			state = state.merge({
				requirements: []
			});

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `CHANGE_REQUIREMENT_FIELD` action', () => {
			const action = {
				type: types.CHANGE_REQUIREMENT_FIELD,
				name: 'minSatisfactionRating',
				value: 55
			};
			state = state.set('minSatisfactionRating', 55);

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `CHANGE_DEEP_REQUIREMENT_FIELD` action', () => {
			const action = {
				type: types.CHANGE_DEEP_REQUIREMENT_FIELD,
				name: 'license',
				fieldName: 'licenseId',
				value: 1023
			};
			state = state.setIn(['license', 'licenseId'], 1023);

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `SET_ACTIVE_REQUIREMENT_TYPE` action', () => {
			const action = {
				type: types.SET_ACTIVE_REQUIREMENT_TYPE,
				requirementType: 'foobar'
			};
			state = state.set('activeRequirementType', 'foobar');

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `CANCEL_REQUIREMENT` action', () => {
			const action = {
				type: types.CANCEL_REQUIREMENT
			};
			state = state.set('activeRequirementType', '');

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `INIT_REQUIREMENTS` action', () => {
			const action = {
				type: types.INIT_REQUIREMENTS,
				id: 123,
				autoEnforce: true
			};
			state = state.set('id', 123).set('autoEnforce', 'true');

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `ACTIVATE_AUTO_ENFORCEMENT_SUCCESS` action', () => {
			const action = {
				type: types.ACTIVATE_AUTO_ENFORCEMENT_SUCCESS,
				result: 'true'
			};
			state = state.set('autoEnforce', 'true');

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `GET_REQUIREMENT_SET_SUCCESS` action', () => {
			const action = {
				type: types.GET_REQUIREMENT_SET_SUCCESS,
				response: { foo: 'bar' }
			};
			state = state.set('requirementsModel', Map({ foo: 'bar' }));

			expect(requirementsData(undefined, action)).toEqual(state);
		});

		it('should handle `GET_REQUIREMENTS_SUCCESS` action', () => {
			const action = {
				type: types.GET_REQUIREMENTS_SUCCESS,
				response: [{ foo: 'bar' }]
			};
			state = state.merge({
				requirements: [{ foo: 'bar' }],
				requirementsLoad: [{ foo: 'bar' }]
			});

			expect(requirementsData(undefined, action)).toEqual(state);
		});
	});

	describe('form reducer', () => {
		let state;

		beforeEach(() => {
			state = Map(initialState.get('formData'));
		});

		it('should return the initial state', () => {
			expect(formData(undefined, {})).toEqual(state);
		});

		it('should handle `CHANGE_FIELD` action', () => {
			const action = {
				type: types.CHANGE_FIELD,
				name: 'name',
				value: 'foobar'
			};

			state = state.merge({
				name: 'foobar',
				talentPoolHasUpdated: true
			});

			expect(formData(undefined, action)).toEqual(state);
		});

		it('should handle `REMOVE_ORG_UNIT` action', () => {
			const startState = Map(initialState.get('formData')).merge({
				orgUnitUuids: List(['abc-001', 'abc-002']),
			});


			const action = {
				type: types.REMOVE_ORG_UNIT,
				value: 'abc-001'
			};

			state = state.merge({
				orgUnitUuids: List(['abc-002']),
				talentPoolHasUpdated: true,
			});

			expect(formData(startState, action)).toEqual(state);
		});

		it('should handle `CHANGE_ORG_MODE` action', () => {
			const startState = Map(initialState.get('formData'));

			const orgMode = {
				uuid: 'org-001',
				name: 'Org A'
			};

			const action = {
				type: types.CHANGE_ORG_MODE,
				value: orgMode
			};

			state = state.merge({
				orgMode: Map(orgMode),
			});

			expect(formData(startState, action)).toEqual(state);
		});

		it('should handle `FETCH_ORG_UNIT_MEMBERS_SUCCESS` action in basic case', () => {
			const startState = Map(initialState.get('formData')).merge({
				groupOwner: 'user-001',
				owners: [['user-001', 'Alex Astonishing'], ['user-002', 'Beth Blissful']]
			});

			const action = {
				type: types.FETCH_ORG_UNIT_MEMBERS_SUCCESS,
				response: [{
					id: 'user-001',
					firstName: 'Alex',
					lastName: 'Astonishing'
				}]
			};

			state = state.merge({
				groupOwner: 'user-001',
				owners: List([['user-001', 'Alex Astonishing']])
			});

			expect(formData(startState, action)).toEqual(state);
		});

		it('should handle `FETCH_ORG_UNIT_MEMBERS_SUCCESS` action when current groupOwner not included', () => {
			const startState = Map(initialState.get('formData')).merge({
				groupOwner: 'user-001',
				owners: [['user-001', 'Alex Astonishing'], ['user-002', 'Beth Blissful']]
			});

			const action = {
				type: types.FETCH_ORG_UNIT_MEMBERS_SUCCESS,
				response: [ {
					id: 'user-003',
					firstName: 'Carl',
					lastName: 'Cooling'
				}]
			};

			state = state.merge({
				groupOwner: 'user-003',
				owners: List([['user-003', 'Carl Cooling']])
			});

			expect(formData(startState, action)).toEqual(state);
		});

		it('should handle `FETCH_ORG_UNIT_MEMBERS_SUCCESS` action when no users from response', () => {
			const startState = Map(initialState.get('formData')).merge({
				groupOwner: 'user-001',
				owners: [['user-001', 'Alex Astonishing'], ['user-002', 'Beth Blissful']]
			});

			const action = {
				type: types.FETCH_ORG_UNIT_MEMBERS_SUCCESS,
				response: []
			};

			state = state.merge({
				groupOwner: '0',
				owners: List([])
			});

			expect(formData(startState, action)).toEqual(state);
		});

		it('should handle `NEW_TALENT_POOL` action', () => {
			const orgMode = {
				uuid: 'org-001',
				name: 'Org A'
			};
			const startState = Map(initialState.get('formData')).merge({
				orgMode: Map(orgMode)
			});

			const action = {
				type: types.NEW_TALENT_POOL
			};
			state = state.merge({
				id: 0,
				name: '',
				description: '',
				groupOwner: 0,
				industryId: 0,
				openMembership: 'true',
				publiclyAvailable: true,
				searchable: false,
				requiresApproval: false,
				autoGenerated: false,
				orgMode: orgMode,
				orgUnits: [orgMode],
				orgUnitUuids: [orgMode.uuid]
			});

			expect(formData(startState, action)).toEqual(state);
		});

		it('should handle `LOAD_EXISTING_GROUP` action', () => {
			const action = {
				type: types.LOAD_EXISTING_GROUP,
				group: {
					id: 666,
					name: 'friends of the dark lord',
					description: 'cool people',
					owner_id: 2,
					industry: 3,
					open_membership: 'false',
					publiclyAvailable: true,
					searchable: true,
					requires_approval: false,
					isActive: false,
					auto_generated: true,
					org_units: [
						{
							uuid: 'org-001',
							name: 'Org A'
						},
						{
							uuid: 'org-002',
							name: 'Org B',
							path: ['Org A']
						}
					]
				}
			};
			state = state.merge({
				id: 666,
				name: 'friends of the dark lord',
				description: 'cool people',
				groupOwner: 2,
				industryId: 3,
				openMembership: 'false',
				publiclyAvailable: true,
				searchable: true,
				requiresApproval: false,
				isActive: false,
				autoGenerated: true,
				orgUnits: [
					{
						uuid: 'org-001',
						name: 'Org A'
					},
					{
						uuid: 'org-002',
						name: 'Org B',
						path: ['Org A']
					}
				],
				orgUnitUuids: ['org-001', 'org-002']
			});

			expect(formData(undefined, action)).toEqual(state);
		});
	});
});
