import { Map, List, fromJS } from 'immutable';
import _ from 'underscore';
import * as types from '../constants/actionTypes';
import * as interactionModes from '../constants/interactionModes';
import Application from '../../core';
import wmAlert from '../../funcs/wmAlert';

// TODO [@jdewitt]: this should be using const, reassignment should be dispatched by action
let initialState = Map({ // eslint-disable-line import/no-mutable-exports
	rootData: Map({
		id: null,
		drawerIsOpen: false,
		interactionMode: interactionModes.MANAGE,
		name: '',
		description: '',
		groupOwner: 0,
		industryId: 0,
		openMembership: 'false',
		publiclyAvailable: true,
		searchable: false,
		requiresApproval: false,
		isActive: false,
		talentPools: [],
		groupMemberSearchResults: [],
		groupMemberSearchFilters: [],
		talentPoolHasUpdated: false,
		hasVendorPoolsFeature: false,
		hasESignatureEnabled: false,
		hasMarketplace: false,
		isDeleteModalOpen: false,
		isFetchingTalentPools: false,
		isFetchingSearchResults: false,
		isFetchingMessages: false,
		isSavingRequirements: false,
		isSaving: false,
		activeTab: 'details',
		error: '',
		members: List([]),
		allInvitedOrApplied: List([]),
		filters: Map({}),
		activeFilters: List([]),
		memberTabMode: 'all',
		inviting: false,
		selectedAll: false,
		selectionLength: 0,
		talentPoolSortField: 'name',
		talentPoolSortDirection: 'asc',
		bulkMenuIsOpen: false,
		memberResultsCount: 0,
		memberResultPage: 1,
		readOnly: false,
		autoGenerated: false,
		memberResultPageSize: 50
	}),
	formData: Map({
		id: 0,
		name: '',
		description: '',
		groupOwner: 0,
		defaultOwner: 0,
		industryId: 0,
		openMembership: 'true',
		isActive: false,
		isDeleteModalOpen: false,
		publiclyAvailable: true,
		searchable: false,
		requiresApproval: false,
		industries: List([]),
		orgMode: Map({
			uuid: '',
			name: '',
			paths: List([])
		}),
		orgUnitUuids: List([]),
		orgUnits: List([]),
		owners: List([]),
		skills: List([]),
		suggestedSkills: List([]),
		autoGenerated: false,
		readOnly: false,
		talentPoolHasUpdated: false,
		requirementsModel: {}
	}),
	requirementsData: Map({
		id: 0,
		agreements: List([]),
		countries: List([]),
		companyTypes: List([]),
		documents: List([]),
		industries: List([]),
		requirementSets: List([]),
		requirements: List([]),
		requirementsLoad: List([]),
		eSignatures: List([]),
		talentPoolMemberships: List([]),
		workerTypes: List([
			{
				id: 1,
				name: 'Employee'
			},
			{
				id: 2,
				name: 'Contractor'
			}
		]),
		activeRequirementType: '',
		assessmentId: null,
		autoEnforce: 'false',
		availabilityStartTime: new Date(),
		availabilityEndTime: new Date(),
		companyType: null,
		country: null,
		day: Map({
			id: null,
			name: null
		}),
		googleInitialized: false,
		hasBackgroundCheck: false,
		certification: Map({
			certificationId: null,
			notifyOnExpiration: false,
			removeMembershipOnExpiration: false
		}),
		insurance: Map({
			insuranceId: null,
			notifyOnExpiration: false,
			removeMembershipOnExpiration: false,
			minimumCoverageEnabled: false,
			minimumCoverageAmount: null
		}),
		license: Map({
			licenseId: null,
			notifyOnExpiration: false,
			removeMembershipOnExpiration: false
		}),
		minSatisfactionRating: 0,
		maxAbandonedValue: 0,
		maxCancelledValue: 0,
		minDeliverableOnTimePercentage: 0,
		minOnTimePercentage: 0,
		maxTravelDistanceValue: 10,
		readOnly: false,
		travelDistanceLocation: Map({
			address1: '',
			city: '',
			state: '',
			country: '',
			postalCode: null,
			latitude: null,
			longitude: null
		}),
		talentPoolMembership: null,
		workerType: null
	}),
	messagesData: Map({
		groupId: 0,
		isActive: false,
		readOnly: false,
		messages: []
	}),
	messageFormData: Map({
		title: '',
		message: ''
	})
});

Application.Events.on('application:initialize', () => {
	if (!_.isUndefined(Application.Data.id)) {
		initialState = initialState.mergeDeep({
			rootData: {
				id: Application.Data.id,
				name: Application.Data.name,
				industryId: Application.Data.industry,
				groupOwner: Application.Data.owner,
				description: Application.Data.description,
				requiresApproval: Application.Data.requiresApproval,
				searchable: Application.Data.isSearchable,
				openMembership: String(Application.Data.openMembership),
				isActive: Application.Data.isActive,
				drawerIsOpen: true,
				interactionMode: interactionModes.MANAGE,
				hasVendorPoolsFeature: Application.Data.hasVendorPoolsFeature,
				hasESignatureEnabled: Application.Data.hasESignatureEnabled,
				hasMarketplace: Application.Data.hasMarketplace
			},
			formData: {
				id: Application.Data.id,
				name: Application.Data.name,
				industryId: Application.Data.industry,
				groupOwner: Application.Data.owner,
				description: Application.Data.description,
				requiresApproval: Application.Data.requiresApproval,
				searchable: Application.Data.isSearchable,
				openMembership: String(Application.Data.openMembership),
				isActive: Application.Data.isActive,
				owners: Application.Data.owners,
				industries: Application.Data.industries,
				autoGenerated: Application.Data.autoGenerated
			},
			requirementsData: {
				id: Application.Data.id,
				industries: Application.Data.industries
			}
		});
	} else {
		initialState = initialState.mergeDeep({
			rootData: {
				hasVendorPoolsFeature: Application.Data.hasVendorPoolsFeature,
				hasESignatureEnabled: Application.Data.hasESignatureEnabled,
				hasMarketplace: Application.Data.hasMarketplace
			},
			formData: {
				owners: Application.Data.owners,
				industries: Application.Data.industries,
				defaultOwner: Application.Data.creator.toString()
			},
			requirementsData: {
				industries: Application.Data.industries
			}
		});
	}
});

export { initialState };
export const rootData = (state = initialState.get('rootData'), action) => {
	switch (action.type) {
	case types.MANAGE_GROUP: {
		const activeTalentPool = action.group;
		let activeTab = state.get('activeTab');
		if (activeTalentPool.open_membership === false && (activeTab === 'requirements' || activeTab === 'messages')) {
			activeTab = 'details';
		}
		return state.merge({
			drawerIsOpen: true,
			activeTab,
			interactionMode: interactionModes.MANAGE,
			id: activeTalentPool.id,
			name: activeTalentPool.name,
			autoGenerated: activeTalentPool.auto_generated,
			industryId: activeTalentPool.industry,
			groupOwner: activeTalentPool.owner_id,
			description: activeTalentPool.description,
			requiresApproval: activeTalentPool.requires_approval,
			searchable: activeTalentPool.searchable,
			openMembership: activeTalentPool.open_membership.toString(),
			isActive: activeTalentPool.isActive,
			members: [],
			allInvitedOrApplied: [],
			autoEnforce: activeTalentPool.autoEnforce.toString(),
			memberTabMode: action.memberTabMode,
			inviting: false,
			selectionLength: 0,
			memberResultPage: 1,
			memberResultsCount: 0
		});
	}
	case types.NEW_TALENT_POOL:
		return state.merge({
			drawerIsOpen: true,
			interactionMode: interactionModes.CREATE
		});
	case types.CHANGE_TAB:
		return state.set('activeTab', action.tab);
	case types.CLOSE_DRAWER:
		return state.merge({
			inviting: false,
			memberResultPage: 1,
			memberResultsCount: 0,
			activeFilters: List([]),
			drawerIsOpen: false
		});
	case types.UPDATE_FILTERS:
		return state.merge({
			filters: action.filters
		});
	case types.FETCH_TALENT_POOLS:
		return state.merge({
			isFetchingTalentPools: true
		});
	case types.FETCH_TALENT_POOLS_SUCCESS:
		return state.merge({
			talentPools: action.response,
			readOnly: action.readOnly,
			isFetchingTalentPools: false
		});
	case types.FETCH_TALENT_POOLS_FAIL:
		return state.merge({
			error: action.error,
			isFetchingTalentPools: false
		});
	case types.FETCH_ORG_UNITS:
		return state.merge({
			isFetchingOrgUnits: true
		});
	case types.FETCH_ORG_UNITS_SUCCESS:
		return state.merge({
			isFetchingOrgUnits: false
		});
	case types.SUBMIT_TALENT_POOL_FORM_SUCCESS:
		return state.merge(action.updatedTalentPool);
	case types.SUBMIT_TALENT_POOL_FORM_CREATE_SUCCESS:
		return state.merge(action.createdTalentPool);
	case types.GET_MEMBERS:
		return state.merge({
			isFetchingSearchResults: true
		});
	case types.GET_INVITED_OR_APPLIED_SUCCESS:
		return state.merge({
			allInvitedOrApplied: action.response
		});
	case types.GET_MEMBERS_SUCCESS: {
		const newMembersArr = action.response.map((member) => {
			const returnMember = member;
			returnMember.selected = false;
			returnMember.actionMenuIsOpen = false;
			return returnMember;
		});

		return state.merge({
			members: newMembersArr,
			isFetchingSearchResults: false,
			selectionLength: 0,
			memberResultsCount: action.count,
			selectedAll: false
		});
	}
	case types.GET_MEMBERS_FAIL:
		return state.merge({
			isFetchingMembers: false
		});
	case types.TOGGLE_TALENT_POOL_ACTIVE: {
		const talentPools = state.get('talentPools').toArray();
		for (let i = 0; i < talentPools.length; i += 1) {
			if (talentPools[i].get('id') === action.groupId) {
				const talentPoolObj = talentPools[i].toObject();
				talentPoolObj.isActive = action.isActive;
				talentPools[i] = talentPoolObj;
				break;
			}
		}
		return state.merge({
			isActive: action.isActive,
			talentPools
		});
	}
	case types.SHOW_INVITE_FLOW:
		Application.Events.trigger('talentpools:resetSearchFilter');
		return state.merge({
			memberResultPage: 1,
			memberResultsCount: 0,
			activeFilters: List([]),
			inviting: action.inviting
		});
	case types.ADD_TO_SELECTION: {
		const userAddArray = state.get('members').toJS();
		const updatedUsers = userAddArray.map((user) => {
			if (user.userNumber === action.user.userNumber) {
				const userObj = user;
				userObj.selected = true;
				return userObj;
			}
			return user;
		});
		const numSelected = updatedUsers.filter(user => user.selected).length;
		return state.merge({
			members: updatedUsers,
			selectionLength: numSelected
		});
	}
	case types.REMOVE_FROM_SELECTION: {
		const userRemoveArray = state.get('members').toJS();
		const updatedUsers = userRemoveArray.map((user) => {
			if (user.userNumber === action.user.userNumber) {
				const userObj = user;
				userObj.selected = false;
				return userObj;
			}
			return user;
		});
		const numSelected = updatedUsers.filter(user => user.selected).length;
		return state.merge({
			members: updatedUsers,
			selectionLength: numSelected
		});
	}
	case types.TOGGLE_SELECT_ALL: {
		const userArray = state.get('members').toJS();
		const updatedUsers = userArray.map((user) => {
			const userObj = user;
			userObj.selected = action.selected;
			return userObj;
		});
		const numSelected = updatedUsers.filter(user => user.selected).length;
		return state.merge({
			members: updatedUsers,
			selectedAll: action.selected,
			selectionLength: numSelected
		});
	}
	case types.INVITE_MEMBERS_SUCCESS:
		return state.merge({
			inviting: false,
			memberResultPage: 1,
			memberResultsCount: 0,
			filters: []
		});
	case types.TALENT_POOL_SORT_CHANGED:
		return state.merge({
			talentPools: action.sortedTalentPools,
			talentPoolSortField: action.fieldName,
			talentPoolSortDirection: action.sortDirection
		});
	case types.OPEN_BULK_ACTION_MENU:
		return state.set('bulkMenuIsOpen', action.isOpen);
	case types.OPEN_MEMBER_ACTION_MENU: {
		const userArray = state.get('members').toJS();
		const updatedUsers = userArray.map((user) => {
			if (user.userNumber === action.userNumber) {
				const userObj = user;
				userObj.actionMenuIsOpen = action.isOpen;
				return userObj;
			}
			return user;
		});
		return state.merge({
			members: updatedUsers
		});
	}
	case types.REMOVE_DECLINE_SUCCESS: {
		const users = state.get('members').toJS().filter((user) => {
			return action.users.map((selectedUser) => {
				return selectedUser.userNumber;
			}).indexOf(user.userNumber) < 0;
		});
		const numSelected = users.filter(user => user.selected).length;
		return state.merge({
			selectionLength: numSelected
		});
	}
	case types.UNINVITE_SUCCESS: {
		const users = state.get('members').toJS().filter((user) => {
			return action.users.map((selectedUser) => {
				return selectedUser.userNumber;
			}).indexOf(user.userNumber) < 0;
		});
		const numSelected = users.filter(user => user.selected).length;
		return state.merge({
			selectionLength: numSelected
		});
	}
	case types.SEARCH_FILTER_UPDATE:
		return state.merge({
			activeFilters: action.filterObject,
			memberResultPage: 1,
			memberResultsCount: 0
		});
	case types.MEMBER_PAGINATION_CHANGED: {
		return state.merge({
			memberResultPage: action.page
		});
	}
	case types.DELETE_TALENT_POOL_SUCCESS: {
		return state.set('drawerIsOpen', false);
	}
	case types.FETCH_MESSAGES: {
		return state.merge({
			isFetchingMessages: true
		});
	}
	case types.FETCH_MESSAGES_SUCCESS:
	case types.FETCH_MESSAGES_FAIL: {
		return state.merge({
			isFetchingMessages: false
		});
	}
	case types.SUBMIT_TALENT_POOL_FORM: {
		return state.merge({
			isSaving: true
		});
	}
	case types.SUBMIT_TALENT_POOL_FORM_FAIL: {
		return state.merge({
			isSaving: false
		});
	}
	case types.SAVE_REQUIREMENT_STARTED: {
		return state.merge({
			isSavingRequirements: true
		});
	}
	case types.SAVE_REQUIREMENT_SUCCESS:
	case types.SAVE_REQUIREMENT_FAIL: {
		return state.merge({
			isSavingRequirements: false
		});
	}
	default:
		return state;
	}
};

// google places uses different names than our API does
const addressMap = {
	lat: 'latitude',
	lng: 'longitude'
};

export const requirementsData = (state = initialState.get('requirementsData'), action) => {
	switch (action.type) {
	case types.ADD_REQUIREMENT: {
		let duplicates = [];
		const existingReqs = state.get('requirements').toJS();
		if (action.multiSelect) {
			duplicates = state.get('requirements').toJS().filter((req) => {
				return (req.$type === action.requirement.$type &&
				req.requirable.id === action.requirement.requirable.id);
			});
		} else {
			duplicates = state.get('requirements').toJS().filter((req) => {
				const name = req.name || req.requirable.name;
				return (req.$type === action.requirement.$type && name === action.requirement.name);
			});
		}
		if (action.requirementType === 'time') {
			duplicates = state.get('requirements').toJS().filter((req) => {
				return (req.$type === action.requirement.$type &&
					req.dayOfWeek === action.requirement.dayOfWeek);
			});
		}
		if (duplicates.length === 0) {
			existingReqs.push(action.requirement);
		} else {
			const duplicateReqName = action.requirement.name || action.requirement.requirable.name;
			wmAlert({
				type: 'danger',
				message: `${duplicateReqName} cannot be added because a requirement of the same type already exists.`
			});
		}
		return state.merge({
			requirements: existingReqs,
			activeRequirementType: ''
		});
	}
	case types.CLEAR_TOGGLED_REQUIREMENTS: {
		return state.merge({
			availabilityStartTime: initialState.getIn(['requirementsData', 'availabilityStartTime']),
			availabilityEndTime: initialState.getIn(['requirementsData', 'availabilityEndTime']),
			assessmentId: initialState.getIn(['requirementsData', 'assessmentId']),
			companyType: initialState.getIn(['requirementsData', 'companyType']),
			country: initialState.getIn(['requirementsData', 'country']),
			insurance: Map().mergeDeep(initialState.getIn(['requirementsData', 'insurance'])),
			license: Map().mergeDeep(initialState.getIn(['requirementsData', 'license'])),
			certification: Map().mergeDeep(initialState.getIn(['requirementsData', 'certification'])),
			maxAbandonedValue: initialState.getIn(['requirementsData', 'maxAbandonedValue']),
			maxTravelDistanceValue: initialState.getIn(['requirementsData', 'maxTravelDistanceValue']),
			minDeliverableOnTimePercentage: initialState.getIn(['requirementsData', 'minDeliverableOnTimePercentage']),
			minOnTimePercentage: initialState.getIn(['requirementsData', 'minOnTimePercentage']),
			minSatisfactionRating: initialState.getIn(['requirementsData', 'minSatisfactionRating']),
			talentPoolMembership: initialState.getIn(['requirementsData', 'talentPoolMembership']),
			travelDistanceLocation: Map().mergeDeep(initialState.getIn(['requirementsData', 'travelDistanceLocation'])),
			workerType: initialState.getIn(['requirementsData', 'workerType']),
			day: Map().mergeDeep(initialState.getIn(['requirementsData', 'day']))
		});
	}
	case types.REMOVE_REQUIREMENT: {
		const reqs = state.get('requirements').toJS().filter((req) => {
			const name = req.name || req.requirable.name;
			return !(req.$type === action.requirementKey && name === action.requirementValue);
		});
		return state.merge({
			requirements: reqs
		});
	}
	case types.TOGGLE_REMOVE_ON_EXPIRY_REQUIREMENT: {
		const reqs = state.get('requirements').toJS();
		reqs.forEach((req) => {
			const name = req.name || req.requirable.name;
			if (req.$type === action.requirementKey && name === action.requirementValue) {
				req.removeMembershipOnExpiry = // eslint-disable-line no-param-reassign
					!req.removeMembershipOnExpiry;
			}
		});
		return state.merge({
			requirements: reqs
		});
	}
	case types.TOGGLE_NOTIFY_ON_EXPIRY_REQUIREMENT: {
		const reqs = state.get('requirements').toJS();
		reqs.forEach((req) => {
			const name = req.name || req.requirable.name;
			if (req.$type === action.requirementKey && name === action.requirementValue) {
				req.notifyOnExpiry = !req.notifyOnExpiry; // eslint-disable-line no-param-reassign
			}
		});
		return state.merge({
			requirements: reqs
		});
	}
	case types.CHANGE_REQUIREMENT_FIELD:
		return state.set(action.name, action.value);
	case types.CHANGE_DEEP_REQUIREMENT_FIELD:
		return state.setIn([action.name, action.fieldName], action.value);
	case types.CHANGE_LOCATION_FIELD:
		{
			const fieldName = addressMap[action.fieldName] || action.fieldName;
			return state.setIn([action.name, fieldName], action.value);
		}
	case types.CLOSE_DRAWER:
		return state.set('requirements', initialState.get(['requirementsData', 'requirements']));
	case types.SET_ACTIVE_REQUIREMENT_TYPE:
		return state.set('activeRequirementType', action.requirementType);
	case types.CANCEL_REQUIREMENT:
		return state.set('activeRequirementType', '');
	case types.INIT_REQUIREMENTS:
		return state.set('id', action.id).set('autoEnforce', action.autoEnforce.toString());
	case types.ACTIVATE_AUTO_ENFORCEMENT_SUCCESS:
		return state.set('autoEnforce', action.result);
	case types.FETCH_AGREEMENTS_SUCCESS:
		return state.set('agreements', action.response);
	case types.FETCH_COUNTRIES_SUCCESS:
		return state.set('countries', action.response);
	case types.FETCH_COMPANY_TYPES_SUCCESS:
		return state.set('companyTypes', action.response);
	case types.FETCH_DOCUMENTS_SUCCESS:
		return state.set('documents', action.response);
	case types.FETCH_ESIGNATURES_SUCCESS:
		return state.set('eSignatures', action.response.results);
	case types.FETCH_TALENT_POOL_MEMBERSHIPS_SUCCESS:
		return state.set('talentPoolMemberships', action.response);
	case types.GET_REQUIREMENT_SET_SUCCESS:
		return state.set('requirementsModel', Map(action.response));
	case types.GET_REQUIREMENTS_SUCCESS:
		return state.merge({
			requirements: action.response,
			requirementsLoad: action.response
		});
	case types.GOOGLE_INITIALIZED:
		return state.set('googleInitialized', true);
	case types.FETCH_TALENT_POOLS_SUCCESS:
		return state.merge({
			readOnly: action.readOnly
		});
	default:
		return state;
	}
};

export const formData = (state = initialState.get('formData'), action) => {
	switch (action.type) {
	case types.CHANGE_FIELD:
		return state.merge({
			[action.name]: action.value,
			talentPoolHasUpdated: true
		});
	case types.ADD_SKILLS:
		{
			const updatedSkills = state.get('skills').push(action.value);
			return state.merge({
				skills: updatedSkills,
				suggestedSkills: initialState.getIn(['formData', 'suggestedSkills']),
				talentPoolHasUpdated: true
			});
		}
	case types.REMOVE_SKILLS:
		{
			return state.merge({
				skills: state.get('skills').filterNot(skill => skill.id === action.value),
				talentPoolHasUpdated: true
			});
		}
	case types.NEW_TALENT_POOL:
		const currentOrgMode = state.get('orgMode');
		const orgUnits = currentOrgMode ? List([currentOrgMode]) : List([]);
		const orgUnitUuids = currentOrgMode ? List([currentOrgMode.get('uuid')]) : List([]);
		return initialState.get('formData')
			.set('groupOwner', state.get('defaultOwner'))
			.set('orgMode', currentOrgMode)
			.set('orgUnits', orgUnits)
			.set('orgUnitUuids', orgUnitUuids);
	case types.SUBMIT_TALENT_POOL_FORM_CREATE_SUCCESS:
		return state.set('id', action.createdTalentPool.id);
	case types.LOAD_EXISTING_GROUP:
		{
			const activeTalentPool = action.group;
			return state.merge({
				id: activeTalentPool.id,
				name: activeTalentPool.name,
				industryId: activeTalentPool.industry,
				groupOwner: activeTalentPool.owner_id,
				description: activeTalentPool.description,
				requiresApproval: activeTalentPool.requires_approval,
				searchable: activeTalentPool.searchable,
				openMembership: activeTalentPool.open_membership.toString(),
				autoGenerated: activeTalentPool.auto_generated,
				isActive: activeTalentPool.isActive,
				talentPoolHasUpdated: false,
				skills: new List(activeTalentPool.skills),
				orgUnits: fromJS(activeTalentPool.org_units),
				orgUnitUuids: List(activeTalentPool.org_units
					? activeTalentPool.org_units.map(orgUnit => orgUnit.uuid)
					: []
				)
			});
		}
	case types.TOGGLE_TALENT_POOL_ACTIVE:
		return state.merge({
			isActive: action.isActive
		});
	case types.FETCH_TALENT_POOLS_SUCCESS:
		return state.merge({
			readOnly: action.readOnly
		});
	case types.FETCH_SUGGESTED_SKILLS_SUCCESS:
		return state.merge({
			suggestedSkills: action.response
		});
	case types.DELETE_TALENT_POOL:
		return state.set('isDeleteModalOpen', true);
	case types.DELETE_TALENT_POOL_CANCEL:
		return state.set('isDeleteModalOpen', false);
	case types.DELETE_TALENT_POOL_SUCCESS:
		return state.set('isDeleteModalOpen', false);
	case types.SUBMIT_TALENT_POOL_FORM_SUCCESS:
		return state.set('talentPoolHasUpdated', false);
	case types.FETCH_ORG_UNITS_SUCCESS:
		return state.merge({ orgUnits: action.response });
	case types.FETCH_ORG_UNIT_MEMBERS_SUCCESS:
		const members = action.response;
		const currentOwner = members.find(user => `${user.id}` === state.get('groupOwner'));
		return state.merge({
			groupOwner: currentOwner ? state.get('groupOwner') : `${members.length && members[0].id}`,
			owners: List(members.map(user => [`${user.id}`, `${user.firstName} ${user.lastName}`]))
		});
	case types.REMOVE_ORG_UNIT:
		return state.merge({
			orgUnitUuids: state.get('orgUnitUuids').filter(it => it !== action.value),
			talentPoolHasUpdated: true
		});
	case types.CHANGE_ORG_MODE:
		return state.merge({
			orgMode: action.value
		});
	default:
		return state;
	}
};

export const messagesData = (state = initialState.get('messagesData'), action) => {
	switch (action.type) {
	case types.CLEAR_MESSAGES:
		return state.merge({
			messages: []
		});
	case types.FETCH_MESSAGES_SUCCESS:
		return state.merge({
			groupId: action.groupId,
			messages: action.response.messages
		});
	case types.MANAGE_GROUP:
		return state.merge({
			groupId: action.group.id,
			isActive: action.group.isActive
		});
	case types.TOGGLE_TALENT_POOL_ACTIVE:
		return state.merge({
			isActive: action.isActive
		});
	case types.FETCH_TALENT_POOLS_SUCCESS:
		return state.merge({
			readOnly: action.readOnly
		});
	default:
		return state;
	}
};

export const messageFormData = (state = initialState.get('messageFormData'), action) => {
	switch (action.type) {
	case types.CHANGE_MESSAGE_FIELD:
		return state.set(action.name, action.value);
	case types.SUBMIT_MESSAGE_FORM_SUCCESS:
		return state.merge({
			title: '',
			message: ''
		});
	default:
		return state;
	}
};
