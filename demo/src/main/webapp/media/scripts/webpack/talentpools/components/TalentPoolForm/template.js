import React from 'react';
import { Map } from 'immutable';
import PropTypes from 'prop-types';
import Radium from 'radium';
import {
	commonStyles,
	WMAutocompleteChips,
	WMCheckbox,
	WMFormRow,
	WMMenuItem,
	WMModal,
	WMPaper,
	WMRadioButton,
	WMRadioButtonGroup,
	WMRaisedButton,
	WMSelectField,
	WMSelectFieldChips,
	WMStackedMenuItem,
	WMToggle,
	WMTextField
} from '@workmarket/front-end-components';

const { baseColors } = commonStyles.colors;

const organizeOrgUnits = (orgUnitUuids, defaultOrgUnitUuid) => {
	if (!orgUnitUuids) {
		return List([]);
	}

	let organized = orgUnitUuids.filter(it => it !== defaultOrgUnitUuid);
	if (orgUnitUuids.indexOf(defaultOrgUnitUuid) !== -1) {
		organized = organized.unshift(defaultOrgUnitUuid);
	}
	return organized;
};

const TalentPoolForm = ({
	onFetchSkill,
	onChangeSkillsField,
	onRemoveSkillsField,
	onChangeField,
	onRemoveOrgUnit,
	onSubmitTalentPoolForm,
	onToggleActive,
	onDeleteTalentPool,
	onDeleteTalentPoolConfirm,
	onDeleteTalentPoolCancel,
	talentPoolFormData,
	enableOrgStructures,
	defaultOrgUnitUuid,
}) => {
	const industryElements = talentPoolFormData.get('industries').toArray().map((industryMap, index) => (
		<WMMenuItem key={ index } value={ industryMap.get('id') } primaryText={ industryMap.get('name') } />
	));

	const ownerElements = talentPoolFormData.get('owners').toArray().map(owner => (
		<WMMenuItem key={ owner[0] } value={ owner[0] } primaryText={ owner[1] } />
	));

	const deleteConfirmTemplateActions = [
		<WMRaisedButton
			label="Cancel"
			secondary
			onClick={ () => onDeleteTalentPoolCancel() }
		/>,
		<WMRaisedButton
			label="Delete"
			primary
			style={ { marginLeft: '1em' } }
			onClick={ () => onDeleteTalentPoolConfirm(talentPoolFormData.get('id')) }
		/>
	];

	let availableOrgUnits = null;
	let orgUnitElements = null;
	let orgUnitChips = null;
	if (enableOrgStructures) {
		availableOrgUnits = talentPoolFormData.get('orgUnits');

		orgUnitElements = availableOrgUnits
			.map(orgUnitMap => {
				const orgUnitUuid = orgUnitMap.get('uuid');
				const pathDelimiter = ' > ';
				const orgUnitPath = orgUnitMap.get('paths');
				const menuItemSecondaryText = orgUnitPath && orgUnitPath.size ?
					orgUnitPath.join(pathDelimiter).concat(pathDelimiter) : null;
				return <WMStackedMenuItem
					disabled={ orgUnitUuid === defaultOrgUnitUuid }
					key={ orgUnitUuid }
					value={ orgUnitUuid }
					primaryText={ orgUnitMap.get('name') }
					secondaryText={ menuItemSecondaryText }
				/>
			});

		orgUnitChips = organizeOrgUnits(talentPoolFormData.get('orgUnitUuids'), defaultOrgUnitUuid)
			.map(orgUnitId => {
				const orgUnit = availableOrgUnits.find(it => it.get('uuid') === orgUnitId);
				return orgUnit ? {
					id: orgUnit.get('uuid'),
					label: orgUnit.get('name'),
					value: orgUnit.get('uuid'),
					meta: orgUnit.get('uuid'),
					isSticky: orgUnit.get('uuid') === defaultOrgUnitUuid
				} : null;
			}).filter(Boolean);
	}

	const deleteAction =
		(<div>
			<WMFormRow
				labelText=""
				id="delete"
			>
				<a
					style={ {
						cursor: 'pointer',
						textDecoration: 'none',
						margin: '1em 0 0 1em',
						color: baseColors.red
					} }
					onClick={ () => onDeleteTalentPool(talentPoolFormData.get('id')) }
				>
					Delete Talent Pool
				</a>
			</WMFormRow>
			<WMModal
				open={ talentPoolFormData.get('isDeleteModalOpen') ? talentPoolFormData.get('isDeleteModalOpen') : false }
				title={ 'Are you sure you want to delete this talent pool?' }
				style={ { zIndex: '10001' } }
				modal={ false }
				actions={ deleteConfirmTemplateActions }
			/>
		</div>);

	return (
		<WMPaper
			style={ { padding: '1em' } }
		>
			<form>
				<WMFormRow
					labelText="Name"
					id="name"
					required={ !talentPoolFormData.get('readOnly') }
				>
					<WMTextField
						disabled={ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') }
						name="name"
						fullWidth
						value={ talentPoolFormData.get('name') }
						onChange={ (event, value) => onChangeField('name', value) }
					/>
				</WMFormRow>

				{ talentPoolFormData.get('openMembership') === 'false' ? null :
				<WMFormRow
					labelText="Industry"
					id="industry"
					required={ !talentPoolFormData.get('readOnly') }
				>
					<WMSelectField
						onChange={ (event, index, value) => onChangeField('industryId', value) }
						fullWidth
						name="industry"
						disabled={ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') }
						value={ talentPoolFormData.get('industryId') }
					>
						{ industryElements }
					</WMSelectField>
				</WMFormRow>
				}

				{ enableOrgStructures &&
				<WMFormRow
					labelText="Org Units"
					id="orgunits"
					required
				>
					<WMSelectFieldChips
						chips={ orgUnitChips }
						fullWidth
						name="orgunits"
						onChange={ (event, index, value) => onChangeField('orgUnitUuids', value) }
						onRemoveChip={ onRemoveOrgUnit }
					>
						{ orgUnitElements }
					</WMSelectFieldChips>
				</WMFormRow>
				}

				<WMFormRow
					id="skills"
					labelText="Skills"
				>
					<WMAutocompleteChips
						chips={ talentPoolFormData.get('skills') }
						chipLabelKey={ 'name' }
						chipMetaKey={ 'id' }
						dataSource={ talentPoolFormData.get('suggestedSkills').toJS() }
						dataSourceConfig={ { text: 'name', value: 'id' } }
						hintText="Type Skill..."
						name="skills"
						onUpdateInput={ event => onFetchSkill(event) }
						onAddChip={ value => onChangeSkillsField(value) }
						onRemoveChip={ metaKey => onRemoveSkillsField(metaKey) }
						readOnly={ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') }
						style={ { color: 'blue', flex: '1' } }
					/>
				</WMFormRow>

				<WMFormRow
					labelText="Owner"
					id="owner"
					required={ !talentPoolFormData.get('readOnly') }
				>
					<WMSelectField
						disabled={ talentPoolFormData.get('readOnly') }
						onChange={ (event, index, value) => onChangeField('groupOwner', value) }
						fullWidth
						name="owner"
						value={ talentPoolFormData.get('groupOwner') }
					>
						{ ownerElements }
					</WMSelectField>
				</WMFormRow>

				<WMFormRow
					labelText="Description"
					id="description"
					required={ !talentPoolFormData.get('readOnly') }
				>
					<WMTextField
						name="description"
						fullWidth
						multiLine
						disabled={ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') }
						value={ talentPoolFormData.get('description') }
						onChange={ (event, value) => onChangeField('description', value) }
					/>
				</WMFormRow>

				<WMFormRow
					labelText="Type"
					id="type"
					required={ !talentPoolFormData.get('readOnly') }
				>
					<WMRadioButtonGroup
						name="openMembership"
						onChange={ (event, value) => onChangeField('openMembership', value) }
						valueSelected={ talentPoolFormData.get('openMembership') }
					>
						<WMRadioButton
							disabled
							name="openMembership"
							label="Visible to workers (public)"
							value="true"
						/>

						<WMRadioButton
							disabled
							name="openMembership"
							label="Only visible to my company (private)"
							value="false"
							style={ { marginBottom: '1em' } }
						/>
					</WMRadioButtonGroup>
				</WMFormRow>

				{ talentPoolFormData.get('openMembership') === 'false' ? null :
				<WMFormRow
					labelText="Public Options"
					id="public-options"
				>
					<div>
						<WMCheckbox
							name="requiresApproval"
							id="requiresApproval"
							label="Review Applicants Manually"
							onCheck={ (event, value) => onChangeField('requiresApproval', value) }
							checked={ talentPoolFormData.get('requiresApproval') }
							disabled={ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') }
						/>
						<WMCheckbox
							name="searchable"
							id="searchable"
							label="Allow workers to discover Talent Pool in marketplace"
							onCheck={ (event, value) => onChangeField('searchable', value) }
							checked={ talentPoolFormData.get('searchable') }
							style={ { marginBottom: '1em' } }
							disabled={ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') }
						/>
					</div>
				</WMFormRow>
				}
				{ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') ? null :
				<WMFormRow
					labelText="Active"
					id="active"
				>
					<div style={ { marginLeft: '.2em', marginTop: '.8em' } }>
						<a onClick={ () => onToggleActive(talentPoolFormData.get('id'), talentPoolFormData.get('name'), talentPoolFormData.get('isActive')) }>
							<WMToggle
								className="material-icons"
								toggled={ talentPoolFormData.get('isActive') }
							/>
						</a>
					</div>
				</WMFormRow>
				}

				{ talentPoolFormData.get('autoGenerated') || talentPoolFormData.get('readOnly') ? null : deleteAction }

				{ talentPoolFormData.get('readOnly') ? null :
				<div style={ { flexDirection: 'row-reverse', display: 'flex' } }>
					<WMRaisedButton
						label="Update Talent Pool"
						style={ { margin: '1em 0 0 1em' } }
						disabled={ !talentPoolFormData.get('talentPoolHasUpdated') }
						backgroundColor={ talentPoolFormData.get('talentPoolHasUpdated') ? baseColors.green : baseColors.white }
						labelColor={ talentPoolFormData.get('talentPoolHasUpdated') ? baseColors.white : baseColors.charcoalGrey }
						id="saveTalentPool"
						onClick={ () => {
							onSubmitTalentPoolForm(talentPoolFormData);
						} }
					/>
				</div>
				}
			</form>
		</WMPaper>
	);
};
export default Radium(TalentPoolForm);

TalentPoolForm.propTypes = {
	onFetchSkill: PropTypes.func.isRequired,
	onChangeField: PropTypes.func.isRequired,
	onChangeSkillsField: PropTypes.func.isRequired,
	onRemoveSkillsField: PropTypes.func.isRequired,
	onRemoveOrgUnit: PropTypes.func,
	onSubmitTalentPoolForm: PropTypes.func.isRequired,
	onToggleActive: PropTypes.func.isRequired,
	onDeleteTalentPool: PropTypes.func.isRequired,
	onDeleteTalentPoolConfirm: PropTypes.func.isRequired,
	onDeleteTalentPoolCancel: PropTypes.func.isRequired,
	talentPoolFormData: PropTypes.instanceOf(Map),
	enableOrgStructures: PropTypes.bool,
	defaultOrgUnitUuid: PropTypes.string
};
