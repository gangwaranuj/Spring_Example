webpackJsonp([4],{

/***/ "./node_modules/video.js/dist/video.js":
/***/ (function(module, exports) {

/**
 * @license
 * Video.js 5.11.7 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.videojs = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = _dereq_('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nbG9iYWwvZG9jdW1lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuIl19
},{"min-document":3}],2:[function(_dereq_,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIl19
},{}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
var getNative = _dereq_('../internal/getNative');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeNow = getNative(Date, 'now');

/**
 * Gets the number of milliseconds that have elapsed since the Unix epoch
 * (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @category Date
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => logs the number of milliseconds it took for the deferred function to be invoked
 */
var now = nativeNow || function() {
  return new Date().getTime();
};

module.exports = now;

},{"../internal/getNative":20}],5:[function(_dereq_,module,exports){
var isObject = _dereq_('../lang/isObject'),
    now = _dereq_('../date/now');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed invocations. Provide an options object to indicate that `func`
 * should be invoked on the leading and/or trailing edge of the `wait` timeout.
 * Subsequent calls to the debounced function return the result of the last
 * `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=false] Specify invoking on the leading
 *  edge of the timeout.
 * @param {number} [options.maxWait] The maximum time `func` is allowed to be
 *  delayed before it's invoked.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing
 *  edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // avoid costly calculations while the window size is in flux
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // ensure `batchLog` is invoked once after 1 second of debounced calls
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', _.debounce(batchLog, 250, {
 *   'maxWait': 1000
 * }));
 *
 * // cancel a debounced call
 * var todoChanges = _.debounce(batchLog, 1000);
 * Object.observe(models.todo, todoChanges);
 *
 * Object.observe(models, function(changes) {
 *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
 *     todoChanges.cancel();
 *   }
 * }, ['delete']);
 *
 * // ...at some point `models.todo` is changed
 * models.todo.completed = true;
 *
 * // ...before 1 second has passed `models.todo` is deleted
 * // which cancels the debounced `todoChanges` call
 * delete models.todo;
 */
function debounce(func, wait, options) {
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = wait < 0 ? 0 : (+wait || 0);
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (isObject(options)) {
    leading = !!options.leading;
    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (maxTimeoutId) {
      clearTimeout(maxTimeoutId);
    }
    lastCalled = 0;
    maxTimeoutId = timeoutId = trailingCall = undefined;
  }

  function complete(isCalled, id) {
    if (id) {
      clearTimeout(id);
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (isCalled) {
      lastCalled = now();
      result = func.apply(thisArg, args);
      if (!timeoutId && !maxTimeoutId) {
        args = thisArg = undefined;
      }
    }
  }

  function delayed() {
    var remaining = wait - (now() - stamp);
    if (remaining <= 0 || remaining > wait) {
      complete(trailingCall, maxTimeoutId);
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  }

  function maxDelayed() {
    complete(trailing, timeoutId);
  }

  function debounced() {
    args = arguments;
    stamp = now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0 || remaining > maxWait;

      if (isCalled) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result = func.apply(thisArg, args);
      }
      else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (isCalled && timeoutId) {
      timeoutId = clearTimeout(timeoutId);
    }
    else if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      isCalled = true;
      result = func.apply(thisArg, args);
    }
    if (isCalled && !timeoutId && !maxTimeoutId) {
      args = thisArg = undefined;
    }
    return result;
  }
  debounced.cancel = cancel;
  return debounced;
}

module.exports = debounce;

},{"../date/now":4,"../lang/isObject":33}],6:[function(_dereq_,module,exports){
/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],7:[function(_dereq_,module,exports){
var debounce = _dereq_('./debounce'),
    isObject = _dereq_('../lang/isObject');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed invocations. Provide an options object to indicate
 * that `func` should be invoked on the leading and/or trailing edge of the
 * `wait` timeout. Subsequent calls to the throttled function return the
 * result of the last `func` call.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the the throttled function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=true] Specify invoking on the leading
 *  edge of the timeout.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing
 *  edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // avoid excessively updating the position while scrolling
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
 * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
 *   'trailing': false
 * }));
 *
 * // cancel a trailing throttled call
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (options === false) {
    leading = false;
  } else if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
}

module.exports = throttle;

},{"../lang/isObject":33,"./debounce":5}],8:[function(_dereq_,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function arrayCopy(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = arrayCopy;

},{}],9:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],10:[function(_dereq_,module,exports){
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],11:[function(_dereq_,module,exports){
var createBaseFor = _dereq_('./createBaseFor');

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./createBaseFor":18}],12:[function(_dereq_,module,exports){
var baseFor = _dereq_('./baseFor'),
    keysIn = _dereq_('../object/keysIn');

/**
 * The base implementation of `_.forIn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForIn(object, iteratee) {
  return baseFor(object, iteratee, keysIn);
}

module.exports = baseForIn;

},{"../object/keysIn":39,"./baseFor":11}],13:[function(_dereq_,module,exports){
var arrayEach = _dereq_('./arrayEach'),
    baseMergeDeep = _dereq_('./baseMergeDeep'),
    isArray = _dereq_('../lang/isArray'),
    isArrayLike = _dereq_('./isArrayLike'),
    isObject = _dereq_('../lang/isObject'),
    isObjectLike = _dereq_('./isObjectLike'),
    isTypedArray = _dereq_('../lang/isTypedArray'),
    keys = _dereq_('../object/keys');

/**
 * The base implementation of `_.merge` without support for argument juggling,
 * multiple sources, and `this` binding `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {Object} Returns `object`.
 */
function baseMerge(object, source, customizer, stackA, stackB) {
  if (!isObject(object)) {
    return object;
  }
  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
      props = isSrcArr ? undefined : keys(source);

  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObjectLike(srcValue)) {
      stackA || (stackA = []);
      stackB || (stackB = []);
      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
    }
    else {
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
      }
      if ((result !== undefined || (isSrcArr && !(key in object))) &&
          (isCommon || (result === result ? (result !== value) : (value === value)))) {
        object[key] = result;
      }
    }
  });
  return object;
}

module.exports = baseMerge;

},{"../lang/isArray":30,"../lang/isObject":33,"../lang/isTypedArray":36,"../object/keys":38,"./arrayEach":9,"./baseMergeDeep":14,"./isArrayLike":21,"./isObjectLike":26}],14:[function(_dereq_,module,exports){
var arrayCopy = _dereq_('./arrayCopy'),
    isArguments = _dereq_('../lang/isArguments'),
    isArray = _dereq_('../lang/isArray'),
    isArrayLike = _dereq_('./isArrayLike'),
    isPlainObject = _dereq_('../lang/isPlainObject'),
    isTypedArray = _dereq_('../lang/isTypedArray'),
    toPlainObject = _dereq_('../lang/toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
  var length = stackA.length,
      srcValue = source[key];

  while (length--) {
    if (stackA[length] == srcValue) {
      object[key] = stackB[length];
      return;
    }
  }
  var value = object[key],
      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
      isCommon = result === undefined;

  if (isCommon) {
    result = srcValue;
    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
      result = isArray(value)
        ? value
        : (isArrayLike(value) ? arrayCopy(value) : []);
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      result = isArguments(value)
        ? toPlainObject(value)
        : (isPlainObject(value) ? value : {});
    }
    else {
      isCommon = false;
    }
  }
  // Add the source value to the stack of traversed objects and associate
  // it with its merged value.
  stackA.push(srcValue);
  stackB.push(result);

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
  } else if (result === result ? (result !== value) : (value === value)) {
    object[key] = result;
  }
}

module.exports = baseMergeDeep;

},{"../lang/isArguments":29,"../lang/isArray":30,"../lang/isPlainObject":34,"../lang/isTypedArray":36,"../lang/toPlainObject":37,"./arrayCopy":8,"./isArrayLike":21}],15:[function(_dereq_,module,exports){
var toObject = _dereq_('./toObject');

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : toObject(object)[key];
  };
}

module.exports = baseProperty;

},{"./toObject":28}],16:[function(_dereq_,module,exports){
var identity = _dereq_('../utility/identity');

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":42}],17:[function(_dereq_,module,exports){
var bindCallback = _dereq_('./bindCallback'),
    isIterateeCall = _dereq_('./isIterateeCall'),
    restParam = _dereq_('../function/restParam');

/**
 * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"../function/restParam":6,"./bindCallback":16,"./isIterateeCall":24}],18:[function(_dereq_,module,exports){
var toObject = _dereq_('./toObject');

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{"./toObject":28}],19:[function(_dereq_,module,exports){
var baseProperty = _dereq_('./baseProperty');

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

module.exports = getLength;

},{"./baseProperty":15}],20:[function(_dereq_,module,exports){
var isNative = _dereq_('../lang/isNative');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

module.exports = getNative;

},{"../lang/isNative":32}],21:[function(_dereq_,module,exports){
var getLength = _dereq_('./getLength'),
    isLength = _dereq_('./isLength');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

module.exports = isArrayLike;

},{"./getLength":19,"./isLength":25}],22:[function(_dereq_,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
var isHostObject = (function() {
  try {
    Object({ 'toString': 0 } + '');
  } catch(e) {
    return function() { return false; };
  }
  return function(value) {
    // IE < 9 presents many host objects as `Object` objects that can coerce
    // to strings despite having improperly defined `toString` methods.
    return typeof value.toString != 'function' && typeof (value + '') == 'string';
  };
}());

module.exports = isHostObject;

},{}],23:[function(_dereq_,module,exports){
/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],24:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('./isArrayLike'),
    isIndex = _dereq_('./isIndex'),
    isObject = _dereq_('../lang/isObject');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

module.exports = isIterateeCall;

},{"../lang/isObject":33,"./isArrayLike":21,"./isIndex":23}],25:[function(_dereq_,module,exports){
/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],26:[function(_dereq_,module,exports){
/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],27:[function(_dereq_,module,exports){
var isArguments = _dereq_('../lang/isArguments'),
    isArray = _dereq_('../lang/isArray'),
    isIndex = _dereq_('./isIndex'),
    isLength = _dereq_('./isLength'),
    isString = _dereq_('../lang/isString'),
    keysIn = _dereq_('../object/keysIn');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object) || isString(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":29,"../lang/isArray":30,"../lang/isString":35,"../object/keysIn":39,"./isIndex":23,"./isLength":25}],28:[function(_dereq_,module,exports){
var isObject = _dereq_('../lang/isObject'),
    isString = _dereq_('../lang/isString'),
    support = _dereq_('../support');

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  if (support.unindexedChars && isString(value)) {
    var index = -1,
        length = value.length,
        result = Object(value);

    while (++index < length) {
      result[index] = value.charAt(index);
    }
    return result;
  }
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":33,"../lang/isString":35,"../support":41}],29:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('../internal/isArrayLike'),
    isObjectLike = _dereq_('../internal/isObjectLike');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{"../internal/isArrayLike":21,"../internal/isObjectLike":26}],30:[function(_dereq_,module,exports){
var getNative = _dereq_('../internal/getNative'),
    isLength = _dereq_('../internal/isLength'),
    isObjectLike = _dereq_('../internal/isObjectLike');

/** `Object#toString` result references. */
var arrayTag = '[object Array]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

module.exports = isArray;

},{"../internal/getNative":20,"../internal/isLength":25,"../internal/isObjectLike":26}],31:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 which returns 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

module.exports = isFunction;

},{"./isObject":33}],32:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isHostObject = _dereq_('../internal/isHostObject'),
    isObjectLike = _dereq_('../internal/isObjectLike');

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
}

module.exports = isNative;

},{"../internal/isHostObject":22,"../internal/isObjectLike":26,"./isFunction":31}],33:[function(_dereq_,module,exports){
/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],34:[function(_dereq_,module,exports){
var baseForIn = _dereq_('../internal/baseForIn'),
    isArguments = _dereq_('./isArguments'),
    isHostObject = _dereq_('../internal/isHostObject'),
    isObjectLike = _dereq_('../internal/isObjectLike'),
    support = _dereq_('../support');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * **Note:** This method assumes objects created by the `Object` constructor
 * have no inherited enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  var Ctor;

  // Exit early for non `Object` objects.
  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||
      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
    return false;
  }
  // IE < 9 iterates inherited properties before own properties. If the first
  // iterated property is an object's own property then there are no inherited
  // enumerable properties.
  var result;
  if (support.ownLast) {
    baseForIn(value, function(subValue, key, object) {
      result = hasOwnProperty.call(object, key);
      return false;
    });
    return result !== false;
  }
  // In most environments an object's own properties are iterated before
  // its inherited properties. If the last iterated property is an object's
  // own property then there are no inherited enumerable properties.
  baseForIn(value, function(subValue, key) {
    result = key;
  });
  return result === undefined || hasOwnProperty.call(value, result);
}

module.exports = isPlainObject;

},{"../internal/baseForIn":12,"../internal/isHostObject":22,"../internal/isObjectLike":26,"../support":41,"./isArguments":29}],35:[function(_dereq_,module,exports){
var isObjectLike = _dereq_('../internal/isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
}

module.exports = isString;

},{"../internal/isObjectLike":26}],36:[function(_dereq_,module,exports){
var isLength = _dereq_('../internal/isLength'),
    isObjectLike = _dereq_('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
}

module.exports = isTypedArray;

},{"../internal/isLength":25,"../internal/isObjectLike":26}],37:[function(_dereq_,module,exports){
var baseCopy = _dereq_('../internal/baseCopy'),
    keysIn = _dereq_('../object/keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable
 * properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return baseCopy(value, keysIn(value));
}

module.exports = toPlainObject;

},{"../internal/baseCopy":10,"../object/keysIn":39}],38:[function(_dereq_,module,exports){
var getNative = _dereq_('../internal/getNative'),
    isArrayLike = _dereq_('../internal/isArrayLike'),
    isObject = _dereq_('../lang/isObject'),
    shimKeys = _dereq_('../internal/shimKeys'),
    support = _dereq_('../support');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/getNative":20,"../internal/isArrayLike":21,"../internal/shimKeys":27,"../lang/isObject":33,"../support":41}],39:[function(_dereq_,module,exports){
var arrayEach = _dereq_('../internal/arrayEach'),
    isArguments = _dereq_('../lang/isArguments'),
    isArray = _dereq_('../lang/isArray'),
    isFunction = _dereq_('../lang/isFunction'),
    isIndex = _dereq_('../internal/isIndex'),
    isLength = _dereq_('../internal/isLength'),
    isObject = _dereq_('../lang/isObject'),
    isString = _dereq_('../lang/isString'),
    support = _dereq_('../support');

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/** Used to fix the JScript `[[DontEnum]]` bug. */
var shadowProps = [
  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
  'toLocaleString', 'toString', 'valueOf'
];

/** Used for native method references. */
var errorProto = Error.prototype,
    objectProto = Object.prototype,
    stringProto = String.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to avoid iterating over non-enumerable properties in IE < 9. */
var nonEnumProps = {};
nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };
nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };
nonEnumProps[objectTag] = { 'constructor': true };

arrayEach(shadowProps, function(key) {
  for (var tag in nonEnumProps) {
    if (hasOwnProperty.call(nonEnumProps, tag)) {
      var props = nonEnumProps[tag];
      props[key] = hasOwnProperty.call(props, key);
    }
  }
});

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;

  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object) || isString(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,
      isProto = proto === object,
      result = Array(length),
      skipIndexes = length > 0,
      skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
      skipProto = support.enumPrototypes && isFunction(object);

  while (++index < length) {
    result[index] = (index + '');
  }
  // lodash skips the `constructor` property when it infers it's iterating
  // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
  // attribute of an existing property and the `constructor` property of a
  // prototype defaults to non-enumerable.
  for (var key in object) {
    if (!(skipProto && key == 'prototype') &&
        !(skipErrorProps && (key == 'message' || key == 'name')) &&
        !(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  if (support.nonEnumShadows && object !== objectProto) {
    var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),
        nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];

    if (tag == objectTag) {
      proto = objectProto;
    }
    length = shadowProps.length;
    while (length--) {
      key = shadowProps[length];
      var nonEnum = nonEnums[key];
      if (!(isProto && nonEnum) &&
          (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
        result.push(key);
      }
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/arrayEach":9,"../internal/isIndex":23,"../internal/isLength":25,"../lang/isArguments":29,"../lang/isArray":30,"../lang/isFunction":31,"../lang/isObject":33,"../lang/isString":35,"../support":41}],40:[function(_dereq_,module,exports){
var baseMerge = _dereq_('../internal/baseMerge'),
    createAssigner = _dereq_('../internal/createAssigner');

/**
 * Recursively merges own enumerable properties of the source object(s), that
 * don't resolve to `undefined` into the destination object. Subsequent sources
 * overwrite property assignments of previous sources. If `customizer` is
 * provided it's invoked to produce the merged values of the destination and
 * source properties. If `customizer` returns `undefined` merging is handled
 * by the method instead. The `customizer` is bound to `thisArg` and invoked
 * with five arguments: (objectValue, sourceValue, key, object, source).
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 *
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 *
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 *
 * // using a customizer callback
 * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
 *
 * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
 *
 * _.merge(object, other, function(a, b) {
 *   if (_.isArray(a)) {
 *     return a.concat(b);
 *   }
 * });
 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 */
var merge = createAssigner(baseMerge);

module.exports = merge;

},{"../internal/baseMerge":13,"../internal/createAssigner":17}],41:[function(_dereq_,module,exports){
/** Used for native method references. */
var arrayProto = Array.prototype,
    errorProto = Error.prototype,
    objectProto = Object.prototype;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/**
 * An object environment feature flags.
 *
 * @static
 * @memberOf _
 * @type Object
 */
var support = {};

(function(x) {
  var Ctor = function() { this.x = x; },
      object = { '0': x, 'length': x },
      props = [];

  Ctor.prototype = { 'valueOf': x, 'y': x };
  for (var key in new Ctor) { props.push(key); }

  /**
   * Detect if `name` or `message` properties of `Error.prototype` are
   * enumerable by default (IE < 9, Safari < 5.1).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
    propertyIsEnumerable.call(errorProto, 'name');

  /**
   * Detect if `prototype` properties are enumerable by default.
   *
   * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
   * (if the prototype or a property on the prototype has been set)
   * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
   * property to `true`.
   *
   * @memberOf _.support
   * @type boolean
   */
  support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');

  /**
   * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
   *
   * In IE < 9 an object's own properties, shadowing non-enumerable ones,
   * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.nonEnumShadows = !/valueOf/.test(props);

  /**
   * Detect if own properties are iterated after inherited properties (IE < 9).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.ownLast = props[0] != 'x';

  /**
   * Detect if `Array#shift` and `Array#splice` augment array-like objects
   * correctly.
   *
   * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array
   * `shift()` and `splice()` functions that fail to remove the last element,
   * `value[0]`, of array-like objects even though the "length" property is
   * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,
   * while `splice()` is buggy regardless of mode in IE < 9.
   *
   * @memberOf _.support
   * @type boolean
   */
  support.spliceObjects = (splice.call(object, 0, 1), !object[0]);

  /**
   * Detect lack of support for accessing string characters by index.
   *
   * IE < 8 can't access characters by index. IE 8 can only access characters
   * by index on string literals, not string objects.
   *
   * @memberOf _.support
   * @type boolean
   */
  support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
}(1, 0));

module.exports = support;

},{}],42:[function(_dereq_,module,exports){
/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],43:[function(_dereq_,module,exports){
'use strict';

var keys = _dereq_('object-keys');

module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	if (typeof sym === 'string') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(Object(sym) instanceof Symbol)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; }
	if (keys(obj).length !== 0) { return false; }
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{"object-keys":50}],44:[function(_dereq_,module,exports){
'use strict';

// modified from https://github.com/es-shims/es6-shim
var keys = _dereq_('object-keys');
var bind = _dereq_('function-bind');
var canBeObject = function (obj) {
	return typeof obj !== 'undefined' && obj !== null;
};
var hasSymbols = _dereq_('./hasSymbols')();
var toObject = Object;
var push = bind.call(Function.call, Array.prototype.push);
var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function assign(target, source1) {
	if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
	var objTarget = toObject(target);
	var s, source, i, props, syms, value, key;
	for (s = 1; s < arguments.length; ++s) {
		source = toObject(arguments[s]);
		props = keys(source);
		if (hasSymbols && Object.getOwnPropertySymbols) {
			syms = Object.getOwnPropertySymbols(source);
			for (i = 0; i < syms.length; ++i) {
				key = syms[i];
				if (propIsEnumerable(source, key)) {
					push(props, key);
				}
			}
		}
		for (i = 0; i < props.length; ++i) {
			key = props[i];
			value = source[key];
			if (propIsEnumerable(source, key)) {
				objTarget[key] = value;
			}
		}
	}
	return objTarget;
};

},{"./hasSymbols":43,"function-bind":49,"object-keys":50}],45:[function(_dereq_,module,exports){
'use strict';

var defineProperties = _dereq_('define-properties');

var implementation = _dereq_('./implementation');
var getPolyfill = _dereq_('./polyfill');
var shim = _dereq_('./shim');

defineProperties(implementation, {
	implementation: implementation,
	getPolyfill: getPolyfill,
	shim: shim
});

module.exports = implementation;

},{"./implementation":44,"./polyfill":52,"./shim":53,"define-properties":46}],46:[function(_dereq_,module,exports){
'use strict';

var keys = _dereq_('object-keys');
var foreach = _dereq_('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":47,"object-keys":50}],47:[function(_dereq_,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],48:[function(_dereq_,module,exports){
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],49:[function(_dereq_,module,exports){
var implementation = _dereq_('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":48}],50:[function(_dereq_,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = _dereq_('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":51}],51:[function(_dereq_,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],52:[function(_dereq_,module,exports){
'use strict';

var implementation = _dereq_('./implementation');

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	// note: this does not detect the bug unless there's 20 characters
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	// which is 72% slower than our shim, and Firefox 40's native implementation.
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};

},{"./implementation":44}],53:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('define-properties');
var getPolyfill = _dereq_('./polyfill');

module.exports = function shimAssign() {
	var polyfill = getPolyfill();
	define(
		Object,
		{ assign: polyfill },
		{ assign: function () { return Object.assign !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":52,"define-properties":46}],54:[function(_dereq_,module,exports){
module.exports = SafeParseTuple

function SafeParseTuple(obj, reviver) {
    var json
    var error = null

    try {
        json = JSON.parse(obj, reviver)
    } catch (err) {
        error = err
    }

    return [error, json]
}

},{}],55:[function(_dereq_,module,exports){
function clean (s) {
  return s.replace(/\n\r?\s*/g, '')
}


module.exports = function tsml (sa) {
  var s = ''
    , i = 0

  for (; i < arguments.length; i++)
    s += clean(sa[i]) + (arguments[i + 1] || '')

  return s
}
},{}],56:[function(_dereq_,module,exports){
"use strict";
var window = _dereq_("global/window")
var once = _dereq_("once")
var isFunction = _dereq_("is-function")
var parseHeaders = _dereq_("parse-headers")
var xtend = _dereq_("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    var callback = options.callback
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)

    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data || null
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            aborted=true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}

function noop() {}

},{"global/window":2,"is-function":57,"once":58,"parse-headers":61,"xtend":62}],57:[function(_dereq_,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],58:[function(_dereq_,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],59:[function(_dereq_,module,exports){
var isFunction = _dereq_('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":57}],60:[function(_dereq_,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],61:[function(_dereq_,module,exports){
var trim = _dereq_('trim')
  , forEach = _dereq_('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":59,"trim":60}],62:[function(_dereq_,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],63:[function(_dereq_,module,exports){
/**
 * @file big-play-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _buttonJs = _dereq_('./button.js');

var _buttonJs2 = _interopRequireDefault(_buttonJs);

var _componentJs = _dereq_('./component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Initial play button. Shows before the video has played. The hiding of the
 * big play button is done via CSS and player states.
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @extends Button
 * @class BigPlayButton
 */

var BigPlayButton = (function (_Button) {
  _inherits(BigPlayButton, _Button);

  function BigPlayButton(player, options) {
    _classCallCheck(this, BigPlayButton);

    _Button.call(this, player, options);
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-big-play-button';
  };

  /**
   * Handles click for play
   *
   * @method handleClick
   */

  BigPlayButton.prototype.handleClick = function handleClick() {
    this.player_.play();
  };

  return BigPlayButton;
})(_buttonJs2['default']);

BigPlayButton.prototype.controlText_ = 'Play Video';

_componentJs2['default'].registerComponent('BigPlayButton', BigPlayButton);
exports['default'] = BigPlayButton;
module.exports = exports['default'];

},{"./button.js":64,"./component.js":67}],64:[function(_dereq_,module,exports){
/**
 * @file button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _clickableComponentJs = _dereq_('./clickable-component.js');

var _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _utilsFnJs = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsLogJs = _dereq_('./utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

/**
 * Base class for all buttons
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @extends ClickableComponent
 * @class Button
 */

var Button = (function (_ClickableComponent) {
  _inherits(Button, _ClickableComponent);

  function Button(player, options) {
    _classCallCheck(this, Button);

    _ClickableComponent.call(this, player, options);
  }

  /**
   * Create the component's DOM element
   *
   * @param {String=} type Element's node type. e.g. 'div'
   * @param {Object=} props An object of properties that should be set on the element
   * @param {Object=} attributes An object of attributes that should be set on the element
   * @return {Element}
   * @method createEl
   */

  Button.prototype.createEl = function createEl() {
    var tag = arguments.length <= 0 || arguments[0] === undefined ? 'button' : arguments[0];
    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    props = _objectAssign2['default']({
      className: this.buildCSSClass()
    }, props);

    if (tag !== 'button') {
      _utilsLogJs2['default'].warn('Creating a Button with an HTML element of ' + tag + ' is deprecated; use ClickableComponent instead.');

      // Add properties for clickable element which is not a native HTML button
      props = _objectAssign2['default']({
        tabIndex: 0
      }, props);

      // Add ARIA attributes for clickable element which is not a native HTML button
      attributes = _objectAssign2['default']({
        role: 'button'
      }, attributes);
    }

    // Add attributes for button element
    attributes = _objectAssign2['default']({
      type: 'button', // Necessary since the default button type is "submit"
      'aria-live': 'polite' // let the screen reader user know that the text of the button may change
    }, attributes);

    var el = _component2['default'].prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Adds a child component inside this button
   *
   * @param {String|Component} child The class name or instance of a child to add
   * @param {Object=} options Options, including options to be passed to children of the child.
   * @return {Component} The child component (created by this process if a string was used)
   * @deprecated
   * @method addChild
   */

  Button.prototype.addChild = function addChild(child) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var className = this.constructor.name;
    _utilsLogJs2['default'].warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');

    // Avoid the error message generated by ClickableComponent's addChild method
    return _component2['default'].prototype.addChild.call(this, child, options);
  };

  /**
   * Handle KeyPress (document level) - Extend with specific functionality for button
   *
   * @method handleKeyPress
   */

  Button.prototype.handleKeyPress = function handleKeyPress(event) {
    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.
    if (event.which === 32 || event.which === 13) {} else {
      _ClickableComponent.prototype.handleKeyPress.call(this, event); // Pass keypress handling up for unsupported keys
    }
  };

  return Button;
})(_clickableComponentJs2['default']);

_component2['default'].registerComponent('Button', Button);
exports['default'] = Button;
module.exports = exports['default'];

},{"./clickable-component.js":65,"./component":67,"./utils/events.js":143,"./utils/fn.js":144,"./utils/log.js":147,"global/document":1,"object.assign":45}],65:[function(_dereq_,module,exports){
/**
 * @file button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _utilsDomJs = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _utilsFnJs = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsLogJs = _dereq_('./utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

/**
 * Clickable Component which is clickable or keyboard actionable, but is not a native HTML button
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @extends Component
 * @class ClickableComponent
 */

var ClickableComponent = (function (_Component) {
  _inherits(ClickableComponent, _Component);

  function ClickableComponent(player, options) {
    _classCallCheck(this, ClickableComponent);

    _Component.call(this, player, options);

    this.emitTapEvents();

    this.on('tap', this.handleClick);
    this.on('click', this.handleClick);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
  }

  /**
   * Create the component's DOM element
   *
   * @param {String=} type Element's node type. e.g. 'div'
   * @param {Object=} props An object of properties that should be set on the element
   * @param {Object=} attributes An object of attributes that should be set on the element
   * @return {Element}
   * @method createEl
   */

  ClickableComponent.prototype.createEl = function createEl() {
    var tag = arguments.length <= 0 || arguments[0] === undefined ? 'div' : arguments[0];
    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    props = _objectAssign2['default']({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);

    if (tag === 'button') {
      _utilsLogJs2['default'].error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');
    }

    // Add ARIA attributes for clickable element which is not a native HTML button
    attributes = _objectAssign2['default']({
      role: 'button',
      'aria-live': 'polite' // let the screen reader user know that the text of the element may change
    }, attributes);

    var el = _Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * create control text
   *
   * @param {Element} el Parent element for the control text
   * @return {Element}
   * @method controlText
   */

  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = Dom.createEl('span', {
      className: 'vjs-control-text'
    });

    if (el) {
      el.appendChild(this.controlTextEl_);
    }

    this.controlText(this.controlText_, el);

    return this.controlTextEl_;
  };

  /**
   * Controls text - both request and localize
   *
   * @param {String}  text Text for element
   * @param {Element=} el Element to set the title on
   * @return {String}
   * @method controlText
   */

  ClickableComponent.prototype.controlText = function controlText(text) {
    var el = arguments.length <= 1 || arguments[1] === undefined ? this.el() : arguments[1];

    if (!text) return this.controlText_ || 'Need Text';

    var localizedText = this.localize(text);

    this.controlText_ = text;
    this.controlTextEl_.innerHTML = localizedText;
    el.setAttribute('title', localizedText);

    return this;
  };

  /**
   * Allows sub components to stack CSS class names
   *
   * @return {String}
   * @method buildCSSClass
   */

  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Adds a child component inside this clickable-component
   *
   * @param {String|Component} child The class name or instance of a child to add
   * @param {Object=} options Options, including options to be passed to children of the child.
   * @return {Component} The child component (created by this process if a string was used)
   * @method addChild
   */

  ClickableComponent.prototype.addChild = function addChild(child) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // TODO: Fix adding an actionable child to a ClickableComponent; currently
    // it will cause issues with assistive technology (e.g. screen readers)
    // which support ARIA, since an element with role="button" cannot have
    // actionable child elements.

    //let className = this.constructor.name;
    //log.warn(`Adding a child to a ClickableComponent (${className}) can cause issues with assistive technology which supports ARIA, since an element with role="button" cannot have actionable child elements.`);

    return _Component.prototype.addChild.call(this, child, options);
  };

  /**
   * Enable the component element
   *
   * @return {Component}
   * @method enable
   */

  ClickableComponent.prototype.enable = function enable() {
    this.removeClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'false');
    return this;
  };

  /**
   * Disable the component element
   *
   * @return {Component}
   * @method disable
   */

  ClickableComponent.prototype.disable = function disable() {
    this.addClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'true');
    return this;
  };

  /**
   * Handle Click - Override with specific functionality for component
   *
   * @method handleClick
   */

  ClickableComponent.prototype.handleClick = function handleClick() {};

  /**
   * Handle Focus - Add keyboard functionality to element
   *
   * @method handleFocus
   */

  ClickableComponent.prototype.handleFocus = function handleFocus() {
    Events.on(_globalDocument2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));
  };

  /**
   * Handle KeyPress (document level) - Trigger click when Space or Enter key is pressed
   *
   * @method handleKeyPress
   */

  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {
    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.handleClick(event);
    } else if (_Component.prototype.handleKeyPress) {
      _Component.prototype.handleKeyPress.call(this, event); // Pass keypress handling up for unsupported keys
    }
  };

  /**
   * Handle Blur - Remove keyboard triggers
   *
   * @method handleBlur
   */

  ClickableComponent.prototype.handleBlur = function handleBlur() {
    Events.off(_globalDocument2['default'], 'keydown', Fn.bind(this, this.handleKeyPress));
  };

  return ClickableComponent;
})(_component2['default']);

_component2['default'].registerComponent('ClickableComponent', ClickableComponent);
exports['default'] = ClickableComponent;
module.exports = exports['default'];

},{"./component":67,"./utils/dom.js":142,"./utils/events.js":143,"./utils/fn.js":144,"./utils/log.js":147,"global/document":1,"object.assign":45}],66:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _button = _dereq_('./button');

var _button2 = _interopRequireDefault(_button);

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

/**
 * The `CloseButton` component is a button which fires a "close" event
 * when it is activated.
 *
 * @extends Button
 * @class CloseButton
 */

var CloseButton = (function (_Button) {
  _inherits(CloseButton, _Button);

  function CloseButton(player, options) {
    _classCallCheck(this, CloseButton);

    _Button.call(this, player, options);
    this.controlText(options && options.controlText || this.localize('Close'));
  }

  CloseButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);
  };

  CloseButton.prototype.handleClick = function handleClick() {
    this.trigger({ type: 'close', bubbles: false });
  };

  return CloseButton;
})(_button2['default']);

_component2['default'].registerComponent('CloseButton', CloseButton);
exports['default'] = CloseButton;
module.exports = exports['default'];

},{"./button":64,"./component":67}],67:[function(_dereq_,module,exports){
/**
 * @file component.js
 *
 * Player Component - Base class for all UI objects
 */

'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _utilsDomJs = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsGuidJs = _dereq_('./utils/guid.js');

var Guid = _interopRequireWildcard(_utilsGuidJs);

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _utilsLogJs = _dereq_('./utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _utilsToTitleCaseJs = _dereq_('./utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

var _utilsMergeOptionsJs = _dereq_('./utils/merge-options.js');

var _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);

/**
 * Base UI Component class
 * Components are embeddable UI objects that are represented by both a
 * javascript object and an element in the DOM. They can be children of other
 * components, and can have many children themselves.
 * ```js
 *     // adding a button to the player
 *     var button = player.addChild('button');
 *     button.el(); // -> button element
 * ```
 * ```html
 *     <div class="video-js">
 *       <div class="vjs-button">Button</div>
 *     </div>
 * ```
 * Components are also event targets.
 * ```js
 *     button.on('click', function(){
 *       console.log('Button Clicked!');
 *     });
 *     button.trigger('customevent');
 * ```
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @class Component
 */

var Component = (function () {
  function Component(player, options, ready) {
    _classCallCheck(this, Component);

    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
        this.player_ = player;
      }

    // Make a copy of prototype.options_ to protect against overriding defaults
    this.options_ = _utilsMergeOptionsJs2['default']({}, this.options_);

    // Updated options with supplied options
    options = this.options_ = _utilsMergeOptionsJs2['default'](this.options_, options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = id + '_component_' + Guid.newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  /**
   * Dispose of the component and all child components
   *
   * @method dispose
   */

  Component.prototype.dispose = function dispose() {
    this.trigger({ type: 'dispose', bubbles: false });

    // Dispose all children.
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }

    // Delete child references
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;

    // Remove all event listeners.
    this.off();

    // Remove element from DOM
    if (this.el_.parentNode) {
      this.el_.parentNode.removeChild(this.el_);
    }

    Dom.removeElData(this.el_);
    this.el_ = null;
  };

  /**
   * Return the component's player
   *
   * @return {Player}
   * @method player
   */

  Component.prototype.player = function player() {
    return this.player_;
  };

  /**
   * Deep merge of options objects
   * Whenever a property is an object on both options objects
   * the two properties will be merged using mergeOptions.
   *
   * ```js
   *     Parent.prototype.options_ = {
   *       optionSet: {
   *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
   *         'childTwo': {},
   *         'childThree': {}
   *       }
   *     }
   *     newOptions = {
   *       optionSet: {
   *         'childOne': { 'foo': 'baz', 'abc': '123' }
   *         'childTwo': null,
   *         'childFour': {}
   *       }
   *     }
   *
   *     this.options(newOptions);
   * ```
   * RESULT
   * ```js
   *     {
   *       optionSet: {
   *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
   *         'childTwo': null, // Disabled. Won't be initialized.
   *         'childThree': {},
   *         'childFour': {}
   *       }
   *     }
   * ```
   *
   * @param  {Object} obj Object of new option values
   * @return {Object}     A NEW object of this.options_ and obj merged
   * @method options
   */

  Component.prototype.options = function options(obj) {
    _utilsLogJs2['default'].warn('this.options() has been deprecated and will be moved to the constructor in 6.0');

    if (!obj) {
      return this.options_;
    }

    this.options_ = _utilsMergeOptionsJs2['default'](this.options_, obj);
    return this.options_;
  };

  /**
   * Get the component's DOM element
   * ```js
   *     var domEl = myComponent.el();
   * ```
   *
   * @return {Element}
   * @method el
   */

  Component.prototype.el = function el() {
    return this.el_;
  };

  /**
   * Create the component's DOM element
   *
   * @param  {String=} tagName  Element's node type. e.g. 'div'
   * @param  {Object=} properties An object of properties that should be set
   * @param  {Object=} attributes An object of attributes that should be set
   * @return {Element}
   * @method createEl
   */

  Component.prototype.createEl = function createEl(tagName, properties, attributes) {
    return Dom.createEl(tagName, properties, attributes);
  };

  Component.prototype.localize = function localize(string) {
    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();

    if (!code || !languages) {
      return string;
    }

    var language = languages[code];

    if (language && language[string]) {
      return language[string];
    }

    var primaryCode = code.split('-')[0];
    var primaryLang = languages[primaryCode];

    if (primaryLang && primaryLang[string]) {
      return primaryLang[string];
    }

    return string;
  };

  /**
   * Return the component's DOM element where children are inserted.
   * Will either be the same as el() or a new element defined in createEl().
   *
   * @return {Element}
   * @method contentEl
   */

  Component.prototype.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };

  /**
   * Get the component's ID
   * ```js
   *     var id = myComponent.id();
   * ```
   *
   * @return {String}
   * @method id
   */

  Component.prototype.id = function id() {
    return this.id_;
  };

  /**
   * Get the component's name. The name is often used to reference the component.
   * ```js
   *     var name = myComponent.name();
   * ```
   *
   * @return {String}
   * @method name
   */

  Component.prototype.name = function name() {
    return this.name_;
  };

  /**
   * Get an array of all child components
   * ```js
   *     var kids = myComponent.children();
   * ```
   *
   * @return {Array} The children
   * @method children
   */

  Component.prototype.children = function children() {
    return this.children_;
  };

  /**
   * Returns a child component with the provided ID
   *
   * @return {Component}
   * @method getChildById
   */

  Component.prototype.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };

  /**
   * Returns a child component with the provided name
   *
   * @return {Component}
   * @method getChild
   */

  Component.prototype.getChild = function getChild(name) {
    return this.childNameIndex_[name];
  };

  /**
   * Adds a child component inside this component
   * ```js
   *     myComponent.el();
   *     // -> <div class='my-component'></div>
   *     myComponent.children();
   *     // [empty array]
   *
   *     var myButton = myComponent.addChild('MyButton');
   *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
   *     // -> myButton === myComponent.children()[0];
   * ```
   * Pass in options for child constructors and options for children of the child
   * ```js
   *     var myButton = myComponent.addChild('MyButton', {
   *       text: 'Press Me',
   *       buttonChildExample: {
   *         buttonChildOption: true
   *       }
   *     });
   * ```
   *
   * @param {String|Component} child The class name or instance of a child to add
   * @param {Object=} options Options, including options to be passed to children of the child.
   * @param {Number} index into our children array to attempt to add the child
   * @return {Component} The child component (created by this process if a string was used)
   * @method addChild
   */

  Component.prototype.addChild = function addChild(child) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var index = arguments.length <= 2 || arguments[2] === undefined ? this.children_.length : arguments[2];

    var component = undefined;
    var componentName = undefined;

    // If child is a string, create nt with options
    if (typeof child === 'string') {
      componentName = child;

      // Options can also be specified as a boolean, so convert to an empty object if false.
      if (!options) {
        options = {};
      }

      // Same as above, but true is deprecated so show a warning.
      if (options === true) {
        _utilsLogJs2['default'].warn('Initializing a child component with `true` is deprecated. Children should be defined in an array when possible, but if necessary use an object instead of `true`.');
        options = {};
      }

      // If no componentClass in options, assume componentClass is the name lowercased
      // (e.g. playButton)
      var componentClassName = options.componentClass || _utilsToTitleCaseJs2['default'](componentName);

      // Set name through options
      options.name = componentName;

      // Create a new object & element for this controls set
      // If there's no .player_, this is a player
      var ComponentClass = Component.getComponent(componentClassName);

      if (!ComponentClass) {
        throw new Error('Component ' + componentClassName + ' does not exist');
      }

      // data stored directly on the videojs object may be
      // misidentified as a component to retain
      // backwards-compatibility with 4.x. check to make sure the
      // component class can be instantiated.
      if (typeof ComponentClass !== 'function') {
        return null;
      }

      component = new ComponentClass(this.player_ || this, options);

      // child is a component instance
    } else {
        component = child;
      }

    this.children_.splice(index, 0, component);

    if (typeof component.id === 'function') {
      this.childIndex_[component.id()] = component;
    }

    // If a name wasn't used to create the component, check if we can use the
    // name function of the component
    componentName = componentName || component.name && component.name();

    if (componentName) {
      this.childNameIndex_[componentName] = component;
    }

    // Add the UI object's element to the container div (box)
    // Having an element is not required
    if (typeof component.el === 'function' && component.el()) {
      var childNodes = this.contentEl().children;
      var refNode = childNodes[index] || null;
      this.contentEl().insertBefore(component.el(), refNode);
    }

    // Return so it can stored on parent object if desired.
    return component;
  };

  /**
   * Remove a child component from this component's list of children, and the
   * child component's element from this component's element
   *
   * @param  {Component} component Component to remove
   * @method removeChild
   */

  Component.prototype.removeChild = function removeChild(component) {
    if (typeof component === 'string') {
      component = this.getChild(component);
    }

    if (!component || !this.children_) {
      return;
    }

    var childFound = false;

    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }

    if (!childFound) {
      return;
    }

    this.childIndex_[component.id()] = null;
    this.childNameIndex_[component.name()] = null;

    var compEl = component.el();

    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };

  /**
   * Add and initialize default child components from options
   * ```js
   *     // when an instance of MyComponent is created, all children in options
   *     // will be added to the instance by their name strings and options
   *     MyComponent.prototype.options_ = {
   *       children: [
   *         'myChildComponent'
   *       ],
   *       myChildComponent: {
   *         myChildOption: true
   *       }
   *     };
   *
   *     // Or when creating the component
   *     var myComp = new MyComponent(player, {
   *       children: [
   *         'myChildComponent'
   *       ],
   *       myChildComponent: {
   *         myChildOption: true
   *       }
   *     });
   * ```
   * The children option can also be an array of
   * child options objects (that also include a 'name' key).
   * This can be used if you have two child components of the
   * same type that need different options.
   * ```js
   *     var myComp = new MyComponent(player, {
   *       children: [
   *         'button',
   *         {
   *           name: 'button',
   *           someOtherOption: true
   *         },
   *         {
   *           name: 'button',
   *           someOtherOption: false
   *         }
   *       ]
   *     });
   * ```
   *
   * @method initChildren
   */

  Component.prototype.initChildren = function initChildren() {
    var _this = this;

    var children = this.options_.children;

    if (children) {
      (function () {
        // `this` is `parent`
        var parentOptions = _this.options_;

        var handleAdd = function handleAdd(child) {
          var name = child.name;
          var opts = child.opts;

          // Allow options for children to be set at the parent options
          // e.g. videojs(id, { controlBar: false });
          // instead of videojs(id, { children: { controlBar: false });
          if (parentOptions[name] !== undefined) {
            opts = parentOptions[name];
          }

          // Allow for disabling default components
          // e.g. options['children']['posterImage'] = false
          if (opts === false) {
            return;
          }

          // Allow options to be passed as a simple boolean if no configuration
          // is necessary.
          if (opts === true) {
            opts = {};
          }

          // We also want to pass the original player options to each component as well so they don't need to
          // reach back into the player for options later.
          opts.playerOptions = _this.options_.playerOptions;

          // Create and add the child component.
          // Add a direct reference to the child by name on the parent instance.
          // If two of the same component are used, different names should be supplied
          // for each
          var newChild = _this.addChild(name, opts);
          if (newChild) {
            _this[name] = newChild;
          }
        };

        // Allow for an array of children details to passed in the options
        var workingChildren = undefined;
        var Tech = Component.getComponent('Tech');

        if (Array.isArray(children)) {
          workingChildren = children;
        } else {
          workingChildren = Object.keys(children);
        }

        workingChildren
        // children that are in this.options_ but also in workingChildren  would
        // give us extra children we do not want. So, we want to filter them out.
        .concat(Object.keys(_this.options_).filter(function (child) {
          return !workingChildren.some(function (wchild) {
            if (typeof wchild === 'string') {
              return child === wchild;
            } else {
              return child === wchild.name;
            }
          });
        })).map(function (child) {
          var name = undefined,
              opts = undefined;

          if (typeof child === 'string') {
            name = child;
            opts = children[name] || _this.options_[name] || {};
          } else {
            name = child.name;
            opts = child;
          }

          return { name: name, opts: opts };
        }).filter(function (child) {
          // we have to make sure that child.name isn't in the techOrder since
          // techs are registerd as Components but can't aren't compatible
          // See https://github.com/videojs/video.js/issues/2772
          var c = Component.getComponent(child.opts.componentClass || _utilsToTitleCaseJs2['default'](child.name));
          return c && !Tech.isTech(c);
        }).forEach(handleAdd);
      })();
    }
  };

  /**
   * Allows sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  Component.prototype.buildCSSClass = function buildCSSClass() {
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
  };

  /**
   * Add an event listener to this component's element
   * ```js
   *     var myFunc = function(){
   *       var myComponent = this;
   *       // Do something when the event is fired
   *     };
   *
   *     myComponent.on('eventType', myFunc);
   * ```
   * The context of myFunc will be myComponent unless previously bound.
   * Alternatively, you can add a listener to another element or component.
   * ```js
   *     myComponent.on(otherElement, 'eventName', myFunc);
   *     myComponent.on(otherComponent, 'eventName', myFunc);
   * ```
   * The benefit of using this over `VjsEvents.on(otherElement, 'eventName', myFunc)`
   * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
   * will be automatically cleaned up when either component is disposed.
   * It will also bind myComponent as the context of myFunc.
   * **NOTE**: When using this on elements in the page other than window
   * and document (both permanent), if you remove the element from the DOM
   * you need to call `myComponent.trigger(el, 'dispose')` on it to clean up
   * references to it and allow the browser to garbage collect it.
   *
   * @param  {String|Component} first   The event type or other component
   * @param  {Function|String}      second  The event handler or event type
   * @param  {Function}             third   The event handler
   * @return {Component}
   * @method on
   */

  Component.prototype.on = function on(first, second, third) {
    var _this2 = this;

    if (typeof first === 'string' || Array.isArray(first)) {
      Events.on(this.el_, first, Fn.bind(this, second));

      // Targeting another component or element
    } else {
        (function () {
          var target = first;
          var type = second;
          var fn = Fn.bind(_this2, third);

          // When this component is disposed, remove the listener from the other component
          var removeOnDispose = function removeOnDispose() {
            return _this2.off(target, type, fn);
          };

          // Use the same function ID so we can remove it later it using the ID
          // of the original listener
          removeOnDispose.guid = fn.guid;
          _this2.on('dispose', removeOnDispose);

          // If the other component is disposed first we need to clean the reference
          // to the other component in this component's removeOnDispose listener
          // Otherwise we create a memory leak.
          var cleanRemover = function cleanRemover() {
            return _this2.off('dispose', removeOnDispose);
          };

          // Add the same function ID so we can easily remove it later
          cleanRemover.guid = fn.guid;

          // Check if this is a DOM node
          if (first.nodeName) {
            // Add the listener to the other element
            Events.on(target, type, fn);
            Events.on(target, 'dispose', cleanRemover);

            // Should be a component
            // Not using `instanceof Component` because it makes mock players difficult
          } else if (typeof first.on === 'function') {
              // Add the listener to the other component
              target.on(type, fn);
              target.on('dispose', cleanRemover);
            }
        })();
      }

    return this;
  };

  /**
   * Remove an event listener from this component's element
   * ```js
   *     myComponent.off('eventType', myFunc);
   * ```
   * If myFunc is excluded, ALL listeners for the event type will be removed.
   * If eventType is excluded, ALL listeners will be removed from the component.
   * Alternatively you can use `off` to remove listeners that were added to other
   * elements or components using `myComponent.on(otherComponent...`.
   * In this case both the event type and listener function are REQUIRED.
   * ```js
   *     myComponent.off(otherElement, 'eventType', myFunc);
   *     myComponent.off(otherComponent, 'eventType', myFunc);
   * ```
   *
   * @param  {String=|Component}  first  The event type or other component
   * @param  {Function=|String}       second The listener function or event type
   * @param  {Function=}              third  The listener for other component
   * @return {Component}
   * @method off
   */

  Component.prototype.off = function off(first, second, third) {
    if (!first || typeof first === 'string' || Array.isArray(first)) {
      Events.off(this.el_, first, second);
    } else {
      var target = first;
      var type = second;
      // Ensure there's at least a guid, even if the function hasn't been used
      var fn = Fn.bind(this, third);

      // Remove the dispose listener on this component,
      // which was given the same guid as the event listener
      this.off('dispose', fn);

      if (first.nodeName) {
        // Remove the listener
        Events.off(target, type, fn);
        // Remove the listener for cleaning the dispose listener
        Events.off(target, 'dispose', fn);
      } else {
        target.off(type, fn);
        target.off('dispose', fn);
      }
    }

    return this;
  };

  /**
   * Add an event listener to be triggered only once and then removed
   * ```js
   *     myComponent.one('eventName', myFunc);
   * ```
   * Alternatively you can add a listener to another element or component
   * that will be triggered only once.
   * ```js
   *     myComponent.one(otherElement, 'eventName', myFunc);
   *     myComponent.one(otherComponent, 'eventName', myFunc);
   * ```
   *
   * @param  {String|Component}  first   The event type or other component
   * @param  {Function|String}       second  The listener function or event type
   * @param  {Function=}             third   The listener function for other component
   * @return {Component}
   * @method one
   */

  Component.prototype.one = function one(first, second, third) {
    var _this3 = this,
        _arguments = arguments;

    if (typeof first === 'string' || Array.isArray(first)) {
      Events.one(this.el_, first, Fn.bind(this, second));
    } else {
      (function () {
        var target = first;
        var type = second;
        var fn = Fn.bind(_this3, third);

        var newFunc = function newFunc() {
          _this3.off(target, type, newFunc);
          fn.apply(null, _arguments);
        };

        // Keep the same function ID so we can remove it later
        newFunc.guid = fn.guid;

        _this3.on(target, type, newFunc);
      })();
    }

    return this;
  };

  /**
   * Trigger an event on an element
   * ```js
   *     myComponent.trigger('eventName');
   *     myComponent.trigger({'type':'eventName'});
   *     myComponent.trigger('eventName', {data: 'some data'});
   *     myComponent.trigger({'type':'eventName'}, {data: 'some data'});
   * ```
   *
   * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
   * @param  {Object} [hash] data hash to pass along with the event
   * @return {Component}       self
   * @method trigger
   */

  Component.prototype.trigger = function trigger(event, hash) {
    Events.trigger(this.el_, event, hash);
    return this;
  };

  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @param  {Function} fn Ready listener
   * @param  {Boolean} sync Exec the listener synchronously if component is ready
   * @return {Component}
   * @method ready
   */

  Component.prototype.ready = function ready(fn) {
    var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    if (fn) {
      if (this.isReady_) {
        if (sync) {
          fn.call(this);
        } else {
          // Call the function asynchronously by default for consistency
          this.setTimeout(fn, 1);
        }
      } else {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
      }
    }
    return this;
  };

  /**
   * Trigger the ready listeners
   *
   * @return {Component}
   * @method triggerReady
   */

  Component.prototype.triggerReady = function triggerReady() {
    this.isReady_ = true;

    // Ensure ready is triggerd asynchronously
    this.setTimeout(function () {
      var readyQueue = this.readyQueue_;

      // Reset Ready Queue
      this.readyQueue_ = [];

      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function (fn) {
          fn.call(this);
        }, this);
      }

      // Allow for using event listeners also
      this.trigger('ready');
    }, 1);
  };

  /**
   * Finds a single DOM element matching `selector` within the component's
   * `contentEl` or another custom context.
   *
   * @method $
   * @param  {String} selector
   *         A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param  {Element|String} [context=document]
   *         A DOM element within which to query. Can also be a selector
   *         string in which case the first matching element will be used
   *         as context. If missing (or no element matches selector), falls
   *         back to `document`.
   *
   * @return {Element|null}
   */

  Component.prototype.$ = function $(selector, context) {
    return Dom.$(selector, context || this.contentEl());
  };

  /**
   * Finds a all DOM elements matching `selector` within the component's
   * `contentEl` or another custom context.
   *
   * @method $$
   * @param  {String} selector
   *         A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param  {Element|String} [context=document]
   *         A DOM element within which to query. Can also be a selector
   *         string in which case the first matching element will be used
   *         as context. If missing (or no element matches selector), falls
   *         back to `document`.
   *
   * @return {NodeList}
   */

  Component.prototype.$$ = function $$(selector, context) {
    return Dom.$$(selector, context || this.contentEl());
  };

  /**
   * Check if a component's element has a CSS class name
   *
   * @param {String} classToCheck Classname to check
   * @return {Component}
   * @method hasClass
   */

  Component.prototype.hasClass = function hasClass(classToCheck) {
    return Dom.hasElClass(this.el_, classToCheck);
  };

  /**
   * Add a CSS class name to the component's element
   *
   * @param {String} classToAdd Classname to add
   * @return {Component}
   * @method addClass
   */

  Component.prototype.addClass = function addClass(classToAdd) {
    Dom.addElClass(this.el_, classToAdd);
    return this;
  };

  /**
   * Remove a CSS class name from the component's element
   *
   * @param {String} classToRemove Classname to remove
   * @return {Component}
   * @method removeClass
   */

  Component.prototype.removeClass = function removeClass(classToRemove) {
    Dom.removeElClass(this.el_, classToRemove);
    return this;
  };

  /**
   * Add or remove a CSS class name from the component's element
   *
   * @param  {String} classToToggle
   * @param  {Boolean|Function} [predicate]
   *         Can be a function that returns a Boolean. If `true`, the class
   *         will be added; if `false`, the class will be removed. If not
   *         given, the class will be added if not present and vice versa.
   *
   * @return {Component}
   * @method toggleClass
   */

  Component.prototype.toggleClass = function toggleClass(classToToggle, predicate) {
    Dom.toggleElClass(this.el_, classToToggle, predicate);
    return this;
  };

  /**
   * Show the component element if hidden
   *
   * @return {Component}
   * @method show
   */

  Component.prototype.show = function show() {
    this.removeClass('vjs-hidden');
    return this;
  };

  /**
   * Hide the component element if currently showing
   *
   * @return {Component}
   * @method hide
   */

  Component.prototype.hide = function hide() {
    this.addClass('vjs-hidden');
    return this;
  };

  /**
   * Lock an item in its visible state
   * To be used with fadeIn/fadeOut.
   *
   * @return {Component}
   * @private
   * @method lockShowing
   */

  Component.prototype.lockShowing = function lockShowing() {
    this.addClass('vjs-lock-showing');
    return this;
  };

  /**
   * Unlock an item to be hidden
   * To be used with fadeIn/fadeOut.
   *
   * @return {Component}
   * @private
   * @method unlockShowing
   */

  Component.prototype.unlockShowing = function unlockShowing() {
    this.removeClass('vjs-lock-showing');
    return this;
  };

  /**
   * Set or get the width of the component (CSS values)
   * Setting the video tag dimension values only works with values in pixels.
   * Percent values will not work.
   * Some percents can be used, but width()/height() will return the number + %,
   * not the actual computed width/height.
   *
   * @param  {Number|String=} num   Optional width number
   * @param  {Boolean} skipListeners Skip the 'resize' event trigger
   * @return {Component} This component, when setting the width
   * @return {Number|String} The width, when getting
   * @method width
   */

  Component.prototype.width = function width(num, skipListeners) {
    return this.dimension('width', num, skipListeners);
  };

  /**
   * Get or set the height of the component (CSS values)
   * Setting the video tag dimension values only works with values in pixels.
   * Percent values will not work.
   * Some percents can be used, but width()/height() will return the number + %,
   * not the actual computed width/height.
   *
   * @param  {Number|String=} num     New component height
   * @param  {Boolean=} skipListeners Skip the resize event trigger
   * @return {Component} This component, when setting the height
   * @return {Number|String} The height, when getting
   * @method height
   */

  Component.prototype.height = function height(num, skipListeners) {
    return this.dimension('height', num, skipListeners);
  };

  /**
   * Set both width and height at the same time
   *
   * @param  {Number|String} width Width of player
   * @param  {Number|String} height Height of player
   * @return {Component} The component
   * @method dimensions
   */

  Component.prototype.dimensions = function dimensions(width, height) {
    // Skip resize listeners on width for optimization
    return this.width(width, true).height(height);
  };

  /**
   * Get or set width or height
   * This is the shared code for the width() and height() methods.
   * All for an integer, integer + 'px' or integer + '%';
   * Known issue: Hidden elements officially have a width of 0. We're defaulting
   * to the style.width value and falling back to computedStyle which has the
   * hidden element issue. Info, but probably not an efficient fix:
   * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
   *
   * @param  {String} widthOrHeight  'width' or 'height'
   * @param  {Number|String=} num     New dimension
   * @param  {Boolean=} skipListeners Skip resize event trigger
   * @return {Component} The component if a dimension was set
   * @return {Number|String} The dimension if nothing was set
   * @private
   * @method dimension
   */

  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== undefined) {
      // Set to zero if null or literally NaN (NaN !== NaN)
      if (num === null || num !== num) {
        num = 0;
      }

      // Check if using css width/height (% or px) and adjust
      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === 'auto') {
        this.el_.style[widthOrHeight] = '';
      } else {
        this.el_.style[widthOrHeight] = num + 'px';
      }

      // skipListeners allows us to avoid triggering the resize event when setting both width and height
      if (!skipListeners) {
        this.trigger('resize');
      }

      // Return component
      return this;
    }

    // Not setting a value, so getting it
    // Make sure element exists
    if (!this.el_) {
      return 0;
    }

    // Get dimension value from style
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf('px');

    if (pxIndex !== -1) {
      // Return the pixel value with no 'px'
      return parseInt(val.slice(0, pxIndex), 10);
    }

    // No px so using % or no style was set, so falling back to offsetWidth/height
    // If component has display:none, offset will return 0
    // TODO: handle display:none and no dimension style using px
    return parseInt(this.el_['offset' + _utilsToTitleCaseJs2['default'](widthOrHeight)], 10);
  };

  /**
   * Get width or height of computed style
   * @param  {String} widthOrHeight  'width' or 'height'
   * @return {Number|Boolean} The bolean false if nothing was set
   * @method currentDimension
   */

  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;

    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
      throw new Error('currentDimension only accepts width or height value');
    }

    if (typeof _globalWindow2['default'].getComputedStyle === 'function') {
      var computedStyle = _globalWindow2['default'].getComputedStyle(this.el_);
      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];
    } else if (this.el_.currentStyle) {
      // ie 8 doesn't support computed style, shim it
      // return clientWidth or clientHeight instead for better accuracy
      var rule = 'offset' + _utilsToTitleCaseJs2['default'](widthOrHeight);
      computedWidthOrHeight = this.el_[rule];
    }

    // remove 'px' from variable and parse as integer
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);
    return computedWidthOrHeight;
  };

  /**
   * Get an object which contains width and height values of computed style
   * @return {Object} The dimensions of element
   * @method currentDimensions
   */

  Component.prototype.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension('width'),
      height: this.currentDimension('height')
    };
  };

  /**
   * Get width of computed style
   * @return {Integer}
   * @method currentWidth
   */

  Component.prototype.currentWidth = function currentWidth() {
    return this.currentDimension('width');
  };

  /**
   * Get height of computed style
   * @return {Integer}
   * @method currentHeight
   */

  Component.prototype.currentHeight = function currentHeight() {
    return this.currentDimension('height');
  };

  /**
   * Emit 'tap' events when touch events are supported
   * This is used to support toggling the controls through a tap on the video.
   * We're requiring them to be enabled because otherwise every component would
   * have this extra overhead unnecessarily, on mobile devices where extra
   * overhead is especially bad.
   *
   * @private
   * @method emitTapEvents
   */

  Component.prototype.emitTapEvents = function emitTapEvents() {
    // Track the start time so we can determine how long the touch lasted
    var touchStart = 0;
    var firstTouch = null;

    // Maximum movement allowed during a touch event to still be considered a tap
    // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
    var tapMovementThreshold = 10;

    // The maximum length a touch can be while still being considered a tap
    var touchTimeThreshold = 200;

    var couldBeTap = undefined;

    this.on('touchstart', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length === 1) {
        // Copy pageX/pageY from the object
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        // Record start time so we can detect a tap vs. "touch and hold"
        touchStart = new Date().getTime();
        // Reset couldBeTap tracking
        couldBeTap = true;
      }
    });

    this.on('touchmove', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        // Some devices will throw touchmoves for all but the slightest of taps.
        // So, if we moved only a small distance, this could still be a tap
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });

    var noTap = function noTap() {
      couldBeTap = false;
    };

    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
    this.on('touchleave', noTap);
    this.on('touchcancel', noTap);

    // When the touch ends, measure how long it took and trigger the appropriate
    // event
    this.on('touchend', function (event) {
      firstTouch = null;
      // Proceed only if the touchmove/leave/cancel event didn't happen
      if (couldBeTap === true) {
        // Measure how long the touch lasted
        var touchTime = new Date().getTime() - touchStart;

        // Make sure the touch was less than the threshold to be considered a tap
        if (touchTime < touchTimeThreshold) {
          // Don't let browser turn this into a click
          event.preventDefault();
          this.trigger('tap');
          // It may be good to copy the touchend event object and change the
          // type to tap, if the other event properties aren't exact after
          // Events.fixEvent runs (e.g. event.target)
        }
      }
    });
  };

  /**
   * Report user touch activity when touch events occur
   * User activity is used to determine when controls should show/hide. It's
   * relatively simple when it comes to mouse events, because any mouse event
   * should show the controls. So we capture mouse events that bubble up to the
   * player and report activity when that happens.
   * With touch events it isn't as easy. We can't rely on touch events at the
   * player level, because a tap (touchstart + touchend) on the video itself on
   * mobile devices is meant to turn controls off (and on). User activity is
   * checked asynchronously, so what could happen is a tap event on the video
   * turns the controls off, then the touchend event bubbles up to the player,
   * which if it reported user activity, would turn the controls right back on.
   * (We also don't want to completely block touch events from bubbling up)
   * Also a touchmove, touch+hold, and anything other than a tap is not supposed
   * to turn the controls back on on a mobile device.
   * Here we're setting the default component behavior to report user activity
   * whenever touch events happen, and this can be turned off by components that
   * want touch events to act differently.
   *
   * @method enableTouchActivity
   */

  Component.prototype.enableTouchActivity = function enableTouchActivity() {
    // Don't continue if the root player doesn't support reporting user activity
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }

    // listener for reporting that the user is active
    var report = Fn.bind(this.player(), this.player().reportUserActivity);

    var touchHolding = undefined;

    this.on('touchstart', function () {
      report();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(touchHolding);
      // report at the same interval as activityCheck
      touchHolding = this.setInterval(report, 250);
    });

    var touchEnd = function touchEnd(event) {
      report();
      // stop the interval that maintains activity if the touch is holding
      this.clearInterval(touchHolding);
    };

    this.on('touchmove', report);
    this.on('touchend', touchEnd);
    this.on('touchcancel', touchEnd);
  };

  /**
   * Creates timeout and sets up disposal automatically.
   *
   * @param {Function} fn The function to run after the timeout.
   * @param {Number} timeout Number of ms to delay before executing specified function.
   * @return {Number} Returns the timeout ID
   * @method setTimeout
   */

  Component.prototype.setTimeout = function setTimeout(fn, timeout) {
    fn = Fn.bind(this, fn);

    // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
    var timeoutId = _globalWindow2['default'].setTimeout(fn, timeout);

    var disposeFn = function disposeFn() {
      this.clearTimeout(timeoutId);
    };

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.on('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Clears a timeout and removes the associated dispose listener
   *
   * @param {Number} timeoutId The id of the timeout to clear
   * @return {Number} Returns the timeout ID
   * @method clearTimeout
   */

  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {
    _globalWindow2['default'].clearTimeout(timeoutId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.off('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Creates an interval and sets up disposal automatically.
   *
   * @param {Function} fn The function to run every N seconds.
   * @param {Number} interval Number of ms to delay before executing specified function.
   * @return {Number} Returns the interval ID
   * @method setInterval
   */

  Component.prototype.setInterval = function setInterval(fn, interval) {
    fn = Fn.bind(this, fn);

    var intervalId = _globalWindow2['default'].setInterval(fn, interval);

    var disposeFn = function disposeFn() {
      this.clearInterval(intervalId);
    };

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.on('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Clears an interval and removes the associated dispose listener
   *
   * @param {Number} intervalId The id of the interval to clear
   * @return {Number} Returns the interval ID
   * @method clearInterval
   */

  Component.prototype.clearInterval = function clearInterval(intervalId) {
    _globalWindow2['default'].clearInterval(intervalId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.off('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Registers a component
   *
   * @param {String} name Name of the component to register
   * @param {Object} comp The component to register
   * @static
   * @method registerComponent
   */

  Component.registerComponent = function registerComponent(name, comp) {
    if (!Component.components_) {
      Component.components_ = {};
    }

    Component.components_[name] = comp;
    return comp;
  };

  /**
   * Gets a component by name
   *
   * @param {String} name Name of the component to get
   * @return {Component}
   * @static
   * @method getComponent
   */

  Component.getComponent = function getComponent(name) {
    if (Component.components_ && Component.components_[name]) {
      return Component.components_[name];
    }

    if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {
      _utilsLogJs2['default'].warn('The ' + name + ' component was added to the videojs object when it should be registered using videojs.registerComponent(name, component)');
      return _globalWindow2['default'].videojs[name];
    }
  };

  /**
   * Sets up the constructor using the supplied init method
   * or uses the init of the parent object
   *
   * @param {Object} props An object of properties
   * @static
   * @deprecated
   * @method extend
   */

  Component.extend = function extend(props) {
    props = props || {};

    _utilsLogJs2['default'].warn('Component.extend({}) has been deprecated, use videojs.extend(Component, {}) instead');

    // Set up the constructor using the supplied init method
    // or using the init of the parent object
    // Make sure to check the unobfuscated version for external libs
    var init = props.init || props.init || this.prototype.init || this.prototype.init || function () {};
    // In Resig's simple class inheritance (previously used) the constructor
    //  is a function that calls `this.init.apply(arguments)`
    // However that would prevent us from using `ParentObject.call(this);`
    //  in a Child constructor because the `this` in `this.init`
    //  would still refer to the Child and cause an infinite loop.
    // We would instead have to do
    //    `ParentObject.prototype.init.apply(this, arguments);`
    //  Bleh. We're not creating a _super() function, so it's good to keep
    //  the parent constructor reference simple.
    var subObj = function subObj() {
      init.apply(this, arguments);
    };

    // Inherit from this object's prototype
    subObj.prototype = Object.create(this.prototype);
    // Reset the constructor property for subObj otherwise
    // instances of subObj would have the constructor of the parent Object
    subObj.prototype.constructor = subObj;

    // Make the class extendable
    subObj.extend = Component.extend;

    // Extend subObj's prototype with functions and other properties from props
    for (var _name in props) {
      if (props.hasOwnProperty(_name)) {
        subObj.prototype[_name] = props[_name];
      }
    }

    return subObj;
  };

  return Component;
})();

Component.registerComponent('Component', Component);
exports['default'] = Component;
module.exports = exports['default'];

},{"./utils/dom.js":142,"./utils/events.js":143,"./utils/fn.js":144,"./utils/guid.js":146,"./utils/log.js":147,"./utils/merge-options.js":148,"./utils/to-title-case.js":151,"global/window":2}],68:[function(_dereq_,module,exports){
/**
 * @file audio-track-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackButtonJs = _dereq_('../track-button.js');

var _trackButtonJs2 = _interopRequireDefault(_trackButtonJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _audioTrackMenuItemJs = _dereq_('./audio-track-menu-item.js');

var _audioTrackMenuItemJs2 = _interopRequireDefault(_audioTrackMenuItemJs);

/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends TrackButton
 * @class AudioTrackButton
 */

var AudioTrackButton = (function (_TrackButton) {
  _inherits(AudioTrackButton, _TrackButton);

  function AudioTrackButton(player) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, AudioTrackButton);

    options.tracks = player.audioTracks && player.audioTracks();

    _TrackButton.call(this, player, options);

    this.el_.setAttribute('aria-label', 'Audio Menu');
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);
  };

  /**
   * Create a menu item for each audio track
   *
   * @return {Array} Array of menu items
   * @method createItems
   */

  AudioTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    var tracks = this.player_.audioTracks && this.player_.audioTracks();

    if (!tracks) {
      return items;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      items.push(new _audioTrackMenuItemJs2['default'](this.player_, {
        // MenuItem is selectable
        'selectable': true,
        'track': track
      }));
    }

    return items;
  };

  return AudioTrackButton;
})(_trackButtonJs2['default']);

AudioTrackButton.prototype.controlText_ = 'Audio Track';
_componentJs2['default'].registerComponent('AudioTrackButton', AudioTrackButton);
exports['default'] = AudioTrackButton;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/fn.js":144,"../track-button.js":98,"./audio-track-menu-item.js":69}],69:[function(_dereq_,module,exports){
/**
 * @file audio-track-menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

/**
 * The audio track menu item
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuItem
 * @class AudioTrackMenuItem
 */

var AudioTrackMenuItem = (function (_MenuItem) {
  _inherits(AudioTrackMenuItem, _MenuItem);

  function AudioTrackMenuItem(player, options) {
    var _this = this;

    _classCallCheck(this, AudioTrackMenuItem);

    var track = options.track;
    var tracks = player.audioTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.enabled;

    _MenuItem.call(this, player, options);

    this.track = track;

    if (tracks) {
      (function () {
        var changeHandler = Fn.bind(_this, _this.handleTracksChange);

        tracks.addEventListener('change', changeHandler);
        _this.on('dispose', function () {
          tracks.removeEventListener('change', changeHandler);
        });
      })();
    }
  }

  /**
   * Handle click on audio track
   *
   * @method handleClick
   */

  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var tracks = this.player_.audioTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) return;

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      track.enabled = track === this.track;
    }
  };

  /**
   * Handle audio track change
   *
   * @method handleTracksChange
   */

  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };

  return AudioTrackMenuItem;
})(_menuMenuItemJs2['default']);

_componentJs2['default'].registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);
exports['default'] = AudioTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":67,"../../menu/menu-item.js":110,"../../utils/fn.js":144}],70:[function(_dereq_,module,exports){
/**
 * @file control-bar.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

// Required children

var _playToggleJs = _dereq_('./play-toggle.js');

var _playToggleJs2 = _interopRequireDefault(_playToggleJs);

var _timeControlsCurrentTimeDisplayJs = _dereq_('./time-controls/current-time-display.js');

var _timeControlsCurrentTimeDisplayJs2 = _interopRequireDefault(_timeControlsCurrentTimeDisplayJs);

var _timeControlsDurationDisplayJs = _dereq_('./time-controls/duration-display.js');

var _timeControlsDurationDisplayJs2 = _interopRequireDefault(_timeControlsDurationDisplayJs);

var _timeControlsTimeDividerJs = _dereq_('./time-controls/time-divider.js');

var _timeControlsTimeDividerJs2 = _interopRequireDefault(_timeControlsTimeDividerJs);

var _timeControlsRemainingTimeDisplayJs = _dereq_('./time-controls/remaining-time-display.js');

var _timeControlsRemainingTimeDisplayJs2 = _interopRequireDefault(_timeControlsRemainingTimeDisplayJs);

var _liveDisplayJs = _dereq_('./live-display.js');

var _liveDisplayJs2 = _interopRequireDefault(_liveDisplayJs);

var _progressControlProgressControlJs = _dereq_('./progress-control/progress-control.js');

var _progressControlProgressControlJs2 = _interopRequireDefault(_progressControlProgressControlJs);

var _fullscreenToggleJs = _dereq_('./fullscreen-toggle.js');

var _fullscreenToggleJs2 = _interopRequireDefault(_fullscreenToggleJs);

var _volumeControlVolumeControlJs = _dereq_('./volume-control/volume-control.js');

var _volumeControlVolumeControlJs2 = _interopRequireDefault(_volumeControlVolumeControlJs);

var _volumeMenuButtonJs = _dereq_('./volume-menu-button.js');

var _volumeMenuButtonJs2 = _interopRequireDefault(_volumeMenuButtonJs);

var _muteToggleJs = _dereq_('./mute-toggle.js');

var _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);

var _textTrackControlsChaptersButtonJs = _dereq_('./text-track-controls/chapters-button.js');

var _textTrackControlsChaptersButtonJs2 = _interopRequireDefault(_textTrackControlsChaptersButtonJs);

var _textTrackControlsDescriptionsButtonJs = _dereq_('./text-track-controls/descriptions-button.js');

var _textTrackControlsDescriptionsButtonJs2 = _interopRequireDefault(_textTrackControlsDescriptionsButtonJs);

var _textTrackControlsSubtitlesButtonJs = _dereq_('./text-track-controls/subtitles-button.js');

var _textTrackControlsSubtitlesButtonJs2 = _interopRequireDefault(_textTrackControlsSubtitlesButtonJs);

var _textTrackControlsCaptionsButtonJs = _dereq_('./text-track-controls/captions-button.js');

var _textTrackControlsCaptionsButtonJs2 = _interopRequireDefault(_textTrackControlsCaptionsButtonJs);

var _audioTrackControlsAudioTrackButtonJs = _dereq_('./audio-track-controls/audio-track-button.js');

var _audioTrackControlsAudioTrackButtonJs2 = _interopRequireDefault(_audioTrackControlsAudioTrackButtonJs);

var _playbackRateMenuPlaybackRateMenuButtonJs = _dereq_('./playback-rate-menu/playback-rate-menu-button.js');

var _playbackRateMenuPlaybackRateMenuButtonJs2 = _interopRequireDefault(_playbackRateMenuPlaybackRateMenuButtonJs);

var _spacerControlsCustomControlSpacerJs = _dereq_('./spacer-controls/custom-control-spacer.js');

var _spacerControlsCustomControlSpacerJs2 = _interopRequireDefault(_spacerControlsCustomControlSpacerJs);

/**
 * Container of main controls
 *
 * @extends Component
 * @class ControlBar
 */

var ControlBar = (function (_Component) {
  _inherits(ControlBar, _Component);

  function ControlBar() {
    _classCallCheck(this, ControlBar);

    _Component.apply(this, arguments);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  ControlBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-control-bar',
      dir: 'ltr'
    }, {
      'role': 'group' // The control bar is a group, so it can contain menuitems
    });
  };

  return ControlBar;
})(_componentJs2['default']);

ControlBar.prototype.options_ = {
  children: ['playToggle', 'volumeMenuButton', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subtitlesButton', 'captionsButton', 'audioTrackButton', 'fullscreenToggle']
};

_componentJs2['default'].registerComponent('ControlBar', ControlBar);
exports['default'] = ControlBar;
module.exports = exports['default'];

},{"../component.js":67,"./audio-track-controls/audio-track-button.js":68,"./fullscreen-toggle.js":71,"./live-display.js":72,"./mute-toggle.js":73,"./play-toggle.js":74,"./playback-rate-menu/playback-rate-menu-button.js":75,"./progress-control/progress-control.js":80,"./spacer-controls/custom-control-spacer.js":83,"./text-track-controls/captions-button.js":86,"./text-track-controls/chapters-button.js":87,"./text-track-controls/descriptions-button.js":89,"./text-track-controls/subtitles-button.js":91,"./time-controls/current-time-display.js":94,"./time-controls/duration-display.js":95,"./time-controls/remaining-time-display.js":96,"./time-controls/time-divider.js":97,"./volume-control/volume-control.js":100,"./volume-menu-button.js":102}],71:[function(_dereq_,module,exports){
/**
 * @file fullscreen-toggle.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _buttonJs = _dereq_('../button.js');

var _buttonJs2 = _interopRequireDefault(_buttonJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Toggle fullscreen video
 *
 * @extends Button
 * @class FullscreenToggle
 */

var FullscreenToggle = (function (_Button) {
  _inherits(FullscreenToggle, _Button);

  function FullscreenToggle(player, options) {
    _classCallCheck(this, FullscreenToggle);

    _Button.call(this, player, options);
    this.on(player, 'fullscreenchange', this.handleFullscreenChange);
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles Fullscreenchange on the component and change control text accordingly
   *
   * @method handleFullscreenChange
   */

  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange() {
    if (this.player_.isFullscreen()) {
      this.controlText('Non-Fullscreen');
    } else {
      this.controlText('Fullscreen');
    }
  };

  /**
   * Handles click for full screen
   *
   * @method handleClick
   */

  FullscreenToggle.prototype.handleClick = function handleClick() {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };

  return FullscreenToggle;
})(_buttonJs2['default']);

FullscreenToggle.prototype.controlText_ = 'Fullscreen';

_componentJs2['default'].registerComponent('FullscreenToggle', FullscreenToggle);
exports['default'] = FullscreenToggle;
module.exports = exports['default'];

},{"../button.js":64,"../component.js":67}],72:[function(_dereq_,module,exports){
/**
 * @file live-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

/**
 * Displays the live indicator
 * TODO - Future make it click to snap to live
 *
 * @extends Component
 * @class LiveDisplay
 */

var LiveDisplay = (function (_Component) {
  _inherits(LiveDisplay, _Component);

  function LiveDisplay(player, options) {
    _classCallCheck(this, LiveDisplay);

    _Component.call(this, player, options);

    this.updateShowing();
    this.on(this.player(), 'durationchange', this.updateShowing);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  LiveDisplay.prototype.createEl = function createEl() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-live-control vjs-control'
    });

    this.contentEl_ = Dom.createEl('div', {
      className: 'vjs-live-display',
      innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  LiveDisplay.prototype.updateShowing = function updateShowing() {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };

  return LiveDisplay;
})(_component2['default']);

_component2['default'].registerComponent('LiveDisplay', LiveDisplay);
exports['default'] = LiveDisplay;
module.exports = exports['default'];

},{"../component":67,"../utils/dom.js":142}],73:[function(_dereq_,module,exports){
/**
 * @file mute-toggle.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _button = _dereq_('../button');

var _button2 = _interopRequireDefault(_button);

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

/**
 * A button component for muting the audio
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Button
 * @class MuteToggle
 */

var MuteToggle = (function (_Button) {
  _inherits(MuteToggle, _Button);

  function MuteToggle(player, options) {
    _classCallCheck(this, MuteToggle);

    _Button.call(this, player, options);

    this.on(player, 'volumechange', this.update);

    // hide mute toggle if the current tech doesn't support volume control
    if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }

    this.on(player, 'loadstart', function () {
      this.update(); // We need to update the button to account for a default muted state.

      if (player.tech_['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handle click on mute
   *
   * @method handleClick
   */

  MuteToggle.prototype.handleClick = function handleClick() {
    this.player_.muted(this.player_.muted() ? false : true);
  };

  /**
   * Update volume
   *
   * @method update
   */

  MuteToggle.prototype.update = function update() {
    var vol = this.player_.volume(),
        level = 3;

    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }

    // Don't rewrite the button text if the actual text doesn't change.
    // This causes unnecessary and confusing information for screen reader users.
    // This check is needed because this function gets called every time the volume level is changed.
    var toMute = this.player_.muted() ? 'Unmute' : 'Mute';
    if (this.controlText() !== toMute) {
      this.controlText(toMute);
    }

    /* TODO improve muted icon classes */
    for (var i = 0; i < 4; i++) {
      Dom.removeElClass(this.el_, 'vjs-vol-' + i);
    }
    Dom.addElClass(this.el_, 'vjs-vol-' + level);
  };

  return MuteToggle;
})(_button2['default']);

MuteToggle.prototype.controlText_ = 'Mute';

_component2['default'].registerComponent('MuteToggle', MuteToggle);
exports['default'] = MuteToggle;
module.exports = exports['default'];

},{"../button":64,"../component":67,"../utils/dom.js":142}],74:[function(_dereq_,module,exports){
/**
 * @file play-toggle.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _buttonJs = _dereq_('../button.js');

var _buttonJs2 = _interopRequireDefault(_buttonJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Button to toggle between play and pause
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Button
 * @class PlayToggle
 */

var PlayToggle = (function (_Button) {
  _inherits(PlayToggle, _Button);

  function PlayToggle(player, options) {
    _classCallCheck(this, PlayToggle);

    _Button.call(this, player, options);

    this.on(player, 'play', this.handlePlay);
    this.on(player, 'pause', this.handlePause);
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handle click to toggle between play and pause
   *
   * @method handleClick
   */

  PlayToggle.prototype.handleClick = function handleClick() {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Add the vjs-playing class to the element so it can change appearance
   *
   * @method handlePlay
   */

  PlayToggle.prototype.handlePlay = function handlePlay() {
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');
    this.controlText('Pause'); // change the button text to "Pause"
  };

  /**
   * Add the vjs-paused class to the element so it can change appearance
   *
   * @method handlePause
   */

  PlayToggle.prototype.handlePause = function handlePause() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    this.controlText('Play'); // change the button text to "Play"
  };

  return PlayToggle;
})(_buttonJs2['default']);

PlayToggle.prototype.controlText_ = 'Play';

_componentJs2['default'].registerComponent('PlayToggle', PlayToggle);
exports['default'] = PlayToggle;
module.exports = exports['default'];

},{"../button.js":64,"../component.js":67}],75:[function(_dereq_,module,exports){
/**
 * @file playback-rate-menu-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _menuMenuButtonJs = _dereq_('../../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _menuMenuJs = _dereq_('../../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _playbackRateMenuItemJs = _dereq_('./playback-rate-menu-item.js');

var _playbackRateMenuItemJs2 = _interopRequireDefault(_playbackRateMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

/**
 * The component for controlling the playback rate
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuButton
 * @class PlaybackRateMenuButton
 */

var PlaybackRateMenuButton = (function (_MenuButton) {
  _inherits(PlaybackRateMenuButton, _MenuButton);

  function PlaybackRateMenuButton(player, options) {
    _classCallCheck(this, PlaybackRateMenuButton);

    _MenuButton.call(this, player, options);

    this.updateVisibility();
    this.updateLabel();

    this.on(player, 'loadstart', this.updateVisibility);
    this.on(player, 'ratechange', this.updateLabel);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  PlaybackRateMenuButton.prototype.createEl = function createEl() {
    var el = _MenuButton.prototype.createEl.call(this);

    this.labelEl_ = Dom.createEl('div', {
      className: 'vjs-playback-rate-value',
      innerHTML: 1.0
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the playback rate menu
   *
   * @return {Menu} Menu object populated with items
   * @method createMenu
   */

  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {
    var menu = new _menuMenuJs2['default'](this.player());
    var rates = this.playbackRates();

    if (rates) {
      for (var i = rates.length - 1; i >= 0; i--) {
        menu.addChild(new _playbackRateMenuItemJs2['default'](this.player(), { 'rate': rates[i] + 'x' }));
      }
    }

    return menu;
  };

  /**
   * Updates ARIA accessibility attributes
   *
   * @method updateARIAAttributes
   */

  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current playback rate
    this.el().setAttribute('aria-valuenow', this.player().playbackRate());
  };

  /**
   * Handle menu item click
   *
   * @method handleClick
   */

  PlaybackRateMenuButton.prototype.handleClick = function handleClick() {
    // select next rate option
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();

    // this will select first one if the last one currently selected
    var newRate = rates[0];
    for (var i = 0; i < rates.length; i++) {
      if (rates[i] > currentRate) {
        newRate = rates[i];
        break;
      }
    }
    this.player().playbackRate(newRate);
  };

  /**
   * Get possible playback rates
   *
   * @return {Array} Possible playback rates
   * @method playbackRates
   */

  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {
    return this.options_['playbackRates'] || this.options_.playerOptions && this.options_.playerOptions['playbackRates'];
  };

  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {Boolean} Whether changing playback rate is supported
   * @method playbackRateSupported
   */

  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_['featuresPlaybackRate'] && this.playbackRates() && this.playbackRates().length > 0;
  };

  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @method updateVisibility
   */

  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility() {
    if (this.playbackRateSupported()) {
      this.removeClass('vjs-hidden');
    } else {
      this.addClass('vjs-hidden');
    }
  };

  /**
   * Update button label when rate changed
   *
   * @method updateLabel
   */

  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel() {
    if (this.playbackRateSupported()) {
      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
    }
  };

  return PlaybackRateMenuButton;
})(_menuMenuButtonJs2['default']);

PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';

_componentJs2['default'].registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);
exports['default'] = PlaybackRateMenuButton;
module.exports = exports['default'];

},{"../../component.js":67,"../../menu/menu-button.js":109,"../../menu/menu.js":111,"../../utils/dom.js":142,"./playback-rate-menu-item.js":76}],76:[function(_dereq_,module,exports){
/**
 * @file playback-rate-menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * The specific menu item type for selecting a playback rate
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuItem
 * @class PlaybackRateMenuItem
 */

var PlaybackRateMenuItem = (function (_MenuItem) {
  _inherits(PlaybackRateMenuItem, _MenuItem);

  function PlaybackRateMenuItem(player, options) {
    _classCallCheck(this, PlaybackRateMenuItem);

    var label = options['rate'];
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options['label'] = label;
    options['selected'] = rate === 1;
    _MenuItem.call(this, player, options);

    this.label = label;
    this.rate = rate;

    this.on(player, 'ratechange', this.update);
  }

  /**
   * Handle click on menu item
   *
   * @method handleClick
   */

  PlaybackRateMenuItem.prototype.handleClick = function handleClick() {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };

  /**
   * Update playback rate with selected rate
   *
   * @method update
   */

  PlaybackRateMenuItem.prototype.update = function update() {
    this.selected(this.player().playbackRate() === this.rate);
  };

  return PlaybackRateMenuItem;
})(_menuMenuItemJs2['default']);

PlaybackRateMenuItem.prototype.contentElType = 'button';

_componentJs2['default'].registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);
exports['default'] = PlaybackRateMenuItem;
module.exports = exports['default'];

},{"../../component.js":67,"../../menu/menu-item.js":110}],77:[function(_dereq_,module,exports){
/**
 * @file load-progress-bar.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

/**
 * Shows load progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class LoadProgressBar
 */

var LoadProgressBar = (function (_Component) {
  _inherits(LoadProgressBar, _Component);

  function LoadProgressBar(player, options) {
    _classCallCheck(this, LoadProgressBar);

    _Component.call(this, player, options);
    this.on(player, 'progress', this.update);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  LoadProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-load-progress',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
    });
  };

  /**
   * Update progress bar
   *
   * @method update
   */

  LoadProgressBar.prototype.update = function update() {
    var buffered = this.player_.buffered();
    var duration = this.player_.duration();
    var bufferedEnd = this.player_.bufferedEnd();
    var children = this.el_.children;

    // get the percent width of a time compared to the total end
    var percentify = function percentify(time, end) {
      var percent = time / end || 0; // no NaN
      return (percent >= 1 ? 1 : percent) * 100 + '%';
    };

    // update the width of the progress bar
    this.el_.style.width = percentify(bufferedEnd, duration);

    // add child elements to represent the individual buffered time ranges
    for (var i = 0; i < buffered.length; i++) {
      var start = buffered.start(i);
      var end = buffered.end(i);
      var part = children[i];

      if (!part) {
        part = this.el_.appendChild(Dom.createEl());
      }

      // set the percent based on the width of the progress bar (bufferedEnd)
      part.style.left = percentify(start, bufferedEnd);
      part.style.width = percentify(end - start, bufferedEnd);
    }

    // remove unused buffered range elements
    for (var i = children.length; i > buffered.length; i--) {
      this.el_.removeChild(children[i - 1]);
    }
  };

  return LoadProgressBar;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('LoadProgressBar', LoadProgressBar);
exports['default'] = LoadProgressBar;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142}],78:[function(_dereq_,module,exports){
/**
 * @file mouse-time-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

var _lodashCompatFunctionThrottle = _dereq_('lodash-compat/function/throttle');

var _lodashCompatFunctionThrottle2 = _interopRequireDefault(_lodashCompatFunctionThrottle);

/**
 * The Mouse Time Display component shows the time you will seek to
 * when hovering over the progress bar
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class MouseTimeDisplay
 */

var MouseTimeDisplay = (function (_Component) {
  _inherits(MouseTimeDisplay, _Component);

  function MouseTimeDisplay(player, options) {
    var _this = this;

    _classCallCheck(this, MouseTimeDisplay);

    _Component.call(this, player, options);

    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {
      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;
    }

    if (this.keepTooltipsInside) {
      this.tooltip = Dom.createEl('div', { className: 'vjs-time-tooltip' });
      this.el().appendChild(this.tooltip);
      this.addClass('vjs-keep-tooltips-inside');
    }

    this.update(0, 0);

    player.on('ready', function () {
      _this.on(player.controlBar.progressControl.el(), 'mousemove', _lodashCompatFunctionThrottle2['default'](Fn.bind(_this, _this.handleMouseMove), 25));
    });
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  MouseTimeDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-mouse-display'
    });
  };

  MouseTimeDisplay.prototype.handleMouseMove = function handleMouseMove(event) {
    var duration = this.player_.duration();
    var newTime = this.calculateDistance(event) * duration;
    var position = event.pageX - Dom.findElPosition(this.el().parentNode).left;

    this.update(newTime, position);
  };

  MouseTimeDisplay.prototype.update = function update(newTime, position) {
    var time = _utilsFormatTimeJs2['default'](newTime, this.player_.duration());

    this.el().style.left = position + 'px';
    this.el().setAttribute('data-current-time', time);

    if (this.keepTooltipsInside) {
      var clampedPosition = this.clampPosition_(position);
      var difference = position - clampedPosition + 1;
      var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltip).width);
      var tooltipWidthHalf = tooltipWidth / 2;

      this.tooltip.innerHTML = time;
      this.tooltip.style.right = '-' + (tooltipWidthHalf - difference) + 'px';
    }
  };

  MouseTimeDisplay.prototype.calculateDistance = function calculateDistance(event) {
    return Dom.getPointerPosition(this.el().parentNode, event).x;
  };

  /**
   * This takes in a horizontal position for the bar and returns a clamped position.
   * Clamped position means that it will keep the position greater than half the width
   * of the tooltip and smaller than the player width minus half the width o the tooltip.
   * It will only clamp the position if `keepTooltipsInside` option is set.
   *
   * @param {Number} position the position the bar wants to be
   * @return {Number} newPosition the (potentially) clamped position
   * @method clampPosition_
   */

  MouseTimeDisplay.prototype.clampPosition_ = function clampPosition_(position) {
    if (!this.keepTooltipsInside) {
      return position;
    }

    var playerWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.player().el()).width);
    var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltip).width);
    var tooltipWidthHalf = tooltipWidth / 2;
    var actualPosition = position;

    if (position < tooltipWidthHalf) {
      actualPosition = Math.ceil(tooltipWidthHalf);
    } else if (position > playerWidth - tooltipWidthHalf) {
      actualPosition = Math.floor(playerWidth - tooltipWidthHalf);
    }

    return actualPosition;
  };

  return MouseTimeDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('MouseTimeDisplay', MouseTimeDisplay);
exports['default'] = MouseTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142,"../../utils/fn.js":144,"../../utils/format-time.js":145,"global/window":2,"lodash-compat/function/throttle":7}],79:[function(_dereq_,module,exports){
/**
 * @file play-progress-bar.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

/**
 * Shows play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class PlayProgressBar
 */

var PlayProgressBar = (function (_Component) {
  _inherits(PlayProgressBar, _Component);

  function PlayProgressBar(player, options) {
    _classCallCheck(this, PlayProgressBar);

    _Component.call(this, player, options);
    this.updateDataAttr();
    this.on(player, 'timeupdate', this.updateDataAttr);
    player.ready(Fn.bind(this, this.updateDataAttr));

    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {
      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;
    }

    if (this.keepTooltipsInside) {
      this.addClass('vjs-keep-tooltips-inside');
    }
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  PlayProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });
  };

  PlayProgressBar.prototype.updateDataAttr = function updateDataAttr() {
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    this.el_.setAttribute('data-current-time', _utilsFormatTimeJs2['default'](time, this.player_.duration()));
  };

  return PlayProgressBar;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('PlayProgressBar', PlayProgressBar);
exports['default'] = PlayProgressBar;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142,"../../utils/fn.js":144,"../../utils/format-time.js":145}],80:[function(_dereq_,module,exports){
/**
 * @file progress-control.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _seekBarJs = _dereq_('./seek-bar.js');

var _seekBarJs2 = _interopRequireDefault(_seekBarJs);

var _mouseTimeDisplayJs = _dereq_('./mouse-time-display.js');

var _mouseTimeDisplayJs2 = _interopRequireDefault(_mouseTimeDisplayJs);

/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class ProgressControl
 */

var ProgressControl = (function (_Component) {
  _inherits(ProgressControl, _Component);

  function ProgressControl() {
    _classCallCheck(this, ProgressControl);

    _Component.apply(this, arguments);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  ProgressControl.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control'
    });
  };

  return ProgressControl;
})(_componentJs2['default']);

ProgressControl.prototype.options_ = {
  children: ['seekBar']
};

_componentJs2['default'].registerComponent('ProgressControl', ProgressControl);
exports['default'] = ProgressControl;
module.exports = exports['default'];

},{"../../component.js":67,"./mouse-time-display.js":78,"./seek-bar.js":81}],81:[function(_dereq_,module,exports){
/**
 * @file seek-bar.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _sliderSliderJs = _dereq_('../../slider/slider.js');

var _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _loadProgressBarJs = _dereq_('./load-progress-bar.js');

var _loadProgressBarJs2 = _interopRequireDefault(_loadProgressBarJs);

var _playProgressBarJs = _dereq_('./play-progress-bar.js');

var _playProgressBarJs2 = _interopRequireDefault(_playProgressBarJs);

var _tooltipProgressBarJs = _dereq_('./tooltip-progress-bar.js');

var _tooltipProgressBarJs2 = _interopRequireDefault(_tooltipProgressBarJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

/**
 * Seek Bar and holder for the progress bars
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Slider
 * @class SeekBar
 */

var SeekBar = (function (_Slider) {
  _inherits(SeekBar, _Slider);

  function SeekBar(player, options) {
    _classCallCheck(this, SeekBar);

    _Slider.call(this, player, options);
    this.on(player, 'timeupdate', this.updateProgress);
    this.on(player, 'ended', this.updateProgress);
    player.ready(Fn.bind(this, this.updateProgress));

    if (options.playerOptions && options.playerOptions.controlBar && options.playerOptions.controlBar.progressControl && options.playerOptions.controlBar.progressControl.keepTooltipsInside) {
      this.keepTooltipsInside = options.playerOptions.controlBar.progressControl.keepTooltipsInside;
    }

    if (this.keepTooltipsInside) {
      this.tooltipProgressBar = this.addChild('TooltipProgressBar');
    }
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  SeekBar.prototype.createEl = function createEl() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': 'progress bar'
    });
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @method updateARIAAttributes
   */

  SeekBar.prototype.updateProgress = function updateProgress() {
    this.updateAriaAttributes(this.el_);

    if (this.keepTooltipsInside) {
      this.updateAriaAttributes(this.tooltipProgressBar.el_);
      this.tooltipProgressBar.el_.style.width = this.bar.el_.style.width;

      var playerWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.player().el()).width);
      var tooltipWidth = parseFloat(_globalWindow2['default'].getComputedStyle(this.tooltipProgressBar.tooltip).width);
      var tooltipStyle = this.tooltipProgressBar.el().style;
      tooltipStyle.maxWidth = Math.floor(playerWidth - tooltipWidth / 2) + 'px';
      tooltipStyle.minWidth = Math.ceil(tooltipWidth / 2) + 'px';
      tooltipStyle.right = '-' + tooltipWidth / 2 + 'px';
    }
  };

  SeekBar.prototype.updateAriaAttributes = function updateAriaAttributes(el) {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    el.setAttribute('aria-valuenow', (this.getPercent() * 100).toFixed(2)); // machine readable value of progress bar (percentage complete)
    el.setAttribute('aria-valuetext', _utilsFormatTimeJs2['default'](time, this.player_.duration())); // human readable value of progress bar (time complete)
  };

  /**
   * Get percentage of video played
   *
   * @return {Number} Percentage played
   * @method getPercent
   */

  SeekBar.prototype.getPercent = function getPercent() {
    var percent = this.player_.currentTime() / this.player_.duration();
    return percent >= 1 ? 1 : percent;
  };

  /**
   * Handle mouse down on seek bar
   *
   * @method handleMouseDown
   */

  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    _Slider.prototype.handleMouseDown.call(this, event);

    this.player_.scrubbing(true);

    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();
  };

  /**
   * Handle mouse move on seek bar
   *
   * @method handleMouseMove
   */

  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {
    var newTime = this.calculateDistance(event) * this.player_.duration();

    // Don't let video end while scrubbing.
    if (newTime === this.player_.duration()) {
      newTime = newTime - 0.1;
    }

    // Set new time (tell player to seek to new time)
    this.player_.currentTime(newTime);
  };

  /**
   * Handle mouse up on seek bar
   *
   * @method handleMouseUp
   */

  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);

    this.player_.scrubbing(false);
    if (this.videoWasPlaying) {
      this.player_.play();
    }
  };

  /**
   * Move more quickly fast forward for keyboard-only users
   *
   * @method stepForward
   */

  SeekBar.prototype.stepForward = function stepForward() {
    this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
  };

  /**
   * Move more quickly rewind for keyboard-only users
   *
   * @method stepBack
   */

  SeekBar.prototype.stepBack = function stepBack() {
    this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users
  };

  return SeekBar;
})(_sliderSliderJs2['default']);

SeekBar.prototype.options_ = {
  children: ['loadProgressBar', 'mouseTimeDisplay', 'playProgressBar'],
  'barName': 'playProgressBar'
};

SeekBar.prototype.playerEvent = 'timeupdate';

_componentJs2['default'].registerComponent('SeekBar', SeekBar);
exports['default'] = SeekBar;
module.exports = exports['default'];

},{"../../component.js":67,"../../slider/slider.js":119,"../../utils/fn.js":144,"../../utils/format-time.js":145,"./load-progress-bar.js":77,"./play-progress-bar.js":79,"./tooltip-progress-bar.js":82,"global/window":2,"object.assign":45}],82:[function(_dereq_,module,exports){
/**
 * @file play-progress-bar.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

/**
 * Shows play progress
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class PlayProgressBar
 */

var TooltipProgressBar = (function (_Component) {
  _inherits(TooltipProgressBar, _Component);

  function TooltipProgressBar(player, options) {
    _classCallCheck(this, TooltipProgressBar);

    _Component.call(this, player, options);
    this.updateDataAttr();
    this.on(player, 'timeupdate', this.updateDataAttr);
    player.ready(Fn.bind(this, this.updateDataAttr));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  TooltipProgressBar.prototype.createEl = function createEl() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-tooltip-progress-bar vjs-slider-bar',
      innerHTML: '<div class="vjs-time-tooltip"></div>\n        <span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });

    this.tooltip = el.querySelector('.vjs-time-tooltip');

    return el;
  };

  TooltipProgressBar.prototype.updateDataAttr = function updateDataAttr() {
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    var formattedTime = _utilsFormatTimeJs2['default'](time, this.player_.duration());
    this.el_.setAttribute('data-current-time', formattedTime);
    this.tooltip.innerHTML = formattedTime;
  };

  return TooltipProgressBar;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('TooltipProgressBar', TooltipProgressBar);
exports['default'] = TooltipProgressBar;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142,"../../utils/fn.js":144,"../../utils/format-time.js":145}],83:[function(_dereq_,module,exports){
/**
 * @file custom-control-spacer.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _spacerJs = _dereq_('./spacer.js');

var _spacerJs2 = _interopRequireDefault(_spacerJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @extends Spacer
 * @class CustomControlSpacer
 */

var CustomControlSpacer = (function (_Spacer) {
  _inherits(CustomControlSpacer, _Spacer);

  function CustomControlSpacer() {
    _classCallCheck(this, CustomControlSpacer);

    _Spacer.apply(this, arguments);
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  CustomControlSpacer.prototype.createEl = function createEl() {
    var el = _Spacer.prototype.createEl.call(this, {
      className: this.buildCSSClass()
    });

    // No-flex/table-cell mode requires there be some content
    // in the cell to fill the remaining space of the table.
    el.innerHTML = '&nbsp;';
    return el;
  };

  return CustomControlSpacer;
})(_spacerJs2['default']);

_componentJs2['default'].registerComponent('CustomControlSpacer', CustomControlSpacer);
exports['default'] = CustomControlSpacer;
module.exports = exports['default'];

},{"../../component.js":67,"./spacer.js":84}],84:[function(_dereq_,module,exports){
/**
 * @file spacer.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @extends Component
 * @class Spacer
 */

var Spacer = (function (_Component) {
  _inherits(Spacer, _Component);

  function Spacer() {
    _classCallCheck(this, Spacer);

    _Component.apply(this, arguments);
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  Spacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  Spacer.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  return Spacer;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Spacer', Spacer);

exports['default'] = Spacer;
module.exports = exports['default'];

},{"../../component.js":67}],85:[function(_dereq_,module,exports){
/**
 * @file caption-settings-menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * The menu item for caption track settings menu
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends TextTrackMenuItem
 * @class CaptionSettingsMenuItem
 */

var CaptionSettingsMenuItem = (function (_TextTrackMenuItem) {
  _inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  function CaptionSettingsMenuItem(player, options) {
    _classCallCheck(this, CaptionSettingsMenuItem);

    options['track'] = {
      'kind': options['kind'],
      'player': player,
      'label': options['kind'] + ' settings',
      'selectable': false,
      'default': false,
      mode: 'disabled'
    };

    // CaptionSettingsMenuItem has no concept of 'selected'
    options['selectable'] = false;

    _TextTrackMenuItem.call(this, player, options);
    this.addClass('vjs-texttrack-settings');
    this.controlText(', opens ' + options['kind'] + ' settings dialog');
  }

  /**
   * Handle click on menu item
   *
   * @method handleClick
   */

  CaptionSettingsMenuItem.prototype.handleClick = function handleClick() {
    this.player().getChild('textTrackSettings').show();
    this.player().getChild('textTrackSettings').el_.focus();
  };

  return CaptionSettingsMenuItem;
})(_textTrackMenuItemJs2['default']);

_componentJs2['default'].registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);
exports['default'] = CaptionSettingsMenuItem;
module.exports = exports['default'];

},{"../../component.js":67,"./text-track-menu-item.js":93}],86:[function(_dereq_,module,exports){
/**
 * @file captions-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _captionSettingsMenuItemJs = _dereq_('./caption-settings-menu-item.js');

var _captionSettingsMenuItemJs2 = _interopRequireDefault(_captionSettingsMenuItemJs);

/**
 * The button component for toggling and selecting captions
 *
 * @param {Object} player  Player object
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends TextTrackButton
 * @class CaptionsButton
 */

var CaptionsButton = (function (_TextTrackButton) {
  _inherits(CaptionsButton, _TextTrackButton);

  function CaptionsButton(player, options, ready) {
    _classCallCheck(this, CaptionsButton);

    _TextTrackButton.call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Captions Menu');
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  /**
   * Update caption menu items
   *
   * @method update
   */

  CaptionsButton.prototype.update = function update() {
    var threshold = 2;
    _TextTrackButton.prototype.update.call(this);

    // if native, then threshold is 1 because no settings button
    if (this.player().tech_ && this.player().tech_['featuresNativeTextTracks']) {
      threshold = 1;
    }

    if (this.items && this.items.length > threshold) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Create caption menu items
   *
   * @return {Array} Array of menu items
   * @method createItems
   */

  CaptionsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_['featuresNativeTextTracks'])) {
      items.push(new _captionSettingsMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));
    }

    return _TextTrackButton.prototype.createItems.call(this, items);
  };

  return CaptionsButton;
})(_textTrackButtonJs2['default']);

CaptionsButton.prototype.kind_ = 'captions';
CaptionsButton.prototype.controlText_ = 'Captions';

_componentJs2['default'].registerComponent('CaptionsButton', CaptionsButton);
exports['default'] = CaptionsButton;
module.exports = exports['default'];

},{"../../component.js":67,"./caption-settings-menu-item.js":85,"./text-track-button.js":92}],87:[function(_dereq_,module,exports){
/**
 * @file chapters-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var _chaptersTrackMenuItemJs = _dereq_('./chapters-track-menu-item.js');

var _chaptersTrackMenuItemJs2 = _interopRequireDefault(_chaptersTrackMenuItemJs);

var _menuMenuJs = _dereq_('../../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsToTitleCaseJs = _dereq_('../../utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

/**
 * The button component for toggling and selecting chapters
 * Chapters act much differently than other text tracks
 * Cues are navigation vs. other tracks of alternative languages
 *
 * @param {Object} player  Player object
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends TextTrackButton
 * @class ChaptersButton
 */

var ChaptersButton = (function (_TextTrackButton) {
  _inherits(ChaptersButton, _TextTrackButton);

  function ChaptersButton(player, options, ready) {
    _classCallCheck(this, ChaptersButton);

    _TextTrackButton.call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Chapters Menu');
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  /**
   * Create a menu item for each text track
   *
   * @return {Array} Array of menu items
   * @method createItems
   */

  ChaptersButton.prototype.createItems = function createItems() {
    var items = [];

    var tracks = this.player_.textTracks();

    if (!tracks) {
      return items;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (track['kind'] === this.kind_) {
        items.push(new _textTrackMenuItemJs2['default'](this.player_, {
          'track': track
        }));
      }
    }

    return items;
  };

  /**
   * Create menu from chapter buttons
   *
   * @return {Menu} Menu of chapter buttons
   * @method createMenu
   */

  ChaptersButton.prototype.createMenu = function createMenu() {
    var _this = this;

    var tracks = this.player_.textTracks() || [];
    var chaptersTrack = undefined;
    var items = this.items || [];

    for (var i = tracks.length - 1; i >= 0; i--) {

      // We will always choose the last track as our chaptersTrack
      var track = tracks[i];

      if (track['kind'] === this.kind_) {
        chaptersTrack = track;

        break;
      }
    }

    var menu = this.menu;
    if (menu === undefined) {
      menu = new _menuMenuJs2['default'](this.player_);
      var title = Dom.createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: _utilsToTitleCaseJs2['default'](this.kind_),
        tabIndex: -1
      });
      menu.children_.unshift(title);
      Dom.insertElFirst(title, menu.contentEl());
    } else {
      // We will empty out the menu children each time because we want a
      // fresh new menu child list each time
      items.forEach(function (item) {
        return menu.removeChild(item);
      });
      // Empty out the ChaptersButton menu items because we no longer need them
      items = [];
    }

    if (chaptersTrack && chaptersTrack.cues == null) {
      chaptersTrack['mode'] = 'hidden';

      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(chaptersTrack);

      if (remoteTextTrackEl) {
        remoteTextTrackEl.addEventListener('load', function (event) {
          return _this.update();
        });
      }
    }

    if (chaptersTrack && chaptersTrack.cues && chaptersTrack.cues.length > 0) {
      var cues = chaptersTrack['cues'],
          cue = undefined;

      for (var i = 0, l = cues.length; i < l; i++) {
        cue = cues[i];

        var mi = new _chaptersTrackMenuItemJs2['default'](this.player_, {
          'track': chaptersTrack,
          'cue': cue
        });

        items.push(mi);

        menu.addChild(mi);
      }
    }

    if (items.length > 0) {
      this.show();
    }
    // Assigning the value of items back to this.items for next iteration
    this.items = items;
    return menu;
  };

  return ChaptersButton;
})(_textTrackButtonJs2['default']);

ChaptersButton.prototype.kind_ = 'chapters';
ChaptersButton.prototype.controlText_ = 'Chapters';

_componentJs2['default'].registerComponent('ChaptersButton', ChaptersButton);
exports['default'] = ChaptersButton;
module.exports = exports['default'];

},{"../../component.js":67,"../../menu/menu.js":111,"../../utils/dom.js":142,"../../utils/fn.js":144,"../../utils/to-title-case.js":151,"./chapters-track-menu-item.js":88,"./text-track-button.js":92,"./text-track-menu-item.js":93,"global/window":2}],88:[function(_dereq_,module,exports){
/**
 * @file chapters-track-menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

/**
 * The chapter track menu item
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuItem
 * @class ChaptersTrackMenuItem
 */

var ChaptersTrackMenuItem = (function (_MenuItem) {
  _inherits(ChaptersTrackMenuItem, _MenuItem);

  function ChaptersTrackMenuItem(player, options) {
    _classCallCheck(this, ChaptersTrackMenuItem);

    var track = options['track'];
    var cue = options['cue'];
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options['label'] = cue.text;
    options['selected'] = cue['startTime'] <= currentTime && currentTime < cue['endTime'];
    _MenuItem.call(this, player, options);

    this.track = track;
    this.cue = cue;
    track.addEventListener('cuechange', Fn.bind(this, this.update));
  }

  /**
   * Handle click on menu item
   *
   * @method handleClick
   */

  ChaptersTrackMenuItem.prototype.handleClick = function handleClick() {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
    this.update(this.cue.startTime);
  };

  /**
   * Update chapter menu item
   *
   * @method update
   */

  ChaptersTrackMenuItem.prototype.update = function update() {
    var cue = this.cue;
    var currentTime = this.player_.currentTime();

    // vjs.log(currentTime, cue.startTime);
    this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);
  };

  return ChaptersTrackMenuItem;
})(_menuMenuItemJs2['default']);

_componentJs2['default'].registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);
exports['default'] = ChaptersTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":67,"../../menu/menu-item.js":110,"../../utils/fn.js":144}],89:[function(_dereq_,module,exports){
/**
 * @file descriptions-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

/**
 * The button component for toggling and selecting descriptions
 *
 * @param {Object} player  Player object
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends TextTrackButton
 * @class DescriptionsButton
 */

var DescriptionsButton = (function (_TextTrackButton) {
  _inherits(DescriptionsButton, _TextTrackButton);

  function DescriptionsButton(player, options, ready) {
    var _this = this;

    _classCallCheck(this, DescriptionsButton);

    _TextTrackButton.call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Descriptions Menu');

    var tracks = player.textTracks();

    if (tracks) {
      (function () {
        var changeHandler = Fn.bind(_this, _this.handleTracksChange);

        tracks.addEventListener('change', changeHandler);
        _this.on('dispose', function () {
          tracks.removeEventListener('change', changeHandler);
        });
      })();
    }
  }

  /**
   * Handle text track change
   *
   * @method handleTracksChange
   */

  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;

    // Check whether a track of a different kind is showing
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (track['kind'] !== this.kind_ && track['mode'] === 'showing') {
        disabled = true;
        break;
      }
    }

    // If another track is showing, disable this menu button
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  return DescriptionsButton;
})(_textTrackButtonJs2['default']);

DescriptionsButton.prototype.kind_ = 'descriptions';
DescriptionsButton.prototype.controlText_ = 'Descriptions';

_componentJs2['default'].registerComponent('DescriptionsButton', DescriptionsButton);
exports['default'] = DescriptionsButton;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/fn.js":144,"./text-track-button.js":92}],90:[function(_dereq_,module,exports){
/**
 * @file off-text-track-menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * A special menu item for turning of a specific type of text track
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends TextTrackMenuItem
 * @class OffTextTrackMenuItem
 */

var OffTextTrackMenuItem = (function (_TextTrackMenuItem) {
  _inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  function OffTextTrackMenuItem(player, options) {
    _classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options['track'] = {
      'kind': options['kind'],
      'player': player,
      'label': options['kind'] + ' off',
      'default': false,
      'mode': 'disabled'
    };

    // MenuItem is selectable
    options['selectable'] = true;

    _TextTrackMenuItem.call(this, player, options);
    this.selected(true);
  }

  /**
   * Handle text track change
   *
   * @param {Object} event Event object
   * @method handleTracksChange
   */

  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var selected = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {
        selected = false;
        break;
      }
    }

    this.selected(selected);
  };

  return OffTextTrackMenuItem;
})(_textTrackMenuItemJs2['default']);

_componentJs2['default'].registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);
exports['default'] = OffTextTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":67,"./text-track-menu-item.js":93}],91:[function(_dereq_,module,exports){
/**
 * @file subtitles-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackButtonJs = _dereq_('./text-track-button.js');

var _textTrackButtonJs2 = _interopRequireDefault(_textTrackButtonJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * The button component for toggling and selecting subtitles
 *
 * @param {Object} player  Player object
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends TextTrackButton
 * @class SubtitlesButton
 */

var SubtitlesButton = (function (_TextTrackButton) {
  _inherits(SubtitlesButton, _TextTrackButton);

  function SubtitlesButton(player, options, ready) {
    _classCallCheck(this, SubtitlesButton);

    _TextTrackButton.call(this, player, options, ready);
    this.el_.setAttribute('aria-label', 'Subtitles Menu');
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  return SubtitlesButton;
})(_textTrackButtonJs2['default']);

SubtitlesButton.prototype.kind_ = 'subtitles';
SubtitlesButton.prototype.controlText_ = 'Subtitles';

_componentJs2['default'].registerComponent('SubtitlesButton', SubtitlesButton);
exports['default'] = SubtitlesButton;
module.exports = exports['default'];

},{"../../component.js":67,"./text-track-button.js":92}],92:[function(_dereq_,module,exports){
/**
 * @file text-track-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackButtonJs = _dereq_('../track-button.js');

var _trackButtonJs2 = _interopRequireDefault(_trackButtonJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _textTrackMenuItemJs = _dereq_('./text-track-menu-item.js');

var _textTrackMenuItemJs2 = _interopRequireDefault(_textTrackMenuItemJs);

var _offTextTrackMenuItemJs = _dereq_('./off-text-track-menu-item.js');

var _offTextTrackMenuItemJs2 = _interopRequireDefault(_offTextTrackMenuItemJs);

/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuButton
 * @class TextTrackButton
 */

var TextTrackButton = (function (_TrackButton) {
  _inherits(TextTrackButton, _TrackButton);

  function TextTrackButton(player) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, TextTrackButton);

    options.tracks = player.textTracks();

    _TrackButton.call(this, player, options);
  }

  /**
   * Create a menu item for each text track
   *
   * @return {Array} Array of menu items
   * @method createItems
   */

  TextTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    // Add an OFF menu item to turn all tracks off
    items.push(new _offTextTrackMenuItemJs2['default'](this.player_, { 'kind': this.kind_ }));

    var tracks = this.player_.textTracks();

    if (!tracks) {
      return items;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // only add tracks that are of the appropriate kind and have a label
      if (track['kind'] === this.kind_) {
        items.push(new _textTrackMenuItemJs2['default'](this.player_, {
          // MenuItem is selectable
          'selectable': true,
          'track': track
        }));
      }
    }

    return items;
  };

  return TextTrackButton;
})(_trackButtonJs2['default']);

_componentJs2['default'].registerComponent('TextTrackButton', TextTrackButton);
exports['default'] = TextTrackButton;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/fn.js":144,"../track-button.js":98,"./off-text-track-menu-item.js":90,"./text-track-menu-item.js":93}],93:[function(_dereq_,module,exports){
/**
 * @file text-track-menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _menuMenuItemJs = _dereq_('../../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuItem
 * @class TextTrackMenuItem
 */

var TextTrackMenuItem = (function (_MenuItem) {
  _inherits(TextTrackMenuItem, _MenuItem);

  function TextTrackMenuItem(player, options) {
    var _this = this;

    _classCallCheck(this, TextTrackMenuItem);

    var track = options['track'];
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options['label'] = track['label'] || track['language'] || 'Unknown';
    options['selected'] = track['default'] || track['mode'] === 'showing';

    _MenuItem.call(this, player, options);

    this.track = track;

    if (tracks) {
      (function () {
        var changeHandler = Fn.bind(_this, _this.handleTracksChange);

        tracks.addEventListener('change', changeHandler);
        _this.on('dispose', function () {
          tracks.removeEventListener('change', changeHandler);
        });
      })();
    }

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks && tracks.onchange === undefined) {
      (function () {
        var event = undefined;

        _this.on(['tap', 'click'], function () {
          if (typeof _globalWindow2['default'].Event !== 'object') {
            // Android 2.3 throws an Illegal Constructor error for window.Event
            try {
              event = new _globalWindow2['default'].Event('change');
            } catch (err) {}
          }

          if (!event) {
            event = _globalDocument2['default'].createEvent('Event');
            event.initEvent('change', true, true);
          }

          tracks.dispatchEvent(event);
        });
      })();
    }
  }

  /**
   * Handle click on text track
   *
   * @method handleClick
   */

  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var kind = this.track['kind'];
    var tracks = this.player_.textTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) return;

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      if (track['kind'] !== kind) {
        continue;
      }

      if (track === this.track) {
        track['mode'] = 'showing';
      } else {
        track['mode'] = 'disabled';
      }
    }
  };

  /**
   * Handle text track change
   *
   * @method handleTracksChange
   */

  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track['mode'] === 'showing');
  };

  return TextTrackMenuItem;
})(_menuMenuItemJs2['default']);

_componentJs2['default'].registerComponent('TextTrackMenuItem', TextTrackMenuItem);
exports['default'] = TextTrackMenuItem;
module.exports = exports['default'];

},{"../../component.js":67,"../../menu/menu-item.js":110,"../../utils/fn.js":144,"global/document":1,"global/window":2}],94:[function(_dereq_,module,exports){
/**
 * @file current-time-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

/**
 * Displays the current time
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class CurrentTimeDisplay
 */

var CurrentTimeDisplay = (function (_Component) {
  _inherits(CurrentTimeDisplay, _Component);

  function CurrentTimeDisplay(player, options) {
    _classCallCheck(this, CurrentTimeDisplay);

    _Component.call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  CurrentTimeDisplay.prototype.createEl = function createEl() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-current-time vjs-time-control vjs-control'
    });

    this.contentEl_ = Dom.createEl('div', {
      className: 'vjs-current-time-display',
      // label the current time for screen reader users
      innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Update current time display
   *
   * @method updateContent
   */

  CurrentTimeDisplay.prototype.updateContent = function updateContent() {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    var localizedText = this.localize('Current Time');
    var formattedTime = _utilsFormatTimeJs2['default'](time, this.player_.duration());
    if (formattedTime !== this.formattedTime_) {
      this.formattedTime_ = formattedTime;
      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime;
    }
  };

  return CurrentTimeDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);
exports['default'] = CurrentTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142,"../../utils/format-time.js":145}],95:[function(_dereq_,module,exports){
/**
 * @file duration-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

/**
 * Displays the duration
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class DurationDisplay
 */

var DurationDisplay = (function (_Component) {
  _inherits(DurationDisplay, _Component);

  function DurationDisplay(player, options) {
    _classCallCheck(this, DurationDisplay);

    _Component.call(this, player, options);

    this.on(player, 'durationchange', this.updateContent);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  DurationDisplay.prototype.createEl = function createEl() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-duration vjs-time-control vjs-control'
    });

    this.contentEl_ = Dom.createEl('div', {
      className: 'vjs-duration-display',
      // label the duration time for screen reader users
      innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> 0:00'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Update duration time display
   *
   * @method updateContent
   */

  DurationDisplay.prototype.updateContent = function updateContent() {
    var duration = this.player_.duration();
    if (duration && this.duration_ !== duration) {
      this.duration_ = duration;
      var localizedText = this.localize('Duration Time');
      var formattedTime = _utilsFormatTimeJs2['default'](duration);
      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> ' + formattedTime; // label the duration time for screen reader users
    }
  };

  return DurationDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('DurationDisplay', DurationDisplay);
exports['default'] = DurationDisplay;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142,"../../utils/format-time.js":145}],96:[function(_dereq_,module,exports){
/**
 * @file remaining-time-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFormatTimeJs = _dereq_('../../utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

/**
 * Displays the time left in the video
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class RemainingTimeDisplay
 */

var RemainingTimeDisplay = (function (_Component) {
  _inherits(RemainingTimeDisplay, _Component);

  function RemainingTimeDisplay(player, options) {
    _classCallCheck(this, RemainingTimeDisplay);

    _Component.call(this, player, options);

    this.on(player, 'timeupdate', this.updateContent);
    this.on(player, 'durationchange', this.updateContent);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  RemainingTimeDisplay.prototype.createEl = function createEl() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-remaining-time vjs-time-control vjs-control'
    });

    this.contentEl_ = Dom.createEl('div', {
      className: 'vjs-remaining-time-display',
      // label the remaining time for screen reader users
      innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> -0:00'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Update remaining time display
   *
   * @method updateContent
   */

  RemainingTimeDisplay.prototype.updateContent = function updateContent() {
    if (this.player_.duration()) {
      var localizedText = this.localize('Remaining Time');
      var formattedTime = _utilsFormatTimeJs2['default'](this.player_.remainingTime());
      if (formattedTime !== this.formattedTime_) {
        this.formattedTime_ = formattedTime;
        this.contentEl_.innerHTML = '<span class="vjs-control-text">' + localizedText + '</span> -' + formattedTime;
      }
    }

    // Allows for smooth scrubbing, when player can't keep up.
    // var time = (this.player_.scrubbing()) ? this.player_.getCache().currentTime : this.player_.currentTime();
    // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
  };

  return RemainingTimeDisplay;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);
exports['default'] = RemainingTimeDisplay;
module.exports = exports['default'];

},{"../../component.js":67,"../../utils/dom.js":142,"../../utils/format-time.js":145}],97:[function(_dereq_,module,exports){
/**
 * @file time-divider.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * The separator between the current time and duration.
 * Can be hidden if it's not needed in the design.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class TimeDivider
 */

var TimeDivider = (function (_Component) {
  _inherits(TimeDivider, _Component);

  function TimeDivider() {
    _classCallCheck(this, TimeDivider);

    _Component.apply(this, arguments);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  TimeDivider.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-control vjs-time-divider',
      innerHTML: '<div><span>/</span></div>'
    });
  };

  return TimeDivider;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('TimeDivider', TimeDivider);
exports['default'] = TimeDivider;
module.exports = exports['default'];

},{"../../component.js":67}],98:[function(_dereq_,module,exports){
/**
 * @file track-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _menuMenuButtonJs = _dereq_('../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends MenuButton
 * @class TrackButton
 */

var TrackButton = (function (_MenuButton) {
  _inherits(TrackButton, _MenuButton);

  function TrackButton(player, options) {
    _classCallCheck(this, TrackButton);

    var tracks = options.tracks;

    _MenuButton.call(this, player, options);

    if (this.items.length <= 1) {
      this.hide();
    }

    if (!tracks) {
      return;
    }

    var updateHandler = Fn.bind(this, this.update);
    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);

    this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
  }

  return TrackButton;
})(_menuMenuButtonJs2['default']);

_componentJs2['default'].registerComponent('TrackButton', TrackButton);
exports['default'] = TrackButton;
module.exports = exports['default'];

},{"../component.js":67,"../menu/menu-button.js":109,"../utils/fn.js":144}],99:[function(_dereq_,module,exports){
/**
 * @file volume-bar.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _sliderSliderJs = _dereq_('../../slider/slider.js');

var _sliderSliderJs2 = _interopRequireDefault(_sliderSliderJs);

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('../../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

// Required children

var _volumeLevelJs = _dereq_('./volume-level.js');

var _volumeLevelJs2 = _interopRequireDefault(_volumeLevelJs);

/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Slider
 * @class VolumeBar
 */

var VolumeBar = (function (_Slider) {
  _inherits(VolumeBar, _Slider);

  function VolumeBar(player, options) {
    _classCallCheck(this, VolumeBar);

    _Slider.call(this, player, options);
    this.on(player, 'volumechange', this.updateARIAAttributes);
    player.ready(Fn.bind(this, this.updateARIAAttributes));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  VolumeBar.prototype.createEl = function createEl() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-bar vjs-slider-bar'
    }, {
      'aria-label': 'volume level'
    });
  };

  /**
   * Handle mouse move on volume bar
   *
   * @method handleMouseMove
   */

  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };

  VolumeBar.prototype.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };

  /**
   * Get percent of volume level
   *
   * @retun {Number} Volume level percent
   * @method getPercent
   */

  VolumeBar.prototype.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    } else {
      return this.player_.volume();
    }
  };

  /**
   * Increase volume level for keyboard users
   *
   * @method stepForward
   */

  VolumeBar.prototype.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };

  /**
   * Decrease volume level for keyboard users
   *
   * @method stepBack
   */

  VolumeBar.prototype.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @method updateARIAAttributes
   */

  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current value of volume bar as a percentage
    var volume = (this.player_.volume() * 100).toFixed(2);
    this.el_.setAttribute('aria-valuenow', volume);
    this.el_.setAttribute('aria-valuetext', volume + '%');
  };

  return VolumeBar;
})(_sliderSliderJs2['default']);

VolumeBar.prototype.options_ = {
  children: ['volumeLevel'],
  'barName': 'volumeLevel'
};

VolumeBar.prototype.playerEvent = 'volumechange';

_componentJs2['default'].registerComponent('VolumeBar', VolumeBar);
exports['default'] = VolumeBar;
module.exports = exports['default'];

},{"../../component.js":67,"../../slider/slider.js":119,"../../utils/fn.js":144,"./volume-level.js":101}],100:[function(_dereq_,module,exports){
/**
 * @file volume-control.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

// Required children

var _volumeBarJs = _dereq_('./volume-bar.js');

var _volumeBarJs2 = _interopRequireDefault(_volumeBarJs);

/**
 * The component for controlling the volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class VolumeControl
 */

var VolumeControl = (function (_Component) {
  _inherits(VolumeControl, _Component);

  function VolumeControl(player, options) {
    _classCallCheck(this, VolumeControl);

    _Component.call(this, player, options);

    // hide volume controls when they're not supported by the current tech
    if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {
      this.addClass('vjs-hidden');
    }
    this.on(player, 'loadstart', function () {
      if (player.tech_['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    });
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  VolumeControl.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-control vjs-control'
    });
  };

  return VolumeControl;
})(_componentJs2['default']);

VolumeControl.prototype.options_ = {
  children: ['volumeBar']
};

_componentJs2['default'].registerComponent('VolumeControl', VolumeControl);
exports['default'] = VolumeControl;
module.exports = exports['default'];

},{"../../component.js":67,"./volume-bar.js":99}],101:[function(_dereq_,module,exports){
/**
 * @file volume-level.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

/**
 * Shows volume level
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class VolumeLevel
 */

var VolumeLevel = (function (_Component) {
  _inherits(VolumeLevel, _Component);

  function VolumeLevel() {
    _classCallCheck(this, VolumeLevel);

    _Component.apply(this, arguments);
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  VolumeLevel.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-level',
      innerHTML: '<span class="vjs-control-text"></span>'
    });
  };

  return VolumeLevel;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('VolumeLevel', VolumeLevel);
exports['default'] = VolumeLevel;
module.exports = exports['default'];

},{"../../component.js":67}],102:[function(_dereq_,module,exports){
/**
 * @file volume-menu-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _popupPopupJs = _dereq_('../popup/popup.js');

var _popupPopupJs2 = _interopRequireDefault(_popupPopupJs);

var _popupPopupButtonJs = _dereq_('../popup/popup-button.js');

var _popupPopupButtonJs2 = _interopRequireDefault(_popupPopupButtonJs);

var _muteToggleJs = _dereq_('./mute-toggle.js');

var _muteToggleJs2 = _interopRequireDefault(_muteToggleJs);

var _volumeControlVolumeBarJs = _dereq_('./volume-control/volume-bar.js');

var _volumeControlVolumeBarJs2 = _interopRequireDefault(_volumeControlVolumeBarJs);

/**
 * Button for volume popup
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends PopupButton
 * @class VolumeMenuButton
 */

var VolumeMenuButton = (function (_PopupButton) {
  _inherits(VolumeMenuButton, _PopupButton);

  function VolumeMenuButton(player) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, VolumeMenuButton);

    // Default to inline
    if (options.inline === undefined) {
      options.inline = true;
    }

    // If the vertical option isn't passed at all, default to true.
    if (options.vertical === undefined) {
      // If an inline volumeMenuButton is used, we should default to using
      // a horizontal slider for obvious reasons.
      if (options.inline) {
        options.vertical = false;
      } else {
        options.vertical = true;
      }
    }

    // The vertical option needs to be set on the volumeBar as well,
    // since that will need to be passed along to the VolumeBar constructor
    options.volumeBar = options.volumeBar || {};
    options.volumeBar.vertical = !!options.vertical;

    _PopupButton.call(this, player, options);

    // Same listeners as MuteToggle
    this.on(player, 'volumechange', this.volumeUpdate);
    this.on(player, 'loadstart', this.volumeUpdate);

    // hide mute toggle if the current tech doesn't support volume control
    function updateVisibility() {
      if (player.tech_ && player.tech_['featuresVolumeControl'] === false) {
        this.addClass('vjs-hidden');
      } else {
        this.removeClass('vjs-hidden');
      }
    }

    updateVisibility.call(this);
    this.on(player, 'loadstart', updateVisibility);

    this.on(this.volumeBar, ['slideractive', 'focus'], function () {
      this.addClass('vjs-slider-active');
    });

    this.on(this.volumeBar, ['sliderinactive', 'blur'], function () {
      this.removeClass('vjs-slider-active');
    });

    this.on(this.volumeBar, ['focus'], function () {
      this.addClass('vjs-lock-showing');
    });

    this.on(this.volumeBar, ['blur'], function () {
      this.removeClass('vjs-lock-showing');
    });
  }

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  VolumeMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var orientationClass = '';
    if (!!this.options_.vertical) {
      orientationClass = 'vjs-volume-menu-button-vertical';
    } else {
      orientationClass = 'vjs-volume-menu-button-horizontal';
    }

    return 'vjs-volume-menu-button ' + _PopupButton.prototype.buildCSSClass.call(this) + ' ' + orientationClass;
  };

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {Popup} The volume popup button
   * @method createPopup
   */

  VolumeMenuButton.prototype.createPopup = function createPopup() {
    var popup = new _popupPopupJs2['default'](this.player_, {
      contentElType: 'div'
    });

    var vb = new _volumeControlVolumeBarJs2['default'](this.player_, this.options_.volumeBar);

    popup.addChild(vb);

    this.menuContent = popup;
    this.volumeBar = vb;

    this.attachVolumeBarEvents();

    return popup;
  };

  /**
   * Handle click on volume popup and calls super
   *
   * @method handleClick
   */

  VolumeMenuButton.prototype.handleClick = function handleClick() {
    _muteToggleJs2['default'].prototype.handleClick.call(this);
    _PopupButton.prototype.handleClick.call(this);
  };

  VolumeMenuButton.prototype.attachVolumeBarEvents = function attachVolumeBarEvents() {
    this.menuContent.on(['mousedown', 'touchdown'], Fn.bind(this, this.handleMouseDown));
  };

  VolumeMenuButton.prototype.handleMouseDown = function handleMouseDown(event) {
    this.on(['mousemove', 'touchmove'], Fn.bind(this.volumeBar, this.volumeBar.handleMouseMove));
    this.on(this.el_.ownerDocument, ['mouseup', 'touchend'], this.handleMouseUp);
  };

  VolumeMenuButton.prototype.handleMouseUp = function handleMouseUp(event) {
    this.off(['mousemove', 'touchmove'], Fn.bind(this.volumeBar, this.volumeBar.handleMouseMove));
  };

  return VolumeMenuButton;
})(_popupPopupButtonJs2['default']);

VolumeMenuButton.prototype.volumeUpdate = _muteToggleJs2['default'].prototype.update;
VolumeMenuButton.prototype.controlText_ = 'Mute';

_componentJs2['default'].registerComponent('VolumeMenuButton', VolumeMenuButton);
exports['default'] = VolumeMenuButton;
module.exports = exports['default'];

},{"../component.js":67,"../popup/popup-button.js":115,"../popup/popup.js":116,"../utils/fn.js":144,"./mute-toggle.js":73,"./volume-control/volume-bar.js":99}],103:[function(_dereq_,module,exports){
/**
 * @file error-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _modalDialog = _dereq_('./modal-dialog');

var _modalDialog2 = _interopRequireDefault(_modalDialog);

var _utilsDom = _dereq_('./utils/dom');

var Dom = _interopRequireWildcard(_utilsDom);

var _utilsMergeOptions = _dereq_('./utils/merge-options');

var _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);

/**
 * Display that an error has occurred making the video unplayable.
 *
 * @extends ModalDialog
 * @class ErrorDisplay
 */

var ErrorDisplay = (function (_ModalDialog) {
  _inherits(ErrorDisplay, _ModalDialog);

  /**
   * Constructor for error display modal.
   *
   * @param  {Player} player
   * @param  {Object} [options]
   */

  function ErrorDisplay(player, options) {
    _classCallCheck(this, ErrorDisplay);

    _ModalDialog.call(this, player, options);
    this.on(player, 'error', this.open);
  }

  /**
   * Include the old class for backward-compatibility.
   *
   * This can be removed in 6.0.
   *
   * @method buildCSSClass
   * @deprecated
   * @return {String}
   */

  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);
  };

  /**
   * Generates the modal content based on the player error.
   *
   * @return {String|Null}
   */

  ErrorDisplay.prototype.content = function content() {
    var error = this.player().error();
    return error ? this.localize(error.message) : '';
  };

  return ErrorDisplay;
})(_modalDialog2['default']);

ErrorDisplay.prototype.options_ = _utilsMergeOptions2['default'](_modalDialog2['default'].prototype.options_, {
  fillAlways: true,
  temporary: false,
  uncloseable: true
});

_component2['default'].registerComponent('ErrorDisplay', ErrorDisplay);
exports['default'] = ErrorDisplay;
module.exports = exports['default'];

},{"./component":67,"./modal-dialog":112,"./utils/dom":142,"./utils/merge-options":148}],104:[function(_dereq_,module,exports){
/**
 * @file event-target.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var EventTarget = function EventTarget() {};

EventTarget.prototype.allowedEvents_ = {};

EventTarget.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;
  this.addEventListener = function () {};
  Events.on(this, type, fn);
  this.addEventListener = ael;
};
EventTarget.prototype.addEventListener = EventTarget.prototype.on;

EventTarget.prototype.off = function (type, fn) {
  Events.off(this, type, fn);
};
EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

EventTarget.prototype.one = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;
  this.addEventListener = function () {};
  Events.one(this, type, fn);
  this.addEventListener = ael;
};

EventTarget.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = {
      type: type
    };
  }
  event = Events.fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  Events.trigger(this, event);
};
// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

exports['default'] = EventTarget;
module.exports = exports['default'];

},{"./utils/events.js":143}],105:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utilsLog = _dereq_('./utils/log');

var _utilsLog2 = _interopRequireDefault(_utilsLog);

/*
 * @file extend.js
 *
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/*
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 * ```js
 * var Button = videojs.getComponent('Button');
 * ```
 * ```js
 * var MyButton = videojs.extend(Button, {
 *   constructor: function(player, options) {
 *     Button.call(this, player, options);
 *   },
 *   onClick: function() {
 *     // doSomething
 *   }
 * });
 * ```
 */
var extendFn = function extendFn(superClass) {
  var subClassMethods = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };
  var methods = {};

  if (typeof subClassMethods === 'object') {
    if (typeof subClassMethods.init === 'function') {
      _utilsLog2['default'].warn('Constructor logic via init() is deprecated; please use constructor() instead.');
      subClassMethods.constructor = subClassMethods.init;
    }
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

exports['default'] = extendFn;
module.exports = exports['default'];

},{"./utils/log":147}],106:[function(_dereq_,module,exports){
/**
 * @file fullscreen-api.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/*
 * Store the browser-specific methods for the fullscreen API
 * @type {Object|undefined}
 * @private
 */
var FullscreenApi = {};

// browser API methods
// map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
var apiMap = [
// Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = undefined;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in _globalDocument2['default']) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var i = 0; i < browserApi.length; i++) {
    FullscreenApi[specApi[i]] = browserApi[i];
  }
}

exports['default'] = FullscreenApi;
module.exports = exports['default'];

},{"global/document":1}],107:[function(_dereq_,module,exports){
/**
 * @file loading-spinner.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

/* Loading Spinner
================================================================================ */
/**
 * Loading spinner for waiting events
 *
 * @extends Component
 * @class LoadingSpinner
 */

var LoadingSpinner = (function (_Component) {
  _inherits(LoadingSpinner, _Component);

  function LoadingSpinner() {
    _classCallCheck(this, LoadingSpinner);

    _Component.apply(this, arguments);
  }

  /**
   * Create the component's DOM element
   *
   * @method createEl
   */

  LoadingSpinner.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-loading-spinner',
      dir: 'ltr'
    });
  };

  return LoadingSpinner;
})(_component2['default']);

_component2['default'].registerComponent('LoadingSpinner', LoadingSpinner);
exports['default'] = LoadingSpinner;
module.exports = exports['default'];

},{"./component":67}],108:[function(_dereq_,module,exports){
/**
 * @file media-error.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

/*
 * Custom MediaError class which mimics the standard HTML5 MediaError class.
 *
 * @param {Number|String|Object|MediaError} value
 *        This can be of multiple types:
 *        - Number: should be a standard error code
 *        - String: an error message (the code will be 0)
 *        - Object: arbitrary properties
 *        - MediaError (native): used to populate a video.js MediaError object
 *        - MediaError (video.js): will return itself if it's already a
 *          video.js MediaError object.
 */
function MediaError(value) {

  // Allow redundant calls to this constructor to avoid having `instanceof`
  // checks peppered around the code.
  if (value instanceof MediaError) {
    return value;
  }

  if (typeof value === 'number') {
    this.code = value;
  } else if (typeof value === 'string') {
    // default code is zero, so this is a custom error
    this.message = value;
  } else if (typeof value === 'object') {

    // We assign the `code` property manually because native MediaError objects
    // do not expose it as an own/enumerable property of the object.
    if (typeof value.code === 'number') {
      this.code = value.code;
    }

    _objectAssign2['default'](this, value);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
}

/*
 * The error code that refers two one of the defined
 * MediaError types
 *
 * @type {Number}
 */
MediaError.prototype.code = 0;

/*
 * An optional message to be shown with the error.
 * Message is not part of the HTML5 video spec
 * but allows for more informative custom errors.
 *
 * @type {String}
 */
MediaError.prototype.message = '';

/*
 * An optional status code that can be set by plugins
 * to allow even more detail about the error.
 * For example the HLS plugin might provide the specific
 * HTTP status code that was returned when the error
 * occurred, then allowing a custom error overlay
 * to display more information.
 *
 * @type {Array}
 */
MediaError.prototype.status = null;

MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', // = 0
'MEDIA_ERR_ABORTED', // = 1
'MEDIA_ERR_NETWORK', // = 2
'MEDIA_ERR_DECODE', // = 3
'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
'MEDIA_ERR_ENCRYPTED' // = 5
];

MediaError.defaultMessages = {
  1: 'You aborted the media playback',
  2: 'A network error caused the media download to fail part-way.',
  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The media is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

exports['default'] = MediaError;
module.exports = exports['default'];

},{"object.assign":45}],109:[function(_dereq_,module,exports){
/**
 * @file menu-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _clickableComponentJs = _dereq_('../clickable-component.js');

var _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _menuJs = _dereq_('./menu.js');

var _menuJs2 = _interopRequireDefault(_menuJs);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

/**
 * A button class with a popup menu
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Button
 * @class MenuButton
 */

var MenuButton = (function (_ClickableComponent) {
  _inherits(MenuButton, _ClickableComponent);

  function MenuButton(player) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, MenuButton);

    _ClickableComponent.call(this, player, options);

    this.update();

    this.enabled_ = true;

    this.el_.setAttribute('aria-haspopup', 'true');
    this.el_.setAttribute('role', 'menuitem');
    this.on('keydown', this.handleSubmenuKeyPress);
  }

  /**
   * Update menu
   *
   * @method update
   */

  MenuButton.prototype.update = function update() {
    var menu = this.createMenu();

    if (this.menu) {
      this.removeChild(this.menu);
    }

    this.menu = menu;
    this.addChild(menu);

    /**
     * Track the state of the menu button
     *
     * @type {Boolean}
     * @private
     */
    this.buttonPressed_ = false;
    this.el_.setAttribute('aria-expanded', 'false');

    if (this.items && this.items.length === 0) {
      this.hide();
    } else if (this.items && this.items.length > 1) {
      this.show();
    }
  };

  /**
   * Create menu
   *
   * @return {Menu} The constructed menu
   * @method createMenu
   */

  MenuButton.prototype.createMenu = function createMenu() {
    var menu = new _menuJs2['default'](this.player_);

    // Add a title list item to the top
    if (this.options_.title) {
      var title = Dom.createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: _utilsToTitleCaseJs2['default'](this.options_.title),
        tabIndex: -1
      });
      menu.children_.unshift(title);
      Dom.insertElFirst(title, menu.contentEl());
    }

    this.items = this['createItems']();

    if (this.items) {
      // Add menu items to the menu
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }

    return menu;
  };

  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @method createItems
   */

  MenuButton.prototype.createItems = function createItems() {};

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  MenuButton.prototype.createEl = function createEl() {
    return _ClickableComponent.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  MenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _ClickableComponent.prototype.buildCSSClass.call(this);
  };

  /**
   * When you click the button it adds focus, which
   * will show the menu indefinitely.
   * So we'll remove focus when the mouse leaves the button.
   * Focus is needed for tab navigation.
   * Allow sub components to stack CSS class names
   *
   * @method handleClick
   */

  MenuButton.prototype.handleClick = function handleClick() {
    this.one(this.menu.contentEl(), 'mouseleave', Fn.bind(this, function (e) {
      this.unpressButton();
      this.el_.blur();
    }));
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };

  /**
   * Handle key press on menu
   *
   * @param {Object} event Key press event
   * @method handleKeyPress
   */

  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
      }
      // Up (38) key or Down (40) key press the 'button'
    } else if (event.which === 38 || event.which === 40) {
        if (!this.buttonPressed_) {
          this.pressButton();
          event.preventDefault();
        }
      } else {
        _ClickableComponent.prototype.handleKeyPress.call(this, event);
      }
  };

  /**
   * Handle key press on submenu
   *
   * @param {Object} event Key press event
   * @method handleSubmenuKeyPress
   */

  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
      }
    }
  };

  /**
   * Makes changes based on button pressed
   *
   * @method pressButton
   */

  MenuButton.prototype.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.el_.setAttribute('aria-expanded', 'true');
      this.menu.focus(); // set the focus into the submenu
    }
  };

  /**
   * Makes changes based on button unpressed
   *
   * @method unpressButton
   */

  MenuButton.prototype.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.el_.setAttribute('aria-expanded', 'false');
      this.el_.focus(); // Set focus back to this menu button
    }
  };

  /**
   * Disable the menu button
   *
   * @return {Component}
   * @method disable
   */

  MenuButton.prototype.disable = function disable() {
    // Unpress, but don't force focus on this button
    this.buttonPressed_ = false;
    this.menu.unlockShowing();
    this.el_.setAttribute('aria-expanded', 'false');

    this.enabled_ = false;

    return _ClickableComponent.prototype.disable.call(this);
  };

  /**
   * Enable the menu button
   *
   * @return {Component}
   * @method disable
   */

  MenuButton.prototype.enable = function enable() {
    this.enabled_ = true;

    return _ClickableComponent.prototype.enable.call(this);
  };

  return MenuButton;
})(_clickableComponentJs2['default']);

_componentJs2['default'].registerComponent('MenuButton', MenuButton);
exports['default'] = MenuButton;
module.exports = exports['default'];

},{"../clickable-component.js":65,"../component.js":67,"../utils/dom.js":142,"../utils/fn.js":144,"../utils/to-title-case.js":151,"./menu.js":111}],110:[function(_dereq_,module,exports){
/**
 * @file menu-item.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _clickableComponentJs = _dereq_('../clickable-component.js');

var _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

/**
 * The component for a menu item. `<li>`
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Button
 * @class MenuItem
 */

var MenuItem = (function (_ClickableComponent) {
  _inherits(MenuItem, _ClickableComponent);

  function MenuItem(player, options) {
    _classCallCheck(this, MenuItem);

    _ClickableComponent.call(this, player, options);

    this.selectable = options['selectable'];

    this.selected(options['selected']);

    if (this.selectable) {
      // TODO: May need to be either menuitemcheckbox or menuitemradio,
      //       and may need logical grouping of menu items.
      this.el_.setAttribute('role', 'menuitemcheckbox');
    } else {
      this.el_.setAttribute('role', 'menuitem');
    }
  }

  /**
   * Create the component's DOM element
   *
   * @param {String=} type Desc
   * @param {Object=} props Desc
   * @return {Element}
   * @method createEl
   */

  MenuItem.prototype.createEl = function createEl(type, props, attrs) {
    return _ClickableComponent.prototype.createEl.call(this, 'li', _objectAssign2['default']({
      className: 'vjs-menu-item',
      innerHTML: this.localize(this.options_['label']),
      tabIndex: -1
    }, props), attrs);
  };

  /**
   * Handle a click on the menu item, and set it to selected
   *
   * @method handleClick
   */

  MenuItem.prototype.handleClick = function handleClick() {
    this.selected(true);
  };

  /**
   * Set this menu item as selected or not
   *
   * @param  {Boolean} selected
   * @method selected
   */

  MenuItem.prototype.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'true');
        // aria-checked isn't fully supported by browsers/screen readers,
        // so indicate selected state to screen reader in the control text.
        this.controlText(', selected');
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'false');
        // Indicate un-selected state to screen reader
        // Note that a space clears out the selected state text
        this.controlText(' ');
      }
    }
  };

  return MenuItem;
})(_clickableComponentJs2['default']);

_componentJs2['default'].registerComponent('MenuItem', MenuItem);
exports['default'] = MenuItem;
module.exports = exports['default'];

},{"../clickable-component.js":65,"../component.js":67,"object.assign":45}],111:[function(_dereq_,module,exports){
/**
 * @file menu.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsEventsJs = _dereq_('../utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

/**
 * The Menu component is used to build pop up menus, including subtitle and
 * captions selection menus.
 *
 * @extends Component
 * @class Menu
 */

var Menu = (function (_Component) {
  _inherits(Menu, _Component);

  function Menu(player, options) {
    _classCallCheck(this, Menu);

    _Component.call(this, player, options);

    this.focusedChild_ = -1;

    this.on('keydown', this.handleKeyPress);
  }

  /**
   * Add a menu item to the menu
   *
   * @param {Object|String} component Component or component type to add
   * @method addItem
   */

  Menu.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', Fn.bind(this, function () {
      this.unlockShowing();
      //TODO: Need to set keyboard focus back to the menuButton
    }));
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  Menu.prototype.createEl = function createEl() {
    var contentElType = this.options_.contentElType || 'ul';
    this.contentEl_ = Dom.createEl(contentElType, {
      className: 'vjs-menu-content'
    });
    this.contentEl_.setAttribute('role', 'menu');
    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });
    el.setAttribute('role', 'presentation');
    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Menu Buttons,
    // where a click on the parent is significant
    Events.on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  /**
   * Handle key press for menu
   *
   * @param {Object} event Event object
   * @method handleKeyPress
   */

  Menu.prototype.handleKeyPress = function handleKeyPress(event) {
    if (event.which === 37 || event.which === 40) {
      // Left and Down Arrows
      event.preventDefault();
      this.stepForward();
    } else if (event.which === 38 || event.which === 39) {
      // Up and Right Arrows
      event.preventDefault();
      this.stepBack();
    }
  };

  /**
   * Move to next (lower) menu item for keyboard users
   *
   * @method stepForward
   */

  Menu.prototype.stepForward = function stepForward() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };

  /**
   * Move to previous (higher) menu item for keyboard users
   *
   * @method stepBack
   */

  Menu.prototype.stepBack = function stepBack() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };

  /**
   * Set focus on a menu item in the menu
   *
   * @param {Object|String} item Index of child item set focus on
   * @method focus
   */

  Menu.prototype.focus = function focus() {
    var item = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

    var children = this.children().slice();
    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);

    if (haveTitle) {
      children.shift();
    }

    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }

      this.focusedChild_ = item;

      children[item].el_.focus();
    }
  };

  return Menu;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Menu', Menu);
exports['default'] = Menu;
module.exports = exports['default'];

},{"../component.js":67,"../utils/dom.js":142,"../utils/events.js":143,"../utils/fn.js":144}],112:[function(_dereq_,module,exports){
/**
 * @file modal-dialog.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilsDom = _dereq_('./utils/dom');

var Dom = _interopRequireWildcard(_utilsDom);

var _utilsFn = _dereq_('./utils/fn');

var Fn = _interopRequireWildcard(_utilsFn);

var _utilsLog = _dereq_('./utils/log');

var _utilsLog2 = _interopRequireDefault(_utilsLog);

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _closeButton = _dereq_('./close-button');

var _closeButton2 = _interopRequireDefault(_closeButton);

var MODAL_CLASS_NAME = 'vjs-modal-dialog';
var ESC = 27;

/**
 * The `ModalDialog` displays over the video and its controls, which blocks
 * interaction with the player until it is closed.
 *
 * Modal dialogs include a "Close" button and will close when that button
 * is activated - or when ESC is pressed anywhere.
 *
 * @extends Component
 * @class ModalDialog
 */

var ModalDialog = (function (_Component) {
  _inherits(ModalDialog, _Component);

  /**
   * Constructor for modals.
   *
   * @param  {Player} player
   * @param  {Object} [options]
   * @param  {Mixed} [options.content=undefined]
   *         Provide customized content for this modal.
   *
   * @param  {String} [options.description]
   *         A text description for the modal, primarily for accessibility.
   *
   * @param  {Boolean} [options.fillAlways=false]
   *         Normally, modals are automatically filled only the first time
   *         they open. This tells the modal to refresh its content
   *         every time it opens.
   *
   * @param  {String} [options.label]
   *         A text label for the modal, primarily for accessibility.
   *
   * @param  {Boolean} [options.temporary=true]
   *         If `true`, the modal can only be opened once; it will be
   *         disposed as soon as it's closed.
   *
   * @param  {Boolean} [options.uncloseable=false]
   *         If `true`, the user will not be able to close the modal
   *         through the UI in the normal ways. Programmatic closing is
   *         still possible.
   *
   */

  function ModalDialog(player, options) {
    _classCallCheck(this, ModalDialog);

    _Component.call(this, player, options);
    this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;

    this.closeable(!this.options_.uncloseable);
    this.content(this.options_.content);

    // Make sure the contentEl is defined AFTER any children are initialized
    // because we only want the contents of the modal in the contentEl
    // (not the UI elements like the close button).
    this.contentEl_ = Dom.createEl('div', {
      className: MODAL_CLASS_NAME + '-content'
    }, {
      role: 'document'
    });

    this.descEl_ = Dom.createEl('p', {
      className: MODAL_CLASS_NAME + '-description vjs-offscreen',
      id: this.el().getAttribute('aria-describedby')
    });

    Dom.textContent(this.descEl_, this.description());
    this.el_.appendChild(this.descEl_);
    this.el_.appendChild(this.contentEl_);
  }

  /*
   * Modal dialog default options.
   *
   * @type {Object}
   * @private
   */

  /**
   * Create the modal's DOM element
   *
   * @method createEl
   * @return {Element}
   */

  ModalDialog.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      'aria-describedby': this.id() + '_description',
      'aria-hidden': 'true',
      'aria-label': this.label(),
      role: 'dialog'
    });
  };

  /**
   * Build the modal's CSS class.
   *
   * @method buildCSSClass
   * @return {String}
   */

  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles key presses on the document, looking for ESC, which closes
   * the modal.
   *
   * @method handleKeyPress
   * @param  {Event} e
   */

  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {
    if (e.which === ESC && this.closeable()) {
      this.close();
    }
  };

  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {String}
   */

  ModalDialog.prototype.label = function label() {
    return this.options_.label || this.localize('Modal Window');
  };

  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {String}
   */

  ModalDialog.prototype.description = function description() {
    var desc = this.options_.description || this.localize('This is a modal window.');

    // Append a universal closeability message if the modal is closeable.
    if (this.closeable()) {
      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
    }

    return desc;
  };

  /**
   * Opens the modal.
   *
   * @method open
   * @return {ModalDialog}
   */

  ModalDialog.prototype.open = function open() {
    if (!this.opened_) {
      var player = this.player();

      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();

      if (this.wasPlaying_) {
        player.pause();
      }

      if (this.closeable()) {
        this.on(this.el_.ownerDocument, 'keydown', Fn.bind(this, this.handleKeyPress));
      }

      player.controls(false);
      this.show();
      this.el().setAttribute('aria-hidden', 'false');
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }
    return this;
  };

  /**
   * Whether or not the modal is opened currently.
   *
   * @method opened
   * @param  {Boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {Boolean}
   */

  ModalDialog.prototype.opened = function opened(value) {
    if (typeof value === 'boolean') {
      this[value ? 'open' : 'close']();
    }
    return this.opened_;
  };

  /**
   * Closes the modal.
   *
   * @method close
   * @return {ModalDialog}
   */

  ModalDialog.prototype.close = function close() {
    if (this.opened_) {
      var player = this.player();

      this.trigger('beforemodalclose');
      this.opened_ = false;

      if (this.wasPlaying_) {
        player.play();
      }

      if (this.closeable()) {
        this.off(this.el_.ownerDocument, 'keydown', Fn.bind(this, this.handleKeyPress));
      }

      player.controls(true);
      this.hide();
      this.el().setAttribute('aria-hidden', 'true');
      this.trigger('modalclose');

      if (this.options_.temporary) {
        this.dispose();
      }
    }
    return this;
  };

  /**
   * Whether or not the modal is closeable via the UI.
   *
   * @method closeable
   * @param  {Boolean} [value]
   *         If given as a Boolean, it will set the `closeable` option.
   *
   * @return {Boolean}
   */

  ModalDialog.prototype.closeable = function closeable(value) {
    if (typeof value === 'boolean') {
      var closeable = this.closeable_ = !!value;
      var _close = this.getChild('closeButton');

      // If this is being made closeable and has no close button, add one.
      if (closeable && !_close) {

        // The close button should be a child of the modal - not its
        // content element, so temporarily change the content element.
        var temp = this.contentEl_;
        this.contentEl_ = this.el_;
        _close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
        this.contentEl_ = temp;
        this.on(_close, 'close', this.close);
      }

      // If this is being made uncloseable and has a close button, remove it.
      if (!closeable && _close) {
        this.off(_close, 'close', this.close);
        this.removeChild(_close);
        _close.dispose();
      }
    }
    return this.closeable_;
  };

  /**
   * Fill the modal's content element with the modal's "content" option.
   *
   * The content element will be emptied before this change takes place.
   *
   * @method fill
   * @return {ModalDialog}
   */

  ModalDialog.prototype.fill = function fill() {
    return this.fillWith(this.content());
  };

  /**
   * Fill the modal's content element with arbitrary content.
   *
   * The content element will be emptied before this change takes place.
   *
   * @method fillWith
   * @param  {Mixed} [content]
   *         The same rules apply to this as apply to the `content` option.
   *
   * @return {ModalDialog}
   */

  ModalDialog.prototype.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;

    this.trigger('beforemodalfill');
    this.hasBeenFilled_ = true;

    // Detach the content element from the DOM before performing
    // manipulation to avoid modifying the live DOM multiple times.
    parentEl.removeChild(contentEl);
    this.empty();
    Dom.insertContent(contentEl, content);
    this.trigger('modalfill');

    // Re-inject the re-filled content element.
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }

    return this;
  };

  /**
   * Empties the content element.
   *
   * This happens automatically anytime the modal is filled.
   *
   * @method empty
   * @return {ModalDialog}
   */

  ModalDialog.prototype.empty = function empty() {
    this.trigger('beforemodalempty');
    Dom.emptyEl(this.contentEl());
    this.trigger('modalempty');
    return this;
  };

  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @method content
   * @param  {Mixed} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {Mixed}
   */

  ModalDialog.prototype.content = function content(value) {
    if (typeof value !== 'undefined') {
      this.content_ = value;
    }
    return this.content_;
  };

  return ModalDialog;
})(_component2['default']);

ModalDialog.prototype.options_ = {
  temporary: true
};

_component2['default'].registerComponent('ModalDialog', ModalDialog);
exports['default'] = ModalDialog;
module.exports = exports['default'];

},{"./close-button":66,"./component":67,"./utils/dom":142,"./utils/fn":144,"./utils/log":147}],113:[function(_dereq_,module,exports){
/**
 * @file player.js
 */
// Subclasses Component
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('./component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _utilsDomJs = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsGuidJs = _dereq_('./utils/guid.js');

var Guid = _interopRequireWildcard(_utilsGuidJs);

var _utilsBrowserJs = _dereq_('./utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _utilsLogJs = _dereq_('./utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _utilsToTitleCaseJs = _dereq_('./utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

var _utilsTimeRangesJs = _dereq_('./utils/time-ranges.js');

var _utilsBufferJs = _dereq_('./utils/buffer.js');

var _utilsStylesheetJs = _dereq_('./utils/stylesheet.js');

var stylesheet = _interopRequireWildcard(_utilsStylesheetJs);

var _fullscreenApiJs = _dereq_('./fullscreen-api.js');

var _fullscreenApiJs2 = _interopRequireDefault(_fullscreenApiJs);

var _mediaErrorJs = _dereq_('./media-error.js');

var _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);

var _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');

var _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _utilsMergeOptionsJs = _dereq_('./utils/merge-options.js');

var _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);

var _tracksTextTrackListConverterJs = _dereq_('./tracks/text-track-list-converter.js');

var _tracksTextTrackListConverterJs2 = _interopRequireDefault(_tracksTextTrackListConverterJs);

var _tracksAudioTrackListJs = _dereq_('./tracks/audio-track-list.js');

var _tracksAudioTrackListJs2 = _interopRequireDefault(_tracksAudioTrackListJs);

var _tracksVideoTrackListJs = _dereq_('./tracks/video-track-list.js');

var _tracksVideoTrackListJs2 = _interopRequireDefault(_tracksVideoTrackListJs);

// Include required child components (importing also registers them)

var _techLoaderJs = _dereq_('./tech/loader.js');

var _techLoaderJs2 = _interopRequireDefault(_techLoaderJs);

var _posterImageJs = _dereq_('./poster-image.js');

var _posterImageJs2 = _interopRequireDefault(_posterImageJs);

var _tracksTextTrackDisplayJs = _dereq_('./tracks/text-track-display.js');

var _tracksTextTrackDisplayJs2 = _interopRequireDefault(_tracksTextTrackDisplayJs);

var _loadingSpinnerJs = _dereq_('./loading-spinner.js');

var _loadingSpinnerJs2 = _interopRequireDefault(_loadingSpinnerJs);

var _bigPlayButtonJs = _dereq_('./big-play-button.js');

var _bigPlayButtonJs2 = _interopRequireDefault(_bigPlayButtonJs);

var _controlBarControlBarJs = _dereq_('./control-bar/control-bar.js');

var _controlBarControlBarJs2 = _interopRequireDefault(_controlBarControlBarJs);

var _errorDisplayJs = _dereq_('./error-display.js');

var _errorDisplayJs2 = _interopRequireDefault(_errorDisplayJs);

var _tracksTextTrackSettingsJs = _dereq_('./tracks/text-track-settings.js');

var _tracksTextTrackSettingsJs2 = _interopRequireDefault(_tracksTextTrackSettingsJs);

var _modalDialog = _dereq_('./modal-dialog');

var _modalDialog2 = _interopRequireDefault(_modalDialog);

// Require html5 tech, at least for disposing the original video tag

var _techTechJs = _dereq_('./tech/tech.js');

var _techTechJs2 = _interopRequireDefault(_techTechJs);

var _techHtml5Js = _dereq_('./tech/html5.js');

var _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods are used to initialize a video.
 * ```js
 * var myPlayer = videojs('example_video_1');
 * ```
 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
 * ```html
 * <video id="example_video_1" data-setup='{}' controls>
 *   <source src="my-source.mp4" type="video/mp4">
 * </video>
 * ```
 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
 *
 * @param {Element} tag        The original video tag used for configuring options
 * @param {Object=} options    Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends Component
 * @class Player
 */

var Player = (function (_Component) {
  _inherits(Player, _Component);

  /**
   * player's constructor function
   *
   * @constructs
   * @method init
   * @param {Element} tag        The original video tag used for configuring options
   * @param {Object=} options    Player options
   * @param {Function=} ready    Ready callback function
   */

  function Player(tag, options, ready) {
    var _this = this;

    _classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + Guid.newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = _objectAssign2['default'](Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // If language is not set, get the closest lang attribute
    if (!options.language) {
      if (typeof tag.closest === 'function') {
        var closest = tag.closest('[lang]');
        if (closest) {
          options.language = closest.getAttribute('lang');
        }
      } else {
        var element = tag;
        while (element && element.nodeType === 1) {
          if (Dom.getElAttributes(element).hasOwnProperty('lang')) {
            options.language = element.getAttribute('lang');
            break;
          }
          element = element.parentNode;
        }
      }
    }

    // Run base component initializing with new options
    _Component.call(this, null, options, ready);

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    this.tag = tag; // Store the original tag used to set options

    // Store the tag attributes used to restore html5 element
    this.tagAttributes = tag && Dom.getElAttributes(tag);

    // Update current language
    this.language(this.options_.language);

    // Update Supported Languages
    if (options.languages) {
      (function () {
        // Normalise player option languages to lowercase
        var languagesToLower = {};

        Object.getOwnPropertyNames(options.languages).forEach(function (name) {
          languagesToLower[name.toLowerCase()] = options.languages[name];
        });
        _this.languages_ = languagesToLower;
      })();
    } else {
      this.languages_ = Player.prototype.options_.languages;
    }

    // Cache for video property values.
    this.cache_ = {};

    // Set poster
    this.poster_ = options.poster || '';

    // Set controls
    this.controls_ = !!options.controls;

    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /*
     * Store the internal state of scrubbing
     *
     * @private
     * @return {Boolean} True if the user is scrubbing
     */
    this.scrubbing_ = false;

    this.el_ = this.createEl();

    // We also want to pass the original player options to each component and plugin
    // as well so they don't need to reach back into the player for options later.
    // We also need to do another copy of this.options_ so we don't end up with
    // an infinite loop.
    var playerOptionsCopy = _utilsMergeOptionsJs2['default'](this.options_);

    // Load plugins
    if (options.plugins) {
      (function () {
        var plugins = options.plugins;

        Object.getOwnPropertyNames(plugins).forEach(function (name) {
          if (typeof this[name] === 'function') {
            this[name](plugins[name]);
          } else {
            _utilsLogJs2['default'].error('Unable to find plugin:', name);
          }
        }, _this);
      })();
    }

    this.options_.playerOptions = playerOptionsCopy;

    this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (this.controls()) {
      this.addClass('vjs-controls-enabled');
    } else {
      this.addClass('vjs-controls-disabled');
    }

    // Set ARIA label and region role depending on player type
    this.el_.setAttribute('role', 'region');
    if (this.isAudio()) {
      this.el_.setAttribute('aria-label', 'audio player');
    } else {
      this.el_.setAttribute('aria-label', 'video player');
    }

    if (this.isAudio()) {
      this.addClass('vjs-audio');
    }

    if (this.flexNotSupported_()) {
      this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // iOS Safari has broken hover handling
    if (!browser.IS_IOS) {
      this.addClass('vjs-workinghover');
    }

    // Make player easily findable by ID
    Player.players[this.id_] = this;

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    this.userActive(true);
    this.reportUserActivity();
    this.listenForUserActivity_();

    this.on('fullscreenchange', this.handleFullscreenChange_);
    this.on('stageclick', this.handleStageClick_);
  }

  /*
   * Global player list
   *
   * @type {Object}
   */

  /**
   * Destroys the video player and does any necessary cleanup
   * ```js
   *     myPlayer.dispose();
   * ```
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @method dispose
   */

  Player.prototype.dispose = function dispose() {
    this.trigger('dispose');
    // prevent dispose from being called twice
    this.off('dispose');

    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
    }

    // Kill reference to this player
    Player.players[this.id_] = null;
    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }
    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }

    if (this.tech_) {
      this.tech_.dispose();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  Player.prototype.createEl = function createEl() {
    var el = this.el_ = _Component.prototype.createEl.call(this, 'div');
    var tag = this.tag;

    // Remove width/height attrs from tag so CSS can make it 100% width/height
    tag.removeAttribute('width');
    tag.removeAttribute('height');

    // Copy over all the attributes from the tag, including ID and class
    // ID will now reference player box, not the video tag
    var attrs = Dom.getElAttributes(tag);

    Object.getOwnPropertyNames(attrs).forEach(function (attr) {
      // workaround so we don't totally break IE7
      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
      if (attr === 'class') {
        el.className = attrs[attr];
      } else {
        el.setAttribute(attr, attrs[attr]);
      }
    });

    // Update tag id/class for use as HTML5 playback tech
    // Might think we should do this after embedding in container so .vjs-tech class
    // doesn't flash 100% width/height, but class only applies with .video-js parent
    tag.playerId = tag.id;
    tag.id += '_html5_api';
    tag.className = 'vjs-tech';

    // Make player findable on elements
    tag.player = el.player = this;
    // Default state of video is paused
    this.addClass('vjs-paused');

    // Add a style element in the player that we'll use to set the width/height
    // of the player in a way that's still overrideable by CSS, just like the
    // video element
    if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = stylesheet.createStyleElement('vjs-styles-dimensions');
      var defaultsStyleEl = Dom.$('.vjs-styles-defaults');
      var head = Dom.$('head');
      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }

    // Pass in the width/height/aspectRatio options which will update the style el
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);

    // Hide any links within the video/audio tag, because IE doesn't hide them completely.
    var links = tag.getElementsByTagName('a');
    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);
      Dom.addElClass(linkEl, 'vjs-hidden');
      linkEl.setAttribute('hidden', 'hidden');
    }

    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
    // keep track of the original for later so we can know if the source originally failed
    tag.initNetworkState_ = tag.networkState;

    // Wrap video tag in div (el/box) container
    if (tag.parentNode) {
      tag.parentNode.insertBefore(el, tag);
    }

    // insert the tag as the first child of the player element
    // then manually add it to the children array so that this.addChild
    // will work properly for other components
    Dom.insertElFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.
    this.children_.unshift(tag);

    this.el_ = el;

    return el;
  };

  /**
   * Get/set player width
   *
   * @param {Number=} value Value for width
   * @return {Number} Width when getting
   * @method width
   */

  Player.prototype.width = function width(value) {
    return this.dimension('width', value);
  };

  /**
   * Get/set player height
   *
   * @param {Number=} value Value for height
   * @return {Number} Height when getting
   * @method height
   */

  Player.prototype.height = function height(value) {
    return this.dimension('height', value);
  };

  /**
   * Get/set dimension for player
   *
   * @param {String} dimension Either width or height
   * @param {Number=} value Value for dimension
   * @return {Component}
   * @method dimension
   */

  Player.prototype.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + '_';

    if (value === undefined) {
      return this[privDimension] || 0;
    }

    if (value === '') {
      // If an empty string is given, reset the dimension to be automatic
      this[privDimension] = undefined;
    } else {
      var parsedVal = parseFloat(value);

      if (isNaN(parsedVal)) {
        _utilsLogJs2['default'].error('Improper value "' + value + '" supplied for for ' + _dimension);
        return this;
      }

      this[privDimension] = parsedVal;
    }

    this.updateStyleEl_();
    return this;
  };

  /**
   * Add/remove the vjs-fluid class
   *
   * @param {Boolean} bool Value of true adds the class, value of false removes the class
   * @method fluid
   */

  Player.prototype.fluid = function fluid(bool) {
    if (bool === undefined) {
      return !!this.fluid_;
    }

    this.fluid_ = !!bool;

    if (bool) {
      this.addClass('vjs-fluid');
    } else {
      this.removeClass('vjs-fluid');
    }
  };

  /**
   * Get/Set the aspect ratio
   *
   * @param {String=} ratio Aspect ratio for player
   * @return aspectRatio
   * @method aspectRatio
   */

  Player.prototype.aspectRatio = function aspectRatio(ratio) {
    if (ratio === undefined) {
      return this.aspectRatio_;
    }

    // Check for width:height format
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
    }
    this.aspectRatio_ = ratio;

    // We're assuming if you set an aspect ratio you want fluid mode,
    // because in fixed mode you could calculate width and height yourself.
    this.fluid(true);

    this.updateStyleEl_();
  };

  /**
   * Update styles of the player element (height, width and aspect ratio)
   *
   * @method updateStyleEl_
   */

  Player.prototype.updateStyleEl_ = function updateStyleEl_() {
    if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();

      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }

      return;
    }

    var width = undefined;
    var height = undefined;
    var aspectRatio = undefined;
    var idClass = undefined;

    // The aspect ratio is either used directly or to calculate width and height.
    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
      // Use any aspectRatio that's been specifically set
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth()) {
      // Otherwise try to get the aspect ratio from the video metadata
      aspectRatio = this.videoWidth() + ':' + this.videoHeight();
    } else {
      // Or use a default. The video element's is 2:1, but 16:9 is more common.
      aspectRatio = '16:9';
    }

    // Get the ratio as a decimal we can use to calculate dimensions
    var ratioParts = aspectRatio.split(':');
    var ratioMultiplier = ratioParts[1] / ratioParts[0];

    if (this.width_ !== undefined) {
      // Use any width that's been specifically set
      width = this.width_;
    } else if (this.height_ !== undefined) {
      // Or calulate the width from the aspect ratio if a height has been set
      width = this.height_ / ratioMultiplier;
    } else {
      // Or use the video's metadata, or use the video el's default of 300
      width = this.videoWidth() || 300;
    }

    if (this.height_ !== undefined) {
      // Use any height that's been specifically set
      height = this.height_;
    } else {
      // Otherwise calculate the height from the ratio and the width
      height = width * ratioMultiplier;
    }

    // Ensure the CSS class is valid by starting with an alpha character
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = 'dimensions-' + this.id();
    } else {
      idClass = this.id() + '-dimensions';
    }

    // Ensure the right class is still on the player for the style element
    this.addClass(idClass);

    stylesheet.setTextContent(this.styleEl_, '\n      .' + idClass + ' {\n        width: ' + width + 'px;\n        height: ' + height + 'px;\n      }\n\n      .' + idClass + '.vjs-fluid {\n        padding-top: ' + ratioMultiplier * 100 + '%;\n      }\n    ');
  };

  /**
   * Load the Media Playback Technology (tech)
   * Load/Create an instance of playback technology including element and API methods
   * And append playback element in player div.
   *
   * @param {String} techName Name of the playback technology
   * @param {String} source Video source
   * @method loadTech_
   * @private
   */

  Player.prototype.loadTech_ = function loadTech_(techName, source) {

    // Pause and remove current playback technology
    if (this.tech_) {
      this.unloadTech_();
    }

    // get rid of the HTML5 video tag as soon as we are using another tech
    if (techName !== 'Html5' && this.tag) {
      _techTechJs2['default'].getTech('Html5').disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }

    this.techName_ = techName;

    // Turn off API access because we're loading a new tech that might load asynchronously
    this.isReady_ = false;

    // Grab tech-specific options from player options and add source and parent element to use.
    var techOptions = _objectAssign2['default']({
      'nativeControlsForTouch': this.options_.nativeControlsForTouch,
      'source': source,
      'playerId': this.id(),
      'techId': this.id() + '_' + techName + '_api',
      'videoTracks': this.videoTracks_,
      'textTracks': this.textTracks_,
      'audioTracks': this.audioTracks_,
      'autoplay': this.options_.autoplay,
      'preload': this.options_.preload,
      'loop': this.options_.loop,
      'muted': this.options_.muted,
      'poster': this.poster(),
      'language': this.language(),
      'vtt.js': this.options_['vtt.js']
    }, this.options_[techName.toLowerCase()]);

    if (this.tag) {
      techOptions.tag = this.tag;
    }

    if (source) {
      this.currentType_ = source.type;
      if (source.src === this.cache_.src && this.cache_.currentTime > 0) {
        techOptions.startTime = this.cache_.currentTime;
      }

      this.cache_.src = source.src;
    }

    // Initialize tech instance
    var techComponent = _techTechJs2['default'].getTech(techName);
    // Support old behavior of techs being registered as components.
    // Remove once that deprecated behavior is removed.
    if (!techComponent) {
      techComponent = _componentJs2['default'].getComponent(techName);
    }
    this.tech_ = new techComponent(techOptions);

    // player.triggerReady is always async, so don't need this to be async
    this.tech_.ready(Fn.bind(this, this.handleTechReady_), true);

    _tracksTextTrackListConverterJs2['default'].jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

    // Listen to all HTML5-defined events and trigger them on the player
    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);
    this.on(this.tech_, 'waiting', this.handleTechWaiting_);
    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);
    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);
    this.on(this.tech_, 'playing', this.handleTechPlaying_);
    this.on(this.tech_, 'ended', this.handleTechEnded_);
    this.on(this.tech_, 'seeking', this.handleTechSeeking_);
    this.on(this.tech_, 'seeked', this.handleTechSeeked_);
    this.on(this.tech_, 'play', this.handleTechPlay_);
    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);
    this.on(this.tech_, 'pause', this.handleTechPause_);
    this.on(this.tech_, 'progress', this.handleTechProgress_);
    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);
    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
    this.on(this.tech_, 'error', this.handleTechError_);
    this.on(this.tech_, 'suspend', this.handleTechSuspend_);
    this.on(this.tech_, 'abort', this.handleTechAbort_);
    this.on(this.tech_, 'emptied', this.handleTechEmptied_);
    this.on(this.tech_, 'stalled', this.handleTechStalled_);
    this.on(this.tech_, 'loadedmetadata', this.handleTechLoadedMetaData_);
    this.on(this.tech_, 'loadeddata', this.handleTechLoadedData_);
    this.on(this.tech_, 'timeupdate', this.handleTechTimeUpdate_);
    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);
    this.on(this.tech_, 'volumechange', this.handleTechVolumeChange_);
    this.on(this.tech_, 'texttrackchange', this.handleTechTextTrackChange_);
    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);
    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);
    this.on(this.tech_, 'textdata', this.handleTechTextData_);

    this.usingNativeControls(this.techGet_('controls'));

    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }

    // Add the tech element in the DOM if it was not already there
    // Make sure to not insert the original video element if using Html5
    if (this.tech_.el().parentNode !== this.el() && (techName !== 'Html5' || !this.tag)) {
      Dom.insertElFirst(this.tech_.el(), this.el());
    }

    // Get rid of the original video tag reference after the first tech is loaded
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };

  /**
   * Unload playback technology
   *
   * @method unloadTech_
   * @private
   */

  Player.prototype.unloadTech_ = function unloadTech_() {
    // Save the current text tracks so that we can reuse the same text tracks with the next tech
    this.videoTracks_ = this.videoTracks();
    this.textTracks_ = this.textTracks();
    this.audioTracks_ = this.audioTracks();
    this.textTracksJson_ = _tracksTextTrackListConverterJs2['default'].textTracksToJson(this.tech_);

    this.isReady_ = false;

    this.tech_.dispose();

    this.tech_ = false;
  };

  /**
   * Return a reference to the current tech.
   * It will only return a reference to the tech if given an object with the
   * `IWillNotUseThisInPlugins` property on it. This is try and prevent misuse
   * of techs by plugins.
   *
   * @param {Object}
   * @return {Object} The Tech
   * @method tech
   */

  Player.prototype.tech = function tech(safety) {
    if (safety && safety.IWillNotUseThisInPlugins) {
      return this.tech_;
    }
    var errorText = '\n      Please make sure that you are not using this inside of a plugin.\n      To disable this alert and error, please pass in an object with\n      `IWillNotUseThisInPlugins` to the `tech` method. See\n      https://github.com/videojs/video.js/issues/2617 for more info.\n    ';
    _globalWindow2['default'].alert(errorText);
    throw new Error(errorText);
  };

  /**
   * Set up click and touch listeners for the playback element
   *
   * On desktops, a click on the video itself will toggle playback,
   * on a mobile device a click on the video toggles controls.
   * (toggling controls is done by toggling the user state between active and
   * inactive)
   * A tap can signal that a user has become active, or has become inactive
   * e.g. a quick tap on an iPhone movie should reveal the controls. Another
   * quick tap should hide them again (signaling the user is in an inactive
   * viewing state)
   * In addition to this, we still want the user to be considered inactive after
   * a few seconds of inactivity.
   * Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   * @method addTechControlsListeners_
   */

  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
    // Make sure to remove all the previous listeners in case we are called multiple times.
    this.removeTechControlsListeners_();

    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
    // trigger mousedown/up.
    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
    // Any touch events are set to block the mousedown event from happening
    this.on(this.tech_, 'mousedown', this.handleTechClick_);

    // If the controls were hidden we don't want that to change without a tap event
    // so we'll check if the controls were already showing before reporting user
    // activity
    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);

    // The tap listener needs to come after the touchend listener because the tap
    // listener cancels out any reportedUserActivity when setting userActive(false)
    this.on(this.tech_, 'tap', this.handleTechTap_);
  };

  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @method removeTechControlsListeners_
   * @private
   */

  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    // We don't want to just use `this.off()` because there might be other needed
    // listeners added by techs that extend this.
    this.off(this.tech_, 'tap', this.handleTechTap_);
    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);
    this.off(this.tech_, 'mousedown', this.handleTechClick_);
  };

  /**
   * Player waits for the tech to be ready
   *
   * @method handleTechReady_
   * @private
   */

  Player.prototype.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();

    // Keep the same volume as before
    if (this.cache_.volume) {
      this.techCall_('setVolume', this.cache_.volume);
    }

    // Look if the tech found a higher resolution poster while loading
    this.handleTechPosterChange_();

    // Update the duration if available
    this.handleTechDurationChange_();

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
      try {
        delete this.tag.poster; // Chrome Fix. Fixed in Chrome v16.
      } catch (e) {
        _utilsLogJs2['default']('deleting tag.poster throws in some browsers', e);
      }
      this.play();
    }
  };

  /**
   * Fired when the user agent begins looking for media data
   *
   * @private
   * @method handleTechLoadStart_
   */

  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
    // TODO: Update to use `emptied` event instead. See #1277.

    this.removeClass('vjs-ended');

    // reset the error state
    this.error(null);

    // If it's already playing we want to trigger a firstplay event now.
    // The firstplay event relies on both the play and loadstart events
    // which can happen in any order for a new source
    if (!this.paused()) {
      this.trigger('loadstart');
      this.trigger('firstplay');
    } else {
      // reset the hasStarted state
      this.hasStarted(false);
      this.trigger('loadstart');
    }
  };

  /**
   * Add/remove the vjs-has-started class
   *
   * @param {Boolean} hasStarted The value of true adds the class the value of false remove the class
   * @return {Boolean} Boolean value if has started
   * @private
   * @method hasStarted
   */

  Player.prototype.hasStarted = function hasStarted(_hasStarted) {
    if (_hasStarted !== undefined) {
      // only update if this is a new value
      if (this.hasStarted_ !== _hasStarted) {
        this.hasStarted_ = _hasStarted;
        if (_hasStarted) {
          this.addClass('vjs-has-started');
          // trigger the firstplay event if this newly has played
          this.trigger('firstplay');
        } else {
          this.removeClass('vjs-has-started');
        }
      }
      return this;
    }
    return !!this.hasStarted_;
  };

  /**
   * Fired whenever the media begins or resumes playback
   *
   * @private
   * @method handleTechPlay_
   */

  Player.prototype.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');

    // hide the poster when the user hits play
    // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
    this.hasStarted(true);

    this.trigger('play');
  };

  /**
   * Fired whenever the media begins waiting
   *
   * @private
   * @method handleTechWaiting_
   */

  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {
    var _this2 = this;

    this.addClass('vjs-waiting');
    this.trigger('waiting');
    this.one('timeupdate', function () {
      return _this2.removeClass('vjs-waiting');
    });
  };

  /**
   * A handler for events that signal that waiting has ended
   * which is not consistent between browsers. See #1351
   *
   * @private
   * @method handleTechCanPlay_
   */

  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass('vjs-waiting');
    this.trigger('canplay');
  };

  /**
   * A handler for events that signal that waiting has ended
   * which is not consistent between browsers. See #1351
   *
   * @private
   * @method handleTechCanPlayThrough_
   */

  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass('vjs-waiting');
    this.trigger('canplaythrough');
  };

  /**
   * A handler for events that signal that waiting has ended
   * which is not consistent between browsers. See #1351
   *
   * @private
   * @method handleTechPlaying_
   */

  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass('vjs-waiting');
    this.trigger('playing');
  };

  /**
   * Fired whenever the player is jumping to a new time
   *
   * @private
   * @method handleTechSeeking_
   */

  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass('vjs-seeking');
    this.trigger('seeking');
  };

  /**
   * Fired when the player has finished jumping to a new time
   *
   * @private
   * @method handleTechSeeked_
   */

  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass('vjs-seeking');
    this.trigger('seeked');
  };

  /**
   * Fired the first time a video is played
   * Not part of the HLS spec, and we're not sure if this is the best
   * implementation yet, so use sparingly. If you don't have a reason to
   * prevent playback, use `myPlayer.one('play');` instead.
   *
   * @private
   * @method handleTechFirstPlay_
   */

  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    //If the first starttime attribute is specified
    //then we will start at the given offset in seconds
    if (this.options_.starttime) {
      this.currentTime(this.options_.starttime);
    }

    this.addClass('vjs-has-started');
    this.trigger('firstplay');
  };

  /**
   * Fired whenever the media has been paused
   *
   * @private
   * @method handleTechPause_
   */

  Player.prototype.handleTechPause_ = function handleTechPause_() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    this.trigger('pause');
  };

  /**
   * Fired while the user agent is downloading media data
   *
   * @private
   * @method handleTechProgress_
   */

  Player.prototype.handleTechProgress_ = function handleTechProgress_() {
    this.trigger('progress');
  };

  /**
   * Fired when the end of the media resource is reached (currentTime == duration)
   *
   * @private
   * @method handleTechEnded_
   */

  Player.prototype.handleTechEnded_ = function handleTechEnded_() {
    this.addClass('vjs-ended');
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }

    this.trigger('ended');
  };

  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @private
   * @method handleTechDurationChange_
   */

  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_('duration'));
  };

  /**
   * Handle a click on the media element to play/pause
   *
   * @param {Object=} event Event object
   * @private
   * @method handleTechClick_
   */

  Player.prototype.handleTechClick_ = function handleTechClick_(event) {
    // We're using mousedown to detect clicks thanks to Flash, but mousedown
    // will also be triggered with right-clicks, so we need to prevent that
    if (event.button !== 0) return;

    // When controls are disabled a click should not toggle playback because
    // the click is considered a control
    if (this.controls()) {
      if (this.paused()) {
        this.play();
      } else {
        this.pause();
      }
    }
  };

  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @private
   * @method handleTechTap_
   */

  Player.prototype.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };

  /**
   * Handle touch to start
   *
   * @private
   * @method handleTechTouchStart_
   */

  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };

  /**
   * Handle touch to move
   *
   * @private
   * @method handleTechTouchMove_
   */

  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };

  /**
   * Handle touch to end
   *
   * @private
   * @method handleTechTouchEnd_
   */

  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  };

  /**
   * Fired when the player switches in or out of fullscreen mode
   *
   * @private
   * @method handleFullscreenChange_
   */

  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * native click events on the SWF aren't triggered on IE11, Win8.1RT
   * use stageclick events triggered from inside the SWF instead
   *
   * @private
   * @method handleStageClick_
   */

  Player.prototype.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };

  /**
   * Handle Tech Fullscreen Change
   *
   * @private
   * @method handleTechFullscreenChange_
   */

  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    if (data) {
      this.isFullscreen(data.isFullscreen);
    }
    this.trigger('fullscreenchange');
  };

  /**
   * Fires when an error occurred during the loading of an audio/video
   *
   * @private
   * @method handleTechError_
   */

  Player.prototype.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();
    this.error(error);
  };

  /**
   * Fires when the browser is intentionally not getting media data
   *
   * @private
   * @method handleTechSuspend_
   */

  Player.prototype.handleTechSuspend_ = function handleTechSuspend_() {
    this.trigger('suspend');
  };

  /**
   * Fires when the loading of an audio/video is aborted
   *
   * @private
   * @method handleTechAbort_
   */

  Player.prototype.handleTechAbort_ = function handleTechAbort_() {
    this.trigger('abort');
  };

  /**
   * Fires when the current playlist is empty
   *
   * @private
   * @method handleTechEmptied_
   */

  Player.prototype.handleTechEmptied_ = function handleTechEmptied_() {
    this.trigger('emptied');
  };

  /**
   * Fires when the browser is trying to get media data, but data is not available
   *
   * @private
   * @method handleTechStalled_
   */

  Player.prototype.handleTechStalled_ = function handleTechStalled_() {
    this.trigger('stalled');
  };

  /**
   * Fires when the browser has loaded meta data for the audio/video
   *
   * @private
   * @method handleTechLoadedMetaData_
   */

  Player.prototype.handleTechLoadedMetaData_ = function handleTechLoadedMetaData_() {
    this.trigger('loadedmetadata');
  };

  Player.prototype.handleTechTextData_ = function handleTechTextData_() {
    var data = null;
    if (arguments.length > 1) {
      data = arguments[1];
    }
    this.trigger('textdata', data);
  };

  /**
   * Fires when the browser has loaded the current frame of the audio/video
   *
   * @private
   * @method handleTechLoadedData_
   */

  Player.prototype.handleTechLoadedData_ = function handleTechLoadedData_() {
    this.trigger('loadeddata');
  };

  /**
   * Fires when the current playback position has changed
   *
   * @private
   * @method handleTechTimeUpdate_
   */

  Player.prototype.handleTechTimeUpdate_ = function handleTechTimeUpdate_() {
    this.trigger('timeupdate');
  };

  /**
   * Fires when the playing speed of the audio/video is changed
   *
   * @private
   * @method handleTechRateChange_
   */

  Player.prototype.handleTechRateChange_ = function handleTechRateChange_() {
    this.trigger('ratechange');
  };

  /**
   * Fires when the volume has been changed
   *
   * @private
   * @method handleTechVolumeChange_
   */

  Player.prototype.handleTechVolumeChange_ = function handleTechVolumeChange_() {
    this.trigger('volumechange');
  };

  /**
   * Fires when the text track has been changed
   *
   * @private
   * @method handleTechTextTrackChange_
   */

  Player.prototype.handleTechTextTrackChange_ = function handleTechTextTrackChange_() {
    this.trigger('texttrackchange');
  };

  /**
   * Get object for cached values.
   *
   * @return {Object}
   * @method getCache
   */

  Player.prototype.getCache = function getCache() {
    return this.cache_;
  };

  /**
   * Pass values to the playback tech
   *
   * @param {String=} method Method
   * @param {Object=} arg Argument
   * @private
   * @method techCall_
   */

  Player.prototype.techCall_ = function techCall_(method, arg) {
    // If it's not ready yet, call method when it is
    if (this.tech_ && !this.tech_.isReady_) {
      this.tech_.ready(function () {
        this[method](arg);
      }, true);

      // Otherwise call method now
    } else {
        try {
          this.tech_ && this.tech_[method](arg);
        } catch (e) {
          _utilsLogJs2['default'](e);
          throw e;
        }
      }
  };

  /**
   * Get calls can't wait for the tech, and sometimes don't need to.
   *
   * @param {String} method Tech method
   * @return {Method}
   * @private
   * @method techGet_
   */

  Player.prototype.techGet_ = function techGet_(method) {
    if (this.tech_ && this.tech_.isReady_) {

      // Flash likes to die and reload when you hide or reposition it.
      // In these cases the object methods go away and we get errors.
      // When that happens we'll catch the errors and inform tech that it's not ready any more.
      try {
        return this.tech_[method]();
      } catch (e) {
        // When building additional tech libs, an expected method may not be defined yet
        if (this.tech_[method] === undefined) {
          _utilsLogJs2['default']('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);
        } else {
          // When a method isn't available on the object it throws a TypeError
          if (e.name === 'TypeError') {
            _utilsLogJs2['default']('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);
            this.tech_.isReady_ = false;
          } else {
            _utilsLogJs2['default'](e);
          }
        }
        throw e;
      }
    }

    return;
  };

  /**
   * start media playback
   * ```js
   *     myPlayer.play();
   * ```
   *
   * @return {Player} self
   * @method play
   */

  Player.prototype.play = function play() {
    // Only calls the tech's play if we already have a src loaded
    if (this.src() || this.currentSrc()) {
      this.techCall_('play');
    } else {
      this.tech_.one('loadstart', function () {
        this.play();
      });
    }

    return this;
  };

  /**
   * Pause the video playback
   * ```js
   *     myPlayer.pause();
   * ```
   *
   * @return {Player} self
   * @method pause
   */

  Player.prototype.pause = function pause() {
    this.techCall_('pause');
    return this;
  };

  /**
   * Check if the player is paused
   * ```js
   *     var isPaused = myPlayer.paused();
   *     var isPlaying = !myPlayer.paused();
   * ```
   *
   * @return {Boolean} false if the media is currently playing, or true otherwise
   * @method paused
   */

  Player.prototype.paused = function paused() {
    // The initial state of paused should be true (in Safari it's actually false)
    return this.techGet_('paused') === false ? false : true;
  };

  /**
   * Returns whether or not the user is "scrubbing". Scrubbing is when the user
   * has clicked the progress bar handle and is dragging it along the progress bar.
   *
   * @param  {Boolean} isScrubbing   True/false the user is scrubbing
   * @return {Boolean}               The scrubbing status when getting
   * @return {Object}                The player when setting
   * @method scrubbing
   */

  Player.prototype.scrubbing = function scrubbing(isScrubbing) {
    if (isScrubbing !== undefined) {
      this.scrubbing_ = !!isScrubbing;

      if (isScrubbing) {
        this.addClass('vjs-scrubbing');
      } else {
        this.removeClass('vjs-scrubbing');
      }

      return this;
    }

    return this.scrubbing_;
  };

  /**
   * Get or set the current time (in seconds)
   * ```js
   *     // get
   *     var whereYouAt = myPlayer.currentTime();
   *     // set
   *     myPlayer.currentTime(120); // 2 minutes into the video
   * ```
   *
   * @param  {Number|String=} seconds The time to seek to
   * @return {Number}        The time in seconds, when not setting
   * @return {Player}    self, when the current time is set
   * @method currentTime
   */

  Player.prototype.currentTime = function currentTime(seconds) {
    if (seconds !== undefined) {

      this.techCall_('setCurrentTime', seconds);

      return this;
    }

    // cache last currentTime and return. default to 0 seconds
    //
    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
    // currentTime when scrubbing, but may not provide much performance benefit afterall.
    // Should be tested. Also something has to read the actual current time or the cache will
    // never get updated.
    return this.cache_.currentTime = this.techGet_('currentTime') || 0;
  };

  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   * ```js
   *     var lengthOfVideo = myPlayer.duration();
   * ```
   * **NOTE**: The video must have started loading before the duration can be
   * known, and in the case of Flash, may not be known until the video starts
   * playing.
   *
   * @param {Number} seconds Duration when setting
   * @return {Number} The duration of the video in seconds when getting
   * @method duration
   */

  Player.prototype.duration = function duration(seconds) {
    if (seconds === undefined) {
      return this.cache_.duration || 0;
    }

    seconds = parseFloat(seconds) || 0;

    // Standardize on Inifity for signaling video is live
    if (seconds < 0) {
      seconds = Infinity;
    }

    if (seconds !== this.cache_.duration) {
      // Cache the last set value for optimized scrubbing (esp. Flash)
      this.cache_.duration = seconds;

      if (seconds === Infinity) {
        this.addClass('vjs-live');
      } else {
        this.removeClass('vjs-live');
      }

      this.trigger('durationchange');
    }

    return this;
  };

  /**
   * Calculates how much time is left.
   * ```js
   *     var timeLeft = myPlayer.remainingTime();
   * ```
   * Not a native video element function, but useful
   *
   * @return {Number} The time remaining in seconds
   * @method remainingTime
   */

  Player.prototype.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };

  // http://dev.w3.org/html5/spec/video.html#dom-media-buffered
  // Buffered returns a timerange object.
  // Kind of like an array of portions of the video that have been downloaded.

  /**
   * Get a TimeRange object with the times of the video that have been downloaded
   * If you just want the percent of the video that's been downloaded,
   * use bufferedPercent.
   * ```js
   *     // Number of different ranges of time have been buffered. Usually 1.
   *     numberOfRanges = bufferedTimeRange.length,
   *     // Time in seconds when the first range starts. Usually 0.
   *     firstRangeStart = bufferedTimeRange.start(0),
   *     // Time in seconds when the first range ends
   *     firstRangeEnd = bufferedTimeRange.end(0),
   *     // Length in seconds of the first time range
   *     firstRangeLength = firstRangeEnd - firstRangeStart;
   * ```
   *
   * @return {Object} A mock TimeRange object (following HTML spec)
   * @method buffered
   */

  Player.prototype.buffered = function buffered() {
    var buffered = this.techGet_('buffered');

    if (!buffered || !buffered.length) {
      buffered = _utilsTimeRangesJs.createTimeRange(0, 0);
    }

    return buffered;
  };

  /**
   * Get the percent (as a decimal) of the video that's been downloaded
   * ```js
   *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
   * ```
   * 0 means none, 1 means all.
   * (This method isn't in the HTML5 spec, but it's very convenient)
   *
   * @return {Number} A decimal between 0 and 1 representing the percent
   * @method bufferedPercent
   */

  Player.prototype.bufferedPercent = function bufferedPercent() {
    return _utilsBufferJs.bufferedPercent(this.buffered(), this.duration());
  };

  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {Number} The end of the last buffered time range
   * @method bufferedEnd
   */

  Player.prototype.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered(),
        duration = this.duration(),
        end = buffered.end(buffered.length - 1);

    if (end > duration) {
      end = duration;
    }

    return end;
  };

  /**
   * Get or set the current volume of the media
   * ```js
   *     // get
   *     var howLoudIsIt = myPlayer.volume();
   *     // set
   *     myPlayer.volume(0.5); // Set volume to half
   * ```
   * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
   *
   * @param  {Number} percentAsDecimal The new volume as a decimal percent
   * @return {Number}              The current volume when getting
   * @return {Player}              self when setting
   * @method volume
   */

  Player.prototype.volume = function volume(percentAsDecimal) {
    var vol = undefined;

    if (percentAsDecimal !== undefined) {
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
      this.cache_.volume = vol;
      this.techCall_('setVolume', vol);

      return this;
    }

    // Default to 1 when returning current volume.
    vol = parseFloat(this.techGet_('volume'));
    return isNaN(vol) ? 1 : vol;
  };

  /**
   * Get the current muted state, or turn mute on or off
   * ```js
   *     // get
   *     var isVolumeMuted = myPlayer.muted();
   *     // set
   *     myPlayer.muted(true); // mute the volume
   * ```
   *
   * @param  {Boolean=} muted True to mute, false to unmute
   * @return {Boolean} True if mute is on, false if not when getting
   * @return {Player} self when setting mute
   * @method muted
   */

  Player.prototype.muted = function muted(_muted) {
    if (_muted !== undefined) {
      this.techCall_('setMuted', _muted);
      return this;
    }
    return this.techGet_('muted') || false; // Default to false
  };

  // Check if current tech can support native fullscreen
  // (e.g. with built in controls like iOS, so not our flash swf)
  /**
   * Check to see if fullscreen is supported
   *
   * @return {Boolean}
   * @method supportsFullScreen
   */

  Player.prototype.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_('supportsFullScreen') || false;
  };

  /**
   * Check if the player is in fullscreen mode
   * ```js
   *     // get
   *     var fullscreenOrNot = myPlayer.isFullscreen();
   *     // set
   *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
   * ```
   * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {Boolean=} isFS Update the player's fullscreen state
   * @return {Boolean} true if fullscreen false if not when getting
   * @return {Player} self when setting
   * @method isFullscreen
   */

  Player.prototype.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== undefined) {
      this.isFullscreen_ = !!isFS;
      return this;
    }
    return !!this.isFullscreen_;
  };

  /**
   * Increase the size of the video to full screen
   * ```js
   *     myPlayer.requestFullscreen();
   * ```
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @return {Player} self
   * @method requestFullscreen
   */

  Player.prototype.requestFullscreen = function requestFullscreen() {
    var fsApi = _fullscreenApiJs2['default'];

    this.isFullscreen(true);

    if (fsApi.requestFullscreen) {
      // the browser supports going fullscreen at the element level so we can
      // take the controls fullscreen as well as the video

      // Trigger fullscreenchange event after change
      // We have to specifically add this each time, and remove
      // when canceling fullscreen. Otherwise if there's multiple
      // players on a page, they would all be reacting to the same fullscreen
      // events
      Events.on(_globalDocument2['default'], fsApi.fullscreenchange, Fn.bind(this, function documentFullscreenChange(e) {
        this.isFullscreen(_globalDocument2['default'][fsApi.fullscreenElement]);

        // If cancelling fullscreen, remove event listener.
        if (this.isFullscreen() === false) {
          Events.off(_globalDocument2['default'], fsApi.fullscreenchange, documentFullscreenChange);
        }

        this.trigger('fullscreenchange');
      }));

      this.el_[fsApi.requestFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      // we can't take the video.js controls fullscreen but we can go fullscreen
      // with native controls
      this.techCall_('enterFullScreen');
    } else {
      // fullscreen isn't supported so we'll just stretch the video element to
      // fill the viewport
      this.enterFullWindow();
      this.trigger('fullscreenchange');
    }

    return this;
  };

  /**
   * Return the video to its normal size after having been in full screen mode
   * ```js
   *     myPlayer.exitFullscreen();
   * ```
   *
   * @return {Player} self
   * @method exitFullscreen
   */

  Player.prototype.exitFullscreen = function exitFullscreen() {
    var fsApi = _fullscreenApiJs2['default'];
    this.isFullscreen(false);

    // Check for browser element fullscreen support
    if (fsApi.requestFullscreen) {
      _globalDocument2['default'][fsApi.exitFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      this.techCall_('exitFullScreen');
    } else {
      this.exitFullWindow();
      this.trigger('fullscreenchange');
    }

    return this;
  };

  /**
   * When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
   *
   * @method enterFullWindow
   */

  Player.prototype.enterFullWindow = function enterFullWindow() {
    this.isFullWindow = true;

    // Storing original doc overflow value to return to when fullscreen is off
    this.docOrigOverflow = _globalDocument2['default'].documentElement.style.overflow;

    // Add listener for esc key to exit fullscreen
    Events.on(_globalDocument2['default'], 'keydown', Fn.bind(this, this.fullWindowOnEscKey));

    // Hide any scroll bars
    _globalDocument2['default'].documentElement.style.overflow = 'hidden';

    // Apply fullscreen styles
    Dom.addElClass(_globalDocument2['default'].body, 'vjs-full-window');

    this.trigger('enterFullWindow');
  };

  /**
   * Check for call to either exit full window or full screen on ESC key
   *
   * @param {String} event Event to check for key press
   * @method fullWindowOnEscKey
   */

  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (event.keyCode === 27) {
      if (this.isFullscreen() === true) {
        this.exitFullscreen();
      } else {
        this.exitFullWindow();
      }
    }
  };

  /**
   * Exit full window
   *
   * @method exitFullWindow
   */

  Player.prototype.exitFullWindow = function exitFullWindow() {
    this.isFullWindow = false;
    Events.off(_globalDocument2['default'], 'keydown', this.fullWindowOnEscKey);

    // Unhide scroll bars.
    _globalDocument2['default'].documentElement.style.overflow = this.docOrigOverflow;

    // Remove fullscreen styles
    Dom.removeElClass(_globalDocument2['default'].body, 'vjs-full-window');

    // Resize the box, controller, and poster to original sizes
    // this.positionAll();
    this.trigger('exitFullWindow');
  };

  /**
   * Check whether the player can play a given mimetype
   *
   * @param {String} type The mimetype to check
   * @return {String} 'probably', 'maybe', or '' (empty string)
   * @method canPlayType
   */

  Player.prototype.canPlayType = function canPlayType(type) {
    var can = undefined;

    // Loop through each playback technology in the options order
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = _utilsToTitleCaseJs2['default'](j[i]);
      var tech = _techTechJs2['default'].getTech(techName);

      // Support old behavior of techs being registered as components.
      // Remove once that deprecated behavior is removed.
      if (!tech) {
        tech = _componentJs2['default'].getComponent(techName);
      }

      // Check if the current tech is defined before continuing
      if (!tech) {
        _utilsLogJs2['default'].error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }

      // Check if the browser supports this technology
      if (tech.isSupported()) {
        can = tech.canPlayType(type);

        if (can) {
          return can;
        }
      }
    }

    return '';
  };

  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources The sources for a media asset
   * @return {Object|Boolean} Object of source and tech order, otherwise false
   * @method selectSource
   */

  Player.prototype.selectSource = function selectSource(sources) {
    var _this3 = this;

    // Get only the techs specified in `techOrder` that exist and are supported by the
    // current platform
    var techs = this.options_.techOrder.map(_utilsToTitleCaseJs2['default']).map(function (techName) {
      // `Component.getComponent(...)` is for support of old behavior of techs
      // being registered as components.
      // Remove once that deprecated behavior is removed.
      return [techName, _techTechJs2['default'].getTech(techName) || _componentJs2['default'].getComponent(techName)];
    }).filter(function (_ref) {
      var techName = _ref[0];
      var tech = _ref[1];

      // Check if the current tech is defined before continuing
      if (tech) {
        // Check if the browser supports this technology
        return tech.isSupported();
      }

      _utilsLogJs2['default'].error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });

    // Iterate over each `innerArray` element once per `outerArray` element and execute
    // `tester` with both. If `tester` returns a non-falsy value, exit early and return
    // that value.
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
      var found = undefined;

      outerArray.some(function (outerChoice) {
        return innerArray.some(function (innerChoice) {
          found = tester(outerChoice, innerChoice);

          if (found) {
            return true;
          }
        });
      });

      return found;
    };

    var foundSourceAndTech = undefined;
    var flip = function flip(fn) {
      return function (a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder(_ref2, source) {
      var techName = _ref2[0];
      var tech = _ref2[1];

      if (tech.canPlaySource(source, _this3.options_[techName.toLowerCase()])) {
        return { source: source, tech: techName };
      }
    };

    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
    // to select from them based on their priority.
    if (this.options_.sourceOrder) {
      // Source-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      // Tech-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }

    return foundSourceAndTech || false;
  };

  /**
   * The source function updates the video source
   * There are three types of variables you can pass as the argument.
   * **URL String**: A URL to the the video file. Use this method if you are sure
   * the current playback technology (HTML5/Flash) can support the source you
   * provide. Currently only MP4 files can be used in both HTML5 and Flash.
   * ```js
   *     myPlayer.src("http://www.example.com/path/to/video.mp4");
   * ```
   * **Source Object (or element):* * A javascript object containing information
   * about the source file. Use this method if you want the player to determine if
   * it can support the file using the type information.
   * ```js
   *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
   * ```
   * **Array of Source Objects:* * To provide multiple versions of the source so
   * that it can be played using HTML5 across browsers you can use an array of
   * source objects. Video.js will detect which version is supported and load that
   * file.
   * ```js
   *     myPlayer.src([
   *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
   *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
   *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
   *     ]);
   * ```
   *
   * @param  {String|Object|Array=} source The source URL, object, or array of sources
   * @return {String} The current video source when getting
   * @return {String} The player when setting
   * @method src
   */

  Player.prototype.src = function src(source) {
    if (source === undefined) {
      return this.techGet_('src');
    }

    var currentTech = _techTechJs2['default'].getTech(this.techName_);
    // Support old behavior of techs being registered as components.
    // Remove once that deprecated behavior is removed.
    if (!currentTech) {
      currentTech = _componentJs2['default'].getComponent(this.techName_);
    }

    // case: Array of source objects to choose from and pick the best to play
    if (Array.isArray(source)) {
      this.sourceList_(source);

      // case: URL String (http://myvideo...)
    } else if (typeof source === 'string') {
        // create a source object from the string
        this.src({ src: source });

        // case: Source object { src: '', type: '' ... }
      } else if (source instanceof Object) {
          // check if the source has a type and the loaded tech cannot play the source
          // if there's no type we'll just try the current tech
          if (source.type && !currentTech.canPlaySource(source, this.options_[this.techName_.toLowerCase()])) {
            // create a source list with the current source and send through
            // the tech loop to check for a compatible technology
            this.sourceList_([source]);
          } else {
            this.cache_.src = source.src;
            this.currentType_ = source.type || '';

            // wait until the tech is ready to set the source
            this.ready(function () {

              // The setSource tech method was added with source handlers
              // so older techs won't support it
              // We need to check the direct prototype for the case where subclasses
              // of the tech do not support source handlers
              if (currentTech.prototype.hasOwnProperty('setSource')) {
                this.techCall_('setSource', source);
              } else {
                this.techCall_('src', source.src);
              }

              if (this.options_.preload === 'auto') {
                this.load();
              }

              if (this.options_.autoplay) {
                this.play();
              }

              // Set the source synchronously if possible (#2326)
            }, true);
          }
        }

    return this;
  };

  /**
   * Handle an array of source objects
   *
   * @param  {Array} sources Array of source objects
   * @private
   * @method sourceList_
   */

  Player.prototype.sourceList_ = function sourceList_(sources) {
    var sourceTech = this.selectSource(sources);

    if (sourceTech) {
      if (sourceTech.tech === this.techName_) {
        // if this technology is already loaded, set the source
        this.src(sourceTech.source);
      } else {
        // load this technology with the chosen source
        this.loadTech_(sourceTech.tech, sourceTech.source);
      }
    } else {
      // We need to wrap this in a timeout to give folks a chance to add error event handlers
      this.setTimeout(function () {
        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
      }, 0);

      // we could not find an appropriate tech, but let's still notify the delegate that this is it
      // this needs a better comment about why this is needed
      this.triggerReady();
    }
  };

  /**
   * Begin loading the src data.
   *
   * @return {Player} Returns the player
   * @method load
   */

  Player.prototype.load = function load() {
    this.techCall_('load');
    return this;
  };

  /**
   * Reset the player. Loads the first tech in the techOrder,
   * and calls `reset` on the tech`.
   *
   * @return {Player} Returns the player
   * @method reset
   */

  Player.prototype.reset = function reset() {
    this.loadTech_(_utilsToTitleCaseJs2['default'](this.options_.techOrder[0]), null);
    this.techCall_('reset');
    return this;
  };

  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {String} The current source
   * @method currentSrc
   */

  Player.prototype.currentSrc = function currentSrc() {
    return this.techGet_('currentSrc') || this.cache_.src || '';
  };

  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {String} The source MIME type
   * @method currentType
   */

  Player.prototype.currentType = function currentType() {
    return this.currentType_ || '';
  };

  /**
   * Get or set the preload attribute
   *
   * @param {Boolean} value Boolean to determine if preload should be used
   * @return {String} The preload attribute value when getting
   * @return {Player} Returns the player when setting
   * @method preload
   */

  Player.prototype.preload = function preload(value) {
    if (value !== undefined) {
      this.techCall_('setPreload', value);
      this.options_.preload = value;
      return this;
    }
    return this.techGet_('preload');
  };

  /**
   * Get or set the autoplay attribute.
   *
   * @param {Boolean} value Boolean to determine if video should autoplay
   * @return {String} The autoplay attribute value when getting
   * @return {Player} Returns the player when setting
   * @method autoplay
   */

  Player.prototype.autoplay = function autoplay(value) {
    if (value !== undefined) {
      this.techCall_('setAutoplay', value);
      this.options_.autoplay = value;
      return this;
    }
    return this.techGet_('autoplay', value);
  };

  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {Boolean} value Boolean to determine if video should loop
   * @return {String} The loop attribute value when getting
   * @return {Player} Returns the player when setting
   * @method loop
   */

  Player.prototype.loop = function loop(value) {
    if (value !== undefined) {
      this.techCall_('setLoop', value);
      this.options_['loop'] = value;
      return this;
    }
    return this.techGet_('loop');
  };

  /**
   * Get or set the poster image source url
   *
   * ##### EXAMPLE:
   * ```js
   *     // get
   *     var currentPoster = myPlayer.poster();
   *     // set
   *     myPlayer.poster('http://example.com/myImage.jpg');
   * ```
   *
   * @param  {String=} src Poster image source URL
   * @return {String} poster URL when getting
   * @return {Player} self when setting
   * @method poster
   */

  Player.prototype.poster = function poster(src) {
    if (src === undefined) {
      return this.poster_;
    }

    // The correct way to remove a poster is to set as an empty string
    // other falsey values will throw errors
    if (!src) {
      src = '';
    }

    // update the internal poster variable
    this.poster_ = src;

    // update the tech's poster
    this.techCall_('setPoster', src);

    // alert components that the poster has been set
    this.trigger('posterchange');

    return this;
  };

  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * soruce if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @private
   * @method handleTechPosterChange_
   */

  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
    if (!this.poster_ && this.tech_ && this.tech_.poster) {
      this.poster_ = this.tech_.poster() || '';

      // Let components know the poster has changed
      this.trigger('posterchange');
    }
  };

  /**
   * Get or set whether or not the controls are showing.
   *
   * @param  {Boolean} bool Set controls to showing or not
   * @return {Boolean}    Controls are showing
   * @method controls
   */

  Player.prototype.controls = function controls(bool) {
    if (bool !== undefined) {
      bool = !!bool; // force boolean
      // Don't trigger a change event unless it actually changed
      if (this.controls_ !== bool) {
        this.controls_ = bool;

        if (this.usingNativeControls()) {
          this.techCall_('setControls', bool);
        }

        if (bool) {
          this.removeClass('vjs-controls-disabled');
          this.addClass('vjs-controls-enabled');
          this.trigger('controlsenabled');

          if (!this.usingNativeControls()) {
            this.addTechControlsListeners_();
          }
        } else {
          this.removeClass('vjs-controls-enabled');
          this.addClass('vjs-controls-disabled');
          this.trigger('controlsdisabled');

          if (!this.usingNativeControls()) {
            this.removeTechControlsListeners_();
          }
        }
      }
      return this;
    }
    return !!this.controls_;
  };

  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls), Flash, or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @param  {Boolean} bool    True signals that native controls are on
   * @return {Player}      Returns the player
   * @private
   * @method usingNativeControls
   */

  Player.prototype.usingNativeControls = function usingNativeControls(bool) {
    if (bool !== undefined) {
      bool = !!bool; // force boolean
      // Don't trigger a change event unless it actually changed
      if (this.usingNativeControls_ !== bool) {
        this.usingNativeControls_ = bool;
        if (bool) {
          this.addClass('vjs-using-native-controls');

          /**
            * player is using the native device controls
           *
            * @event usingnativecontrols
            * @memberof Player
            * @instance
            * @private
            */
          this.trigger('usingnativecontrols');
        } else {
          this.removeClass('vjs-using-native-controls');

          /**
            * player is using the custom HTML controls
           *
            * @event usingcustomcontrols
            * @memberof Player
            * @instance
            * @private
            */
          this.trigger('usingcustomcontrols');
        }
      }
      return this;
    }
    return !!this.usingNativeControls_;
  };

  /**
   * Set or get the current MediaError
   *
   * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
   * @return {MediaError|null}     when getting
   * @return {Player}              when setting
   * @method error
   */

  Player.prototype.error = function error(err) {
    if (err === undefined) {
      return this.error_ || null;
    }

    // restoring to default
    if (err === null) {
      this.error_ = err;
      this.removeClass('vjs-error');
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return this;
    }

    this.error_ = new _mediaErrorJs2['default'](err);

    // add the vjs-error classname to the player
    this.addClass('vjs-error');

    // log the name of the error type and any message
    // ie8 just logs "[object object]" if you just log the error object
    _utilsLogJs2['default'].error('(CODE:' + this.error_.code + ' ' + _mediaErrorJs2['default'].errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

    // fire an error event on the player
    this.trigger('error');

    return this;
  };

  /**
   * Returns whether or not the player is in the "ended" state.
   *
   * @return {Boolean} True if the player is in the ended state, false if not.
   * @method ended
   */

  Player.prototype.ended = function ended() {
    return this.techGet_('ended');
  };

  /**
   * Returns whether or not the player is in the "seeking" state.
   *
   * @return {Boolean} True if the player is in the seeking state, false if not.
   * @method seeking
   */

  Player.prototype.seeking = function seeking() {
    return this.techGet_('seeking');
  };

  /**
   * Returns the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @return {TimeRanges} the seekable intervals of the media timeline
   * @method seekable
   */

  Player.prototype.seekable = function seekable() {
    return this.techGet_('seekable');
  };

  /**
   * Report user activity
   *
   * @param {Object} event Event object
   * @method reportUserActivity
   */

  Player.prototype.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };

  /**
   * Get/set if user is active
   *
   * @param {Boolean} bool Value when setting
   * @return {Boolean} Value if user is active user when getting
   * @method userActive
   */

  Player.prototype.userActive = function userActive(bool) {
    if (bool !== undefined) {
      bool = !!bool;
      if (bool !== this.userActive_) {
        this.userActive_ = bool;
        if (bool) {
          // If the user was inactive and is now active we want to reset the
          // inactivity timer
          this.userActivity_ = true;
          this.removeClass('vjs-user-inactive');
          this.addClass('vjs-user-active');
          this.trigger('useractive');
        } else {
          // We're switching the state to inactive manually, so erase any other
          // activity
          this.userActivity_ = false;

          // Chrome/Safari/IE have bugs where when you change the cursor it can
          // trigger a mousemove event. This causes an issue when you're hiding
          // the cursor when the user is inactive, and a mousemove signals user
          // activity. Making it impossible to go into inactive mode. Specifically
          // this happens in fullscreen when we really need to hide the cursor.
          //
          // When this gets resolved in ALL browsers it can be removed
          // https://code.google.com/p/chromium/issues/detail?id=103041
          if (this.tech_) {
            this.tech_.one('mousemove', function (e) {
              e.stopPropagation();
              e.preventDefault();
            });
          }

          this.removeClass('vjs-user-active');
          this.addClass('vjs-user-inactive');
          this.trigger('userinactive');
        }
      }
      return this;
    }
    return this.userActive_;
  };

  /**
   * Listen for user activity based on timeout value
   *
   * @private
   * @method listenForUserActivity_
   */

  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress = undefined,
        lastMoveX = undefined,
        lastMoveY = undefined;

    var handleActivity = Fn.bind(this, this.reportUserActivity);

    var handleMouseMove = function handleMouseMove(e) {
      // #1068 - Prevent mousemove spamming
      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };

    var handleMouseDown = function handleMouseDown() {
      handleActivity();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(mouseInProgress);
      // Setting userActivity=true now and setting the interval to the same time
      // as the activityCheck interval (250) should ensure we never miss the
      // next activityCheck
      mouseInProgress = this.setInterval(handleActivity, 250);
    };

    var handleMouseUp = function handleMouseUp(event) {
      handleActivity();
      // Stop the interval that maintains activity if the mouse/touch is down
      this.clearInterval(mouseInProgress);
    };

    // Any mouse movement will be considered user activity
    this.on('mousedown', handleMouseDown);
    this.on('mousemove', handleMouseMove);
    this.on('mouseup', handleMouseUp);

    // Listen for keyboard navigation
    // Shouldn't need to use inProgress interval because of key repeat
    this.on('keydown', handleActivity);
    this.on('keyup', handleActivity);

    // Run an interval every 250 milliseconds instead of stuffing everything into
    // the mousemove/touchmove function itself, to prevent performance degradation.
    // `this.reportUserActivity` simply sets this.userActivity_ to true, which
    // then gets picked up by this loop
    // http://ejohn.org/blog/learning-from-twitter/
    var inactivityTimeout = undefined;
    var activityCheck = this.setInterval(function () {
      // Check to see if mouse/touch activity has happened
      if (this.userActivity_) {
        // Reset the activity tracker
        this.userActivity_ = false;

        // If the user state was inactive, set the state to active
        this.userActive(true);

        // Clear any existing inactivity timeout to start the timer over
        this.clearTimeout(inactivityTimeout);

        var timeout = this.options_['inactivityTimeout'];
        if (timeout > 0) {
          // In <timeout> milliseconds, if no more activity has occurred the
          // user will be considered inactive
          inactivityTimeout = this.setTimeout(function () {
            // Protect against the case where the inactivityTimeout can trigger just
            // before the next user activity is picked up by the activityCheck loop
            // causing a flicker
            if (!this.userActivity_) {
              this.userActive(false);
            }
          }, timeout);
        }
      }
    }, 250);
  };

  /**
   * Gets or sets the current playback rate.  A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param  {Number} rate    New playback rate to set.
   * @return {Number}         Returns the new playback rate when setting
   * @return {Number}         Returns the current playback rate when getting
   * @method playbackRate
   */

  Player.prototype.playbackRate = function playbackRate(rate) {
    if (rate !== undefined) {
      this.techCall_('setPlaybackRate', rate);
      return this;
    }

    if (this.tech_ && this.tech_['featuresPlaybackRate']) {
      return this.techGet_('playbackRate');
    } else {
      return 1.0;
    }
  };

  /**
   * Gets or sets the audio flag
   *
   * @param  {Boolean} bool    True signals that this is an audio player.
   * @return {Boolean}         Returns true if player is audio, false if not when getting
   * @return {Player}      Returns the player if setting
   * @private
   * @method isAudio
   */

  Player.prototype.isAudio = function isAudio(bool) {
    if (bool !== undefined) {
      this.isAudio_ = !!bool;
      return this;
    }

    return !!this.isAudio_;
  };

  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {Number} the current network activity state
   * @method networkState
   */

  Player.prototype.networkState = function networkState() {
    return this.techGet_('networkState');
  };

  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {Number} the current playback rendering state
   * @method readyState
   */

  Player.prototype.readyState = function readyState() {
    return this.techGet_('readyState');
  };

  /**
   * Get a video track list
   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
   *
   * @return {VideoTrackList} thes current video track list
   * @method videoTracks
   */

  Player.prototype.videoTracks = function videoTracks() {
    // if we have not yet loadTech_, we create videoTracks_
    // these will be passed to the tech during loading
    if (!this.tech_) {
      this.videoTracks_ = this.videoTracks_ || new _tracksVideoTrackListJs2['default']();
      return this.videoTracks_;
    }

    return this.tech_.videoTracks();
  };

  /**
   * Get an audio track list
   * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
   *
   * @return {AudioTrackList} thes current audio track list
   * @method audioTracks
   */

  Player.prototype.audioTracks = function audioTracks() {
    // if we have not yet loadTech_, we create videoTracks_
    // these will be passed to the tech during loading
    if (!this.tech_) {
      this.audioTracks_ = this.audioTracks_ || new _tracksAudioTrackListJs2['default']();
      return this.audioTracks_;
    }

    return this.tech_.audioTracks();
  };

  /*
    * Text tracks are tracks of timed text events.
    * Captions - text displayed over the video for the hearing impaired
    * Subtitles - text displayed over the video for those who don't understand language in the video
    * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
    * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
    */

  /**
   * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
   * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
   *
   * @return {Array}           Array of track objects
   * @method textTracks
   */

  Player.prototype.textTracks = function textTracks() {
    // cannot use techGet_ directly because it checks to see whether the tech is ready.
    // Flash is unlikely to be ready in time but textTracks should still work.
    return this.tech_ && this.tech_['textTracks']();
  };

  /**
   * Get an array of remote text tracks
   *
   * @return {Array}
   * @method remoteTextTracks
   */

  Player.prototype.remoteTextTracks = function remoteTextTracks() {
    return this.tech_ && this.tech_['remoteTextTracks']();
  };

  /**
   * Get an array of remote html track elements
   *
   * @return {HTMLTrackElement[]}
   * @method remoteTextTrackEls
   */

  Player.prototype.remoteTextTrackEls = function remoteTextTrackEls() {
    return this.tech_ && this.tech_['remoteTextTrackEls']();
  };

  /**
   * Add a text track
   * In addition to the W3C settings we allow adding additional info through options.
   * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
   * @param {String=} label       Optional label
   * @param {String=} language    Optional language
   * @method addTextTrack
   */

  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    return this.tech_ && this.tech_['addTextTrack'](kind, label, language);
  };

  /**
   * Add a remote text track
   *
   * @param {Object} options    Options for remote text track
   * @method addRemoteTextTrack
   */

  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options) {
    return this.tech_ && this.tech_['addRemoteTextTrack'](options);
  };

  /**
   * Remove a remote text track
   *
   * @param {Object} track    Remote text track to remove
   * @method removeRemoteTextTrack
   */
  // destructure the input into an object with a track argument, defaulting to arguments[0]
  // default the whole argument to an empty object if nothing was passed in

  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref3$track = _ref3.track;
    var track = _ref3$track === undefined ? arguments[0] : _ref3$track;
    // jshint ignore:line
    this.tech_ && this.tech_['removeRemoteTextTrack'](track);
  };

  /**
   * Get video width
   *
   * @return {Number} Video width
   * @method videoWidth
   */

  Player.prototype.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };

  /**
   * Get video height
   *
   * @return {Number} Video height
   * @method videoHeight
   */

  Player.prototype.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };

  // Methods to add support for
  // initialTime: function(){ return this.techCall_('initialTime'); },
  // startOffsetTime: function(){ return this.techCall_('startOffsetTime'); },
  // played: function(){ return this.techCall_('played'); },
  // defaultPlaybackRate: function(){ return this.techCall_('defaultPlaybackRate'); },
  // defaultMuted: function(){ return this.techCall_('defaultMuted'); }

  /**
   * The player's language code
   * NOTE: The language should be set in the player options if you want the
   * the controls to be built with a specific language. Changing the lanugage
   * later will not update controls text.
   *
   * @param {String} code  The locale string
   * @return {String}      The locale string when getting
   * @return {Player}      self when setting
   * @method language
   */

  Player.prototype.language = function language(code) {
    if (code === undefined) {
      return this.language_;
    }

    this.language_ = ('' + code).toLowerCase();
    return this;
  };

  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array} Array of languages
   * @method languages
   */

  Player.prototype.languages = function languages() {
    return _utilsMergeOptionsJs2['default'](Player.prototype.options_.languages, this.languages_);
  };

  /**
   * Converts track info to JSON
   *
   * @return {Object} JSON object of options
   * @method toJSON
   */

  Player.prototype.toJSON = function toJSON() {
    var options = _utilsMergeOptionsJs2['default'](this.options_);
    var tracks = options.tracks;

    options.tracks = [];

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // deep merge tracks and null out player so no circular references
      track = _utilsMergeOptionsJs2['default'](track);
      track.player = undefined;
      options.tracks[i] = track;
    }

    return options;
  };

  /**
   * Creates a simple modal dialog (an instance of the `ModalDialog`
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {String|Function|Element|Array|Null} content
   *        Same as `ModalDialog#content`'s param of the same name.
   *
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the `ModalDialog`.
   *
   * @return {ModalDialog}
   */

  Player.prototype.createModal = function createModal(content, options) {
    var player = this;

    options = options || {};
    options.content = content || '';

    var modal = new _modalDialog2['default'](player, options);

    player.addChild(modal);
    modal.on('dispose', function () {
      player.removeChild(modal);
    });

    return modal.open();
  };

  /**
   * Gets tag settings
   *
   * @param {Element} tag The player tag
   * @return {Array} An array of sources and track objects
   * @static
   * @method getTagSettings
   */

  Player.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      'sources': [],
      'tracks': []
    };

    var tagOptions = Dom.getElAttributes(tag);
    var dataSetup = tagOptions['data-setup'];

    // Check if data-setup attr exists.
    if (dataSetup !== null) {
      // Parse options JSON

      var _safeParseTuple = _safeJsonParseTuple2['default'](dataSetup || '{}');

      var err = _safeParseTuple[0];
      var data = _safeParseTuple[1];

      if (err) {
        _utilsLogJs2['default'].error(err);
      }
      _objectAssign2['default'](tagOptions, data);
    }

    _objectAssign2['default'](baseOptions, tagOptions);

    // Get tag children settings
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;

      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
        var childName = child.nodeName.toLowerCase();
        if (childName === 'source') {
          baseOptions.sources.push(Dom.getElAttributes(child));
        } else if (childName === 'track') {
          baseOptions.tracks.push(Dom.getElAttributes(child));
        }
      }
    }

    return baseOptions;
  };

  return Player;
})(_componentJs2['default']);

Player.players = {};

var navigator = _globalWindow2['default'].navigator;
/*
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 *
 * @type {Object}
 * @private
 */
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: ['html5', 'flash'],
  // techOrder: ['flash','html5'],

  html5: {},
  flash: {},

  // defaultVolume: 0.85,
  defaultVolume: 0.00, // The freakin seaguls are driving me crazy!

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],

  language: navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this media.'
};

/**
 * Fired when the user agent begins looking for media data
 *
 * @event loadstart
 */
Player.prototype.handleTechLoadStart_;

/**
 * Fired when the player has initial duration and dimension information
 *
 * @event loadedmetadata
 */
Player.prototype.handleLoadedMetaData_;

/**
 * Fired when the player receives text data
 *
 * @event textdata
 */
Player.prototype.handleTextData_;

/**
 * Fired when the player has downloaded data at the current playback position
 *
 * @event loadeddata
 */
Player.prototype.handleLoadedData_;

/**
 * Fired when the user is active, e.g. moves the mouse over the player
 *
 * @event useractive
 */
Player.prototype.handleUserActive_;

/**
 * Fired when the user is inactive, e.g. a short delay after the last mouse move or control interaction
 *
 * @event userinactive
 */
Player.prototype.handleUserInactive_;

/**
 * Fired when the current playback position has changed *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 *
 * @event timeupdate
 */
Player.prototype.handleTimeUpdate_;

/**
 * Fired when video playback ends
 *
 * @event ended
 */
Player.prototype.handleTechEnded_;

/**
 * Fired when the volume changes
 *
 * @event volumechange
 */
Player.prototype.handleVolumeChange_;

/**
 * Fired when an error occurs
 *
 * @event error
 */
Player.prototype.handleError_;

Player.prototype.flexNotSupported_ = function () {
  var elem = _globalDocument2['default'].createElement('i');

  // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more
  // common flex features that we can rely on when checking for flex support.
  return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style || 'msFlexOrder' in elem.style) /* IE10-specific (2012 flex spec)  */;
};

_componentJs2['default'].registerComponent('Player', Player);
exports['default'] = Player;
module.exports = exports['default'];
// If empty string, make it a parsable json object.

},{"./big-play-button.js":63,"./component.js":67,"./control-bar/control-bar.js":70,"./error-display.js":103,"./fullscreen-api.js":106,"./loading-spinner.js":107,"./media-error.js":108,"./modal-dialog":112,"./poster-image.js":117,"./tech/html5.js":122,"./tech/loader.js":123,"./tech/tech.js":124,"./tracks/audio-track-list.js":125,"./tracks/text-track-display.js":130,"./tracks/text-track-list-converter.js":131,"./tracks/text-track-settings.js":133,"./tracks/video-track-list.js":138,"./utils/browser.js":140,"./utils/buffer.js":141,"./utils/dom.js":142,"./utils/events.js":143,"./utils/fn.js":144,"./utils/guid.js":146,"./utils/log.js":147,"./utils/merge-options.js":148,"./utils/stylesheet.js":149,"./utils/time-ranges.js":150,"./utils/to-title-case.js":151,"global/document":1,"global/window":2,"object.assign":45,"safe-json-parse/tuple":54}],114:[function(_dereq_,module,exports){
/**
 * @file plugins.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _playerJs = _dereq_('./player.js');

var _playerJs2 = _interopRequireDefault(_playerJs);

/**
 * The method for registering a video.js plugin
 *
 * @param  {String} name The name of the plugin
 * @param  {Function} init The function that is run when the player inits
 * @method plugin
 */
var plugin = function plugin(name, init) {
  _playerJs2['default'].prototype[name] = init;
};

exports['default'] = plugin;
module.exports = exports['default'];

},{"./player.js":113}],115:[function(_dereq_,module,exports){
/**
 * @file popup-button.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _clickableComponentJs = _dereq_('../clickable-component.js');

var _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _popupJs = _dereq_('./popup.js');

var _popupJs2 = _interopRequireDefault(_popupJs);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

/**
 * A button class with a popup control
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends ClickableComponent
 * @class PopupButton
 */

var PopupButton = (function (_ClickableComponent) {
  _inherits(PopupButton, _ClickableComponent);

  function PopupButton(player) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, PopupButton);

    _ClickableComponent.call(this, player, options);

    this.update();
  }

  /**
   * Update popup
   *
   * @method update
   */

  PopupButton.prototype.update = function update() {
    var popup = this.createPopup();

    if (this.popup) {
      this.removeChild(this.popup);
    }

    this.popup = popup;
    this.addChild(popup);

    if (this.items && this.items.length === 0) {
      this.hide();
    } else if (this.items && this.items.length > 1) {
      this.show();
    }
  };

  /**
   * Create popup - Override with specific functionality for component
   *
   * @return {Popup} The constructed popup
   * @method createPopup
   */

  PopupButton.prototype.createPopup = function createPopup() {};

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  PopupButton.prototype.createEl = function createEl() {
    return _ClickableComponent.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  /**
   * Allow sub components to stack CSS class names
   *
   * @return {String} The constructed class name
   * @method buildCSSClass
   */

  PopupButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _ClickableComponent.prototype.buildCSSClass.call(this);
  };

  return PopupButton;
})(_clickableComponentJs2['default']);

_componentJs2['default'].registerComponent('PopupButton', PopupButton);
exports['default'] = PopupButton;
module.exports = exports['default'];

},{"../clickable-component.js":65,"../component.js":67,"../utils/dom.js":142,"../utils/fn.js":144,"../utils/to-title-case.js":151,"./popup.js":116}],116:[function(_dereq_,module,exports){
/**
 * @file popup.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsEventsJs = _dereq_('../utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

/**
 * The Popup component is used to build pop up controls.
 *
 * @extends Component
 * @class Popup
 */

var Popup = (function (_Component) {
  _inherits(Popup, _Component);

  function Popup() {
    _classCallCheck(this, Popup);

    _Component.apply(this, arguments);
  }

  /**
   * Add a popup item to the popup
   *
   * @param {Object|String} component Component or component type to add
   * @method addItem
   */

  Popup.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', Fn.bind(this, function () {
      this.unlockShowing();
    }));
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  Popup.prototype.createEl = function createEl() {
    var contentElType = this.options_.contentElType || 'ul';
    this.contentEl_ = Dom.createEl(contentElType, {
      className: 'vjs-menu-content'
    });
    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });
    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Popup Buttons,
    // where a click on the parent is significant
    Events.on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  return Popup;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Popup', Popup);
exports['default'] = Popup;
module.exports = exports['default'];

},{"../component.js":67,"../utils/dom.js":142,"../utils/events.js":143,"../utils/fn.js":144}],117:[function(_dereq_,module,exports){
/**
 * @file poster-image.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _clickableComponentJs = _dereq_('./clickable-component.js');

var _clickableComponentJs2 = _interopRequireDefault(_clickableComponentJs);

var _componentJs = _dereq_('./component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsFnJs = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsDomJs = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsBrowserJs = _dereq_('./utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

/**
 * The component that handles showing the poster image.
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Button
 * @class PosterImage
 */

var PosterImage = (function (_ClickableComponent) {
  _inherits(PosterImage, _ClickableComponent);

  function PosterImage(player, options) {
    _classCallCheck(this, PosterImage);

    _ClickableComponent.call(this, player, options);

    this.update();
    player.on('posterchange', Fn.bind(this, this.update));
  }

  /**
   * Clean up the poster image
   *
   * @method dispose
   */

  PosterImage.prototype.dispose = function dispose() {
    this.player().off('posterchange', this.update);
    _ClickableComponent.prototype.dispose.call(this);
  };

  /**
   * Create the poster's image element
   *
   * @return {Element}
   * @method createEl
   */

  PosterImage.prototype.createEl = function createEl() {
    var el = Dom.createEl('div', {
      className: 'vjs-poster',

      // Don't want poster to be tabbable.
      tabIndex: -1
    });

    // To ensure the poster image resizes while maintaining its original aspect
    // ratio, use a div with `background-size` when available. For browsers that
    // do not support `background-size` (e.g. IE8), fall back on using a regular
    // img element.
    if (!browser.BACKGROUND_SIZE_SUPPORTED) {
      this.fallbackImg_ = Dom.createEl('img');
      el.appendChild(this.fallbackImg_);
    }

    return el;
  };

  /**
   * Event handler for updates to the player's poster source
   *
   * @method update
   */

  PosterImage.prototype.update = function update() {
    var url = this.player().poster();

    this.setSrc(url);

    // If there's no poster source we should display:none on this component
    // so it's not still clickable or right-clickable
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Set the poster source depending on the display method
   *
   * @param {String} url The URL to the poster source
   * @method setSrc
   */

  PosterImage.prototype.setSrc = function setSrc(url) {
    if (this.fallbackImg_) {
      this.fallbackImg_.src = url;
    } else {
      var backgroundImage = '';
      // Any falsey values should stay as an empty string, otherwise
      // this will throw an extra error
      if (url) {
        backgroundImage = 'url("' + url + '")';
      }

      this.el_.style.backgroundImage = backgroundImage;
    }
  };

  /**
   * Event handler for clicks on the poster image
   *
   * @method handleClick
   */

  PosterImage.prototype.handleClick = function handleClick() {
    // We don't want a click to trigger playback when controls are disabled
    // but CSS should be hiding the poster to prevent that from happening
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  return PosterImage;
})(_clickableComponentJs2['default']);

_componentJs2['default'].registerComponent('PosterImage', PosterImage);
exports['default'] = PosterImage;
module.exports = exports['default'];

},{"./clickable-component.js":65,"./component.js":67,"./utils/browser.js":140,"./utils/dom.js":142,"./utils/fn.js":144}],118:[function(_dereq_,module,exports){
/**
 * @file setup.js
 *
 * Functions for automatically setting up a player
 * based on the data-setup attribute of the video tag
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _windowLoaded = false;
var videojs = undefined;

// Automatically set up any tags that have a data-setup attribute
var autoSetup = function autoSetup() {
  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
  // to build up a new, combined list of elements.
  var vids = _globalDocument2['default'].getElementsByTagName('video');
  var audios = _globalDocument2['default'].getElementsByTagName('audio');
  var mediaEls = [];
  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }
  if (audios && audios.length > 0) {
    for (var i = 0, e = audios.length; i < e; i++) {
      mediaEls.push(audios[i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var i = 0, e = mediaEls.length; i < e; i++) {
      var mediaEl = mediaEls[i];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl['player'] === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            var player = videojs(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
          autoSetupTimeout(1);
          break;
        }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
      autoSetupTimeout(1);
    }
};

// Pause to let the DOM keep processing
var autoSetupTimeout = function autoSetupTimeout(wait, vjs) {
  if (vjs) {
    videojs = vjs;
  }

  setTimeout(autoSetup, wait);
};

if (_globalDocument2['default'].readyState === 'complete') {
  _windowLoaded = true;
} else {
  Events.one(_globalWindow2['default'], 'load', function () {
    _windowLoaded = true;
  });
}

var hasLoaded = function hasLoaded() {
  return _windowLoaded;
};

exports.autoSetup = autoSetup;
exports.autoSetupTimeout = autoSetupTimeout;
exports.hasLoaded = hasLoaded;

},{"./utils/events.js":143,"global/document":1,"global/window":2}],119:[function(_dereq_,module,exports){
/**
 * @file slider.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

/**
 * The base functionality for sliders like the volume bar and seek bar
 *
 * @param {Player|Object} player
 * @param {Object=} options
 * @extends Component
 * @class Slider
 */

var Slider = (function (_Component) {
  _inherits(Slider, _Component);

  function Slider(player, options) {
    _classCallCheck(this, Slider);

    _Component.call(this, player, options);

    // Set property names to bar to match with the child Slider class is looking for
    this.bar = this.getChild(this.options_.barName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    this.vertical(!!this.options_.vertical);

    this.on('mousedown', this.handleMouseDown);
    this.on('touchstart', this.handleMouseDown);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
    this.on('click', this.handleClick);

    this.on(player, 'controlsvisible', this.update);
    this.on(player, this.playerEvent, this.update);
  }

  /**
   * Create the component's DOM element
   *
   * @param {String} type Type of element to create
   * @param {Object=} props List of properties in Object form
   * @return {Element}
   * @method createEl
   */

  Slider.prototype.createEl = function createEl(type) {
    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    // Add the slider element class to all sub classes
    props.className = props.className + ' vjs-slider';
    props = _objectAssign2['default']({
      tabIndex: 0
    }, props);

    attributes = _objectAssign2['default']({
      'role': 'slider',
      'aria-valuenow': 0,
      'aria-valuemin': 0,
      'aria-valuemax': 100,
      tabIndex: 0
    }, attributes);

    return _Component.prototype.createEl.call(this, type, props, attributes);
  };

  /**
   * Handle mouse down on slider
   *
   * @param {Object} event Mouse down event object
   * @method handleMouseDown
   */

  Slider.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;

    event.preventDefault();
    Dom.blockTextSelection();

    this.addClass('vjs-sliding');
    this.trigger('slideractive');

    this.on(doc, 'mousemove', this.handleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchmove', this.handleMouseMove);
    this.on(doc, 'touchend', this.handleMouseUp);

    this.handleMouseMove(event);
  };

  /**
   * To be overridden by a subclass
   *
   * @method handleMouseMove
   */

  Slider.prototype.handleMouseMove = function handleMouseMove() {};

  /**
   * Handle mouse up on Slider
   *
   * @method handleMouseUp
   */

  Slider.prototype.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;

    Dom.unblockTextSelection();

    this.removeClass('vjs-sliding');
    this.trigger('sliderinactive');

    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);

    this.update();
  };

  /**
   * Update slider
   *
   * @method update
   */

  Slider.prototype.update = function update() {
    // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
    // execution stack. The player is destroyed before then update will cause an error
    if (!this.el_) return;

    // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
    // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
    var progress = this.getPercent();
    var bar = this.bar;

    // If there's no bar...
    if (!bar) return;

    // Protect against no duration and other division issues
    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
      progress = 0;
    }

    // Convert to a percentage for setting
    var percentage = (progress * 100).toFixed(2) + '%';

    // Set the new bar width or height
    if (this.vertical()) {
      bar.el().style.height = percentage;
    } else {
      bar.el().style.width = percentage;
    }
  };

  /**
   * Calculate distance for slider
   *
   * @param {Object} event Event object
   * @method calculateDistance
   */

  Slider.prototype.calculateDistance = function calculateDistance(event) {
    var position = Dom.getPointerPosition(this.el_, event);
    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };

  /**
   * Handle on focus for slider
   *
   * @method handleFocus
   */

  Slider.prototype.handleFocus = function handleFocus() {
    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Handle key press for slider
   *
   * @param {Object} event Event object
   * @method handleKeyPress
   */

  Slider.prototype.handleKeyPress = function handleKeyPress(event) {
    if (event.which === 37 || event.which === 40) {
      // Left and Down Arrows
      event.preventDefault();
      this.stepBack();
    } else if (event.which === 38 || event.which === 39) {
      // Up and Right Arrows
      event.preventDefault();
      this.stepForward();
    }
  };

  /**
   * Handle on blur for slider
   *
   * @method handleBlur
   */

  Slider.prototype.handleBlur = function handleBlur() {
    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event Event object
   * @method handleClick
   */

  Slider.prototype.handleClick = function handleClick(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  };

  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {Boolean} bool True if slider is vertical, false is horizontal
   * @return {Boolean} True if slider is vertical, false is horizontal
   * @method vertical
   */

  Slider.prototype.vertical = function vertical(bool) {
    if (bool === undefined) {
      return this.vertical_ || false;
    }

    this.vertical_ = !!bool;

    if (this.vertical_) {
      this.addClass('vjs-slider-vertical');
    } else {
      this.addClass('vjs-slider-horizontal');
    }

    return this;
  };

  return Slider;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('Slider', Slider);
exports['default'] = Slider;
module.exports = exports['default'];

},{"../component.js":67,"../utils/dom.js":142,"object.assign":45}],120:[function(_dereq_,module,exports){
/**
 * @file flash-rtmp.js
 */
'use strict';

exports.__esModule = true;
function FlashRtmpDecorator(Flash) {
  Flash.streamingFormats = {
    'rtmp/mp4': 'MP4',
    'rtmp/flv': 'FLV'
  };

  Flash.streamFromParts = function (connection, stream) {
    return connection + '&' + stream;
  };

  Flash.streamToParts = function (src) {
    var parts = {
      connection: '',
      stream: ''
    };

    if (!src) return parts;

    // Look for the normal URL separator we expect, '&'.
    // If found, we split the URL into two pieces around the
    // first '&'.
    var connEnd = src.search(/&(?!\w+=)/);
    var streamBegin = undefined;
    if (connEnd !== -1) {
      streamBegin = connEnd + 1;
    } else {
      // If there's not a '&', we use the last '/' as the delimiter.
      connEnd = streamBegin = src.lastIndexOf('/') + 1;
      if (connEnd === 0) {
        // really, there's not a '/'?
        connEnd = streamBegin = src.length;
      }
    }
    parts.connection = src.substring(0, connEnd);
    parts.stream = src.substring(streamBegin, src.length);

    return parts;
  };

  Flash.isStreamingType = function (srcType) {
    return srcType in Flash.streamingFormats;
  };

  // RTMP has four variations, any string starting
  // with one of these protocols should be valid
  Flash.RTMP_RE = /^rtmp[set]?:\/\//i;

  Flash.isStreamingSrc = function (src) {
    return Flash.RTMP_RE.test(src);
  };

  /**
   * A source handler for RTMP urls
   * @type {Object}
   */
  Flash.rtmpSourceHandler = {};

  /**
   * Check if Flash can play the given videotype
   * @param  {String} type    The mimetype to check
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canPlayType = function (type) {
    if (Flash.isStreamingType(type)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Check if Flash can handle the source natively
   * @param  {Object} source  The source object
   * @param  {Object} options The options passed to the tech
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {
    var can = Flash.rtmpSourceHandler.canPlayType(source.type);

    if (can) {
      return can;
    }

    if (Flash.isStreamingSrc(source.src)) {
      return 'maybe';
    }

    return '';
  };

  /**
   * Pass the source to the flash object
   * Adaptive source handlers will have more complicated workflows before passing
   * video data to the video element
   * @param  {Object} source   The source object
   * @param  {Flash}  tech     The instance of the Flash tech
   * @param  {Object} options  The options to pass to the source
   */
  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {
    var srcParts = Flash.streamToParts(source.src);

    tech['setRtmpConnection'](srcParts.connection);
    tech['setRtmpStream'](srcParts.stream);
  };

  // Register the native source handler
  Flash.registerSourceHandler(Flash.rtmpSourceHandler);

  return Flash;
}

exports['default'] = FlashRtmpDecorator;
module.exports = exports['default'];

},{}],121:[function(_dereq_,module,exports){
/**
 * @file flash.js
 * VideoJS-SWF - Custom Flash Player with HTML5-ish API
 * https://github.com/zencoder/video-js-swf
 * Not using setupTriggers. Using global onEvent func to distribute events
 */

'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _tech = _dereq_('./tech');

var _tech2 = _interopRequireDefault(_tech);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsUrlJs = _dereq_('../utils/url.js');

var Url = _interopRequireWildcard(_utilsUrlJs);

var _utilsTimeRangesJs = _dereq_('../utils/time-ranges.js');

var _flashRtmp = _dereq_('./flash-rtmp');

var _flashRtmp2 = _interopRequireDefault(_flashRtmp);

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var navigator = _globalWindow2['default'].navigator;
/**
 * Flash Media Controller - Wrapper for fallback SWF API
 *
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready Ready callback function
 * @extends Tech
 * @class Flash
 */

var Flash = (function (_Tech) {
  _inherits(Flash, _Tech);

  function Flash(options, ready) {
    _classCallCheck(this, Flash);

    _Tech.call(this, options, ready);

    // Set the source when ready
    if (options.source) {
      this.ready(function () {
        this.setSource(options.source);
      }, true);
    }

    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers
    // This allows resetting the playhead when we catch the reload
    if (options.startTime) {
      this.ready(function () {
        this.load();
        this.play();
        this.currentTime(options.startTime);
      }, true);
    }

    // Add global window functions that the swf expects
    // A 4.x workflow we weren't able to solve for in 5.0
    // because of the need to hard code these functions
    // into the swf for security reasons
    _globalWindow2['default'].videojs = _globalWindow2['default'].videojs || {};
    _globalWindow2['default'].videojs.Flash = _globalWindow2['default'].videojs.Flash || {};
    _globalWindow2['default'].videojs.Flash.onReady = Flash.onReady;
    _globalWindow2['default'].videojs.Flash.onEvent = Flash.onEvent;
    _globalWindow2['default'].videojs.Flash.onError = Flash.onError;

    this.on('seeked', function () {
      this.lastSeekTarget_ = undefined;
    });
  }

  // Create setters and getters for attributes

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  Flash.prototype.createEl = function createEl() {
    var options = this.options_;

    // If video.js is hosted locally you should also set the location
    // for the hosted swf, which should be relative to the page (not video.js)
    // Otherwise this adds a CDN url.
    // The CDN also auto-adds a swf URL for that specific version.
    if (!options.swf) {
      options.swf = '//vjs.zencdn.net/swf/5.1.0/video-js.swf';
    }

    // Generate ID for swf object
    var objId = options.techId;

    // Merge default flashvars with ones passed in to init
    var flashVars = _objectAssign2['default']({

      // SWF Callback Functions
      'readyFunction': 'videojs.Flash.onReady',
      'eventProxyFunction': 'videojs.Flash.onEvent',
      'errorEventProxyFunction': 'videojs.Flash.onError',

      // Player Settings
      'autoplay': options.autoplay,
      'preload': options.preload,
      'loop': options.loop,
      'muted': options.muted

    }, options.flashVars);

    // Merge default parames with ones passed in
    var params = _objectAssign2['default']({
      'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance
      'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading
    }, options.params);

    // Merge default attributes with ones passed in
    var attributes = _objectAssign2['default']({
      'id': objId,
      'name': objId, // Both ID and Name needed or swf to identify itself
      'class': 'vjs-tech'
    }, options.attributes);

    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);
    this.el_.tech = this;

    return this.el_;
  };

  /**
   * Play for flash tech
   *
   * @method play
   */

  Flash.prototype.play = function play() {
    if (this.ended()) {
      this.setCurrentTime(0);
    }
    this.el_.vjs_play();
  };

  /**
   * Pause for flash tech
   *
   * @method pause
   */

  Flash.prototype.pause = function pause() {
    this.el_.vjs_pause();
  };

  /**
   * Get/set video
   *
   * @param {Object=} src Source object
   * @return {Object}
   * @method src
   */

  Flash.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.currentSrc();
    }

    // Setting src through `src` not `setSrc` will be deprecated
    return this.setSrc(_src);
  };

  /**
   * Set video
   *
   * @param {Object=} src Source object
   * @deprecated
   * @method setSrc
   */

  Flash.prototype.setSrc = function setSrc(src) {
    // Make sure source URL is absolute.
    src = Url.getAbsoluteURL(src);
    this.el_.vjs_src(src);

    // Currently the SWF doesn't autoplay if you load a source later.
    // e.g. Load player w/ no source, wait 2s, set src.
    if (this.autoplay()) {
      var tech = this;
      this.setTimeout(function () {
        tech.play();
      }, 0);
    }
  };

  /**
   * Returns true if the tech is currently seeking.
   * @return {boolean} true if seeking
   */

  Flash.prototype.seeking = function seeking() {
    return this.lastSeekTarget_ !== undefined;
  };

  /**
   * Set current time
   *
   * @param {Number} time Current time of video
   * @method setCurrentTime
   */

  Flash.prototype.setCurrentTime = function setCurrentTime(time) {
    var seekable = this.seekable();
    if (seekable.length) {
      // clamp to the current seekable range
      time = time > seekable.start(0) ? time : seekable.start(0);
      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);

      this.lastSeekTarget_ = time;
      this.trigger('seeking');
      this.el_.vjs_setProperty('currentTime', time);
      _Tech.prototype.setCurrentTime.call(this);
    }
  };

  /**
   * Get current time
   *
   * @param {Number=} time Current time of video
   * @return {Number} Current time
   * @method currentTime
   */

  Flash.prototype.currentTime = function currentTime(time) {
    // when seeking make the reported time keep up with the requested time
    // by reading the time we're seeking to
    if (this.seeking()) {
      return this.lastSeekTarget_ || 0;
    }
    return this.el_.vjs_getProperty('currentTime');
  };

  /**
   * Get current source
   *
   * @method currentSrc
   */

  Flash.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    } else {
      return this.el_.vjs_getProperty('currentSrc');
    }
  };

  /**
   * Get media duration
   *
   * @returns {Number} Media duration
   */

  Flash.prototype.duration = function duration() {
    if (this.readyState() === 0) {
      return NaN;
    } else {
      var duration = this.el_.vjs_getProperty('duration');
      return duration >= 0 ? duration : Infinity;
    }
  };

  /**
   * Load media into player
   *
   * @method load
   */

  Flash.prototype.load = function load() {
    this.el_.vjs_load();
  };

  /**
   * Get poster
   *
   * @method poster
   */

  Flash.prototype.poster = function poster() {
    this.el_.vjs_getProperty('poster');
  };

  /**
   * Poster images are not handled by the Flash tech so make this a no-op
   *
   * @method setPoster
   */

  Flash.prototype.setPoster = function setPoster() {};

  /**
   * Determine if can seek in media
   *
   * @return {TimeRangeObject}
   * @method seekable
   */

  Flash.prototype.seekable = function seekable() {
    var duration = this.duration();
    if (duration === 0) {
      return _utilsTimeRangesJs.createTimeRange();
    }
    return _utilsTimeRangesJs.createTimeRange(0, duration);
  };

  /**
   * Get buffered time range
   *
   * @return {TimeRangeObject}
   * @method buffered
   */

  Flash.prototype.buffered = function buffered() {
    var ranges = this.el_.vjs_getProperty('buffered');
    if (ranges.length === 0) {
      return _utilsTimeRangesJs.createTimeRange();
    }
    return _utilsTimeRangesJs.createTimeRange(ranges[0][0], ranges[0][1]);
  };

  /**
   * Get fullscreen support -
   * Flash does not allow fullscreen through javascript
   * so always returns false
   *
   * @return {Boolean} false
   * @method supportsFullScreen
   */

  Flash.prototype.supportsFullScreen = function supportsFullScreen() {
    return false; // Flash does not allow fullscreen through javascript
  };

  /**
   * Request to enter fullscreen
   * Flash does not allow fullscreen through javascript
   * so always returns false
   *
   * @return {Boolean} false
   * @method enterFullScreen
   */

  Flash.prototype.enterFullScreen = function enterFullScreen() {
    return false;
  };

  return Flash;
})(_tech2['default']);

var _api = Flash.prototype;
var _readWrite = 'rtmpConnection,rtmpStream,preload,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(',');
var _readOnly = 'networkState,readyState,initialTime,startOffsetTime,paused,ended,videoWidth,videoHeight'.split(',');

function _createSetter(attr) {
  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);
  _api['set' + attrUpper] = function (val) {
    return this.el_.vjs_setProperty(attr, val);
  };
}
function _createGetter(attr) {
  _api[attr] = function () {
    return this.el_.vjs_getProperty(attr);
  };
}

// Create getter and setters for all read/write attributes
for (var i = 0; i < _readWrite.length; i++) {
  _createGetter(_readWrite[i]);
  _createSetter(_readWrite[i]);
}

// Create getters for read-only attributes
for (var i = 0; i < _readOnly.length; i++) {
  _createGetter(_readOnly[i]);
}

/* Flash Support Testing -------------------------------------------------------- */

Flash.isSupported = function () {
  return Flash.version()[0] >= 10;
  // return swfobject.hasFlashPlayerVersion('10');
};

// Add Source Handler pattern functions to this tech
_tech2['default'].withSourceHandlers(Flash);

/*
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 *
 * @param  {Object} source   The source object
 * @param  {Flash} tech  The instance of the Flash tech
 */
Flash.nativeSourceHandler = {};

/**
 * Check if Flash can play the given videotype
 * @param  {String} type    The mimetype to check
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Flash.nativeSourceHandler.canPlayType = function (type) {
  if (type in Flash.formats) {
    return 'maybe';
  }

  return '';
};

/*
 * Check Flash can handle the source natively
 *
 * @param  {Object} source  The source object
 * @param  {Object} options The options passed to the tech
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Flash.nativeSourceHandler.canHandleSource = function (source, options) {
  var type;

  function guessMimeType(src) {
    var ext = Url.getFileExtension(src);
    if (ext) {
      return 'video/' + ext;
    }
    return '';
  }

  if (!source.type) {
    type = guessMimeType(source.src);
  } else {
    // Strip code information from the type because we don't get that specific
    type = source.type.replace(/;.*/, '').toLowerCase();
  }

  return Flash.nativeSourceHandler.canPlayType(type);
};

/*
 * Pass the source to the flash object
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 *
 * @param  {Object} source   The source object
 * @param  {Flash}  tech     The instance of the Flash tech
 * @param  {Object} options  The options to pass to the source
 */
Flash.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/*
 * Clean up the source handler when disposing the player or switching sources..
 * (no cleanup is needed when supporting the format natively)
 */
Flash.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Flash.registerSourceHandler(Flash.nativeSourceHandler);

Flash.formats = {
  'video/flv': 'FLV',
  'video/x-flv': 'FLV',
  'video/mp4': 'MP4',
  'video/m4v': 'MP4'
};

Flash.onReady = function (currSwf) {
  var el = Dom.getEl(currSwf);
  var tech = el && el.tech;

  // if there is no el then the tech has been disposed
  // and the tech element was removed from the player div
  if (tech && tech.el()) {
    // check that the flash object is really ready
    Flash.checkReady(tech);
  }
};

// The SWF isn't always ready when it says it is. Sometimes the API functions still need to be added to the object.
// If it's not ready, we set a timeout to check again shortly.
Flash.checkReady = function (tech) {
  // stop worrying if the tech has been disposed
  if (!tech.el()) {
    return;
  }

  // check if API property exists
  if (tech.el().vjs_getProperty) {
    // tell tech it's ready
    tech.triggerReady();
  } else {
    // wait longer
    this.setTimeout(function () {
      Flash['checkReady'](tech);
    }, 50);
  }
};

// Trigger events from the swf on the player
Flash.onEvent = function (swfID, eventName) {
  var tech = Dom.getEl(swfID).tech;
  tech.trigger(eventName, Array.prototype.slice.call(arguments, 2));
};

// Log errors from the swf
Flash.onError = function (swfID, err) {
  var tech = Dom.getEl(swfID).tech;

  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED
  if (err === 'srcnotfound') {
    return tech.error(4);
  }

  // trigger a custom error
  tech.error('FLASH: ' + err);
};

// Flash Version Check
Flash.version = function () {
  var version = '0,0,0';

  // IE
  try {
    version = new _globalWindow2['default'].ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {}
  }
  return version.split(',');
};

// Flash embedding method. Only used in non-iframe mode
Flash.embed = function (swf, flashVars, params, attributes) {
  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);

  // Get element by embedding code and retrieving created element
  var obj = Dom.createEl('div', { innerHTML: code }).childNodes[0];

  return obj;
};

Flash.getEmbedCode = function (swf, flashVars, params, attributes) {
  var objTag = '<object type="application/x-shockwave-flash" ';
  var flashVarsString = '';
  var paramsString = '';
  var attrsString = '';

  // Convert flash vars to string
  if (flashVars) {
    Object.getOwnPropertyNames(flashVars).forEach(function (key) {
      flashVarsString += key + '=' + flashVars[key] + '&amp;';
    });
  }

  // Add swf, flashVars, and other default params
  params = _objectAssign2['default']({
    'movie': swf,
    'flashvars': flashVarsString,
    'allowScriptAccess': 'always', // Required to talk to swf
    'allowNetworking': 'all' // All should be default, but having security issues.
  }, params);

  // Create param tags string
  Object.getOwnPropertyNames(params).forEach(function (key) {
    paramsString += '<param name="' + key + '" value="' + params[key] + '" />';
  });

  attributes = _objectAssign2['default']({
    // Add swf to attributes (need both for IE and Others to work)
    'data': swf,

    // Default to 100% width/height
    'width': '100%',
    'height': '100%'

  }, attributes);

  // Create Attributes string
  Object.getOwnPropertyNames(attributes).forEach(function (key) {
    attrsString += key + '="' + attributes[key] + '" ';
  });

  return '' + objTag + attrsString + '>' + paramsString + '</object>';
};

// Run Flash through the RTMP decorator
_flashRtmp2['default'](Flash);

_component2['default'].registerComponent('Flash', Flash);
_tech2['default'].registerTech('Flash', Flash);
exports['default'] = Flash;
module.exports = exports['default'];

},{"../component":67,"../utils/dom.js":142,"../utils/time-ranges.js":150,"../utils/url.js":152,"./flash-rtmp":120,"./tech":124,"global/window":2,"object.assign":45}],122:[function(_dereq_,module,exports){
/**
 * @file html5.js
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 */

'use strict';

exports.__esModule = true;

var _templateObject = _taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used. \n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used. \n            This may prevent text tracks from loading.']);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

var _techJs = _dereq_('./tech.js');

var _techJs2 = _interopRequireDefault(_techJs);

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _utilsDomJs = _dereq_('../utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsUrlJs = _dereq_('../utils/url.js');

var Url = _interopRequireWildcard(_utilsUrlJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsLogJs = _dereq_('../utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _tsml = _dereq_('tsml');

var _tsml2 = _interopRequireDefault(_tsml);

var _srcJsTracksTextTrackJs = _dereq_('../../../src/js/tracks/text-track.js');

var _srcJsTracksTextTrackJs2 = _interopRequireDefault(_srcJsTracksTextTrackJs);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _objectAssign = _dereq_('object.assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _utilsMergeOptionsJs = _dereq_('../utils/merge-options.js');

var _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);

var _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 *
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready Ready callback function
 * @extends Tech
 * @class Html5
 */

var Html5 = (function (_Tech) {
  _inherits(Html5, _Tech);

  function Html5(options, ready) {
    var _this = this;

    _classCallCheck(this, Html5);

    _Tech.call(this, options, ready);

    var source = options.source;
    var crossoriginTracks = false;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      this.setSource(source);
    } else {
      this.handleLateInit_(this.el_);
    }

    if (this.el_.hasChildNodes()) {

      var nodes = this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();

        if (nodeName === 'track') {
          if (!this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            // store HTMLTrackElement and TextTrack to remote list
            this.remoteTextTrackEls().addTrackElement_(node);
            this.remoteTextTracks().addTrack_(node.track);
            if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && Url.isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        this.el_.removeChild(removeNodes[i]);
      }
    }

    var trackTypes = ['audio', 'video'];

    // ProxyNativeTextTracks
    trackTypes.forEach(function (type) {
      var capitalType = _utilsToTitleCaseJs2['default'](type);

      if (!_this['featuresNative' + capitalType + 'Tracks']) {
        return;
      }
      var tl = _this.el()[type + 'Tracks'];

      if (tl && tl.addEventListener) {
        tl.addEventListener('change', Fn.bind(_this, _this['handle' + capitalType + 'TrackChange_']));
        tl.addEventListener('addtrack', Fn.bind(_this, _this['handle' + capitalType + 'TrackAdd_']));
        tl.addEventListener('removetrack', Fn.bind(_this, _this['handle' + capitalType + 'TrackRemove_']));

        // Remove (native) trackts that are not used anymore
        _this.on('loadstart', _this['removeOld' + capitalType + 'Tracks_']);
      }
    });

    if (this.featuresNativeTextTracks) {
      if (crossoriginTracks) {
        _utilsLogJs2['default'].warn(_tsml2['default'](_templateObject));
      }

      this.handleTextTrackChange_ = Fn.bind(this, this.handleTextTrackChange);
      this.handleTextTrackAdd_ = Fn.bind(this, this.handleTextTrackAdd);
      this.handleTextTrackRemove_ = Fn.bind(this, this.handleTextTrackRemove);
      this.proxyNativeTextTracks_();
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if ((browser.TOUCH_ENABLED || browser.IS_IPHONE || browser.IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      this.setControls(true);
    }

    this.triggerReady();
  }

  /* HTML5 Support Testing ---------------------------------------------------- */

  /*
  * Element for testing browser HTML5 video capabilities
  *
  * @type {Element}
  * @constant
  * @private
  */

  /**
   * Dispose of html5 media element
   *
   * @method dispose
   */

  Html5.prototype.dispose = function dispose() {
    var _this2 = this;

    // Un-ProxyNativeTracks
    ['audio', 'video', 'text'].forEach(function (type) {
      var capitalType = _utilsToTitleCaseJs2['default'](type);
      var tl = _this2.el_[type + 'Tracks'];

      if (tl && tl.removeEventListener) {
        tl.removeEventListener('change', _this2['handle' + capitalType + 'TrackChange_']);
        tl.removeEventListener('addtrack', _this2['handle' + capitalType + 'TrackAdd_']);
        tl.removeEventListener('removetrack', _this2['handle' + capitalType + 'TrackRemove_']);
      }

      // Stop removing old text tracks
      if (tl) {
        _this2.off('loadstart', _this2['removeOld' + capitalType + 'Tracks_']);
      }
    });

    Html5.disposeMediaElement(this.el_);
    // tech will handle clearing of the emulated track list
    _Tech.prototype.dispose.call(this);
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  Html5.prototype.createEl = function createEl() {
    var el = this.options_.tag;

    // Check if this browser supports moving the element into the box.
    // On the iPhone video will break if you move the element,
    // So we have to create a brand new element.
    if (!el || this['movingMediaElementInDOM'] === false) {

      // If the original tag is still there, clone and remove it.
      if (el) {
        var clone = el.cloneNode(true);
        el.parentNode.insertBefore(clone, el);
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = _globalDocument2['default'].createElement('video');

        // determine if native controls should be used
        var tagAttributes = this.options_.tag && Dom.getElAttributes(this.options_.tag);
        var attributes = _utilsMergeOptionsJs2['default']({}, tagAttributes);
        if (!browser.TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }

        Dom.setElAttributes(el, _objectAssign2['default'](attributes, {
          id: this.options_.techId,
          'class': 'vjs-tech'
        }));
      }

      el.playerId = this.options_.playerId;
    }

    // Update specific tag settings, in case they were overridden
    var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted'];
    for (var i = settingsAttrs.length - 1; i >= 0; i--) {
      var attr = settingsAttrs[i];
      var overwriteAttrs = {};
      if (typeof this.options_[attr] !== 'undefined') {
        overwriteAttrs[attr] = this.options_[attr];
      }
      Dom.setElAttributes(el, overwriteAttrs);
    }

    return el;
    // jenniisawesome = true;
  };

  // If we're loading the playback object after it has started loading
  // or playing the video (often with autoplay on) then the loadstart event
  // has already fired and we need to fire it manually because many things
  // rely on it.

  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {
    var _this3 = this;

    if (el.networkState === 0 || el.networkState === 3) {
      // The video element hasn't started loading the source yet
      // or didn't find a source
      return;
    }

    if (el.readyState === 0) {
      var _ret = (function () {
        // NetworkState is set synchronously BUT loadstart is fired at the
        // end of the current stack, usually before setInterval(fn, 0).
        // So at this point we know loadstart may have already fired or is
        // about to fire, and either way the player hasn't seen it yet.
        // We don't want to fire loadstart prematurely here and cause a
        // double loadstart so we'll wait and see if it happens between now
        // and the next loop, and fire it if not.
        // HOWEVER, we also want to make sure it fires before loadedmetadata
        // which could also happen between now and the next loop, so we'll
        // watch for that also.
        var loadstartFired = false;
        var setLoadstartFired = function setLoadstartFired() {
          loadstartFired = true;
        };
        _this3.on('loadstart', setLoadstartFired);

        var triggerLoadstart = function triggerLoadstart() {
          // We did miss the original loadstart. Make sure the player
          // sees loadstart before loadedmetadata
          if (!loadstartFired) {
            this.trigger('loadstart');
          }
        };
        _this3.on('loadedmetadata', triggerLoadstart);

        _this3.ready(function () {
          this.off('loadstart', setLoadstartFired);
          this.off('loadedmetadata', triggerLoadstart);

          if (!loadstartFired) {
            // We did miss the original native loadstart. Fire it now.
            this.trigger('loadstart');
          }
        });

        return {
          v: undefined
        };
      })();

      if (typeof _ret === 'object') return _ret.v;
    }

    // From here on we know that loadstart already fired and we missed it.
    // The other readyState events aren't as much of a problem if we double
    // them, so not going to go to as much trouble as loadstart to prevent
    // that unless we find reason to.
    var eventsToTrigger = ['loadstart'];

    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
    eventsToTrigger.push('loadedmetadata');

    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
    if (el.readyState >= 2) {
      eventsToTrigger.push('loadeddata');
    }

    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
    if (el.readyState >= 3) {
      eventsToTrigger.push('canplay');
    }

    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
    if (el.readyState >= 4) {
      eventsToTrigger.push('canplaythrough');
    }

    // We still need to give the player time to add event listeners
    this.ready(function () {
      eventsToTrigger.forEach(function (type) {
        this.trigger(type);
      }, this);
    });
  };

  Html5.prototype.proxyNativeTextTracks_ = function proxyNativeTextTracks_() {
    var tt = this.el().textTracks;

    if (tt) {
      // Add tracks - if player is initialised after DOM loaded, textTracks
      // will not trigger addtrack
      for (var i = 0; i < tt.length; i++) {
        this.textTracks().addTrack_(tt[i]);
      }

      if (tt.addEventListener) {
        tt.addEventListener('change', this.handleTextTrackChange_);
        tt.addEventListener('addtrack', this.handleTextTrackAdd_);
        tt.addEventListener('removetrack', this.handleTextTrackRemove_);
      }

      // Remove (native) texttracks that are not used anymore
      this.on('loadstart', this.removeOldTextTracks_);
    }
  };

  Html5.prototype.handleTextTrackChange = function handleTextTrackChange(e) {
    var tt = this.textTracks();
    this.textTracks().trigger({
      type: 'change',
      target: tt,
      currentTarget: tt,
      srcElement: tt
    });
  };

  Html5.prototype.handleTextTrackAdd = function handleTextTrackAdd(e) {
    this.textTracks().addTrack_(e.track);
  };

  Html5.prototype.handleTextTrackRemove = function handleTextTrackRemove(e) {
    this.textTracks().removeTrack_(e.track);
  };

  Html5.prototype.handleVideoTrackChange_ = function handleVideoTrackChange_(e) {
    var vt = this.videoTracks();
    this.videoTracks().trigger({
      type: 'change',
      target: vt,
      currentTarget: vt,
      srcElement: vt
    });
  };

  Html5.prototype.handleVideoTrackAdd_ = function handleVideoTrackAdd_(e) {
    this.videoTracks().addTrack_(e.track);
  };

  Html5.prototype.handleVideoTrackRemove_ = function handleVideoTrackRemove_(e) {
    this.videoTracks().removeTrack_(e.track);
  };

  Html5.prototype.handleAudioTrackChange_ = function handleAudioTrackChange_(e) {
    var audioTrackList = this.audioTracks();
    this.audioTracks().trigger({
      type: 'change',
      target: audioTrackList,
      currentTarget: audioTrackList,
      srcElement: audioTrackList
    });
  };

  Html5.prototype.handleAudioTrackAdd_ = function handleAudioTrackAdd_(e) {
    this.audioTracks().addTrack_(e.track);
  };

  Html5.prototype.handleAudioTrackRemove_ = function handleAudioTrackRemove_(e) {
    this.audioTracks().removeTrack_(e.track);
  };

  /**
   * This is a helper function that is used in removeOldTextTracks_, removeOldAudioTracks_ and
   * removeOldVideoTracks_
   * @param {Track[]} techTracks Tracks for this tech
   * @param {Track[]} elTracks Tracks for the HTML5 video element
   * @private
   */

  Html5.prototype.removeOldTracks_ = function removeOldTracks_(techTracks, elTracks) {
    // This will loop over the techTracks and check if they are still used by the HTML5 video element
    // If not, they will be removed from the emulated list
    var removeTracks = [];
    if (!elTracks) {
      return;
    }

    for (var i = 0; i < techTracks.length; i++) {
      var techTrack = techTracks[i];

      var found = false;
      for (var j = 0; j < elTracks.length; j++) {
        if (elTracks[j] === techTrack) {
          found = true;
          break;
        }
      }

      if (!found) {
        removeTracks.push(techTrack);
      }
    }

    for (var i = 0; i < removeTracks.length; i++) {
      var _track = removeTracks[i];
      techTracks.removeTrack_(_track);
    }
  };

  Html5.prototype.removeOldTextTracks_ = function removeOldTextTracks_() {
    var techTracks = this.textTracks();
    var elTracks = this.el().textTracks;
    this.removeOldTracks_(techTracks, elTracks);
  };

  Html5.prototype.removeOldAudioTracks_ = function removeOldAudioTracks_() {
    var techTracks = this.audioTracks();
    var elTracks = this.el().audioTracks;
    this.removeOldTracks_(techTracks, elTracks);
  };

  Html5.prototype.removeOldVideoTracks_ = function removeOldVideoTracks_() {
    var techTracks = this.videoTracks();
    var elTracks = this.el().videoTracks;
    this.removeOldTracks_(techTracks, elTracks);
  };

  /**
   * Play for html5 tech
   *
   * @method play
   */

  Html5.prototype.play = function play() {
    var playPromise = this.el_.play();

    // Catch/silence error when a pause interrupts a play request
    // on browsers which return a promise
    if (playPromise !== undefined && typeof playPromise.then === 'function') {
      playPromise.then(null, function (e) {});
    }
  };

  /**
   * Pause for html5 tech
   *
   * @method pause
   */

  Html5.prototype.pause = function pause() {
    this.el_.pause();
  };

  /**
   * Paused for html5 tech
   *
   * @return {Boolean}
   * @method paused
   */

  Html5.prototype.paused = function paused() {
    return this.el_.paused;
  };

  /**
   * Get current time
   *
   * @return {Number}
   * @method currentTime
   */

  Html5.prototype.currentTime = function currentTime() {
    return this.el_.currentTime;
  };

  /**
   * Set current time
   *
   * @param {Number} seconds Current time of video
   * @method setCurrentTime
   */

  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {
    try {
      this.el_.currentTime = seconds;
    } catch (e) {
      _utilsLogJs2['default'](e, 'Video is not ready. (Video.js)');
      // this.warning(VideoJS.warnings.videoNotReady);
    }
  };

  /**
   * Get duration
   *
   * @return {Number}
   * @method duration
   */

  Html5.prototype.duration = function duration() {
    return this.el_.duration || 0;
  };

  /**
   * Get a TimeRange object that represents the intersection
   * of the time ranges for which the user agent has all
   * relevant media
   *
   * @return {TimeRangeObject}
   * @method buffered
   */

  Html5.prototype.buffered = function buffered() {
    return this.el_.buffered;
  };

  /**
   * Get volume level
   *
   * @return {Number}
   * @method volume
   */

  Html5.prototype.volume = function volume() {
    return this.el_.volume;
  };

  /**
   * Set volume level
   *
   * @param {Number} percentAsDecimal Volume percent as a decimal
   * @method setVolume
   */

  Html5.prototype.setVolume = function setVolume(percentAsDecimal) {
    this.el_.volume = percentAsDecimal;
  };

  /**
   * Get if muted
   *
   * @return {Boolean}
   * @method muted
   */

  Html5.prototype.muted = function muted() {
    return this.el_.muted;
  };

  /**
   * Set muted
   *
   * @param {Boolean} If player is to be muted or note
   * @method setMuted
   */

  Html5.prototype.setMuted = function setMuted(muted) {
    this.el_.muted = muted;
  };

  /**
   * Get player width
   *
   * @return {Number}
   * @method width
   */

  Html5.prototype.width = function width() {
    return this.el_.offsetWidth;
  };

  /**
   * Get player height
   *
   * @return {Number}
   * @method height
   */

  Html5.prototype.height = function height() {
    return this.el_.offsetHeight;
  };

  /**
   * Get if there is fullscreen support
   *
   * @return {Boolean}
   * @method supportsFullScreen
   */

  Html5.prototype.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === 'function') {
      var userAgent = _globalWindow2['default'].navigator.userAgent;
      // Seems to be broken in Chromium/Chrome && Safari in Leopard
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Request to enter fullscreen
   *
   * @method enterFullScreen
   */

  Html5.prototype.enterFullScreen = function enterFullScreen() {
    var video = this.el_;

    if ('webkitDisplayingFullscreen' in video) {
      this.one('webkitbeginfullscreen', function () {
        this.one('webkitendfullscreen', function () {
          this.trigger('fullscreenchange', { isFullscreen: false });
        });

        this.trigger('fullscreenchange', { isFullscreen: true });
      });
    }

    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      // attempt to prime the video element for programmatic access
      // this isn't necessary on the desktop but shouldn't hurt
      this.el_.play();

      // playing and pausing synchronously during the transition to fullscreen
      // can get iOS ~6.1 devices into a play/pause loop
      this.setTimeout(function () {
        video.pause();
        video.webkitEnterFullScreen();
      }, 0);
    } else {
      video.webkitEnterFullScreen();
    }
  };

  /**
   * Request to exit fullscreen
   *
   * @method exitFullScreen
   */

  Html5.prototype.exitFullScreen = function exitFullScreen() {
    this.el_.webkitExitFullScreen();
  };

  /**
   * Get/set video
   *
   * @param {Object=} src Source object
   * @return {Object}
   * @method src
   */

  Html5.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.el_.src;
    } else {
      // Setting src through `src` instead of `setSrc` will be deprecated
      this.setSrc(_src);
    }
  };

  /**
   * Set video
   *
   * @param {Object} src Source object
   * @deprecated
   * @method setSrc
   */

  Html5.prototype.setSrc = function setSrc(src) {
    this.el_.src = src;
  };

  /**
   * Load media into player
   *
   * @method load
   */

  Html5.prototype.load = function load() {
    this.el_.load();
  };

  /**
   * Reset the tech. Removes all sources and calls `load`.
   *
   * @method reset
   */

  Html5.prototype.reset = function reset() {
    Html5.resetMediaElement(this.el_);
  };

  /**
   * Get current source
   *
   * @return {Object}
   * @method currentSrc
   */

  Html5.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    } else {
      return this.el_.currentSrc;
    }
  };

  /**
   * Get poster
   *
   * @return {String}
   * @method poster
   */

  Html5.prototype.poster = function poster() {
    return this.el_.poster;
  };

  /**
   * Set poster
   *
   * @param {String} val URL to poster image
   * @method
   */

  Html5.prototype.setPoster = function setPoster(val) {
    this.el_.poster = val;
  };

  /**
   * Get preload attribute
   *
   * @return {String}
   * @method preload
   */

  Html5.prototype.preload = function preload() {
    return this.el_.preload;
  };

  /**
   * Set preload attribute
   *
   * @param {String} val Value for preload attribute
   * @method setPreload
   */

  Html5.prototype.setPreload = function setPreload(val) {
    this.el_.preload = val;
  };

  /**
   * Get autoplay attribute
   *
   * @return {String}
   * @method autoplay
   */

  Html5.prototype.autoplay = function autoplay() {
    return this.el_.autoplay;
  };

  /**
   * Set autoplay attribute
   *
   * @param {String} val Value for preload attribute
   * @method setAutoplay
   */

  Html5.prototype.setAutoplay = function setAutoplay(val) {
    this.el_.autoplay = val;
  };

  /**
   * Get controls attribute
   *
   * @return {String}
   * @method controls
   */

  Html5.prototype.controls = function controls() {
    return this.el_.controls;
  };

  /**
   * Set controls attribute
   *
   * @param {String} val Value for controls attribute
   * @method setControls
   */

  Html5.prototype.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };

  /**
   * Get loop attribute
   *
   * @return {String}
   * @method loop
   */

  Html5.prototype.loop = function loop() {
    return this.el_.loop;
  };

  /**
   * Set loop attribute
   *
   * @param {String} val Value for loop attribute
   * @method setLoop
   */

  Html5.prototype.setLoop = function setLoop(val) {
    this.el_.loop = val;
  };

  /**
   * Get error value
   *
   * @return {String}
   * @method error
   */

  Html5.prototype.error = function error() {
    return this.el_.error;
  };

  /**
   * Get whether or not the player is in the "seeking" state
   *
   * @return {Boolean}
   * @method seeking
   */

  Html5.prototype.seeking = function seeking() {
    return this.el_.seeking;
  };

  /**
   * Get a TimeRanges object that represents the
   * ranges of the media resource to which it is possible
   * for the user agent to seek.
   *
   * @return {TimeRangeObject}
   * @method seekable
   */

  Html5.prototype.seekable = function seekable() {
    return this.el_.seekable;
  };

  /**
   * Get if video ended
   *
   * @return {Boolean}
   * @method ended
   */

  Html5.prototype.ended = function ended() {
    return this.el_.ended;
  };

  /**
   * Get the value of the muted content attribute
   * This attribute has no dynamic effect, it only
   * controls the default state of the element
   *
   * @return {Boolean}
   * @method defaultMuted
   */

  Html5.prototype.defaultMuted = function defaultMuted() {
    return this.el_.defaultMuted;
  };

  /**
   * Get desired speed at which the media resource is to play
   *
   * @return {Number}
   * @method playbackRate
   */

  Html5.prototype.playbackRate = function playbackRate() {
    return this.el_.playbackRate;
  };

  /**
   * Returns a TimeRanges object that represents the ranges of the
   * media resource that the user agent has played.
   * @return {TimeRangeObject} the range of points on the media
   * timeline that has been reached through normal playback
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-played
   */

  Html5.prototype.played = function played() {
    return this.el_.played;
  };

  /**
   * Set desired speed at which the media resource is to play
   *
   * @param {Number} val Speed at which the media resource is to play
   * @method setPlaybackRate
   */

  Html5.prototype.setPlaybackRate = function setPlaybackRate(val) {
    this.el_.playbackRate = val;
  };

  /**
   * Get the current state of network activity for the element, from
   * the list below
   * NETWORK_EMPTY (numeric value 0)
   * NETWORK_IDLE (numeric value 1)
   * NETWORK_LOADING (numeric value 2)
   * NETWORK_NO_SOURCE (numeric value 3)
   *
   * @return {Number}
   * @method networkState
   */

  Html5.prototype.networkState = function networkState() {
    return this.el_.networkState;
  };

  /**
   * Get a value that expresses the current state of the element
   * with respect to rendering the current playback position, from
   * the codes in the list below
   * HAVE_NOTHING (numeric value 0)
   * HAVE_METADATA (numeric value 1)
   * HAVE_CURRENT_DATA (numeric value 2)
   * HAVE_FUTURE_DATA (numeric value 3)
   * HAVE_ENOUGH_DATA (numeric value 4)
   *
   * @return {Number}
   * @method readyState
   */

  Html5.prototype.readyState = function readyState() {
    return this.el_.readyState;
  };

  /**
   * Get width of video
   *
   * @return {Number}
   * @method videoWidth
   */

  Html5.prototype.videoWidth = function videoWidth() {
    return this.el_.videoWidth;
  };

  /**
   * Get height of video
   *
   * @return {Number}
   * @method videoHeight
   */

  Html5.prototype.videoHeight = function videoHeight() {
    return this.el_.videoHeight;
  };

  /**
   * Get text tracks
   *
   * @return {TextTrackList}
   * @method textTracks
   */

  Html5.prototype.textTracks = function textTracks() {
    return _Tech.prototype.textTracks.call(this);
  };

  /**
   * Creates and returns a text track object
   *
   * @param {String} kind Text track kind (subtitles, captions, descriptions
   *                                       chapters and metadata)
   * @param {String=} label Label to identify the text track
   * @param {String=} language Two letter language abbreviation
   * @return {TextTrackObject}
   * @method addTextTrack
   */

  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this['featuresNativeTextTracks']) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }

    return this.el_.addTextTrack(kind, label, language);
  };

  /**
   * Creates a remote text track object and returns a html track element
   *
   * @param {Object} options The object should contain values for
   * kind, language, label and src (location of the WebVTT file)
   * @return {HTMLTrackElement}
   * @method addRemoteTextTrack
   */

  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    if (!this['featuresNativeTextTracks']) {
      return _Tech.prototype.addRemoteTextTrack.call(this, options);
    }

    var htmlTrackElement = _globalDocument2['default'].createElement('track');

    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options['default']) {
      htmlTrackElement['default'] = options['default'];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }

    this.el().appendChild(htmlTrackElement);

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack_(htmlTrackElement.track);

    return htmlTrackElement;
  };

  /**
   * Remove remote text track from TextTrackList object
   *
   * @param {TextTrackObject} track Texttrack object to remove
   * @method removeRemoteTextTrack
   */

  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    if (!this['featuresNativeTextTracks']) {
      return _Tech.prototype.removeRemoteTextTrack.call(this, track);
    }

    var tracks = undefined,
        i = undefined;

    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack_(track);

    tracks = this.$$('track');

    i = tracks.length;
    while (i--) {
      if (track === tracks[i] || track === tracks[i].track) {
        this.el().removeChild(tracks[i]);
      }
    }
  };

  return Html5;
})(_techJs2['default']);

Html5.TEST_VID = _globalDocument2['default'].createElement('video');
var track = _globalDocument2['default'].createElement('track');
track.kind = 'captions';
track.srclang = 'en';
track.label = 'English';
Html5.TEST_VID.appendChild(track);

/*
 * Check if HTML5 video is supported by this browser/device
 *
 * @return {Boolean}
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID['volume'] = 0.5;
  } catch (e) {
    return false;
  }

  return !!Html5.TEST_VID.canPlayType;
};

// Add Source Handler pattern functions to this tech
_techJs2['default'].withSourceHandlers(Html5);

/*
 * The default native source handler.
 * This simply passes the source to the video element. Nothing fancy.
 *
 * @param  {Object} source   The source object
 * @param  {Html5} tech  The instance of the HTML5 tech
 */
Html5.nativeSourceHandler = {};

/*
 * Check if the video element can play the given videotype
 *
 * @param  {String} type    The mimetype to check
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canPlayType = function (type) {
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return '';
  }
};

/*
 * Check if the video element can handle the source natively
 *
 * @param  {Object} source  The source object
 * @param  {Object} options The options passed to the tech
 * @return {String}         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canHandleSource = function (source, options) {
  var match, ext;

  // If a type was provided we should rely on that
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);
  } else if (source.src) {
    // If no type, fall back to checking 'video/[EXTENSION]'
    ext = Url.getFileExtension(source.src);

    return Html5.nativeSourceHandler.canPlayType('video/' + ext);
  }

  return '';
};

/*
 * Pass the source to the video element
 * Adaptive source handlers will have more complicated workflows before passing
 * video data to the video element
 *
 * @param  {Object} source   The source object
 * @param  {Html5}  tech     The instance of the Html5 tech
 * @param  {Object} options  The options to pass to the source
 */
Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/*
* Clean up the source handler when disposing the player or switching sources..
* (no cleanup is needed when supporting the format natively)
*/
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

/*
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 *
 * @return {Boolean}
 */
Html5.canControlVolume = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var volume = Html5.TEST_VID.volume;
    Html5.TEST_VID.volume = volume / 2 + 0.1;
    return volume !== Html5.TEST_VID.volume;
  } catch (e) {
    return false;
  }
};

/*
 * Check if playbackRate is supported in this browser/device.
 *
 * @return {Boolean}
 */
Html5.canControlPlaybackRate = function () {
  // Playback rate API is implemented in Android Chrome, but doesn't do anything
  // https://github.com/videojs/video.js/issues/3180
  if (browser.IS_ANDROID && browser.IS_CHROME) {
    return false;
  }
  // IE will error if Windows Media Player not installed #3315
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;
    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};

/*
 * Check to see if native text tracks are supported by this browser/device
 *
 * @return {Boolean}
 */
Html5.supportsNativeTextTracks = function () {
  var supportsTextTracks;

  // Figure out native text track support
  // If mode is a number, we cannot change it because it'll disappear from view.
  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
  // Firefox isn't playing nice either with modifying the mode
  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
  supportsTextTracks = !!Html5.TEST_VID.textTracks;
  if (supportsTextTracks && Html5.TEST_VID.textTracks.length > 0) {
    supportsTextTracks = typeof Html5.TEST_VID.textTracks[0]['mode'] !== 'number';
  }
  if (supportsTextTracks && browser.IS_FIREFOX) {
    supportsTextTracks = false;
  }
  if (supportsTextTracks && !('onremovetrack' in Html5.TEST_VID.textTracks)) {
    supportsTextTracks = false;
  }

  return supportsTextTracks;
};

/*
 * Check to see if native video tracks are supported by this browser/device
 *
 * @return {Boolean}
 */
Html5.supportsNativeVideoTracks = function () {
  var supportsVideoTracks = !!Html5.TEST_VID.videoTracks;
  return supportsVideoTracks;
};

/*
 * Check to see if native audio tracks are supported by this browser/device
 *
 * @return {Boolean}
 */
Html5.supportsNativeAudioTracks = function () {
  var supportsAudioTracks = !!Html5.TEST_VID.audioTracks;
  return supportsAudioTracks;
};

/**
 * An array of events available on the Html5 tech.
 *
 * @private
 * @type {Array}
 */
Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'volumechange'];

/*
 * Set the tech's volume control support status
 *
 * @type {Boolean}
 */
Html5.prototype['featuresVolumeControl'] = Html5.canControlVolume();

/*
 * Set the tech's playbackRate support status
 *
 * @type {Boolean}
 */
Html5.prototype['featuresPlaybackRate'] = Html5.canControlPlaybackRate();

/*
 * Set the tech's status on moving the video element.
 * In iOS, if you move a video element in the DOM, it breaks video playback.
 *
 * @type {Boolean}
 */
Html5.prototype['movingMediaElementInDOM'] = !browser.IS_IOS;

/*
 * Set the the tech's fullscreen resize support status.
 * HTML video is able to automatically resize when going to fullscreen.
 * (No longer appears to be used. Can probably be removed.)
 */
Html5.prototype['featuresFullscreenResize'] = true;

/*
 * Set the tech's progress event support status
 * (this disables the manual progress events of the Tech)
 */
Html5.prototype['featuresProgressEvents'] = true;

/*
 * Sets the tech's status on native text track support
 *
 * @type {Boolean}
 */
Html5.prototype['featuresNativeTextTracks'] = Html5.supportsNativeTextTracks();

/**
 * Sets the tech's status on native text track support
 *
 * @type {Boolean}
 */
Html5.prototype['featuresNativeVideoTracks'] = Html5.supportsNativeVideoTracks();

/**
 * Sets the tech's status on native audio track support
 *
 * @type {Boolean}
 */
Html5.prototype['featuresNativeAudioTracks'] = Html5.supportsNativeAudioTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = undefined;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {
  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (browser.ANDROID_VERSION >= 4.0) {
    if (!canPlayType) {
      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;
    }

    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }

  // Override Android 2.2 and less canPlayType method which is broken
  if (browser.IS_OLD_ANDROID) {
    if (!canPlayType) {
      canPlayType = Html5.TEST_VID.constructor.prototype.canPlayType;
    }

    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;
  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  canPlayType = null;
  return r;
};

// by default, patch the video element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};

Html5.resetMediaElement = function (el) {
  if (!el) {
    return;
  }

  var sources = el.querySelectorAll('source');
  var i = sources.length;
  while (i--) {
    el.removeChild(sources[i]);
  }

  // remove any src reference.
  // not setting `src=''` because that throws an error
  el.removeAttribute('src');

  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {}
    })();
  }
};

_component2['default'].registerComponent('Html5', Html5);
_techJs2['default'].registerTech('Html5', Html5);
exports['default'] = Html5;
module.exports = exports['default'];

},{"../../../src/js/tracks/text-track.js":134,"../component":67,"../utils/browser.js":140,"../utils/dom.js":142,"../utils/fn.js":144,"../utils/log.js":147,"../utils/merge-options.js":148,"../utils/to-title-case.js":151,"../utils/url.js":152,"./tech.js":124,"global/document":1,"global/window":2,"object.assign":45,"tsml":55}],123:[function(_dereq_,module,exports){
/**
 * @file loader.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _componentJs = _dereq_('../component.js');

var _componentJs2 = _interopRequireDefault(_componentJs);

var _techJs = _dereq_('./tech.js');

var _techJs2 = _interopRequireDefault(_techJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _utilsToTitleCaseJs = _dereq_('../utils/to-title-case.js');

var _utilsToTitleCaseJs2 = _interopRequireDefault(_utilsToTitleCaseJs);

/**
 * The Media Loader is the component that decides which playback technology to load
 * when the player is initialized.
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends Component
 * @class MediaLoader
 */

var MediaLoader = (function (_Component) {
  _inherits(MediaLoader, _Component);

  function MediaLoader(player, options, ready) {
    _classCallCheck(this, MediaLoader);

    _Component.call(this, player, options, ready);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.

    if (!options.playerOptions['sources'] || options.playerOptions['sources'].length === 0) {
      for (var i = 0, j = options.playerOptions['techOrder']; i < j.length; i++) {
        var techName = _utilsToTitleCaseJs2['default'](j[i]);
        var tech = _techJs2['default'].getTech(techName);
        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!techName) {
          tech = _componentJs2['default'].getComponent(techName);
        }

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      // // Loop through playback technologies (HTML5, Flash) and check for support.
      // // Then load the best source.
      // // A few assumptions here:
      // //   All playback technologies respect preload false.
      player.src(options.playerOptions['sources']);
    }
  }

  return MediaLoader;
})(_componentJs2['default']);

_componentJs2['default'].registerComponent('MediaLoader', MediaLoader);
exports['default'] = MediaLoader;
module.exports = exports['default'];

},{"../component.js":67,"../utils/to-title-case.js":151,"./tech.js":124,"global/window":2}],124:[function(_dereq_,module,exports){
/**
 * @file tech.js
 * Media Technology Controller - Base class for media playback
 * technology controllers like Flash and HTML5
 */

'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _tracksHtmlTrackElement = _dereq_('../tracks/html-track-element');

var _tracksHtmlTrackElement2 = _interopRequireDefault(_tracksHtmlTrackElement);

var _tracksHtmlTrackElementList = _dereq_('../tracks/html-track-element-list');

var _tracksHtmlTrackElementList2 = _interopRequireDefault(_tracksHtmlTrackElementList);

var _utilsMergeOptionsJs = _dereq_('../utils/merge-options.js');

var _utilsMergeOptionsJs2 = _interopRequireDefault(_utilsMergeOptionsJs);

var _tracksTextTrack = _dereq_('../tracks/text-track');

var _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);

var _tracksTextTrackList = _dereq_('../tracks/text-track-list');

var _tracksTextTrackList2 = _interopRequireDefault(_tracksTextTrackList);

var _tracksVideoTrack = _dereq_('../tracks/video-track');

var _tracksVideoTrack2 = _interopRequireDefault(_tracksVideoTrack);

var _tracksVideoTrackList = _dereq_('../tracks/video-track-list');

var _tracksVideoTrackList2 = _interopRequireDefault(_tracksVideoTrackList);

var _tracksAudioTrackList = _dereq_('../tracks/audio-track-list');

var _tracksAudioTrackList2 = _interopRequireDefault(_tracksAudioTrackList);

var _tracksAudioTrack = _dereq_('../tracks/audio-track');

var _tracksAudioTrack2 = _interopRequireDefault(_tracksAudioTrack);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsLogJs = _dereq_('../utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _utilsTimeRangesJs = _dereq_('../utils/time-ranges.js');

var _utilsBufferJs = _dereq_('../utils/buffer.js');

var _mediaErrorJs = _dereq_('../media-error.js');

var _mediaErrorJs2 = _interopRequireDefault(_mediaErrorJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Base class for media (HTML5 Video, Flash) controllers
 *
 * @param {Object=} options Options object
 * @param {Function=} ready Ready callback function
 * @extends Component
 * @class Tech
 */

var Tech = (function (_Component) {
  _inherits(Tech, _Component);

  function Tech() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var ready = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

    _classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;
    _Component.call(this, null, options, ready);

    // keep track of whether the current source has played at all to
    // implement a very limited played()
    this.hasStarted_ = false;
    this.on('playing', function () {
      this.hasStarted_ = true;
    });
    this.on('loadstart', function () {
      this.hasStarted_ = false;
    });

    this.textTracks_ = options.textTracks;
    this.videoTracks_ = options.videoTracks;
    this.audioTracks_ = options.audioTracks;

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!this.featuresProgressEvents) {
      this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!this.featuresTimeupdateEvents) {
      this.manualTimeUpdatesOn();
    }

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      this.featuresNativeTextTracks = false;
    }

    if (!this.featuresNativeTextTracks) {
      this.on('ready', this.emulateTextTracks);
    }

    this.initTextTrackListeners();
    this.initTrackListeners();

    // Turn on component tap events
    this.emitTapEvents();
  }

  /**
   * List of associated text tracks
   *
   * @type {TextTrackList}
   * @private
   */

  /* Fallbacks for unsupported event types
  ================================================================================ */
  // Manually trigger progress events based on changes to the buffered amount
  // Many flash players and older HTML5 browsers don't send progress or progress-like events
  /**
   * Turn on progress events
   *
   * @method manualProgressOn
   */

  Tech.prototype.manualProgressOn = function manualProgressOn() {
    this.on('durationchange', this.onDurationChange);

    this.manualProgress = true;

    // Trigger progress watching when a source begins loading
    this.one('ready', this.trackProgress);
  };

  /**
   * Turn off progress events
   *
   * @method manualProgressOff
   */

  Tech.prototype.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();

    this.off('durationchange', this.onDurationChange);
  };

  /**
   * Track progress
   *
   * @method trackProgress
   */

  Tech.prototype.trackProgress = function trackProgress() {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(Fn.bind(this, function () {
      // Don't trigger unless buffered amount is greater than last time

      var numBufferedPercent = this.bufferedPercent();

      if (this.bufferedPercent_ !== numBufferedPercent) {
        this.trigger('progress');
      }

      this.bufferedPercent_ = numBufferedPercent;

      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };

  /**
   * Update duration
   *
   * @method onDurationChange
   */

  Tech.prototype.onDurationChange = function onDurationChange() {
    this.duration_ = this.duration();
  };

  /**
   * Create and get TimeRange object for buffering
   *
   * @return {TimeRangeObject}
   * @method buffered
   */

  Tech.prototype.buffered = function buffered() {
    return _utilsTimeRangesJs.createTimeRange(0, 0);
  };

  /**
   * Get buffered percent
   *
   * @return {Number}
   * @method bufferedPercent
   */

  Tech.prototype.bufferedPercent = function bufferedPercent() {
    return _utilsBufferJs.bufferedPercent(this.buffered(), this.duration_);
  };

  /**
   * Stops tracking progress by clearing progress interval
   *
   * @method stopTrackingProgress
   */

  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };

  /*! Time Tracking -------------------------------------------------------------- */
  /**
   * Set event listeners for on play and pause and tracking current time
   *
   * @method manualTimeUpdatesOn
   */

  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;

    this.on('play', this.trackCurrentTime);
    this.on('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Remove event listeners for on play and pause and tracking current time
   *
   * @method manualTimeUpdatesOff
   */

  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off('play', this.trackCurrentTime);
    this.off('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Tracks current time
   *
   * @method trackCurrentTime
   */

  Tech.prototype.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function () {
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
  };

  /**
   * Turn off play progress tracking (when paused or dragging)
   *
   * @method stopTrackingCurrentTime
   */

  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);

    // #1002 - if the video ends right before the next timeupdate would happen,
    // the progress bar won't make it all the way to the end
    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
  };

  /**
   * Turn off any manual progress or timeupdate tracking
   *
   * @method dispose
   */

  Tech.prototype.dispose = function dispose() {

    // clear out all tracks because we can't reuse them between techs
    this.clearTracks(['audio', 'video', 'text']);

    // Turn off any manual progress or timeupdate tracking
    if (this.manualProgress) {
      this.manualProgressOff();
    }

    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * clear out a track list, or multiple track lists
   *
   * Note: Techs without source handlers should call this between
   * sources for video & audio tracks, as usually you don't want
   * to use them between tracks and we have no automatic way to do
   * it for you
   *
   * @method clearTracks
   * @param {Array|String} types type(s) of track lists to empty
   */

  Tech.prototype.clearTracks = function clearTracks(types) {
    var _this = this;

    types = [].concat(types);
    // clear out all tracks because we can't reuse them between techs
    types.forEach(function (type) {
      var list = _this[type + 'Tracks']() || [];
      var i = list.length;
      while (i--) {
        var track = list[i];
        if (type === 'text') {
          _this.removeRemoteTextTrack(track);
        }
        list.removeTrack_(track);
      }
    });
  };

  /**
   * Reset the tech. Removes all sources and resets readyState.
   *
   * @method reset
   */

  Tech.prototype.reset = function reset() {};

  /**
   * When invoked without an argument, returns a MediaError object
   * representing the current error state of the player or null if
   * there is no error. When invoked with an argument, set the current
   * error state of the player.
   * @param {MediaError=} err    Optional an error object
   * @return {MediaError}        the current error object or null
   * @method error
   */

  Tech.prototype.error = function error(err) {
    if (err !== undefined) {
      this.error_ = new _mediaErrorJs2['default'](err);
      this.trigger('error');
    }
    return this.error_;
  };

  /**
   * Return the time ranges that have been played through for the
   * current source. This implementation is incomplete. It does not
   * track the played time ranges, only whether the source has played
   * at all or not.
   * @return {TimeRangeObject} a single time range if this video has
   * played or an empty set of ranges if not.
   * @method played
   */

  Tech.prototype.played = function played() {
    if (this.hasStarted_) {
      return _utilsTimeRangesJs.createTimeRange(0, 0);
    }
    return _utilsTimeRangesJs.createTimeRange();
  };

  /**
   * Set current time
   *
   * @method setCurrentTime
   */

  Tech.prototype.setCurrentTime = function setCurrentTime() {
    // improve the accuracy of manual timeupdates
    if (this.manualTimeUpdates) {
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  };

  /**
   * Initialize texttrack listeners
   *
   * @method initTextTrackListeners
   */

  Tech.prototype.initTextTrackListeners = function initTextTrackListeners() {
    var textTrackListChanges = Fn.bind(this, function () {
      this.trigger('texttrackchange');
    });

    var tracks = this.textTracks();

    if (!tracks) return;

    tracks.addEventListener('removetrack', textTrackListChanges);
    tracks.addEventListener('addtrack', textTrackListChanges);

    this.on('dispose', Fn.bind(this, function () {
      tracks.removeEventListener('removetrack', textTrackListChanges);
      tracks.removeEventListener('addtrack', textTrackListChanges);
    }));
  };

  /**
   * Initialize audio and video track listeners
   *
   * @method initTrackListeners
   */

  Tech.prototype.initTrackListeners = function initTrackListeners() {
    var _this2 = this;

    var trackTypes = ['video', 'audio'];

    trackTypes.forEach(function (type) {
      var trackListChanges = function trackListChanges() {
        _this2.trigger(type + 'trackchange');
      };

      var tracks = _this2[type + 'Tracks']();

      tracks.addEventListener('removetrack', trackListChanges);
      tracks.addEventListener('addtrack', trackListChanges);

      _this2.on('dispose', function () {
        tracks.removeEventListener('removetrack', trackListChanges);
        tracks.removeEventListener('addtrack', trackListChanges);
      });
    });
  };

  /**
   * Emulate texttracks
   *
   * @method emulateTextTracks
   */

  Tech.prototype.emulateTextTracks = function emulateTextTracks() {
    var _this3 = this;

    var tracks = this.textTracks();
    if (!tracks) {
      return;
    }

    if (!_globalWindow2['default']['WebVTT'] && this.el().parentNode != null) {
      (function () {
        var script = _globalDocument2['default'].createElement('script');
        script.src = _this3.options_['vtt.js'] || 'https://cdn.rawgit.com/gkatsev/vtt.js/vjs-v0.12.1/dist/vtt.min.js';
        script.onload = function () {
          _this3.trigger('vttjsloaded');
        };
        script.onerror = function () {
          _this3.trigger('vttjserror');
        };
        _this3.on('dispose', function () {
          script.onload = null;
          script.onerror = null;
        });
        // but have not loaded yet and we set it to true before the inject so that
        // we don't overwrite the injected window.WebVTT if it loads right away
        _globalWindow2['default']['WebVTT'] = true;
        _this3.el().parentNode.appendChild(script);
      })();
    }

    var updateDisplay = function updateDisplay() {
      return _this3.trigger('texttrackchange');
    };
    var textTracksChanges = function textTracksChanges() {
      updateDisplay();

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener('cuechange', updateDisplay);
        if (track.mode === 'showing') {
          track.addEventListener('cuechange', updateDisplay);
        }
      }
    };

    textTracksChanges();
    tracks.addEventListener('change', textTracksChanges);

    this.on('dispose', function () {
      tracks.removeEventListener('change', textTracksChanges);
    });
  };

  /**
   * Get videotracks
   *
   * @returns {VideoTrackList}
   * @method videoTracks
   */

  Tech.prototype.videoTracks = function videoTracks() {
    this.videoTracks_ = this.videoTracks_ || new _tracksVideoTrackList2['default']();
    return this.videoTracks_;
  };

  /**
   * Get audiotracklist
   *
   * @returns {AudioTrackList}
   * @method audioTracks
   */

  Tech.prototype.audioTracks = function audioTracks() {
    this.audioTracks_ = this.audioTracks_ || new _tracksAudioTrackList2['default']();
    return this.audioTracks_;
  };

  /*
   * Provide default methods for text tracks.
   *
   * Html5 tech overrides these.
   */

  /**
   * Get texttracks
   *
   * @returns {TextTrackList}
   * @method textTracks
   */

  Tech.prototype.textTracks = function textTracks() {
    this.textTracks_ = this.textTracks_ || new _tracksTextTrackList2['default']();
    return this.textTracks_;
  };

  /**
   * Get remote texttracks
   *
   * @returns {TextTrackList}
   * @method remoteTextTracks
   */

  Tech.prototype.remoteTextTracks = function remoteTextTracks() {
    this.remoteTextTracks_ = this.remoteTextTracks_ || new _tracksTextTrackList2['default']();
    return this.remoteTextTracks_;
  };

  /**
   * Get remote htmltrackelements
   *
   * @returns {HTMLTrackElementList}
   * @method remoteTextTrackEls
   */

  Tech.prototype.remoteTextTrackEls = function remoteTextTrackEls() {
    this.remoteTextTrackEls_ = this.remoteTextTrackEls_ || new _tracksHtmlTrackElementList2['default']();
    return this.remoteTextTrackEls_;
  };

  /**
   * Creates and returns a remote text track object
   *
   * @param {String} kind Text track kind (subtitles, captions, descriptions
   *                                       chapters and metadata)
   * @param {String=} label Label to identify the text track
   * @param {String=} language Two letter language abbreviation
   * @return {TextTrackObject}
   * @method addTextTrack
   */

  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error('TextTrack kind is required but was not provided');
    }

    return createTrackHelper(this, kind, label, language);
  };

  /**
   * Creates a remote text track object and returns a emulated html track element
   *
   * @param {Object} options The object should contain values for
   * kind, language, label and src (location of the WebVTT file)
   * @return {HTMLTrackElement}
   * @method addRemoteTextTrack
   */

  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack(options) {
    var track = _utilsMergeOptionsJs2['default'](options, {
      tech: this
    });

    var htmlTrackElement = new _tracksHtmlTrackElement2['default'](track);

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack_(htmlTrackElement.track);

    // must come after remoteTextTracks()
    this.textTracks().addTrack_(htmlTrackElement.track);

    return htmlTrackElement;
  };

  /**
   * Remove remote texttrack
   *
   * @param {TextTrackObject} track Texttrack to remove
   * @method removeRemoteTextTrack
   */

  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    this.textTracks().removeTrack_(track);

    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack_(track);
  };

  /**
   * Provide a default setPoster method for techs
   * Poster support for techs should be optional, so we don't want techs to
   * break if they don't have a way to set a poster.
   *
   * @method setPoster
   */

  Tech.prototype.setPoster = function setPoster() {};

  /*
   * Check if the tech can support the given type
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {String} type    The mimetype to check
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */

  Tech.prototype.canPlayType = function canPlayType() {
    return '';
  };

  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component An item to check
   * @return {Boolean}         Whether it is a tech or not
   */

  Tech.isTech = function isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  };

  /**
   * Registers a Tech
   *
   * @param {String} name Name of the Tech to register
   * @param {Object} tech The tech to register
   * @static
   * @method registerComponent
   */

  Tech.registerTech = function registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }

    if (!Tech.isTech(tech)) {
      throw new Error('Tech ' + name + ' must be a Tech');
    }

    Tech.techs_[name] = tech;
    return tech;
  };

  /**
   * Gets a component by name
   *
   * @param {String} name Name of the component to get
   * @return {Component}
   * @static
   * @method getComponent
   */

  Tech.getTech = function getTech(name) {
    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }

    if (_globalWindow2['default'] && _globalWindow2['default'].videojs && _globalWindow2['default'].videojs[name]) {
      _utilsLogJs2['default'].warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');
      return _globalWindow2['default'].videojs[name];
    }
  };

  return Tech;
})(_component2['default']);

Tech.prototype.textTracks_;

/**
 * List of associated audio tracks
 *
 * @type {AudioTrackList}
 * @private
 */
Tech.prototype.audioTracks_;

/**
 * List of associated video tracks
 *
 * @type {VideoTrackList}
 * @private
 */
Tech.prototype.videoTracks_;

var createTrackHelper = function createTrackHelper(self, kind, label, language) {
  var options = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new _tracksTextTrack2['default'](options);
  tracks.addTrack_(track);

  return track;
};

Tech.prototype.featuresVolumeControl = true;

// Resizing plugins using request fullscreen reloads the plugin
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;

// Optional events that we can manually mimic with timers
// currently not triggered by video-js-swf
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresTimeupdateEvents = false;

Tech.prototype.featuresNativeTextTracks = false;

/*
 * A functional mixin for techs that want to use the Source Handler pattern.
 *
 * ##### EXAMPLE:
 *
 *   Tech.withSourceHandlers.call(MyTech);
 *
 */
Tech.withSourceHandlers = function (_Tech) {
  /*
   * Register a source handler
   * Source handlers are scripts for handling specific formats.
   * The source handler pattern is used for adaptive formats (HLS, DASH) that
   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
   * @param  {Function} handler  The source handler
   * @param  {Boolean}  first    Register it before any existing handlers
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /*
   * Check if the tech can support the given type
   * @param  {String} type    The mimetype to check
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlayType = function (type) {
    var handlers = _Tech.sourceHandlers || [];
    var can = undefined;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);

      if (can) {
        return can;
      }
    }

    return '';
  };

  /*
   * Return the first source handler that supports the source
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   * @param  {Object} source  The source object
   * @param  {Object} options The options passed to the tech
   * @returns {Object}       The first source handler that supports the source
   * @returns {null}         Null if no source handler is found
   */
  _Tech.selectSourceHandler = function (source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can = undefined;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /*
   * Check if the tech can support the given source
   * @param  {Object} srcObj  The source object
   * @param  {Object} options The options passed to the tech
   * @return {String}         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlaySource = function (srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);

    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }

    return '';
  };

  /*
   * When using a source handler, prefer its implementation of
   * any function normally provided by the tech.
   */
  var deferrable = ['seekable', 'duration'];

  deferrable.forEach(function (fnName) {
    var originalFn = this[fnName];

    if (typeof originalFn !== 'function') {
      return;
    }

    this[fnName] = function () {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);

  /*
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   * @param {Object} source  A source object with src and type keys
   * @return {Tech} self
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        _utilsLogJs2['default'].error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    // if we have a source and get another one
    // then we are loading something new
    // than clear all of our current tracks
    if (this.currentSource_) {
      this.clearTracks(['audio', 'video']);

      this.currentSource_ = null;
    }

    if (sh !== _Tech.nativeSourceHandler) {

      this.currentSource_ = source;

      // Catch if someone replaced the src without calling setSource.
      // If they do, set currentSource_ to null and dispose our source handler.
      this.off(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);
      this.off(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);
      this.one(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);
    }

    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.on('dispose', this.disposeSourceHandler);

    return this;
  };

  // On the first loadstart after setSource
  _Tech.prototype.firstLoadStartListener_ = function () {
    this.one(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);
  };

  // On successive loadstarts when setSource has not been called again
  _Tech.prototype.successiveLoadStartListener_ = function () {
    this.currentSource_ = null;
    this.disposeSourceHandler();
    this.one(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);
  };

  /*
   * Clean up any existing source handler
   */
  _Tech.prototype.disposeSourceHandler = function () {
    if (this.sourceHandler_ && this.sourceHandler_.dispose) {
      this.off(this.el_, 'loadstart', _Tech.prototype.firstLoadStartListener_);
      this.off(this.el_, 'loadstart', _Tech.prototype.successiveLoadStartListener_);
      this.sourceHandler_.dispose();
      this.sourceHandler_ = null;
    }
  };
};

_component2['default'].registerComponent('Tech', Tech);
// Old name for Tech
_component2['default'].registerComponent('MediaTechController', Tech);
Tech.registerTech('Tech', Tech);
exports['default'] = Tech;
module.exports = exports['default'];

},{"../component":67,"../media-error.js":108,"../tracks/audio-track":126,"../tracks/audio-track-list":125,"../tracks/html-track-element":128,"../tracks/html-track-element-list":127,"../tracks/text-track":134,"../tracks/text-track-list":132,"../tracks/video-track":139,"../tracks/video-track-list":138,"../utils/buffer.js":141,"../utils/fn.js":144,"../utils/log.js":147,"../utils/merge-options.js":148,"../utils/time-ranges.js":150,"global/document":1,"global/window":2}],125:[function(_dereq_,module,exports){
/**
 * @file audio-track-list.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackList = _dereq_('./track-list');

var _trackList2 = _interopRequireDefault(_trackList);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * anywhere we call this function we diverge from the spec
 * as we only support one enabled audiotrack at a time
 *
 * @param {Array|AudioTrackList} list list to work on
 * @param {AudioTrack} track the track to skip
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].enabled = false;
  }
};
/**
 * A list of possible audio tracks. All functionality is in the
 * base class Tracklist and the spec for AudioTrackList is located at:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
 *
 * interface AudioTrackList : EventTarget {
 *   readonly attribute unsigned long length;
 *   getter AudioTrack (unsigned long index);
 *   AudioTrack? getTrackById(DOMString id);
 *
 *   attribute EventHandler onchange;
 *   attribute EventHandler onaddtrack;
 *   attribute EventHandler onremovetrack;
 * };
 *
 * @param {AudioTrack[]} tracks a list of audio tracks to instantiate the list with
 * @extends TrackList
 * @class AudioTrackList
 */

var AudioTrackList = (function (_TrackList) {
  _inherits(AudioTrackList, _TrackList);

  function AudioTrackList() {
    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    _classCallCheck(this, AudioTrackList);

    var list = undefined;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (browser.IS_IE8) {
      list = _globalDocument2['default'].createElement('custom');
      for (var prop in _trackList2['default'].prototype) {
        if (prop !== 'constructor') {
          list[prop] = _trackList2['default'].prototype[prop];
        }
      }
      for (var prop in AudioTrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = AudioTrackList.prototype[prop];
        }
      }
    }

    list = _TrackList.call(this, tracks, list);
    list.changing_ = false;

    return list;
  }

  AudioTrackList.prototype.addTrack_ = function addTrack_(track) {
    var _this = this;

    if (track.enabled) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack_.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    track.addEventListener('enabledchange', function () {
      // when we are disabling other tracks (since we don't support
      // more than one track at a time) we will set changing_
      // to true so that we don't trigger additional change events
      if (_this.changing_) {
        return;
      }
      _this.changing_ = true;
      disableOthers(_this, track);
      _this.changing_ = false;
      _this.trigger('change');
    });
  };

  AudioTrackList.prototype.addTrack = function addTrack(track) {
    this.addTrack_(track);
  };

  AudioTrackList.prototype.removeTrack = function removeTrack(track) {
    _TrackList.prototype.removeTrack_.call(this, track);
  };

  return AudioTrackList;
})(_trackList2['default']);

exports['default'] = AudioTrackList;
module.exports = exports['default'];

},{"../utils/browser.js":140,"./track-list":136,"global/document":1}],126:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackEnums = _dereq_('./track-enums');

var _track = _dereq_('./track');

var _track2 = _interopRequireDefault(_track);

var _utilsMergeOptions = _dereq_('../utils/merge-options');

var _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

/**
 * A single audio text track as defined in:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack
 *
 * interface AudioTrack {
 *   readonly attribute DOMString id;
 *   readonly attribute DOMString kind;
 *   readonly attribute DOMString label;
 *   readonly attribute DOMString language;
 *   attribute boolean enabled;
 * };
 *
 * @param {Object=} options Object of option names and values
 * @class AudioTrack
 */

var AudioTrack = (function (_Track) {
  _inherits(AudioTrack, _Track);

  function AudioTrack() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, AudioTrack);

    var settings = _utilsMergeOptions2['default'](options, {
      kind: _trackEnums.AudioTrackKind[options.kind] || ''
    });
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = _Track.call(this, settings);
    var enabled = false;

    if (browser.IS_IE8) {
      for (var prop in AudioTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = AudioTrack.prototype[prop];
        }
      }
    }

    Object.defineProperty(track, 'enabled', {
      get: function get() {
        return enabled;
      },
      set: function set(newEnabled) {
        // an invalid or unchanged value
        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;
        this.trigger('enabledchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.enabled) {
      track.enabled = settings.enabled;
    }
    track.loaded_ = true;

    return track;
  }

  return AudioTrack;
})(_track2['default']);

exports['default'] = AudioTrack;
module.exports = exports['default'];

},{"../utils/browser.js":140,"../utils/merge-options":148,"./track":137,"./track-enums":135}],127:[function(_dereq_,module,exports){
/**
 * @file html-track-element-list.js
 */

'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var HtmlTrackElementList = (function () {
  function HtmlTrackElementList() {
    var trackElements = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    _classCallCheck(this, HtmlTrackElementList);

    var list = this;

    if (browser.IS_IE8) {
      list = _globalDocument2['default'].createElement('custom');

      for (var prop in HtmlTrackElementList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = HtmlTrackElementList.prototype[prop];
        }
      }
    }

    list.trackElements_ = [];

    Object.defineProperty(list, 'length', {
      get: function get() {
        return this.trackElements_.length;
      }
    });

    for (var i = 0, _length = trackElements.length; i < _length; i++) {
      list.addTrackElement_(trackElements[i]);
    }

    if (browser.IS_IE8) {
      return list;
    }
  }

  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
    this.trackElements_.push(trackElement);
  };

  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_ = undefined;

    for (var i = 0, _length2 = this.trackElements_.length; i < _length2; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];

        break;
      }
    }

    return trackElement_;
  };

  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, _length3 = this.trackElements_.length; i < _length3; i++) {
      if (trackElement === this.trackElements_[i]) {
        this.trackElements_.splice(i, 1);

        break;
      }
    }
  };

  return HtmlTrackElementList;
})();

exports['default'] = HtmlTrackElementList;
module.exports = exports['default'];

},{"../utils/browser.js":140,"global/document":1}],128:[function(_dereq_,module,exports){
/**
 * @file html-track-element.js
 */

'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _eventTarget = _dereq_('../event-target');

var _eventTarget2 = _interopRequireDefault(_eventTarget);

var _tracksTextTrack = _dereq_('../tracks/text-track');

var _tracksTextTrack2 = _interopRequireDefault(_tracksTextTrack);

var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;

/**
 * https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement
 *
 * interface HTMLTrackElement : HTMLElement {
 *   attribute DOMString kind;
 *   attribute DOMString src;
 *   attribute DOMString srclang;
 *   attribute DOMString label;
 *   attribute boolean default;
 *
 *   const unsigned short NONE = 0;
 *   const unsigned short LOADING = 1;
 *   const unsigned short LOADED = 2;
 *   const unsigned short ERROR = 3;
 *   readonly attribute unsigned short readyState;
 *
 *   readonly attribute TextTrack track;
 * };
 *
 * @param {Object} options TextTrack configuration
 * @class HTMLTrackElement
 */

var HTMLTrackElement = (function (_EventTarget) {
  _inherits(HTMLTrackElement, _EventTarget);

  function HTMLTrackElement() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, HTMLTrackElement);

    _EventTarget.call(this);

    var readyState = undefined,
        trackElement = this;

    if (browser.IS_IE8) {
      trackElement = _globalDocument2['default'].createElement('custom');

      for (var prop in HTMLTrackElement.prototype) {
        if (prop !== 'constructor') {
          trackElement[prop] = HTMLTrackElement.prototype[prop];
        }
      }
    }

    var track = new _tracksTextTrack2['default'](options);

    trackElement.kind = track.kind;
    trackElement.src = track.src;
    trackElement.srclang = track.language;
    trackElement.label = track.label;
    trackElement['default'] = track['default'];

    Object.defineProperty(trackElement, 'readyState', {
      get: function get() {
        return readyState;
      }
    });

    Object.defineProperty(trackElement, 'track', {
      get: function get() {
        return track;
      }
    });

    readyState = NONE;

    track.addEventListener('loadeddata', function () {
      readyState = LOADED;

      trackElement.trigger({
        type: 'load',
        target: trackElement
      });
    });

    if (browser.IS_IE8) {
      return trackElement;
    }
  }

  return HTMLTrackElement;
})(_eventTarget2['default']);

HTMLTrackElement.prototype.allowedEvents_ = {
  load: 'load'
};

HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;

exports['default'] = HTMLTrackElement;
module.exports = exports['default'];

},{"../event-target":104,"../tracks/text-track":134,"../utils/browser.js":140,"global/document":1}],129:[function(_dereq_,module,exports){
/**
 * @file text-track-cue-list.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * A List of text track cues as defined in:
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
 *
 * interface TextTrackCueList {
 *   readonly attribute unsigned long length;
 *   getter TextTrackCue (unsigned long index);
 *   TextTrackCue? getCueById(DOMString id);
 * };
 *
 * @param {Array} cues A list of cues to be initialized with
 * @class TextTrackCueList
 */

var TextTrackCueList = (function () {
  function TextTrackCueList(cues) {
    _classCallCheck(this, TextTrackCueList);

    var list = this;

    if (browser.IS_IE8) {
      list = _globalDocument2['default'].createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    Object.defineProperty(list, 'length', {
      get: function get() {
        return this.length_;
      }
    });

    if (browser.IS_IE8) {
      return list;
    }
  }

  /**
   * A setter for cues in this list
   *
   * @param {Array} cues an array of cues
   * @method setCues_
   * @private
   */

  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;

    this.cues_ = cues;
    this.length_ = cues.length;

    var defineProp = function defineProp(index) {
      if (!('' + index in this)) {
        Object.defineProperty(this, '' + index, {
          get: function get() {
            return this.cues_[index];
          }
        });
      }
    };

    if (oldLength < l) {
      i = oldLength;

      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };

  /**
   * Get a cue that is currently in the Cue list by id
   *
   * @param {String} id
   * @method getCueById
   * @return {Object} a single cue
   */

  TextTrackCueList.prototype.getCueById = function getCueById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];

      if (cue.id === id) {
        result = cue;
        break;
      }
    }

    return result;
  };

  return TextTrackCueList;
})();

exports['default'] = TextTrackCueList;
module.exports = exports['default'];

},{"../utils/browser.js":140,"global/document":1}],130:[function(_dereq_,module,exports){
/**
 * @file text-track-display.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _menuMenuJs = _dereq_('../menu/menu.js');

var _menuMenuJs2 = _interopRequireDefault(_menuMenuJs);

var _menuMenuItemJs = _dereq_('../menu/menu-item.js');

var _menuMenuItemJs2 = _interopRequireDefault(_menuMenuItemJs);

var _menuMenuButtonJs = _dereq_('../menu/menu-button.js');

var _menuMenuButtonJs2 = _interopRequireDefault(_menuMenuButtonJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * The component for displaying text track cues
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @param {Function=} ready    Ready callback function
 * @extends Component
 * @class TextTrackDisplay
 */

var TextTrackDisplay = (function (_Component) {
  _inherits(TextTrackDisplay, _Component);

  function TextTrackDisplay(player, options, ready) {
    _classCallCheck(this, TextTrackDisplay);

    _Component.call(this, player, options, ready);

    player.on('loadstart', Fn.bind(this, this.toggleDisplay));
    player.on('texttrackchange', Fn.bind(this, this.updateDisplay));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(Fn.bind(this, function () {
      if (player.tech_ && player.tech_['featuresNativeTextTracks']) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', Fn.bind(this, this.updateDisplay));

      var tracks = this.options_.playerOptions['tracks'] || [];
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        this.player_.addRemoteTextTrack(track);
      }

      var modes = { 'captions': 1, 'subtitles': 1 };
      var trackList = this.player_.textTracks();
      var firstDesc = undefined;
      var firstCaptions = undefined;

      if (trackList) {
        for (var i = 0; i < trackList.length; i++) {
          var track = trackList[i];
          if (track['default']) {
            if (track.kind === 'descriptions' && !firstDesc) {
              firstDesc = track;
            } else if (track.kind in modes && !firstCaptions) {
              firstCaptions = track;
            }
          }
        }

        // We want to show the first default track but captions and subtitles
        // take precedence over descriptions.
        // So, display the first default captions or subtitles track
        // and otherwise the first default descriptions track.
        if (firstCaptions) {
          firstCaptions.mode = 'showing';
        } else if (firstDesc) {
          firstDesc.mode = 'showing';
        }
      }
    }));
  }

  /**
  * Add cue HTML to display
  *
  * @param {Number} color Hex number for color, like #f0e
  * @param {Number} opacity Value for opacity,0.0 - 1.0
  * @return {RGBAColor} In the form 'rgba(255, 0, 0, 0.3)'
  * @method constructColor
  */

  /**
   * Toggle display texttracks
   *
   * @method toggleDisplay
   */

  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_['featuresNativeTextTracks']) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  TextTrackDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-text-track-display'
    }, {
      'aria-live': 'assertive',
      'aria-atomic': 'true'
    });
  };

  /**
   * Clear display texttracks
   *
   * @method clearDisplay
   */

  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {
    if (typeof _globalWindow2['default']['WebVTT'] === 'function') {
      _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], [], this.el_);
    }
  };

  /**
   * Update display texttracks
   *
   * @method updateDisplay
   */

  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();

    this.clearDisplay();

    if (!tracks) {
      return;
    }

    // Track display prioritization model: if multiple tracks are 'showing',
    //  display the first 'subtitles' or 'captions' track which is 'showing',
    //  otherwise display the first 'descriptions' track which is 'showing'

    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;

    var i = tracks.length;
    while (i--) {
      var track = tracks[i];
      if (track['mode'] === 'showing') {
        if (track['kind'] === 'descriptions') {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }

    if (captionsSubtitlesTrack) {
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      this.updateForTrack(descriptionsTrack);
    }
  };

  /**
   * Add texttrack to texttrack list
   *
   * @param {TextTrackObject} track Texttrack object to be added to list
   * @method updateForTrack
   */

  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {
    if (typeof _globalWindow2['default']['WebVTT'] !== 'function' || !track['activeCues']) {
      return;
    }

    var overrides = this.player_['textTrackSettings'].getValues();

    var cues = [];
    for (var _i = 0; _i < track['activeCues'].length; _i++) {
      cues.push(track['activeCues'][_i]);
    }

    _globalWindow2['default']['WebVTT']['processCues'](_globalWindow2['default'], cues, this.el_);

    var i = cues.length;
    while (i--) {
      var cue = cues[i];
      if (!cue) {
        continue;
      }

      var cueDiv = cue.displayState;
      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === 'dropshadow') {
          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
        } else if (overrides.edgeStyle === 'raised') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
        } else if (overrides.edgeStyle === 'depressed') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
        } else if (overrides.edgeStyle === 'uniform') {
          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = _globalWindow2['default'].parseFloat(cueDiv.style.fontSize);
        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
        cueDiv.style.height = 'auto';
        cueDiv.style.top = 'auto';
        cueDiv.style.bottom = '2px';
      }
      if (overrides.fontFamily && overrides.fontFamily !== 'default') {
        if (overrides.fontFamily === 'small-caps') {
          cueDiv.firstChild.style.fontVariant = 'small-caps';
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };

  return TextTrackDisplay;
})(_component2['default']);

function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

/**
 * Try to update style
 * Some style changes will throw an error, particularly in IE8. Those should be noops.
 *
 * @param {Element} el The element to be styles
 * @param {CSSProperty} style The CSS property to be styled
 * @param {CSSStyle} rule The actual style to be applied to the property
 * @method tryUpdateStyle
 */
function tryUpdateStyle(el, style, rule) {
  //
  try {
    el.style[style] = rule;
  } catch (e) {}
}

_component2['default'].registerComponent('TextTrackDisplay', TextTrackDisplay);
exports['default'] = TextTrackDisplay;
module.exports = exports['default'];

},{"../component":67,"../menu/menu-button.js":109,"../menu/menu-item.js":110,"../menu/menu.js":111,"../utils/fn.js":144,"global/document":1,"global/window":2}],131:[function(_dereq_,module,exports){
/**
 * Utilities for capturing text track state and re-creating tracks
 * based on a capture.
 *
 * @file text-track-list-converter.js
 */

/**
 * Examine a single text track and return a JSON-compatible javascript
 * object that represents the text track's state.
 * @param track {TextTrackObject} the text track to query
 * @return {Object} a serializable javascript representation of the
 * @private
 */
'use strict';

exports.__esModule = true;
var trackToJson_ = function trackToJson_(track) {
  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {
    if (track[prop]) {
      acc[prop] = track[prop];
    }

    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });

  return ret;
};

/**
 * Examine a tech and return a JSON-compatible javascript array that
 * represents the state of all text tracks currently configured. The
 * return array is compatible with `jsonToTextTracks`.
 * @param tech {tech} the tech object to query
 * @return {Array} a serializable javascript representation of the
 * @function textTracksToJson
 */
var textTracksToJson = function textTracksToJson(tech) {

  var trackEls = tech.$$('track');

  var trackObjs = Array.prototype.map.call(trackEls, function (t) {
    return t.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
    var json = trackToJson_(trackEl.track);
    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });

  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};

/**
 * Creates a set of remote text tracks on a tech based on an array of
 * javascript text track representations.
 * @param json {Array} an array of text track representation objects,
 * like those that would be produced by `textTracksToJson`
 * @param tech {tech} the tech to create text tracks on
 * @function jsonToTextTracks
 */
var jsonToTextTracks = function jsonToTextTracks(json, tech) {
  json.forEach(function (track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;
    if (!track.src && track.cues) {
      track.cues.forEach(function (cue) {
        return addedTrack.addCue(cue);
      });
    }
  });

  return tech.textTracks();
};

exports['default'] = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };
module.exports = exports['default'];

},{}],132:[function(_dereq_,module,exports){
/**
 * @file text-track-list.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackList = _dereq_('./track-list');

var _trackList2 = _interopRequireDefault(_trackList);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * A list of possible text tracks. All functionality is in the
 * base class TrackList. The spec for TextTrackList is located at:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
 *
 * interface TextTrackList : EventTarget {
 *   readonly attribute unsigned long length;
 *   getter TextTrack (unsigned long index);
 *   TextTrack? getTrackById(DOMString id);
 *
 *   attribute EventHandler onchange;
 *   attribute EventHandler onaddtrack;
 *   attribute EventHandler onremovetrack;
 * };
 *
 * @param {TextTrack[]} tracks A list of tracks to initialize the list with
 * @extends TrackList
 * @class TextTrackList
 */

var TextTrackList = (function (_TrackList) {
  _inherits(TextTrackList, _TrackList);

  function TextTrackList() {
    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    _classCallCheck(this, TextTrackList);

    var list = undefined;

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (browser.IS_IE8) {
      list = _globalDocument2['default'].createElement('custom');
      for (var prop in _trackList2['default'].prototype) {
        if (prop !== 'constructor') {
          list[prop] = _trackList2['default'].prototype[prop];
        }
      }
      for (var prop in TextTrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackList.prototype[prop];
        }
      }
    }

    list = _TrackList.call(this, tracks, list);
    return list;
  }

  TextTrackList.prototype.addTrack_ = function addTrack_(track) {
    _TrackList.prototype.addTrack_.call(this, track);
    track.addEventListener('modechange', Fn.bind(this, function () {
      this.trigger('change');
    }));
  };

  /**
   * Remove TextTrack from TextTrackList
   * NOTE: Be mindful of what is passed in as it may be a HTMLTrackElement
   *
   * @param {TextTrack} rtrack
   * @method removeTrack_
   * @private
   */

  TextTrackList.prototype.removeTrack_ = function removeTrack_(rtrack) {
    var track = undefined;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a TextTrack from TextTrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {TextTrack}
   * @private
   */

  TextTrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];

      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TextTrackList;
})(_trackList2['default']);

exports['default'] = TextTrackList;
module.exports = exports['default'];

},{"../utils/browser.js":140,"../utils/fn.js":144,"./track-list":136,"global/document":1}],133:[function(_dereq_,module,exports){
/**
 * @file text-track-settings.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _component = _dereq_('../component');

var _component2 = _interopRequireDefault(_component);

var _utilsEventsJs = _dereq_('../utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsLogJs = _dereq_('../utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _safeJsonParseTuple = _dereq_('safe-json-parse/tuple');

var _safeJsonParseTuple2 = _interopRequireDefault(_safeJsonParseTuple);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

/**
 * Manipulate settings of texttracks
 *
 * @param {Object} player  Main Player
 * @param {Object=} options Object of option names and values
 * @extends Component
 * @class TextTrackSettings
 */

var TextTrackSettings = (function (_Component) {
  _inherits(TextTrackSettings, _Component);

  function TextTrackSettings(player, options) {
    _classCallCheck(this, TextTrackSettings);

    _Component.call(this, player, options);
    this.hide();

    // Grab `persistTextTrackSettings` from the player options if not passed in child options
    if (options.persistTextTrackSettings === undefined) {
      this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
    }

    Events.on(this.$('.vjs-done-button'), 'click', Fn.bind(this, function () {
      this.saveSettings();
      this.hide();
    }));

    Events.on(this.$('.vjs-default-button'), 'click', Fn.bind(this, function () {
      this.$('.vjs-fg-color > select').selectedIndex = 0;
      this.$('.vjs-bg-color > select').selectedIndex = 0;
      this.$('.window-color > select').selectedIndex = 0;
      this.$('.vjs-text-opacity > select').selectedIndex = 0;
      this.$('.vjs-bg-opacity > select').selectedIndex = 0;
      this.$('.vjs-window-opacity > select').selectedIndex = 0;
      this.$('.vjs-edge-style select').selectedIndex = 0;
      this.$('.vjs-font-family select').selectedIndex = 0;
      this.$('.vjs-font-percent select').selectedIndex = 2;
      this.updateDisplay();
    }));

    Events.on(this.$('.vjs-fg-color > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-bg-color > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.window-color > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-text-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-bg-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-window-opacity > select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-font-percent select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-edge-style select'), 'change', Fn.bind(this, this.updateDisplay));
    Events.on(this.$('.vjs-font-family select'), 'change', Fn.bind(this, this.updateDisplay));

    if (this.options_.persistTextTrackSettings) {
      this.restoreSettings();
    }
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   * @method createEl
   */

  TextTrackSettings.prototype.createEl = function createEl() {
    var uniqueId = this.id_;
    var dialogLabelId = 'TTsettingsDialogLabel-' + uniqueId;
    var dialogDescriptionId = 'TTsettingsDialogDescription-' + uniqueId;

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-caption-settings vjs-modal-overlay',
      innerHTML: captionOptionsMenuTemplate(uniqueId, dialogLabelId, dialogDescriptionId),
      tabIndex: -1
    }, {
      role: 'dialog',
      'aria-labelledby': dialogLabelId,
      'aria-describedby': dialogDescriptionId
    });
  };

  /**
   * Get texttrack settings
   * Settings are
   * .vjs-edge-style
   * .vjs-font-family
   * .vjs-fg-color
   * .vjs-text-opacity
   * .vjs-bg-color
   * .vjs-bg-opacity
   * .window-color
   * .vjs-window-opacity
   *
   * @return {Object}
   * @method getValues
   */

  TextTrackSettings.prototype.getValues = function getValues() {
    var textEdge = getSelectedOptionValue(this.$('.vjs-edge-style select'));
    var fontFamily = getSelectedOptionValue(this.$('.vjs-font-family select'));
    var fgColor = getSelectedOptionValue(this.$('.vjs-fg-color > select'));
    var textOpacity = getSelectedOptionValue(this.$('.vjs-text-opacity > select'));
    var bgColor = getSelectedOptionValue(this.$('.vjs-bg-color > select'));
    var bgOpacity = getSelectedOptionValue(this.$('.vjs-bg-opacity > select'));
    var windowColor = getSelectedOptionValue(this.$('.window-color > select'));
    var windowOpacity = getSelectedOptionValue(this.$('.vjs-window-opacity > select'));
    var fontPercent = _globalWindow2['default']['parseFloat'](getSelectedOptionValue(this.$('.vjs-font-percent > select')));

    var result = {
      'backgroundOpacity': bgOpacity,
      'textOpacity': textOpacity,
      'windowOpacity': windowOpacity,
      'edgeStyle': textEdge,
      'fontFamily': fontFamily,
      'color': fgColor,
      'backgroundColor': bgColor,
      'windowColor': windowColor,
      'fontPercent': fontPercent
    };
    for (var _name in result) {
      if (result[_name] === '' || result[_name] === 'none' || _name === 'fontPercent' && result[_name] === 1.00) {
        delete result[_name];
      }
    }
    return result;
  };

  /**
   * Set texttrack settings
   * Settings are
   * .vjs-edge-style
   * .vjs-font-family
   * .vjs-fg-color
   * .vjs-text-opacity
   * .vjs-bg-color
   * .vjs-bg-opacity
   * .window-color
   * .vjs-window-opacity
   *
   * @param {Object} values Object with texttrack setting values
   * @method setValues
   */

  TextTrackSettings.prototype.setValues = function setValues(values) {
    setSelectedOption(this.$('.vjs-edge-style select'), values.edgeStyle);
    setSelectedOption(this.$('.vjs-font-family select'), values.fontFamily);
    setSelectedOption(this.$('.vjs-fg-color > select'), values.color);
    setSelectedOption(this.$('.vjs-text-opacity > select'), values.textOpacity);
    setSelectedOption(this.$('.vjs-bg-color > select'), values.backgroundColor);
    setSelectedOption(this.$('.vjs-bg-opacity > select'), values.backgroundOpacity);
    setSelectedOption(this.$('.window-color > select'), values.windowColor);
    setSelectedOption(this.$('.vjs-window-opacity > select'), values.windowOpacity);

    var fontPercent = values.fontPercent;

    if (fontPercent) {
      fontPercent = fontPercent.toFixed(2);
    }

    setSelectedOption(this.$('.vjs-font-percent > select'), fontPercent);
  };

  /**
   * Restore texttrack settings
   *
   * @method restoreSettings
   */

  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {
    var err = undefined,
        values = undefined;

    try {
      var _safeParseTuple = _safeJsonParseTuple2['default'](_globalWindow2['default'].localStorage.getItem('vjs-text-track-settings'));

      err = _safeParseTuple[0];
      values = _safeParseTuple[1];

      if (err) {
        _utilsLogJs2['default'].error(err);
      }
    } catch (e) {
      _utilsLogJs2['default'].warn(e);
    }

    if (values) {
      this.setValues(values);
    }
  };

  /**
   * Save texttrack settings to local storage
   *
   * @method saveSettings
   */

  TextTrackSettings.prototype.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }

    var values = this.getValues();
    try {
      if (Object.getOwnPropertyNames(values).length > 0) {
        _globalWindow2['default'].localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
      } else {
        _globalWindow2['default'].localStorage.removeItem('vjs-text-track-settings');
      }
    } catch (e) {
      _utilsLogJs2['default'].warn(e);
    }
  };

  /**
   * Update display of texttrack settings
   *
   * @method updateDisplay
   */

  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild('textTrackDisplay');
    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };

  return TextTrackSettings;
})(_component2['default']);

_component2['default'].registerComponent('TextTrackSettings', TextTrackSettings);

function getSelectedOptionValue(target) {
  var selectedOption = undefined;
  // not all browsers support selectedOptions, so, fallback to options
  if (target.selectedOptions) {
    selectedOption = target.selectedOptions[0];
  } else if (target.options) {
    selectedOption = target.options[target.options.selectedIndex];
  }

  return selectedOption.value;
}

function setSelectedOption(target, value) {
  if (!value) {
    return;
  }

  var i = undefined;
  for (i = 0; i < target.options.length; i++) {
    var option = target.options[i];
    if (option.value === value) {
      break;
    }
  }

  target.selectedIndex = i;
}

function captionOptionsMenuTemplate(uniqueId, dialogLabelId, dialogDescriptionId) {

  var template = '\n    <div role="document">\n      <div role="heading" aria-level="1" id="' + dialogLabelId + '" class="vjs-control-text">Captions Settings Dialog</div>\n      <div id="' + dialogDescriptionId + '" class="vjs-control-text">Beginning of dialog window. Escape will cancel and close the window.</div>\n      <div class="vjs-tracksettings">\n        <div class="vjs-tracksettings-colors">\n          <fieldset class="vjs-fg-color vjs-tracksetting">\n            <legend>Text</legend>\n            <label class="vjs-label" for="captions-foreground-color-' + uniqueId + '">Color</label>\n            <select id="captions-foreground-color-' + uniqueId + '">\n              <option value="#FFF" selected>White</option>\n              <option value="#000">Black</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-text-opacity vjs-opacity">\n              <label class="vjs-label" for="captions-foreground-opacity-' + uniqueId + '">Transparency</label>\n              <select id="captions-foreground-opacity-' + uniqueId + '">\n                <option value="1" selected>Opaque</option>\n                <option value="0.5">Semi-Opaque</option>\n              </select>\n            </span>\n          </fieldset>\n          <fieldset class="vjs-bg-color vjs-tracksetting">\n            <legend>Background</legend>\n            <label class="vjs-label" for="captions-background-color-' + uniqueId + '">Color</label>\n            <select id="captions-background-color-' + uniqueId + '">\n              <option value="#000" selected>Black</option>\n              <option value="#FFF">White</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-bg-opacity vjs-opacity">\n              <label class="vjs-label" for="captions-background-opacity-' + uniqueId + '">Transparency</label>\n              <select id="captions-background-opacity-' + uniqueId + '">\n                <option value="1" selected>Opaque</option>\n                <option value="0.5">Semi-Transparent</option>\n                <option value="0">Transparent</option>\n              </select>\n            </span>\n          </fieldset>\n          <fieldset class="window-color vjs-tracksetting">\n            <legend>Window</legend>\n            <label class="vjs-label" for="captions-window-color-' + uniqueId + '">Color</label>\n            <select id="captions-window-color-' + uniqueId + '">\n              <option value="#000" selected>Black</option>\n              <option value="#FFF">White</option>\n              <option value="#F00">Red</option>\n              <option value="#0F0">Green</option>\n              <option value="#00F">Blue</option>\n              <option value="#FF0">Yellow</option>\n              <option value="#F0F">Magenta</option>\n              <option value="#0FF">Cyan</option>\n            </select>\n            <span class="vjs-window-opacity vjs-opacity">\n              <label class="vjs-label" for="captions-window-opacity-' + uniqueId + '">Transparency</label>\n              <select id="captions-window-opacity-' + uniqueId + '">\n                <option value="0" selected>Transparent</option>\n                <option value="0.5">Semi-Transparent</option>\n                <option value="1">Opaque</option>\n              </select>\n            </span>\n          </fieldset>\n        </div> <!-- vjs-tracksettings-colors -->\n        <div class="vjs-tracksettings-font">\n          <div class="vjs-font-percent vjs-tracksetting">\n            <label class="vjs-label" for="captions-font-size-' + uniqueId + '">Font Size</label>\n            <select id="captions-font-size-' + uniqueId + '">\n              <option value="0.50">50%</option>\n              <option value="0.75">75%</option>\n              <option value="1.00" selected>100%</option>\n              <option value="1.25">125%</option>\n              <option value="1.50">150%</option>\n              <option value="1.75">175%</option>\n              <option value="2.00">200%</option>\n              <option value="3.00">300%</option>\n              <option value="4.00">400%</option>\n            </select>\n          </div>\n          <div class="vjs-edge-style vjs-tracksetting">\n            <label class="vjs-label" for="captions-edge-style-' + uniqueId + '">Text Edge Style</label>\n            <select id="captions-edge-style-' + uniqueId + '">\n              <option value="none" selected>None</option>\n              <option value="raised">Raised</option>\n              <option value="depressed">Depressed</option>\n              <option value="uniform">Uniform</option>\n              <option value="dropshadow">Dropshadow</option>\n            </select>\n          </div>\n          <div class="vjs-font-family vjs-tracksetting">\n            <label class="vjs-label" for="captions-font-family-' + uniqueId + '">Font Family</label>\n            <select id="captions-font-family-' + uniqueId + '">\n              <option value="proportionalSansSerif" selected>Proportional Sans-Serif</option>\n              <option value="monospaceSansSerif">Monospace Sans-Serif</option>\n              <option value="proportionalSerif">Proportional Serif</option>\n              <option value="monospaceSerif">Monospace Serif</option>\n              <option value="casual">Casual</option>\n              <option value="script">Script</option>\n              <option value="small-caps">Small Caps</option>\n            </select>\n          </div>\n        </div> <!-- vjs-tracksettings-font -->\n        <div class="vjs-tracksettings-controls">\n          <button class="vjs-default-button">Defaults</button>\n          <button class="vjs-done-button">Done</button>\n        </div>\n      </div> <!-- vjs-tracksettings -->\n    </div> <!--  role="document" -->';

  return template;
}

exports['default'] = TextTrackSettings;
module.exports = exports['default'];

},{"../component":67,"../utils/events.js":143,"../utils/fn.js":144,"../utils/log.js":147,"global/window":2,"safe-json-parse/tuple":54}],134:[function(_dereq_,module,exports){
/**
 * @file text-track.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _textTrackCueList = _dereq_('./text-track-cue-list');

var _textTrackCueList2 = _interopRequireDefault(_textTrackCueList);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _trackEnums = _dereq_('./track-enums');

var _utilsLogJs = _dereq_('../utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _trackJs = _dereq_('./track.js');

var _trackJs2 = _interopRequireDefault(_trackJs);

var _utilsUrlJs = _dereq_('../utils/url.js');

var _xhr = _dereq_('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _utilsMergeOptions = _dereq_('../utils/merge-options');

var _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

/**
 * takes a webvtt file contents and parses it into cues
 *
 * @param {String} srcContent webVTT file contents
 * @param {Track} track track to addcues to
 */
var parseCues = function parseCues(srcContent, track) {
  var parser = new _globalWindow2['default'].WebVTT.Parser(_globalWindow2['default'], _globalWindow2['default'].vttjs, _globalWindow2['default'].WebVTT.StringDecoder());
  var errors = [];

  parser.oncue = function (cue) {
    track.addCue(cue);
  };

  parser.onparsingerror = function (error) {
    errors.push(error);
  };

  parser.onflush = function () {
    track.trigger({
      type: 'loadeddata',
      target: track
    });
  };

  parser.parse(srcContent);
  if (errors.length > 0) {
    if (console.groupCollapsed) {
      console.groupCollapsed('Text Track parsing errors for ' + track.src);
    }
    errors.forEach(function (error) {
      return _utilsLogJs2['default'].error(error);
    });
    if (console.groupEnd) {
      console.groupEnd();
    }
  }

  parser.flush();
};

/**
 * load a track from a  specifed url
 *
 * @param {String} src url to load track from
 * @param {Track} track track to addcues to
 */
var loadTrack = function loadTrack(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = _utilsUrlJs.isCrossOrigin(src);

  if (crossOrigin) {
    opts.cors = crossOrigin;
  }

  _xhr2['default'](opts, Fn.bind(this, function (err, response, responseBody) {
    if (err) {
      return _utilsLogJs2['default'].error(err, response);
    }

    track.loaded_ = true;

    // Make sure that vttjs has loaded, otherwise, wait till it finished loading
    // NOTE: this is only used for the alt/video.novtt.js build
    if (typeof _globalWindow2['default'].WebVTT !== 'function') {
      if (track.tech_) {
        (function () {
          var loadHandler = function loadHandler() {
            return parseCues(responseBody, track);
          };
          track.tech_.on('vttjsloaded', loadHandler);
          track.tech_.on('vttjserror', function () {
            _utilsLogJs2['default'].error('vttjs failed to load, stopping trying to process ' + track.src);
            track.tech_.off('vttjsloaded', loadHandler);
          });
        })();
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};

/**
 * A single text track as defined in:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
 *
 * interface TextTrack : EventTarget {
 *   readonly attribute TextTrackKind kind;
 *   readonly attribute DOMString label;
 *   readonly attribute DOMString language;
 *
 *   readonly attribute DOMString id;
 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
 *
 *   attribute TextTrackMode mode;
 *
 *   readonly attribute TextTrackCueList? cues;
 *   readonly attribute TextTrackCueList? activeCues;
 *
 *   void addCue(TextTrackCue cue);
 *   void removeCue(TextTrackCue cue);
 *
 *   attribute EventHandler oncuechange;
 * };
 *
 * @param {Object=} options Object of option names and values
 * @extends Track
 * @class TextTrack
 */

var TextTrack = (function (_Track) {
  _inherits(TextTrack, _Track);

  function TextTrack() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, TextTrack);

    if (!options.tech) {
      throw new Error('A tech was not provided.');
    }

    var settings = _utilsMergeOptions2['default'](options, {
      kind: _trackEnums.TextTrackKind[options.kind] || 'subtitles',
      language: options.language || options.srclang || ''
    });
    var mode = _trackEnums.TextTrackMode[settings.mode] || 'disabled';
    var default_ = settings['default'];

    if (settings.kind === 'metadata' || settings.kind === 'chapters') {
      mode = 'hidden';
    }
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var tt = _Track.call(this, settings);
    tt.tech_ = settings.tech;

    if (browser.IS_IE8) {
      for (var prop in TextTrack.prototype) {
        if (prop !== 'constructor') {
          tt[prop] = TextTrack.prototype[prop];
        }
      }
    }

    tt.cues_ = [];
    tt.activeCues_ = [];

    var cues = new _textTrackCueList2['default'](tt.cues_);
    var activeCues = new _textTrackCueList2['default'](tt.activeCues_);
    var changed = false;
    var timeupdateHandler = Fn.bind(tt, function () {
      this.activeCues;
      if (changed) {
        this.trigger('cuechange');
        changed = false;
      }
    });

    if (mode !== 'disabled') {
      tt.tech_.on('timeupdate', timeupdateHandler);
    }

    Object.defineProperty(tt, 'default', {
      get: function get() {
        return default_;
      },
      set: function set() {}
    });

    Object.defineProperty(tt, 'mode', {
      get: function get() {
        return mode;
      },
      set: function set(newMode) {
        if (!_trackEnums.TextTrackMode[newMode]) {
          return;
        }
        mode = newMode;
        if (mode === 'showing') {
          this.tech_.on('timeupdate', timeupdateHandler);
        }
        this.trigger('modechange');
      }
    });

    Object.defineProperty(tt, 'cues', {
      get: function get() {
        if (!this.loaded_) {
          return null;
        }

        return cues;
      },
      set: function set() {}
    });

    Object.defineProperty(tt, 'activeCues', {
      get: function get() {
        if (!this.loaded_) {
          return null;
        }

        // nothing to do
        if (this.cues.length === 0) {
          return activeCues;
        }

        var ct = this.tech_.currentTime();
        var active = [];

        for (var i = 0, l = this.cues.length; i < l; i++) {
          var cue = this.cues[i];

          if (cue.startTime <= ct && cue.endTime >= ct) {
            active.push(cue);
          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
            active.push(cue);
          }
        }

        changed = false;

        if (active.length !== this.activeCues_.length) {
          changed = true;
        } else {
          for (var i = 0; i < active.length; i++) {
            if (this.activeCues_.indexOf(active[i]) === -1) {
              changed = true;
            }
          }
        }

        this.activeCues_ = active;
        activeCues.setCues_(this.activeCues_);

        return activeCues;
      },
      set: function set() {}
    });

    if (settings.src) {
      tt.src = settings.src;
      loadTrack(settings.src, tt);
    } else {
      tt.loaded_ = true;
    }

    return tt;
  }

  /**
   * cuechange - One or more cues in the track have become active or stopped being active.
   */

  /**
   * add a cue to the internal list of cues
   *
   * @param {Object} cue the cue to add to our internal list
   * @method addCue
   */

  TextTrack.prototype.addCue = function addCue(cue) {
    var tracks = this.tech_.textTracks();

    if (tracks) {
      for (var i = 0; i < tracks.length; i++) {
        if (tracks[i] !== this) {
          tracks[i].removeCue(cue);
        }
      }
    }

    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };

  /**
   * remvoe a cue from our internal list
   *
   * @param {Object} removeCue the cue to remove from our internal list
   * @method removeCue
   */

  TextTrack.prototype.removeCue = function removeCue(_removeCue) {
    var removed = false;

    for (var i = 0, l = this.cues_.length; i < l; i++) {
      var cue = this.cues_[i];

      if (cue === _removeCue) {
        this.cues_.splice(i, 1);
        removed = true;
      }
    }

    if (removed) {
      this.cues.setCues_(this.cues_);
    }
  };

  return TextTrack;
})(_trackJs2['default']);

TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

exports['default'] = TextTrack;
module.exports = exports['default'];

},{"../utils/browser.js":140,"../utils/fn.js":144,"../utils/log.js":147,"../utils/merge-options":148,"../utils/url.js":152,"./text-track-cue-list":129,"./track-enums":135,"./track.js":137,"global/document":1,"global/window":2,"xhr":56}],135:[function(_dereq_,module,exports){
/**
 * @file track-kinds.js
 */

/**
 * https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
 *
 * enum VideoTrackKind {
 *   "alternative",
 *   "captions",
 *   "main",
 *   "sign",
 *   "subtitles",
 *   "commentary",
 *   "",
 * };
 */
'use strict';

exports.__esModule = true;
var VideoTrackKind = {
  alternative: 'alternative',
  captions: 'captions',
  main: 'main',
  sign: 'sign',
  subtitles: 'subtitles',
  commentary: 'commentary'
};

/**
 * https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
 *
 * enum AudioTrackKind {
 *   "alternative",
 *   "descriptions",
 *   "main",
 *   "main-desc",
 *   "translation",
 *   "commentary",
 *   "",
 * };
 */
var AudioTrackKind = {
  alternative: 'alternative',
  descriptions: 'descriptions',
  main: 'main',
  'main-desc': 'main-desc',
  translation: 'translation',
  commentary: 'commentary'
};

/**
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
 *
 * enum TextTrackKind {
 *   "subtitles",
 *   "captions",
 *   "descriptions",
 *   "chapters",
 *   "metadata"
 * };
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

/**
 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 *
 * enum TextTrackMode { "disabled",  "hidden",  "showing" };
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/* jshint ignore:start */
// we ignore jshint here because it does not see
// AudioTrackKind as defined here
exports['default'] = { VideoTrackKind: VideoTrackKind, AudioTrackKind: AudioTrackKind, TextTrackKind: TextTrackKind, TextTrackMode: TextTrackMode };

/* jshint ignore:end */
module.exports = exports['default'];

},{}],136:[function(_dereq_,module,exports){
/**
 * @file track-list.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _eventTarget = _dereq_('../event-target');

var _eventTarget2 = _interopRequireDefault(_eventTarget);

var _utilsFnJs = _dereq_('../utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Common functionaliy between Text, Audio, and Video TrackLists
 * Interfaces defined in the following spec:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html
 *
 * @param {Track[]} tracks A list of tracks to initialize the list with
 * @param {Object} list the child object with inheritance done manually for ie8
 * @extends EventTarget
 * @class TrackList
 */

var TrackList = (function (_EventTarget) {
  _inherits(TrackList, _EventTarget);

  function TrackList() {
    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var list = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    _classCallCheck(this, TrackList);

    _EventTarget.call(this);
    if (!list) {
      list = this;
      if (browser.IS_IE8) {
        list = _globalDocument2['default'].createElement('custom');
        for (var prop in TrackList.prototype) {
          if (prop !== 'constructor') {
            list[prop] = TrackList.prototype[prop];
          }
        }
      }
    }

    list.tracks_ = [];
    Object.defineProperty(list, 'length', {
      get: function get() {
        return this.tracks_.length;
      }
    });

    for (var i = 0; i < tracks.length; i++) {
      list.addTrack_(tracks[i]);
    }

    return list;
  }

  /**
   * change - One or more tracks in the track list have been enabled or disabled.
   * addtrack - A track has been added to the track list.
   * removetrack - A track has been removed from the track list.
   */

  /**
   * Add a Track from TrackList
   *
   * @param {Mixed} track
   * @method addTrack_
   * @private
   */

  TrackList.prototype.addTrack_ = function addTrack_(track) {
    var index = this.tracks_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get() {
          return this.tracks_[index];
        }
      });
    }

    // Do not add duplicate tracks
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      this.trigger({
        track: track,
        type: 'addtrack'
      });
    }
  };

  /**
   * Remove a Track from TrackList
   *
   * @param {Track} rtrack track to be removed
   * @method removeTrack_
   * @private
   */

  TrackList.prototype.removeTrack_ = function removeTrack_(rtrack) {
    var track = undefined;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */

  TrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];
      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TrackList;
})(_eventTarget2['default']);

TrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var _event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype['on' + _event] = null;
}

exports['default'] = TrackList;
module.exports = exports['default'];

},{"../event-target":104,"../utils/browser.js":140,"../utils/fn.js":144,"global/document":1}],137:[function(_dereq_,module,exports){
/**
 * @file track.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _utilsGuidJs = _dereq_('../utils/guid.js');

var Guid = _interopRequireWildcard(_utilsGuidJs);

var _eventTarget = _dereq_('../event-target');

var _eventTarget2 = _interopRequireDefault(_eventTarget);

/**
 * setup the common parts of an audio, video, or text track
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html
 *
 * @param {String} type The type of track we are dealing with audio|video|text
 * @param {Object=} options Object of option names and values
 * @extends EventTarget
 * @class Track
 */

var Track = (function (_EventTarget) {
  _inherits(Track, _EventTarget);

  function Track() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Track);

    _EventTarget.call(this);

    var track = this;
    if (browser.IS_IE8) {
      track = _globalDocument2['default'].createElement('custom');
      for (var prop in Track.prototype) {
        if (prop !== 'constructor') {
          track[prop] = Track.prototype[prop];
        }
      }
    }

    var trackProps = {
      id: options.id || 'vjs_track_' + Guid.newGUID(),
      kind: options.kind || '',
      label: options.label || '',
      language: options.language || ''
    };

    var _loop = function (key) {
      Object.defineProperty(track, key, {
        get: function get() {
          return trackProps[key];
        },
        set: function set() {}
      });
    };

    for (var key in trackProps) {
      _loop(key);
    }

    return track;
  }

  return Track;
})(_eventTarget2['default']);

exports['default'] = Track;
module.exports = exports['default'];

},{"../event-target":104,"../utils/browser.js":140,"../utils/guid.js":146,"global/document":1}],138:[function(_dereq_,module,exports){
/**
 * @file video-track-list.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackList = _dereq_('./track-list');

var _trackList2 = _interopRequireDefault(_trackList);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * disable other video tracks before selecting the new one
 *
 * @param {Array|VideoTrackList} list list to work on
 * @param {VideoTrack} track the track to skip
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].selected = false;
  }
};

/**
* A list of possiblee video tracks. Most functionality is in the
 * base class Tracklist and the spec for VideoTrackList is located at:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
 *
 * interface VideoTrackList : EventTarget {
 *   readonly attribute unsigned long length;
 *   getter VideoTrack (unsigned long index);
 *   VideoTrack? getTrackById(DOMString id);
 *   readonly attribute long selectedIndex;
 *
 *   attribute EventHandler onchange;
 *   attribute EventHandler onaddtrack;
 *   attribute EventHandler onremovetrack;
 * };
 *
 * @param {VideoTrack[]} tracks a list of video tracks to instantiate the list with
 # @extends TrackList
 * @class VideoTrackList
 */

var VideoTrackList = (function (_TrackList) {
  _inherits(VideoTrackList, _TrackList);

  function VideoTrackList() {
    var tracks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    _classCallCheck(this, VideoTrackList);

    var list = undefined;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (browser.IS_IE8) {
      list = _globalDocument2['default'].createElement('custom');
      for (var prop in _trackList2['default'].prototype) {
        if (prop !== 'constructor') {
          list[prop] = _trackList2['default'].prototype[prop];
        }
      }
      for (var prop in VideoTrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = VideoTrackList.prototype[prop];
        }
      }
    }

    list = _TrackList.call(this, tracks, list);
    list.changing_ = false;

    Object.defineProperty(list, 'selectedIndex', {
      get: function get() {
        for (var i = 0; i < this.length; i++) {
          if (this[i].selected) {
            return i;
          }
        }
        return -1;
      },
      set: function set() {}
    });

    return list;
  }

  VideoTrackList.prototype.addTrack_ = function addTrack_(track) {
    var _this = this;

    if (track.selected) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack_.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }
    track.addEventListener('selectedchange', function () {
      if (_this.changing_) {
        return;
      }
      _this.changing_ = true;
      disableOthers(_this, track);
      _this.changing_ = false;
      _this.trigger('change');
    });
  };

  VideoTrackList.prototype.addTrack = function addTrack(track) {
    this.addTrack_(track);
  };

  VideoTrackList.prototype.removeTrack = function removeTrack(track) {
    _TrackList.prototype.removeTrack_.call(this, track);
  };

  return VideoTrackList;
})(_trackList2['default']);

exports['default'] = VideoTrackList;
module.exports = exports['default'];

},{"../utils/browser.js":140,"./track-list":136,"global/document":1}],139:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _trackEnums = _dereq_('./track-enums');

var _track = _dereq_('./track');

var _track2 = _interopRequireDefault(_track);

var _utilsMergeOptions = _dereq_('../utils/merge-options');

var _utilsMergeOptions2 = _interopRequireDefault(_utilsMergeOptions);

var _utilsBrowserJs = _dereq_('../utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

/**
 * A single video text track as defined in:
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack
 *
 * interface VideoTrack {
 *   readonly attribute DOMString id;
 *   readonly attribute DOMString kind;
 *   readonly attribute DOMString label;
 *   readonly attribute DOMString language;
 *   attribute boolean selected;
 * };
 *
 * @param {Object=} options Object of option names and values
 * @class VideoTrack
 */

var VideoTrack = (function (_Track) {
  _inherits(VideoTrack, _Track);

  function VideoTrack() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, VideoTrack);

    var settings = _utilsMergeOptions2['default'](options, {
      kind: _trackEnums.VideoTrackKind[options.kind] || ''
    });

    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = _Track.call(this, settings);
    var selected = false;

    if (browser.IS_IE8) {
      for (var prop in VideoTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = VideoTrack.prototype[prop];
        }
      }
    }

    Object.defineProperty(track, 'selected', {
      get: function get() {
        return selected;
      },
      set: function set(newSelected) {
        // an invalid or unchanged value
        if (typeof newSelected !== 'boolean' || newSelected === selected) {
          return;
        }
        selected = newSelected;
        this.trigger('selectedchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.selected) {
      track.selected = settings.selected;
    }

    return track;
  }

  return VideoTrack;
})(_track2['default']);

exports['default'] = VideoTrack;
module.exports = exports['default'];

},{"../utils/browser.js":140,"../utils/merge-options":148,"./track":137,"./track-enums":135}],140:[function(_dereq_,module,exports){
/**
 * @file browser.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var USER_AGENT = _globalWindow2['default'].navigator.userAgent;
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;

/*
 * Device is an iPhone
 *
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPAD = /iPad/i.test(USER_AGENT);

exports.IS_IPAD = IS_IPAD;
// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
// to identify iPhones, we need to exclude iPads.
// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
exports.IS_IPHONE = IS_IPHONE;
var IS_IPOD = /iPod/i.test(USER_AGENT);
exports.IS_IPOD = IS_IPOD;
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

exports.IS_IOS = IS_IOS;
var IOS_VERSION = (function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) {
    return match[1];
  }
})();

exports.IOS_VERSION = IOS_VERSION;
var IS_ANDROID = /Android/i.test(USER_AGENT);
exports.IS_ANDROID = IS_ANDROID;
var ANDROID_VERSION = (function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
      major,
      minor;

  if (!match) {
    return null;
  }

  major = match[1] && parseFloat(match[1]);
  minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  } else {
    return null;
  }
})();
exports.ANDROID_VERSION = ANDROID_VERSION;
// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
exports.IS_OLD_ANDROID = IS_OLD_ANDROID;
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;

exports.IS_NATIVE_ANDROID = IS_NATIVE_ANDROID;
var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
exports.IS_FIREFOX = IS_FIREFOX;
var IS_EDGE = /Edge/i.test(USER_AGENT);
exports.IS_EDGE = IS_EDGE;
var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
exports.IS_CHROME = IS_CHROME;
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
exports.IS_IE8 = IS_IE8;
var IE_VERSION = (function (result) {
  return result && parseFloat(result[1]);
})(/MSIE\s(\d+)\.\d/.exec(USER_AGENT));

exports.IE_VERSION = IE_VERSION;
var TOUCH_ENABLED = !!('ontouchstart' in _globalWindow2['default'] || _globalWindow2['default'].DocumentTouch && _globalDocument2['default'] instanceof _globalWindow2['default'].DocumentTouch);
exports.TOUCH_ENABLED = TOUCH_ENABLED;
var BACKGROUND_SIZE_SUPPORTED = ('backgroundSize' in _globalDocument2['default'].createElement('video').style);
exports.BACKGROUND_SIZE_SUPPORTED = BACKGROUND_SIZE_SUPPORTED;

},{"global/document":1,"global/window":2}],141:[function(_dereq_,module,exports){
/**
 * @file buffer.js
 */
'use strict';

exports.__esModule = true;
exports.bufferedPercent = bufferedPercent;

var _timeRangesJs = _dereq_('./time-ranges.js');

/**
 * Compute how much your video has been buffered
 *
 * @param  {Object} Buffered object
 * @param  {Number} Total duration
 * @return {Number} Percent buffered of the total duration
 * @private
 * @function bufferedPercent
 */

function bufferedPercent(buffered, duration) {
  var bufferedDuration = 0,
      start,
      end;

  if (!duration) {
    return 0;
  }

  if (!buffered || !buffered.length) {
    buffered = _timeRangesJs.createTimeRange(0, 0);
  }

  for (var i = 0; i < buffered.length; i++) {
    start = buffered.start(i);
    end = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
}

},{"./time-ranges.js":150}],142:[function(_dereq_,module,exports){
/**
 * @file dom.js
 */
'use strict';

exports.__esModule = true;
exports.getEl = getEl;
exports.createEl = createEl;
exports.textContent = textContent;
exports.insertElFirst = insertElFirst;
exports.getElData = getElData;
exports.hasElData = hasElData;
exports.removeElData = removeElData;
exports.hasElClass = hasElClass;
exports.addElClass = addElClass;
exports.removeElClass = removeElClass;
exports.toggleElClass = toggleElClass;
exports.setElAttributes = setElAttributes;
exports.getElAttributes = getElAttributes;
exports.blockTextSelection = blockTextSelection;
exports.unblockTextSelection = unblockTextSelection;
exports.findElPosition = findElPosition;
exports.getPointerPosition = getPointerPosition;
exports.isEl = isEl;
exports.isTextNode = isTextNode;
exports.emptyEl = emptyEl;
exports.normalizeContent = normalizeContent;
exports.appendContent = appendContent;
exports.insertContent = insertContent;

var _templateObject = _taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _guidJs = _dereq_('./guid.js');

var Guid = _interopRequireWildcard(_guidJs);

var _logJs = _dereq_('./log.js');

var _logJs2 = _interopRequireDefault(_logJs);

var _tsml = _dereq_('tsml');

var _tsml2 = _interopRequireDefault(_tsml);

/**
 * Detect if a value is a string with any non-whitespace characters.
 *
 * @param  {String} str
 * @return {Boolean}
 */
function isNonBlankString(str) {
  return typeof str === 'string' && /\S/.test(str);
}

/**
 * Throws an error if the passed string has whitespace. This is used by
 * class methods to be relatively consistent with the classList API.
 *
 * @param  {String} str
 * @return {Boolean}
 */
function throwIfWhitespace(str) {
  if (/\s/.test(str)) {
    throw new Error('class has illegal whitespace characters');
  }
}

/**
 * Produce a regular expression for matching a class name.
 *
 * @param  {String} className
 * @return {RegExp}
 */
function classRegExp(className) {
  return new RegExp('(^|\\s)' + className + '($|\\s)');
}

/**
 * Creates functions to query the DOM using a given method.
 *
 * @function createQuerier
 * @private
 * @param  {String} method
 * @return {Function}
 */
function createQuerier(method) {
  return function (selector, context) {
    if (!isNonBlankString(selector)) {
      return _globalDocument2['default'][method](null);
    }
    if (isNonBlankString(context)) {
      context = _globalDocument2['default'].querySelector(context);
    }
    return (isEl(context) ? context : _globalDocument2['default'])[method](selector);
  };
}

/**
 * Shorthand for document.getElementById()
 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
 *
 * @param  {String} id  Element ID
 * @return {Element}    Element with supplied ID
 * @function getEl
 */

function getEl(id) {
  if (id.indexOf('#') === 0) {
    id = id.slice(1);
  }

  return _globalDocument2['default'].getElementById(id);
}

/**
 * Creates an element and applies properties.
 *
 * @param  {String} [tagName='div'] Name of tag to be created.
 * @param  {Object} [properties={}] Element properties to be applied.
 * @param  {Object} [attributes={}] Element attributes to be applied.
 * @return {Element}
 * @function createEl
 */

function createEl() {
  var tagName = arguments.length <= 0 || arguments[0] === undefined ? 'div' : arguments[0];
  var properties = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var attributes = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var el = _globalDocument2['default'].createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // See #2176
    // We originally were accepting both properties and attributes in the
    // same object, but that doesn't work so well.
    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
      _logJs2['default'].warn(_tsml2['default'](_templateObject, propName, val));
      el.setAttribute(propName, val);
    } else {
      el[propName] = val;
    }
  });

  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var val = attributes[attrName];
    el.setAttribute(attrName, attributes[attrName]);
  });

  return el;
}

/**
 * Injects text into an element, replacing any existing contents entirely.
 *
 * @param  {Element} el
 * @param  {String} text
 * @return {Element}
 * @function textContent
 */

function textContent(el, text) {
  if (typeof el.textContent === 'undefined') {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
}

/**
 * Insert an element as the first child node of another
 *
 * @param  {Element} child   Element to insert
 * @param  {Element} parent Element to insert child into
 * @private
 * @function insertElFirst
 */

function insertElFirst(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}

/**
 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
 * Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 *
 * @type {Object}
 * @private
 */
var elData = {};

/*
 * Unique attribute name to store an element's guid in
 *
 * @type {String}
 * @constant
 * @private
 */
var elIdAttr = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 *
 * @param  {Element} el Element to store data for.
 * @return {Object}
 * @function getElData
 */

function getElData(el) {
  var id = el[elIdAttr];

  if (!id) {
    id = el[elIdAttr] = Guid.newGUID();
  }

  if (!elData[id]) {
    elData[id] = {};
  }

  return elData[id];
}

/**
 * Returns whether or not an element has cached data
 *
 * @param  {Element} el A dom element
 * @return {Boolean}
 * @private
 * @function hasElData
 */

function hasElData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(elData[id]).length;
}

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 *
 * @param  {Element} el Remove data for an element
 * @private
 * @function removeElData
 */

function removeElData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return;
  }

  // Remove all stored data
  delete elData[id];

  // Remove the elIdAttr property from the DOM node
  try {
    delete el[elIdAttr];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(elIdAttr);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[elIdAttr] = null;
    }
  }
}

/**
 * Check if an element has a CSS class
 *
 * @function hasElClass
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 */

function hasElClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  } else {
    return classRegExp(classToCheck).test(element.className);
  }
}

/**
 * Add a CSS class name to an element
 *
 * @function addElClass
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 */

function addElClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);

    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it
    // in the case of classList not being supported.
  } else if (!hasElClass(element, classToAdd)) {
      element.className = (element.className + ' ' + classToAdd).trim();
    }

  return element;
}

/**
 * Remove a CSS class name from an element
 *
 * @function removeElClass
 * @param {Element} element    Element to remove from class name
 * @param {String} classToRemove Classname to remove
 */

function removeElClass(element, classToRemove) {
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function (c) {
      return c !== classToRemove;
    }).join(' ');
  }

  return element;
}

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @function toggleElClass
 * @param    {Element} element
 * @param    {String} classToToggle
 * @param    {Boolean|Function} [predicate]
 *           Can be a function that returns a Boolean. If `true`, the class
 *           will be added; if `false`, the class will be removed. If not
 *           given, the class will be added if not present and vice versa.
 */

function toggleElClass(element, classToToggle, predicate) {

  // This CANNOT use `classList` internally because IE does not support the
  // second parameter to the `classList.toggle()` method! Which is fine because
  // `classList` will be used by the add/remove functions.
  var has = hasElClass(element, classToToggle);

  if (typeof predicate === 'function') {
    predicate = predicate(element, classToToggle);
  }

  if (typeof predicate !== 'boolean') {
    predicate = !has;
  }

  // If the necessary class operation matches the current state of the
  // element, no action is required.
  if (predicate === has) {
    return;
  }

  if (predicate) {
    addElClass(element, classToToggle);
  } else {
    removeElClass(element, classToToggle);
  }

  return element;
}

/**
 * Apply attributes to an HTML element.
 *
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 * @private
 * @function setElAttributes
 */

function setElAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
}

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 * @private
 * @function getElAttributes
 */

function getElAttributes(tag) {
  var obj, knownBooleans, attrs, attrName, attrVal;

  obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      attrName = attrs[i].name;
      attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
}

/**
 * Attempt to block the ability to select text while dragging controls
 *
 * @return {Boolean}
 * @function blockTextSelection
 */

function blockTextSelection() {
  _globalDocument2['default'].body.focus();
  _globalDocument2['default'].onselectstart = function () {
    return false;
  };
}

/**
 * Turn off text selection blocking
 *
 * @return {Boolean}
 * @function unblockTextSelection
 */

function unblockTextSelection() {
  _globalDocument2['default'].onselectstart = function () {
    return true;
  };
}

/**
 * Offset Left
 * getBoundingClientRect technique from
 * John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
 *
 * @function findElPosition
 * @param {Element} el Element from which to get offset
 * @return {Object}
 */

function findElPosition(el) {
  var box = undefined;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = _globalDocument2['default'].documentElement;
  var body = _globalDocument2['default'].body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = _globalWindow2['default'].pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = _globalWindow2['default'].pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: Math.round(left),
    top: Math.round(top)
  };
}

/**
 * Get pointer position in element
 * Returns an object with x and y coordinates.
 * The base on the coordinates are the bottom left of the element.
 *
 * @function getPointerPosition
 * @param {Element} el Element on which to get the pointer position on
 * @param {Event} event Event object
 * @return {Object} This object will have x and y coordinates corresponding to the mouse position
 */

function getPointerPosition(el, event) {
  var position = {};
  var box = findElPosition(el);
  var boxW = el.offsetWidth;
  var boxH = el.offsetHeight;

  var boxY = box.top;
  var boxX = box.left;
  var pageY = event.pageY;
  var pageX = event.pageX;

  if (event.changedTouches) {
    pageX = event.changedTouches[0].pageX;
    pageY = event.changedTouches[0].pageY;
  }

  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));

  return position;
}

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @function isEl
 * @param    {Mixed} value
 * @return   {Boolean}
 */

function isEl(value) {
  return !!value && typeof value === 'object' && value.nodeType === 1;
}

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @param  {Mixed} value
 * @return {Boolean}
 */

function isTextNode(value) {
  return !!value && typeof value === 'object' && value.nodeType === 3;
}

/**
 * Empties the contents of an element.
 *
 * @function emptyEl
 * @param    {Element} el
 * @return   {Element}
 */

function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}

/**
 * Normalizes content for eventual insertion into the DOM.
 *
 * This allows a wide range of content definition methods, but protects
 * from falling into the trap of simply writing to `innerHTML`, which is
 * an XSS concern.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @function normalizeContent
 * @param    {String|Element|TextNode|Array|Function} content
 * @return   {Array}
 */

function normalizeContent(content) {

  // First, invoke content if it is a function. If it produces an array,
  // that needs to happen before normalization.
  if (typeof content === 'function') {
    content = content();
  }

  // Next up, normalize to an array, so one or many items can be normalized,
  // filtered, and returned.
  return (Array.isArray(content) ? content : [content]).map(function (value) {

    // First, invoke value if it is a function to produce a new value,
    // which will be subsequently normalized to a Node of some kind.
    if (typeof value === 'function') {
      value = value();
    }

    if (isEl(value) || isTextNode(value)) {
      return value;
    }

    if (typeof value === 'string' && /\S/.test(value)) {
      return _globalDocument2['default'].createTextNode(value);
    }
  }).filter(function (value) {
    return value;
  });
}

/**
 * Normalizes and appends content to an element.
 *
 * @function appendContent
 * @param    {Element} el
 * @param    {String|Element|TextNode|Array|Function} content
 *           See: `normalizeContent`
 * @return   {Element}
 */

function appendContent(el, content) {
  normalizeContent(content).forEach(function (node) {
    return el.appendChild(node);
  });
  return el;
}

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * @function insertContent
 * @param    {Element} el
 * @param    {String|Element|TextNode|Array|Function} content
 *           See: `normalizeContent`
 * @return   {Element}
 */

function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}

/**
 * Finds a single DOM element matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @function $
 * @param    {String} selector
 *           A valid CSS selector, which will be passed to `querySelector`.
 *
 * @param    {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return   {Element|null}
 */
var $ = createQuerier('querySelector');

exports.$ = $;
/**
 * Finds a all DOM elements matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @function $$
 * @param    {String} selector
 *           A valid CSS selector, which will be passed to `querySelectorAll`.
 *
 * @param    {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return   {NodeList}
 */
var $$ = createQuerier('querySelectorAll');
exports.$$ = $$;

},{"./guid.js":146,"./log.js":147,"global/document":1,"global/window":2,"tsml":55}],143:[function(_dereq_,module,exports){
/**
 * @file events.js
 *
 * Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 */

'use strict';

exports.__esModule = true;
exports.on = on;
exports.off = off;
exports.trigger = trigger;
exports.one = one;
exports.fixEvent = fixEvent;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _domJs = _dereq_('./dom.js');

var Dom = _interopRequireWildcard(_domJs);

var _guidJs = _dereq_('./guid.js');

var Guid = _interopRequireWildcard(_guidJs);

var _logJs = _dereq_('./log.js');

var _logJs2 = _interopRequireDefault(_logJs);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 * @method on
 */

function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = Dom.getElData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) data.handlers = {};

  if (!data.handlers[type]) data.handlers[type] = [];

  if (!fn.guid) fn.guid = Guid.newGUID();

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event, hash) {

      if (data.disabled) return;
      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash);
            } catch (e) {
              _logJs2['default'].error(e);
            }
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      elem.addEventListener(type, data.dispatcher, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

/**
 * Removes event listeners from an element
 *
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 * @method off
 */

function off(elem, type, fn) {
  // Don't want to add a cache object through getElData if not needed
  if (!Dom.hasElData(elem)) return;

  var data = Dom.getElData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    _cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) return;

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

/**
 * Trigger an event for an element
 *
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 * @param  {Object} [hash] data hash to pass along with the event
 * @return {Boolean=} Returned only if default was prevented
 * @method trigger
 */

function trigger(elem, event, hash) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasElData first.
  var elemData = Dom.hasElData(elem) ? Dom.getElData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
      var targetData = Dom.getElData(event.target);

      // Checks if the target has a default action for this event.
      if (event.target[event.type]) {
        // Temporarily disables event dispatching on the target as we have already executed the handler.
        targetData.disabled = true;
        // Executes the default action.
        if (typeof event.target[event.type] === 'function') {
          event.target[event.type]();
        }
        // Re-enables event dispatching.
        targetData.disabled = false;
      }
    }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

/**
 * Trigger a listener only once for an event
 *
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type Name/type of event
 * @param  {Function} fn Event handler function
 * @method one
 */

function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };
  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || Guid.newGUID();
  on(elem, type, func);
}

/**
 * Fix a native event to have standard property values
 *
 * @param  {Object} event Event object to fix
 * @return {Object}
 * @private
 * @method fixEvent
 */

function fixEvent(event) {

  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || _globalWindow2['default'].event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      // and webkitMovementX/Y
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || _globalDocument2['default'];
    }

    // Handle which other element the event is related to
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = _globalDocument2['default'].documentElement,
          body = _globalDocument2['default'].body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Clean up the listener cache and dispatchers
*
 * @param  {Element|Object} elem Element to clean up
 * @param  {String} type Type of event to clean up
 * @private
 * @method _cleanUpEvents
 */
function _cleanUpEvents(elem, type) {
  var data = Dom.getElData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }

  // Finally remove the element data if there is no data left
  if (Object.getOwnPropertyNames(data).length === 0) {
    Dom.removeElData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 *
 * @param  {Function} fn   The event method we want to use.
 * @param  {Element|Object} elem Element or object to bind listeners to
 * @param  {String}   type Type of event to bind to.
 * @param  {Function} callback   Event listener.
 * @private
 * @function _handleMultipleEvents
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    //Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

},{"./dom.js":142,"./guid.js":146,"./log.js":147,"global/document":1,"global/window":2}],144:[function(_dereq_,module,exports){
/**
 * @file fn.js
 */
'use strict';

exports.__esModule = true;

var _guidJs = _dereq_('./guid.js');

/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
 * It also stores a unique id on the function so it can be easily removed from events
 *
 * @param  {*}   context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}   uid     An optional unique ID for the function to be set
 * @return {Function}
 * @private
 * @method bind
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = _guidJs.newGUID();
  }

  // Create the new function that changes the context
  var ret = function ret() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  ret.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return ret;
};
exports.bind = bind;

},{"./guid.js":146}],145:[function(_dereq_,module,exports){
/**
 * @file format-time.js
 *
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @private
 * @function formatTime
 */
'use strict';

exports.__esModule = true;
function formatTime(seconds) {
  var guide = arguments.length <= 1 || arguments[1] === undefined ? seconds : arguments[1];
  return (function () {
    seconds = seconds < 0 ? 0 : seconds;
    var s = Math.floor(seconds % 60);
    var m = Math.floor(seconds / 60 % 60);
    var h = Math.floor(seconds / 3600);
    var gm = Math.floor(guide / 60 % 60);
    var gh = Math.floor(guide / 3600);

    // handle invalid times
    if (isNaN(seconds) || seconds === Infinity) {
      // '-' is false for all relational operators (e.g. <, >=) so this setting
      // will add the minimum number of fields specified by the guide
      h = m = s = '-';
    }

    // Check if we need to show hours
    h = h > 0 || gh > 0 ? h + ':' : '';

    // If hours are showing, we may need to add a leading zero.
    // Always show at least one digit of minutes.
    m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

    // Check if leading zero is need for seconds
    s = s < 10 ? '0' + s : s;

    return h + m + s;
  })();
}

exports['default'] = formatTime;
module.exports = exports['default'];

},{}],146:[function(_dereq_,module,exports){
/**
 * @file guid.js
 *
 * Unique ID for an element or function
 * @type {Number}
 * @private
 */
"use strict";

exports.__esModule = true;
exports.newGUID = newGUID;
var _guid = 1;

/**
 * Get the next unique ID
 *
 * @return {String} 
 * @function newGUID
 */

function newGUID() {
  return _guid++;
}

},{}],147:[function(_dereq_,module,exports){
/**
 * @file log.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _browser = _dereq_('./browser');

/**
 * Log messages to the console and history based on the type of message
 *
 * @param  {String} type
 *         The name of the console method to use.
 * @param  {Array} args
 *         The arguments to be passed to the matching console method.
 * @param  {Boolean} [stringify]
 *         By default, only old IEs should get console argument stringification,
 *         but this is exposed as a parameter to facilitate testing.
 */
var logByType = function logByType(type, args) {
  var stringify = arguments.length <= 2 || arguments[2] === undefined ? !!_browser.IE_VERSION && _browser.IE_VERSION < 11 : arguments[2];

  var console = _globalWindow2['default'].console;

  // If there's no console then don't try to output messages, but they will
  // still be stored in `log.history`.
  //
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  // when the module is executed.
  var fn = console && console[type] || function () {};

  if (type !== 'log') {

    // add the type to the front of the message when it's not "log"
    args.unshift(type.toUpperCase() + ':');
  }

  // add to history
  log.history.push(args);

  // add console prefix after adding to history
  args.unshift('VIDEOJS:');

  // IEs previous to 11 log objects uselessly as "[object Object]"; so, JSONify
  // objects and arrays for those less-capable browsers.
  if (stringify) {
    args = args.map(function (a) {
      if (a && typeof a === 'object' || Array.isArray(a)) {
        try {
          return JSON.stringify(a);
        } catch (x) {}
      }

      // Cast to string before joining, so we get null and undefined explicitly
      // included in output (as we would in a modern console).
      return String(a);
    }).join(' ');
  }

  // Old IE versions do not allow .apply() for console methods (they are
  // reported as objects rather than functions).
  if (!fn.apply) {
    fn(args);
  } else {
    fn[Array.isArray(args) ? 'apply' : 'call'](console, args);
  }
};

exports.logByType = logByType;
/**
 * Log plain debug messages
 *
 * @function log
 */
function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  logByType('log', args);
}

/**
 * Keep a history of log messages
 *
 * @type {Array}
 */
log.history = [];

/**
 * Log error messages
 *
 * @method error
 */
log.error = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return logByType('error', args);
};

/**
 * Log warning messages
 *
 * @method warn
 */
log.warn = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return logByType('warn', args);
};

exports['default'] = log;

},{"./browser":140,"global/window":2}],148:[function(_dereq_,module,exports){
/**
 * @file merge-options.js
 */
'use strict';

exports.__esModule = true;
exports['default'] = mergeOptions;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodashCompatObjectMerge = _dereq_('lodash-compat/object/merge');

var _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);

function isPlain(obj) {
  return !!obj && typeof obj === 'object' && obj.toString() === '[object Object]' && obj.constructor === Object;
}

/**
 * Merge customizer. video.js simply overwrites non-simple objects
 * (like arrays) instead of attempting to overlay them.
 * @see https://lodash.com/docs#merge
 */
var customizer = function customizer(destination, source) {
  // If we're not working with a plain object, copy the value as is
  // If source is an array, for instance, it will replace destination
  if (!isPlain(source)) {
    return source;
  }

  // If the new value is a plain object but the first object value is not
  // we need to create a new object for the first object to merge with.
  // This makes it consistent with how merge() works by default
  // and also protects from later changes the to first object affecting
  // the second object's values.
  if (!isPlain(destination)) {
    return mergeOptions(source);
  }
};

/**
 * Merge one or more options objects, recursively merging **only**
 * plain object properties.  Previously `deepMerge`.
 *
 * @param  {...Object} source One or more objects to merge
 * @returns {Object}          a new object that is the union of all
 * provided objects
 * @function mergeOptions
 */

function mergeOptions() {
  // contruct the call dynamically to handle the variable number of
  // objects to merge
  var args = Array.prototype.slice.call(arguments);

  // unshift an empty object into the front of the call as the target
  // of the merge
  args.unshift({});

  // customize conflict resolution to match our historical merge behavior
  args.push(customizer);

  _lodashCompatObjectMerge2['default'].apply(null, args);

  // return the mutated result object
  return args[0];
}

module.exports = exports['default'];

},{"lodash-compat/object/merge":40}],149:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var createStyleElement = function createStyleElement(className) {
  var style = _globalDocument2['default'].createElement('style');
  style.className = className;

  return style;
};

exports.createStyleElement = createStyleElement;
var setTextContent = function setTextContent(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};
exports.setTextContent = setTextContent;

},{"global/document":1}],150:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;
exports.createTimeRanges = createTimeRanges;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _logJs = _dereq_('./log.js');

var _logJs2 = _interopRequireDefault(_logJs);

/**
 * @file time-ranges.js
 *
 * Should create a fake TimeRange object
 * Mimics an HTML5 time range instance, which has functions that
 * return the start and end times for a range
 * TimeRanges are returned by the buffered() method
 *
 * @param  {(Number|Array)} Start of a single range or an array of ranges
 * @param  {Number} End of a single range
 * @private
 * @method createTimeRanges
 */

function createTimeRanges(start, end) {
  if (Array.isArray(start)) {
    return createTimeRangesObj(start);
  } else if (start === undefined || end === undefined) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

exports.createTimeRange = createTimeRanges;

function createTimeRangesObj(ranges) {
  if (ranges === undefined || ranges.length === 0) {
    return {
      length: 0,
      start: function start() {
        throw new Error('This TimeRanges object is empty');
      },
      end: function end() {
        throw new Error('This TimeRanges object is empty');
      }
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, 'start', 0, ranges),
    end: getRange.bind(null, 'end', 1, ranges)
  };
}

function getRange(fnName, valueIndex, ranges, rangeIndex) {
  if (rangeIndex === undefined) {
    _logJs2['default'].warn('DEPRECATED: Function \'' + fnName + '\' on \'TimeRanges\' called without an index argument.');
    rangeIndex = 0;
  }
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}

function rangeCheck(fnName, index, maxIndex) {
  if (index < 0 || index > maxIndex) {
    throw new Error('Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is greater than or equal to the maximum bound (' + maxIndex + ').');
  }
}

},{"./log.js":147}],151:[function(_dereq_,module,exports){
/**
 * @file to-title-case.js
 *
 * Uppercase the first letter of a string
 *
 * @param  {String} string String to be uppercased
 * @return {String}
 * @private
 * @method toTitleCase
 */
"use strict";

exports.__esModule = true;
function toTitleCase(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

exports["default"] = toTitleCase;
module.exports = exports["default"];

},{}],152:[function(_dereq_,module,exports){
/**
 * @file url.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

/**
 * Resolve and parse the elements of a URL
 *
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 * @method parseUrl
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = _globalDocument2['default'].createElement('a');
  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = undefined;
  if (addToBody) {
    div = _globalDocument2['default'].createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    _globalDocument2['default'].body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }
  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    _globalDocument2['default'].body.removeChild(div);
  }

  return details;
};

exports.parseUrl = parseUrl;
/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 *
 * @param  {String} url URL to make absolute
 * @return {String}     Absolute URL
 * @private
 * @method getAbsoluteURL
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = _globalDocument2['default'].createElement('div');
    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

exports.getAbsoluteURL = getAbsoluteURL;
/**
 * Returns the extension of the passed file name. It will return an empty string if you pass an invalid path
 *
 * @param {String}    path    The fileName path like '/path/to/file.mp4'
 * @returns {String}          The extension in lower case or an empty string if no extension could be found.
 * @method getFileExtension
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

exports.getFileExtension = getFileExtension;
/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {String} url The url to check
 * @return {Boolean}   Whether it is a cross domain request or not
 * @method isCrossOrigin
 */
var isCrossOrigin = function isCrossOrigin(url) {
  var winLoc = _globalWindow2['default'].location;
  var urlInfo = parseUrl(url);

  // IE8 protocol relative urls will return ':' for protocol
  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  return crossOrigin;
};
exports.isCrossOrigin = isCrossOrigin;

},{"global/document":1,"global/window":2}],153:[function(_dereq_,module,exports){
/**
 * @file video.js
 */
'use strict';

exports.__esModule = true;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _globalWindow = _dereq_('global/window');

var _globalWindow2 = _interopRequireDefault(_globalWindow);

var _globalDocument = _dereq_('global/document');

var _globalDocument2 = _interopRequireDefault(_globalDocument);

var _setup = _dereq_('./setup');

var setup = _interopRequireWildcard(_setup);

var _utilsStylesheetJs = _dereq_('./utils/stylesheet.js');

var stylesheet = _interopRequireWildcard(_utilsStylesheetJs);

var _component = _dereq_('./component');

var _component2 = _interopRequireDefault(_component);

var _eventTarget = _dereq_('./event-target');

var _eventTarget2 = _interopRequireDefault(_eventTarget);

var _utilsEventsJs = _dereq_('./utils/events.js');

var Events = _interopRequireWildcard(_utilsEventsJs);

var _player = _dereq_('./player');

var _player2 = _interopRequireDefault(_player);

var _pluginsJs = _dereq_('./plugins.js');

var _pluginsJs2 = _interopRequireDefault(_pluginsJs);

var _srcJsUtilsMergeOptionsJs = _dereq_('../../src/js/utils/merge-options.js');

var _srcJsUtilsMergeOptionsJs2 = _interopRequireDefault(_srcJsUtilsMergeOptionsJs);

var _utilsFnJs = _dereq_('./utils/fn.js');

var Fn = _interopRequireWildcard(_utilsFnJs);

var _tracksTextTrackJs = _dereq_('./tracks/text-track.js');

var _tracksTextTrackJs2 = _interopRequireDefault(_tracksTextTrackJs);

var _tracksAudioTrackJs = _dereq_('./tracks/audio-track.js');

var _tracksAudioTrackJs2 = _interopRequireDefault(_tracksAudioTrackJs);

var _tracksVideoTrackJs = _dereq_('./tracks/video-track.js');

var _tracksVideoTrackJs2 = _interopRequireDefault(_tracksVideoTrackJs);

var _utilsTimeRangesJs = _dereq_('./utils/time-ranges.js');

var _utilsFormatTimeJs = _dereq_('./utils/format-time.js');

var _utilsFormatTimeJs2 = _interopRequireDefault(_utilsFormatTimeJs);

var _utilsLogJs = _dereq_('./utils/log.js');

var _utilsLogJs2 = _interopRequireDefault(_utilsLogJs);

var _utilsDomJs = _dereq_('./utils/dom.js');

var Dom = _interopRequireWildcard(_utilsDomJs);

var _utilsBrowserJs = _dereq_('./utils/browser.js');

var browser = _interopRequireWildcard(_utilsBrowserJs);

var _utilsUrlJs = _dereq_('./utils/url.js');

var Url = _interopRequireWildcard(_utilsUrlJs);

var _extendJs = _dereq_('./extend.js');

var _extendJs2 = _interopRequireDefault(_extendJs);

var _lodashCompatObjectMerge = _dereq_('lodash-compat/object/merge');

var _lodashCompatObjectMerge2 = _interopRequireDefault(_lodashCompatObjectMerge);

var _xhr = _dereq_('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

// Include the built-in techs

var _techTechJs = _dereq_('./tech/tech.js');

var _techTechJs2 = _interopRequireDefault(_techTechJs);

var _techHtml5Js = _dereq_('./tech/html5.js');

var _techHtml5Js2 = _interopRequireDefault(_techHtml5Js);

var _techFlashJs = _dereq_('./tech/flash.js');

var _techFlashJs2 = _interopRequireDefault(_techFlashJs);

// HTML5 Element Shim for IE8
if (typeof HTMLVideoElement === 'undefined') {
  _globalDocument2['default'].createElement('video');
  _globalDocument2['default'].createElement('audio');
  _globalDocument2['default'].createElement('track');
}

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 * The `videojs` function can be used to initialize or retrieve a player.
 * ```js
 *     var myPlayer = videojs('my_video_id');
 * ```
 *
 * @param  {String|Element} id      Video element or video element ID
 * @param  {Object=} options        Optional options object for config/settings
 * @param  {Function=} ready        Optional ready callback
 * @return {Player}                 A player instance
 * @mixes videojs
 * @method videojs
 */
function videojs(id, options, ready) {
  var tag = undefined; // Element of ID

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (videojs.getPlayers()[id]) {

      // If options or ready funtion are passed, warn
      if (options) {
        _utilsLogJs2['default'].warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        videojs.getPlayers()[id].ready(ready);
      }

      return videojs.getPlayers()[id];

      // Otherwise get element for ID
    } else {
        tag = Dom.getEl(id);
      }

    // ID is a media element
  } else {
      tag = id;
    }

  // Check for a useable element
  if (!tag || !tag.nodeName) {
    // re: nodeName, could be a box div also
    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
  }

  // Element may have a player attr referring to an already created player instance.
  // If not, set up a new player and return the instance.
  return tag['player'] || _player2['default'].players[tag.playerId] || new _player2['default'](tag, options, ready);
}

// Add default styles
if (_globalWindow2['default'].VIDEOJS_NO_DYNAMIC_STYLE !== true) {
  var style = Dom.$('.vjs-styles-defaults');

  if (!style) {
    style = stylesheet.createStyleElement('vjs-styles-defaults');
    var head = Dom.$('head');
    head.insertBefore(style, head.firstChild);
    stylesheet.setTextContent(style, '\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ');
  }
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
setup.autoSetupTimeout(1, videojs);

/*
 * Current software version (semver)
 *
 * @type {String}
 */
videojs.VERSION = '5.11.7';

/**
 * The global options object. These are the settings that take effect
 * if no overrides are specified when the player is created.
 *
 * ```js
 *     videojs.options.autoplay = true
 *     // -> all players will autoplay by default
 * ```
 *
 * @type {Object}
 */
videojs.options = _player2['default'].prototype.options_;

/**
 * Get an object with the currently created players, keyed by player ID
 *
 * @return {Object} The created players
 * @mixes videojs
 * @method getPlayers
 */
videojs.getPlayers = function () {
  return _player2['default'].players;
};

/**
 * Expose players object.
 *
 * @memberOf videojs
 * @property {Object} players
 */
videojs.players = _player2['default'].players;

/**
 * Get a component class object by name
 * ```js
 *     var VjsButton = videojs.getComponent('Button');
 *     // Create a new instance of the component
 *     var myButton = new VjsButton(myPlayer);
 * ```
 *
 * @return {Component} Component identified by name
 * @mixes videojs
 * @method getComponent
 */
videojs.getComponent = _component2['default'].getComponent;

/**
 * Register a component so it can referred to by name
 * Used when adding to other
 * components, either through addChild
 * `component.addChild('myComponent')`
 * or through default children options
 * `{ children: ['myComponent'] }`.
 * ```js
 *     // Get a component to subclass
 *     var VjsButton = videojs.getComponent('Button');
 *     // Subclass the component (see 'extend' doc for more info)
 *     var MySpecialButton = videojs.extend(VjsButton, {});
 *     // Register the new component
 *     VjsButton.registerComponent('MySepcialButton', MySepcialButton);
 *     // (optionally) add the new component as a default player child
 *     myPlayer.addChild('MySepcialButton');
 * ```
 * NOTE: You could also just initialize the component before adding.
 * `component.addChild(new MyComponent());`
 *
 * @param {String} The class name of the component
 * @param {Component} The component class
 * @return {Component} The newly registered component
 * @mixes videojs
 * @method registerComponent
 */
videojs.registerComponent = function (name, comp) {
  if (_techTechJs2['default'].isTech(comp)) {
    _utilsLogJs2['default'].warn('The ' + name + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');
  }

  _component2['default'].registerComponent.call(_component2['default'], name, comp);
};

/**
 * Get a Tech class object by name
 * ```js
 *     var Html5 = videojs.getTech('Html5');
 *     // Create a new instance of the component
 *     var html5 = new Html5(options);
 * ```
 *
 * @return {Tech} Tech identified by name
 * @mixes videojs
 * @method getComponent
 */
videojs.getTech = _techTechJs2['default'].getTech;

/**
 * Register a Tech so it can referred to by name.
 * This is used in the tech order for the player.
 *
 * ```js
 *     // get the Html5 Tech
 *     var Html5 = videojs.getTech('Html5');
 *     var MyTech = videojs.extend(Html5, {});
 *     // Register the new Tech
 *     VjsButton.registerTech('Tech', MyTech);
 *     var player = videojs('myplayer', {
 *       techOrder: ['myTech', 'html5']
 *     });
 * ```
 *
 * @param {String} The class name of the tech
 * @param {Tech} The tech class
 * @return {Tech} The newly registered Tech
 * @mixes videojs
 * @method registerTech
 */
videojs.registerTech = _techTechJs2['default'].registerTech;

/**
 * A suite of browser and device tests
 *
 * @type {Object}
 * @private
 */
videojs.browser = browser;

/**
 * Whether or not the browser supports touch events. Included for backward
 * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`
 * instead going forward.
 *
 * @deprecated
 * @type {Boolean}
 */
videojs.TOUCH_ENABLED = browser.TOUCH_ENABLED;

/**
 * Subclass an existing class
 * Mimics ES6 subclassing with the `extend` keyword
 * ```js
 *     // Create a basic javascript 'class'
 *     function MyClass(name){
 *       // Set a property at initialization
 *       this.myName = name;
 *     }
 *     // Create an instance method
 *     MyClass.prototype.sayMyName = function(){
 *       alert(this.myName);
 *     };
 *     // Subclass the exisitng class and change the name
 *     // when initializing
 *     var MySubClass = videojs.extend(MyClass, {
 *       constructor: function(name) {
 *         // Call the super class constructor for the subclass
 *         MyClass.call(this, name)
 *       }
 *     });
 *     // Create an instance of the new sub class
 *     var myInstance = new MySubClass('John');
 *     myInstance.sayMyName(); // -> should alert "John"
 * ```
 *
 * @param {Function} The Class to subclass
 * @param {Object} An object including instace methods for the new class
 *                   Optionally including a `constructor` function
 * @return {Function} The newly created subclass
 * @mixes videojs
 * @method extend
 */
videojs.extend = _extendJs2['default'];

/**
 * Merge two options objects recursively
 * Performs a deep merge like lodash.merge but **only merges plain objects**
 * (not arrays, elements, anything else)
 * Other values will be copied directly from the second object.
 * ```js
 *     var defaultOptions = {
 *       foo: true,
 *       bar: {
 *         a: true,
 *         b: [1,2,3]
 *       }
 *     };
 *     var newOptions = {
 *       foo: false,
 *       bar: {
 *         b: [4,5,6]
 *       }
 *     };
 *     var result = videojs.mergeOptions(defaultOptions, newOptions);
 *     // result.foo = false;
 *     // result.bar.a = true;
 *     // result.bar.b = [4,5,6];
 * ```
 *
 * @param {Object} defaults  The options object whose values will be overriden
 * @param {Object} overrides The options object with values to override the first
 * @param {Object} etc       Any number of additional options objects
 *
 * @return {Object} a new object with the merged values
 * @mixes videojs
 * @method mergeOptions
 */
videojs.mergeOptions = _srcJsUtilsMergeOptionsJs2['default'];

/**
 * Change the context (this) of a function
 *
 *     videojs.bind(newContext, function(){
 *       this === newContext
 *     });
 *
 * NOTE: as of v5.0 we require an ES5 shim, so you should use the native
 * `function(){}.bind(newContext);` instead of this.
 *
 * @param  {*}        context The object to bind as scope
 * @param  {Function} fn      The function to be bound to a scope
 * @param  {Number=}  uid     An optional unique ID for the function to be set
 * @return {Function}
 */
videojs.bind = Fn.bind;

/**
 * Create a Video.js player plugin
 * Plugins are only initialized when options for the plugin are included
 * in the player options, or the plugin function on the player instance is
 * called.
 * **See the plugin guide in the docs for a more detailed example**
 * ```js
 *     // Make a plugin that alerts when the player plays
 *     videojs.plugin('myPlugin', function(myPluginOptions) {
 *       myPluginOptions = myPluginOptions || {};
 *
 *       var player = this;
 *       var alertText = myPluginOptions.text || 'Player is playing!'
 *
 *       player.on('play', function(){
 *         alert(alertText);
 *       });
 *     });
 *     // USAGE EXAMPLES
 *     // EXAMPLE 1: New player with plugin options, call plugin immediately
 *     var player1 = videojs('idOne', {
 *       myPlugin: {
 *         text: 'Custom text!'
 *       }
 *     });
 *     // Click play
 *     // --> Should alert 'Custom text!'
 *     // EXAMPLE 3: New player, initialize plugin later
 *     var player3 = videojs('idThree');
 *     // Click play
 *     // --> NO ALERT
 *     // Click pause
 *     // Initialize plugin using the plugin function on the player instance
 *     player3.myPlugin({
 *       text: 'Plugin added later!'
 *     });
 *     // Click play
 *     // --> Should alert 'Plugin added later!'
 * ```
 *
 * @param {String} name The plugin name
 * @param {Function} fn The plugin function that will be called with options
 * @mixes videojs
 * @method plugin
 */
videojs.plugin = _pluginsJs2['default'];

/**
 * Adding languages so that they're available to all players.
 * ```js
 *     videojs.addLanguage('es', { 'Hello': 'Hola' });
 * ```
 *
 * @param  {String} code The language code or dictionary property
 * @param  {Object} data The data values to be translated
 * @return {Object} The resulting language dictionary object
 * @mixes videojs
 * @method addLanguage
 */
videojs.addLanguage = function (code, data) {
  var _merge;

  code = ('' + code).toLowerCase();
  return _lodashCompatObjectMerge2['default'](videojs.options.languages, (_merge = {}, _merge[code] = data, _merge))[code];
};

/**
 * Log debug messages.
 *
 * @param {...Object} messages One or more messages to log
 */
videojs.log = _utilsLogJs2['default'];

/**
 * Creates an emulated TimeRange object.
 *
 * @param  {Number|Array} start Start time in seconds or an array of ranges
 * @param  {Number} end   End time in seconds
 * @return {Object}       Fake TimeRange object
 * @method createTimeRange
 */
videojs.createTimeRange = videojs.createTimeRanges = _utilsTimeRangesJs.createTimeRanges;

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @param  {Number} seconds Number of seconds to be turned into a string
 * @param  {Number} guide   Number (in seconds) to model the string after
 * @return {String}         Time formatted as H:MM:SS or M:SS
 * @method formatTime
 */
videojs.formatTime = _utilsFormatTimeJs2['default'];

/**
 * Resolve and parse the elements of a URL
 *
 * @param  {String} url The url to parse
 * @return {Object}     An object of url details
 * @method parseUrl
 */
videojs.parseUrl = Url.parseUrl;

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {String} url The url to check
 * @return {Boolean}   Whether it is a cross domain request or not
 * @method isCrossOrigin
 */
videojs.isCrossOrigin = Url.isCrossOrigin;

/**
 * Event target class.
 *
 * @type {Function}
 */
videojs.EventTarget = _eventTarget2['default'];

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param  {Element|Object}   elem Element or object to bind listeners to
 * @param  {String|Array}   type Type of event to bind to.
 * @param  {Function} fn   Event listener.
 * @method on
 */
videojs.on = Events.on;

/**
 * Trigger a listener only once for an event
 *
 * @param  {Element|Object}   elem Element or object to
 * @param  {String|Array}   type Name/type of event
 * @param  {Function} fn Event handler function
 * @method one
 */
videojs.one = Events.one;

/**
 * Removes event listeners from an element
 *
 * @param  {Element|Object}   elem Object to remove listeners from
 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
 * @method off
 */
videojs.off = Events.off;

/**
 * Trigger an event for an element
 *
 * @param  {Element|Object}      elem  Element to trigger an event on
 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
 * @param  {Object} [hash] data hash to pass along with the event
 * @return {Boolean=} Returned only if default was prevented
 * @method trigger
 */
videojs.trigger = Events.trigger;

/**
 * A cross-browser XMLHttpRequest wrapper. Here's a simple example:
 *
 *     videojs.xhr({
 *       body: someJSONString,
 *       uri: "/foo",
 *       headers: {
 *         "Content-Type": "application/json"
 *       }
 *     }, function (err, resp, body) {
 *       // check resp.statusCode
 *     });
 *
 * Check out the [full
 * documentation](https://github.com/Raynos/xhr/blob/v2.1.0/README.md)
 * for more options.
 *
 * @param {Object} options settings for the request.
 * @return {XMLHttpRequest|XDomainRequest} the request object.
 * @see https://github.com/Raynos/xhr
 */
videojs.xhr = _xhr2['default'];

/**
 * TextTrack class
 *
 * @type {Function}
 */
videojs.TextTrack = _tracksTextTrackJs2['default'];

/**
 * export the AudioTrack class so that source handlers can create
 * AudioTracks and then add them to the players AudioTrackList
 *
 * @type {Function}
 */
videojs.AudioTrack = _tracksAudioTrackJs2['default'];

/**
 * export the VideoTrack class so that source handlers can create
 * VideoTracks and then add them to the players VideoTrackList
 *
 * @type {Function}
 */
videojs.VideoTrack = _tracksVideoTrackJs2['default'];

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @method isEl
 * @param  {Mixed} value
 * @return {Boolean}
 */
videojs.isEl = Dom.isEl;

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @method isTextNode
 * @param  {Mixed} value
 * @return {Boolean}
 */
videojs.isTextNode = Dom.isTextNode;

/**
 * Creates an element and applies properties.
 *
 * @method createEl
 * @param  {String} [tagName='div'] Name of tag to be created.
 * @param  {Object} [properties={}] Element properties to be applied.
 * @param  {Object} [attributes={}] Element attributes to be applied.
 * @return {Element}
 */
videojs.createEl = Dom.createEl;

/**
 * Check if an element has a CSS class
 *
 * @method hasClass
 * @param {Element} element Element to check
 * @param {String} classToCheck Classname to check
 */
videojs.hasClass = Dom.hasElClass;

/**
 * Add a CSS class name to an element
 *
 * @method addClass
 * @param {Element} element    Element to add class name to
 * @param {String} classToAdd Classname to add
 */
videojs.addClass = Dom.addElClass;

/**
 * Remove a CSS class name from an element
 *
 * @method removeClass
 * @param {Element} element    Element to remove from class name
 * @param {String} classToRemove Classname to remove
 */
videojs.removeClass = Dom.removeElClass;

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @method toggleElClass
 * @param  {Element} element
 * @param  {String} classToToggle
 * @param  {Boolean|Function} [predicate]
 *         Can be a function that returns a Boolean. If `true`, the class
 *         will be added; if `false`, the class will be removed. If not
 *         given, the class will be added if not present and vice versa.
 */
videojs.toggleClass = Dom.toggleElClass;

/**
 * Apply attributes to an HTML element.
 *
 * @method setAttributes
 * @param  {Element} el         Target element.
 * @param  {Object=} attributes Element attributes to be applied.
 */
videojs.setAttributes = Dom.setElAttributes;

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @method getAttributes
 * @param  {Element} tag Element from which to get tag attributes
 * @return {Object}
 */
videojs.getAttributes = Dom.getElAttributes;

/**
 * Empties the contents of an element.
 *
 * @method emptyEl
 * @param  {Element} el
 * @return {Element}
 */
videojs.emptyEl = Dom.emptyEl;

/**
 * Normalizes and appends content to an element.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @method appendContent
 * @param  {Element} el
 * @param  {String|Element|TextNode|Array|Function} content
 * @return {Element}
 */
videojs.appendContent = Dom.appendContent;

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @method insertContent
 * @param  {Element} el
 * @param  {String|Element|TextNode|Array|Function} content
 * @return {Element}
 */
videojs.insertContent = Dom.insertContent;

/*
 * Custom Universal Module Definition (UMD)
 *
 * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
 * still support requirejs and browserify. This also needs to be closure
 * compiler compatible, so string keys are used.
 */
if (typeof define === 'function' && define['amd']) {
  define('videojs', [], function () {
    return videojs;
  });

  // checking that module is an object too because of umdjs/umd#35
} else if (typeof exports === 'object' && typeof module === 'object') {
    module['exports'] = videojs;
  }

exports['default'] = videojs;
module.exports = exports['default'];

},{"../../src/js/utils/merge-options.js":148,"./component":67,"./event-target":104,"./extend.js":105,"./player":113,"./plugins.js":114,"./setup":118,"./tech/flash.js":121,"./tech/html5.js":122,"./tech/tech.js":124,"./tracks/audio-track.js":126,"./tracks/text-track.js":134,"./tracks/video-track.js":139,"./utils/browser.js":140,"./utils/dom.js":142,"./utils/events.js":143,"./utils/fn.js":144,"./utils/format-time.js":145,"./utils/log.js":147,"./utils/stylesheet.js":149,"./utils/time-ranges.js":150,"./utils/url.js":152,"global/document":1,"global/window":2,"lodash-compat/object/merge":40,"xhr":56}]},{},[153])(153)
});


//# sourceMappingURL=video.js.map
/* vtt.js - v0.12.1 (https://github.com/mozilla/vtt.js) built on 08-07-2015 */

(function(root) {
  var vttjs = root.vttjs = {};
  var cueShim = vttjs.VTTCue;
  var regionShim = vttjs.VTTRegion;
  var oldVTTCue = root.VTTCue;
  var oldVTTRegion = root.VTTRegion;

  vttjs.shim = function() {
    vttjs.VTTCue = cueShim;
    vttjs.VTTRegion = regionShim;
  };

  vttjs.restore = function() {
    vttjs.VTTCue = oldVTTCue;
    vttjs.VTTRegion = oldVTTRegion;
  };
}(this));

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(root, vttjs) {

  var autoKeyword = "auto";
  var directionSetting = {
    "": true,
    "lr": true,
    "rl": true
  };
  var alignSetting = {
    "start": true,
    "middle": true,
    "end": true,
    "left": true,
    "right": true
  };

  function findDirectionSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = "";
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = "";
    var _snapToLines = true;
    var _line = "auto";
    var _lineAlign = "start";
    var _position = 50;
    var _positionAlign = "middle";
    var _size = 50;
    var _align = "middle";

    Object.defineProperty(cue,
      "id", extend({}, baseObj, {
        get: function() {
          return _id;
        },
        set: function(value) {
          _id = "" + value;
        }
      }));

    Object.defineProperty(cue,
      "pauseOnExit", extend({}, baseObj, {
        get: function() {
          return _pauseOnExit;
        },
        set: function(value) {
          _pauseOnExit = !!value;
        }
      }));

    Object.defineProperty(cue,
      "startTime", extend({}, baseObj, {
        get: function() {
          return _startTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "endTime", extend({}, baseObj, {
        get: function() {
          return _endTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "text", extend({}, baseObj, {
        get: function() {
          return _text;
        },
        set: function(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "region", extend({}, baseObj, {
        get: function() {
          return _region;
        },
        set: function(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "vertical", extend({}, baseObj, {
        get: function() {
          return _vertical;
        },
        set: function(value) {
          var setting = findDirectionSetting(value);
          // Have to check for false because the setting an be an empty string.
          if (setting === false) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "snapToLines", extend({}, baseObj, {
        get: function() {
          return _snapToLines;
        },
        set: function(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "line", extend({}, baseObj, {
        get: function() {
          return _line;
        },
        set: function(value) {
          if (typeof value !== "number" && value !== autoKeyword) {
            throw new SyntaxError("An invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "lineAlign", extend({}, baseObj, {
        get: function() {
          return _lineAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _lineAlign = setting;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "position", extend({}, baseObj, {
        get: function() {
          return _position;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "positionAlign", extend({}, baseObj, {
        get: function() {
          return _positionAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _positionAlign = setting;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "size", extend({}, baseObj, {
        get: function() {
          return _size;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      }));

    Object.defineProperty(cue,
      "align", extend({}, baseObj, {
        get: function() {
          return _align;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function() {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  root.VTTCue = root.VTTCue || VTTCue;
  vttjs.VTTCue = VTTCue;
}(this, (this.vttjs || {})));

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(root, vttjs) {

  var scrollSetting = {
    "": true,
    "up": true
  };

  function findScrollSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var scroll = scrollSetting[value.toLowerCase()];
    return scroll ? value.toLowerCase() : false;
  }

  function isValidPercentValue(value) {
    return typeof value === "number" && (value >= 0 && value <= 100);
  }

  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
  function VTTRegion() {
    var _width = 100;
    var _lines = 3;
    var _regionAnchorX = 0;
    var _regionAnchorY = 100;
    var _viewportAnchorX = 0;
    var _viewportAnchorY = 100;
    var _scroll = "";

    Object.defineProperties(this, {
      "width": {
        enumerable: true,
        get: function() {
          return _width;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("Width must be between 0 and 100.");
          }
          _width = value;
        }
      },
      "lines": {
        enumerable: true,
        get: function() {
          return _lines;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Lines must be set to a number.");
          }
          _lines = value;
        }
      },
      "regionAnchorY": {
        enumerable: true,
        get: function() {
          return _regionAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorX must be between 0 and 100.");
          }
          _regionAnchorY = value;
        }
      },
      "regionAnchorX": {
        enumerable: true,
        get: function() {
          return _regionAnchorX;
        },
        set: function(value) {
          if(!isValidPercentValue(value)) {
            throw new Error("RegionAnchorY must be between 0 and 100.");
          }
          _regionAnchorX = value;
        }
      },
      "viewportAnchorY": {
        enumerable: true,
        get: function() {
          return _viewportAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          }
          _viewportAnchorY = value;
        }
      },
      "viewportAnchorX": {
        enumerable: true,
        get: function() {
          return _viewportAnchorX;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          }
          _viewportAnchorX = value;
        }
      },
      "scroll": {
        enumerable: true,
        get: function() {
          return _scroll;
        },
        set: function(value) {
          var setting = findScrollSetting(value);
          // Have to check for false as an empty string is a legal value.
          if (setting === false) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _scroll = setting;
        }
      }
    });
  }

  root.VTTRegion = root.VTTRegion || VTTRegion;
  vttjs.VTTRegion = VTTRegion;
}(this, (this.vttjs || {})));

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

(function(global) {

  var _objCreate = Object.create || (function() {
    function F() {}
    return function(o) {
      if (arguments.length !== 1) {
        throw new Error('Object.create shim only accepts one parameter.');
      }
      F.prototype = o;
      return new F();
    };
  })();

  // Creates a new ParserError object from an errorData object. The errorData
  // object should have default code and message properties. The default message
  // property can be overriden by passing in a message parameter.
  // See ParsingError.Errors below for acceptable errors.
  function ParsingError(errorData, message) {
    this.name = "ParsingError";
    this.code = errorData.code;
    this.message = message || errorData.message;
  }
  ParsingError.prototype = _objCreate(Error.prototype);
  ParsingError.prototype.constructor = ParsingError;

  // ParsingError metadata for acceptable ParsingErrors.
  ParsingError.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };

  // Try to parse input as a time stamp.
  function parseTimeStamp(input) {

    function computeSeconds(h, m, s, f) {
      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
    }

    var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
    if (!m) {
      return null;
    }

    if (m[3]) {
      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
      return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
    } else if (m[1] > 59) {
      // Timestamp takes the form of [hours]:[minutes].[milliseconds]
      // First position is hours as it's over 59.
      return computeSeconds(m[1], m[2], 0,  m[4]);
    } else {
      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
      return computeSeconds(0, m[1], m[2], m[4]);
    }
  }

  // A settings object holds key/value pairs and will ignore anything but the first
  // assignment to a specific key.
  function Settings() {
    this.values = _objCreate(null);
  }

  Settings.prototype = {
    // Only accept the first assignment to any key.
    set: function(k, v) {
      if (!this.get(k) && v !== "") {
        this.values[k] = v;
      }
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    },
    // Check whether we have a value for a key.
    has: function(k) {
      return k in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function(k, v, a) {
      for (var n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function(k, v) {
      if (/^-?\d+$/.test(v)) { // integer
        this.set(k, parseInt(v, 10));
      }
    },
    // Accept a setting if its a valid percentage.
    percent: function(k, v) {
      var m;
      if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
        v = parseFloat(v);
        if (v >= 0 && v <= 100) {
          this.set(k, v);
          return true;
        }
      }
      return false;
    }
  };

  // Helper function to parse input into groups separated by 'groupDelim', and
  // interprete each group as a key/value pair separated by 'keyValueDelim'.
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
      if (typeof groups[i] !== "string") {
        continue;
      }
      var kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      var k = kv[0];
      var v = kv[1];
      callback(k, v);
    }
  }

  function parseCue(input, cue, regionList) {
    // Remember the original input if we need to throw an error.
    var oInput = input;
    // 4.1 WebVTT timestamp
    function consumeTimeStamp() {
      var ts = parseTimeStamp(input);
      if (ts === null) {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                              "Malformed timestamp: " + oInput);
      }
      // Remove time stamp from input.
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }

    // 4.4.2 WebVTT cue settings
    function consumeCueSettings(input, cue) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "region":
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k, v, ["rl", "lr"]);
          break;
        case "line":
          var vals = v.split(","),
              vals0 = vals[0];
          settings.integer(k, vals0);
          settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
          settings.alt(k, vals0, ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
          }
          break;
        case "position":
          vals = v.split(",");
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
          }
          break;
        case "size":
          settings.percent(k, v);
          break;
        case "align":
          settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
          break;
        }
      }, /:/, /\s/);

      // Apply default values for any missing fields.
      cue.region = settings.get("region", null);
      cue.vertical = settings.get("vertical", "");
      cue.line = settings.get("line", "auto");
      cue.lineAlign = settings.get("lineAlign", "start");
      cue.snapToLines = settings.get("snapToLines", true);
      cue.size = settings.get("size", 100);
      cue.align = settings.get("align", "middle");
      cue.position = settings.get("position", {
        start: 0,
        left: 0,
        middle: 50,
        end: 100,
        right: 100
      }, cue.align);
      cue.positionAlign = settings.get("positionAlign", {
        start: "start",
        left: "start",
        middle: "middle",
        end: "end",
        right: "end"
      }, cue.align);
    }

    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }

    // 4.1 WebVTT cue timings.
    skipWhitespace();
    cue.startTime = consumeTimeStamp();   // (1) collect cue start time
    skipWhitespace();
    if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                             "Malformed time stamp (time stamps must be separated by '-->'): " +
                             oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();     // (5) collect cue end time

    // 4.1 WebVTT cue settings list.
    skipWhitespace();
    consumeCueSettings(input, cue);
  }

  var ESCAPE = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&lrm;": "\u200e",
    "&rlm;": "\u200f",
    "&nbsp;": "\u00a0"
  };

  var TAG_NAME = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  };

  var TAG_ANNOTATION = {
    v: "title",
    lang: "lang"
  };

  var NEEDS_PARENT = {
    rt: "ruby"
  };

  // Parse content into a document fragment.
  function parseContent(window, input) {
    function nextToken() {
      // Check for end-of-string.
      if (!input) {
        return null;
      }

      // Consume 'n' characters from the input.
      function consume(result) {
        input = input.substr(result.length);
        return result;
      }

      var m = input.match(/^([^<]*)(<[^>]+>?)?/);
      // If there is some text before the next tag, return it, otherwise return
      // the tag.
      return consume(m[1] ? m[1] : m[2]);
    }

    // Unescape a string 's'.
    function unescape1(e) {
      return ESCAPE[e];
    }
    function unescape(s) {
      while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
        s = s.replace(m[0], unescape1);
      }
      return s;
    }

    function shouldAdd(current, element) {
      return !NEEDS_PARENT[element.localName] ||
             NEEDS_PARENT[element.localName] === current.localName;
    }

    // Create an element for this tag.
    function createElement(type, annotation) {
      var tagName = TAG_NAME[type];
      if (!tagName) {
        return null;
      }
      var element = window.document.createElement(tagName);
      element.localName = tagName;
      var name = TAG_ANNOTATION[type];
      if (name && annotation) {
        element[name] = annotation.trim();
      }
      return element;
    }

    var rootDiv = window.document.createElement("div"),
        current = rootDiv,
        t,
        tagStack = [];

    while ((t = nextToken()) !== null) {
      if (t[0] === '<') {
        if (t[1] === "/") {
          // If the closing tag matches, move back up to the parent node.
          if (tagStack.length &&
              tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
            tagStack.pop();
            current = current.parentNode;
          }
          // Otherwise just ignore the end tag.
          continue;
        }
        var ts = parseTimeStamp(t.substr(1, t.length - 2));
        var node;
        if (ts) {
          // Timestamps are lead nodes as well.
          node = window.document.createProcessingInstruction("timestamp", ts);
          current.appendChild(node);
          continue;
        }
        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        // If we can't parse the tag, skip to the next tag.
        if (!m) {
          continue;
        }
        // Try to construct an element, and ignore the tag if we couldn't.
        node = createElement(m[1], m[3]);
        if (!node) {
          continue;
        }
        // Determine if the tag should be added based on the context of where it
        // is placed in the cuetext.
        if (!shouldAdd(current, node)) {
          continue;
        }
        // Set the class list (as a list of classes, separated by space).
        if (m[2]) {
          node.className = m[2].substr(1).replace('.', ' ');
        }
        // Append the node to the current node, and enter the scope of the new
        // node.
        tagStack.push(m[1]);
        current.appendChild(node);
        current = node;
        continue;
      }

      // Text nodes are leaf nodes.
      current.appendChild(window.document.createTextNode(unescape(t)));
    }

    return rootDiv;
  }

  // This is a list of all the Unicode characters that have a strong
  // right-to-left category. What this means is that these characters are
  // written right-to-left for sure. It was generated by pulling all the strong
  // right-to-left characters out of the Unicode data table. That table can
  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
  var strongRTLChars = [0x05BE, 0x05C0, 0x05C3, 0x05C6, 0x05D0, 0x05D1,
      0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA,
      0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3,
      0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x05F0, 0x05F1,
      0x05F2, 0x05F3, 0x05F4, 0x0608, 0x060B, 0x060D, 0x061B, 0x061E, 0x061F,
      0x0620, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628,
      0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631,
      0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063A,
      0x063B, 0x063C, 0x063D, 0x063E, 0x063F, 0x0640, 0x0641, 0x0642, 0x0643,
      0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A, 0x066D, 0x066E,
      0x066F, 0x0671, 0x0672, 0x0673, 0x0674, 0x0675, 0x0676, 0x0677, 0x0678,
      0x0679, 0x067A, 0x067B, 0x067C, 0x067D, 0x067E, 0x067F, 0x0680, 0x0681,
      0x0682, 0x0683, 0x0684, 0x0685, 0x0686, 0x0687, 0x0688, 0x0689, 0x068A,
      0x068B, 0x068C, 0x068D, 0x068E, 0x068F, 0x0690, 0x0691, 0x0692, 0x0693,
      0x0694, 0x0695, 0x0696, 0x0697, 0x0698, 0x0699, 0x069A, 0x069B, 0x069C,
      0x069D, 0x069E, 0x069F, 0x06A0, 0x06A1, 0x06A2, 0x06A3, 0x06A4, 0x06A5,
      0x06A6, 0x06A7, 0x06A8, 0x06A9, 0x06AA, 0x06AB, 0x06AC, 0x06AD, 0x06AE,
      0x06AF, 0x06B0, 0x06B1, 0x06B2, 0x06B3, 0x06B4, 0x06B5, 0x06B6, 0x06B7,
      0x06B8, 0x06B9, 0x06BA, 0x06BB, 0x06BC, 0x06BD, 0x06BE, 0x06BF, 0x06C0,
      0x06C1, 0x06C2, 0x06C3, 0x06C4, 0x06C5, 0x06C6, 0x06C7, 0x06C8, 0x06C9,
      0x06CA, 0x06CB, 0x06CC, 0x06CD, 0x06CE, 0x06CF, 0x06D0, 0x06D1, 0x06D2,
      0x06D3, 0x06D4, 0x06D5, 0x06E5, 0x06E6, 0x06EE, 0x06EF, 0x06FA, 0x06FB,
      0x06FC, 0x06FD, 0x06FE, 0x06FF, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704,
      0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070A, 0x070B, 0x070C, 0x070D,
      0x070F, 0x0710, 0x0712, 0x0713, 0x0714, 0x0715, 0x0716, 0x0717, 0x0718,
      0x0719, 0x071A, 0x071B, 0x071C, 0x071D, 0x071E, 0x071F, 0x0720, 0x0721,
      0x0722, 0x0723, 0x0724, 0x0725, 0x0726, 0x0727, 0x0728, 0x0729, 0x072A,
      0x072B, 0x072C, 0x072D, 0x072E, 0x072F, 0x074D, 0x074E, 0x074F, 0x0750,
      0x0751, 0x0752, 0x0753, 0x0754, 0x0755, 0x0756, 0x0757, 0x0758, 0x0759,
      0x075A, 0x075B, 0x075C, 0x075D, 0x075E, 0x075F, 0x0760, 0x0761, 0x0762,
      0x0763, 0x0764, 0x0765, 0x0766, 0x0767, 0x0768, 0x0769, 0x076A, 0x076B,
      0x076C, 0x076D, 0x076E, 0x076F, 0x0770, 0x0771, 0x0772, 0x0773, 0x0774,
      0x0775, 0x0776, 0x0777, 0x0778, 0x0779, 0x077A, 0x077B, 0x077C, 0x077D,
      0x077E, 0x077F, 0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0786,
      0x0787, 0x0788, 0x0789, 0x078A, 0x078B, 0x078C, 0x078D, 0x078E, 0x078F,
      0x0790, 0x0791, 0x0792, 0x0793, 0x0794, 0x0795, 0x0796, 0x0797, 0x0798,
      0x0799, 0x079A, 0x079B, 0x079C, 0x079D, 0x079E, 0x079F, 0x07A0, 0x07A1,
      0x07A2, 0x07A3, 0x07A4, 0x07A5, 0x07B1, 0x07C0, 0x07C1, 0x07C2, 0x07C3,
      0x07C4, 0x07C5, 0x07C6, 0x07C7, 0x07C8, 0x07C9, 0x07CA, 0x07CB, 0x07CC,
      0x07CD, 0x07CE, 0x07CF, 0x07D0, 0x07D1, 0x07D2, 0x07D3, 0x07D4, 0x07D5,
      0x07D6, 0x07D7, 0x07D8, 0x07D9, 0x07DA, 0x07DB, 0x07DC, 0x07DD, 0x07DE,
      0x07DF, 0x07E0, 0x07E1, 0x07E2, 0x07E3, 0x07E4, 0x07E5, 0x07E6, 0x07E7,
      0x07E8, 0x07E9, 0x07EA, 0x07F4, 0x07F5, 0x07FA, 0x0800, 0x0801, 0x0802,
      0x0803, 0x0804, 0x0805, 0x0806, 0x0807, 0x0808, 0x0809, 0x080A, 0x080B,
      0x080C, 0x080D, 0x080E, 0x080F, 0x0810, 0x0811, 0x0812, 0x0813, 0x0814,
      0x0815, 0x081A, 0x0824, 0x0828, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834,
      0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083A, 0x083B, 0x083C, 0x083D,
      0x083E, 0x0840, 0x0841, 0x0842, 0x0843, 0x0844, 0x0845, 0x0846, 0x0847,
      0x0848, 0x0849, 0x084A, 0x084B, 0x084C, 0x084D, 0x084E, 0x084F, 0x0850,
      0x0851, 0x0852, 0x0853, 0x0854, 0x0855, 0x0856, 0x0857, 0x0858, 0x085E,
      0x08A0, 0x08A2, 0x08A3, 0x08A4, 0x08A5, 0x08A6, 0x08A7, 0x08A8, 0x08A9,
      0x08AA, 0x08AB, 0x08AC, 0x200F, 0xFB1D, 0xFB1F, 0xFB20, 0xFB21, 0xFB22,
      0xFB23, 0xFB24, 0xFB25, 0xFB26, 0xFB27, 0xFB28, 0xFB2A, 0xFB2B, 0xFB2C,
      0xFB2D, 0xFB2E, 0xFB2F, 0xFB30, 0xFB31, 0xFB32, 0xFB33, 0xFB34, 0xFB35,
      0xFB36, 0xFB38, 0xFB39, 0xFB3A, 0xFB3B, 0xFB3C, 0xFB3E, 0xFB40, 0xFB41,
      0xFB43, 0xFB44, 0xFB46, 0xFB47, 0xFB48, 0xFB49, 0xFB4A, 0xFB4B, 0xFB4C,
      0xFB4D, 0xFB4E, 0xFB4F, 0xFB50, 0xFB51, 0xFB52, 0xFB53, 0xFB54, 0xFB55,
      0xFB56, 0xFB57, 0xFB58, 0xFB59, 0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D, 0xFB5E,
      0xFB5F, 0xFB60, 0xFB61, 0xFB62, 0xFB63, 0xFB64, 0xFB65, 0xFB66, 0xFB67,
      0xFB68, 0xFB69, 0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D, 0xFB6E, 0xFB6F, 0xFB70,
      0xFB71, 0xFB72, 0xFB73, 0xFB74, 0xFB75, 0xFB76, 0xFB77, 0xFB78, 0xFB79,
      0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D, 0xFB7E, 0xFB7F, 0xFB80, 0xFB81, 0xFB82,
      0xFB83, 0xFB84, 0xFB85, 0xFB86, 0xFB87, 0xFB88, 0xFB89, 0xFB8A, 0xFB8B,
      0xFB8C, 0xFB8D, 0xFB8E, 0xFB8F, 0xFB90, 0xFB91, 0xFB92, 0xFB93, 0xFB94,
      0xFB95, 0xFB96, 0xFB97, 0xFB98, 0xFB99, 0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D,
      0xFB9E, 0xFB9F, 0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3, 0xFBA4, 0xFBA5, 0xFBA6,
      0xFBA7, 0xFBA8, 0xFBA9, 0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD, 0xFBAE, 0xFBAF,
      0xFBB0, 0xFBB1, 0xFBB2, 0xFBB3, 0xFBB4, 0xFBB5, 0xFBB6, 0xFBB7, 0xFBB8,
      0xFBB9, 0xFBBA, 0xFBBB, 0xFBBC, 0xFBBD, 0xFBBE, 0xFBBF, 0xFBC0, 0xFBC1,
      0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6, 0xFBD7, 0xFBD8, 0xFBD9, 0xFBDA, 0xFBDB,
      0xFBDC, 0xFBDD, 0xFBDE, 0xFBDF, 0xFBE0, 0xFBE1, 0xFBE2, 0xFBE3, 0xFBE4,
      0xFBE5, 0xFBE6, 0xFBE7, 0xFBE8, 0xFBE9, 0xFBEA, 0xFBEB, 0xFBEC, 0xFBED,
      0xFBEE, 0xFBEF, 0xFBF0, 0xFBF1, 0xFBF2, 0xFBF3, 0xFBF4, 0xFBF5, 0xFBF6,
      0xFBF7, 0xFBF8, 0xFBF9, 0xFBFA, 0xFBFB, 0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF,
      0xFC00, 0xFC01, 0xFC02, 0xFC03, 0xFC04, 0xFC05, 0xFC06, 0xFC07, 0xFC08,
      0xFC09, 0xFC0A, 0xFC0B, 0xFC0C, 0xFC0D, 0xFC0E, 0xFC0F, 0xFC10, 0xFC11,
      0xFC12, 0xFC13, 0xFC14, 0xFC15, 0xFC16, 0xFC17, 0xFC18, 0xFC19, 0xFC1A,
      0xFC1B, 0xFC1C, 0xFC1D, 0xFC1E, 0xFC1F, 0xFC20, 0xFC21, 0xFC22, 0xFC23,
      0xFC24, 0xFC25, 0xFC26, 0xFC27, 0xFC28, 0xFC29, 0xFC2A, 0xFC2B, 0xFC2C,
      0xFC2D, 0xFC2E, 0xFC2F, 0xFC30, 0xFC31, 0xFC32, 0xFC33, 0xFC34, 0xFC35,
      0xFC36, 0xFC37, 0xFC38, 0xFC39, 0xFC3A, 0xFC3B, 0xFC3C, 0xFC3D, 0xFC3E,
      0xFC3F, 0xFC40, 0xFC41, 0xFC42, 0xFC43, 0xFC44, 0xFC45, 0xFC46, 0xFC47,
      0xFC48, 0xFC49, 0xFC4A, 0xFC4B, 0xFC4C, 0xFC4D, 0xFC4E, 0xFC4F, 0xFC50,
      0xFC51, 0xFC52, 0xFC53, 0xFC54, 0xFC55, 0xFC56, 0xFC57, 0xFC58, 0xFC59,
      0xFC5A, 0xFC5B, 0xFC5C, 0xFC5D, 0xFC5E, 0xFC5F, 0xFC60, 0xFC61, 0xFC62,
      0xFC63, 0xFC64, 0xFC65, 0xFC66, 0xFC67, 0xFC68, 0xFC69, 0xFC6A, 0xFC6B,
      0xFC6C, 0xFC6D, 0xFC6E, 0xFC6F, 0xFC70, 0xFC71, 0xFC72, 0xFC73, 0xFC74,
      0xFC75, 0xFC76, 0xFC77, 0xFC78, 0xFC79, 0xFC7A, 0xFC7B, 0xFC7C, 0xFC7D,
      0xFC7E, 0xFC7F, 0xFC80, 0xFC81, 0xFC82, 0xFC83, 0xFC84, 0xFC85, 0xFC86,
      0xFC87, 0xFC88, 0xFC89, 0xFC8A, 0xFC8B, 0xFC8C, 0xFC8D, 0xFC8E, 0xFC8F,
      0xFC90, 0xFC91, 0xFC92, 0xFC93, 0xFC94, 0xFC95, 0xFC96, 0xFC97, 0xFC98,
      0xFC99, 0xFC9A, 0xFC9B, 0xFC9C, 0xFC9D, 0xFC9E, 0xFC9F, 0xFCA0, 0xFCA1,
      0xFCA2, 0xFCA3, 0xFCA4, 0xFCA5, 0xFCA6, 0xFCA7, 0xFCA8, 0xFCA9, 0xFCAA,
      0xFCAB, 0xFCAC, 0xFCAD, 0xFCAE, 0xFCAF, 0xFCB0, 0xFCB1, 0xFCB2, 0xFCB3,
      0xFCB4, 0xFCB5, 0xFCB6, 0xFCB7, 0xFCB8, 0xFCB9, 0xFCBA, 0xFCBB, 0xFCBC,
      0xFCBD, 0xFCBE, 0xFCBF, 0xFCC0, 0xFCC1, 0xFCC2, 0xFCC3, 0xFCC4, 0xFCC5,
      0xFCC6, 0xFCC7, 0xFCC8, 0xFCC9, 0xFCCA, 0xFCCB, 0xFCCC, 0xFCCD, 0xFCCE,
      0xFCCF, 0xFCD0, 0xFCD1, 0xFCD2, 0xFCD3, 0xFCD4, 0xFCD5, 0xFCD6, 0xFCD7,
      0xFCD8, 0xFCD9, 0xFCDA, 0xFCDB, 0xFCDC, 0xFCDD, 0xFCDE, 0xFCDF, 0xFCE0,
      0xFCE1, 0xFCE2, 0xFCE3, 0xFCE4, 0xFCE5, 0xFCE6, 0xFCE7, 0xFCE8, 0xFCE9,
      0xFCEA, 0xFCEB, 0xFCEC, 0xFCED, 0xFCEE, 0xFCEF, 0xFCF0, 0xFCF1, 0xFCF2,
      0xFCF3, 0xFCF4, 0xFCF5, 0xFCF6, 0xFCF7, 0xFCF8, 0xFCF9, 0xFCFA, 0xFCFB,
      0xFCFC, 0xFCFD, 0xFCFE, 0xFCFF, 0xFD00, 0xFD01, 0xFD02, 0xFD03, 0xFD04,
      0xFD05, 0xFD06, 0xFD07, 0xFD08, 0xFD09, 0xFD0A, 0xFD0B, 0xFD0C, 0xFD0D,
      0xFD0E, 0xFD0F, 0xFD10, 0xFD11, 0xFD12, 0xFD13, 0xFD14, 0xFD15, 0xFD16,
      0xFD17, 0xFD18, 0xFD19, 0xFD1A, 0xFD1B, 0xFD1C, 0xFD1D, 0xFD1E, 0xFD1F,
      0xFD20, 0xFD21, 0xFD22, 0xFD23, 0xFD24, 0xFD25, 0xFD26, 0xFD27, 0xFD28,
      0xFD29, 0xFD2A, 0xFD2B, 0xFD2C, 0xFD2D, 0xFD2E, 0xFD2F, 0xFD30, 0xFD31,
      0xFD32, 0xFD33, 0xFD34, 0xFD35, 0xFD36, 0xFD37, 0xFD38, 0xFD39, 0xFD3A,
      0xFD3B, 0xFD3C, 0xFD3D, 0xFD50, 0xFD51, 0xFD52, 0xFD53, 0xFD54, 0xFD55,
      0xFD56, 0xFD57, 0xFD58, 0xFD59, 0xFD5A, 0xFD5B, 0xFD5C, 0xFD5D, 0xFD5E,
      0xFD5F, 0xFD60, 0xFD61, 0xFD62, 0xFD63, 0xFD64, 0xFD65, 0xFD66, 0xFD67,
      0xFD68, 0xFD69, 0xFD6A, 0xFD6B, 0xFD6C, 0xFD6D, 0xFD6E, 0xFD6F, 0xFD70,
      0xFD71, 0xFD72, 0xFD73, 0xFD74, 0xFD75, 0xFD76, 0xFD77, 0xFD78, 0xFD79,
      0xFD7A, 0xFD7B, 0xFD7C, 0xFD7D, 0xFD7E, 0xFD7F, 0xFD80, 0xFD81, 0xFD82,
      0xFD83, 0xFD84, 0xFD85, 0xFD86, 0xFD87, 0xFD88, 0xFD89, 0xFD8A, 0xFD8B,
      0xFD8C, 0xFD8D, 0xFD8E, 0xFD8F, 0xFD92, 0xFD93, 0xFD94, 0xFD95, 0xFD96,
      0xFD97, 0xFD98, 0xFD99, 0xFD9A, 0xFD9B, 0xFD9C, 0xFD9D, 0xFD9E, 0xFD9F,
      0xFDA0, 0xFDA1, 0xFDA2, 0xFDA3, 0xFDA4, 0xFDA5, 0xFDA6, 0xFDA7, 0xFDA8,
      0xFDA9, 0xFDAA, 0xFDAB, 0xFDAC, 0xFDAD, 0xFDAE, 0xFDAF, 0xFDB0, 0xFDB1,
      0xFDB2, 0xFDB3, 0xFDB4, 0xFDB5, 0xFDB6, 0xFDB7, 0xFDB8, 0xFDB9, 0xFDBA,
      0xFDBB, 0xFDBC, 0xFDBD, 0xFDBE, 0xFDBF, 0xFDC0, 0xFDC1, 0xFDC2, 0xFDC3,
      0xFDC4, 0xFDC5, 0xFDC6, 0xFDC7, 0xFDF0, 0xFDF1, 0xFDF2, 0xFDF3, 0xFDF4,
      0xFDF5, 0xFDF6, 0xFDF7, 0xFDF8, 0xFDF9, 0xFDFA, 0xFDFB, 0xFDFC, 0xFE70,
      0xFE71, 0xFE72, 0xFE73, 0xFE74, 0xFE76, 0xFE77, 0xFE78, 0xFE79, 0xFE7A,
      0xFE7B, 0xFE7C, 0xFE7D, 0xFE7E, 0xFE7F, 0xFE80, 0xFE81, 0xFE82, 0xFE83,
      0xFE84, 0xFE85, 0xFE86, 0xFE87, 0xFE88, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C,
      0xFE8D, 0xFE8E, 0xFE8F, 0xFE90, 0xFE91, 0xFE92, 0xFE93, 0xFE94, 0xFE95,
      0xFE96, 0xFE97, 0xFE98, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C, 0xFE9D, 0xFE9E,
      0xFE9F, 0xFEA0, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4, 0xFEA5, 0xFEA6, 0xFEA7,
      0xFEA8, 0xFEA9, 0xFEAA, 0xFEAB, 0xFEAC, 0xFEAD, 0xFEAE, 0xFEAF, 0xFEB0,
      0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4, 0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8, 0xFEB9,
      0xFEBA, 0xFEBB, 0xFEBC, 0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0, 0xFEC1, 0xFEC2,
      0xFEC3, 0xFEC4, 0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8, 0xFEC9, 0xFECA, 0xFECB,
      0xFECC, 0xFECD, 0xFECE, 0xFECF, 0xFED0, 0xFED1, 0xFED2, 0xFED3, 0xFED4,
      0xFED5, 0xFED6, 0xFED7, 0xFED8, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC, 0xFEDD,
      0xFEDE, 0xFEDF, 0xFEE0, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE5, 0xFEE6,
      0xFEE7, 0xFEE8, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC, 0xFEED, 0xFEEE, 0xFEEF,
      0xFEF0, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF7, 0xFEF8,
      0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0x10800, 0x10801, 0x10802, 0x10803,
      0x10804, 0x10805, 0x10808, 0x1080A, 0x1080B, 0x1080C, 0x1080D, 0x1080E,
      0x1080F, 0x10810, 0x10811, 0x10812, 0x10813, 0x10814, 0x10815, 0x10816,
      0x10817, 0x10818, 0x10819, 0x1081A, 0x1081B, 0x1081C, 0x1081D, 0x1081E,
      0x1081F, 0x10820, 0x10821, 0x10822, 0x10823, 0x10824, 0x10825, 0x10826,
      0x10827, 0x10828, 0x10829, 0x1082A, 0x1082B, 0x1082C, 0x1082D, 0x1082E,
      0x1082F, 0x10830, 0x10831, 0x10832, 0x10833, 0x10834, 0x10835, 0x10837,
      0x10838, 0x1083C, 0x1083F, 0x10840, 0x10841, 0x10842, 0x10843, 0x10844,
      0x10845, 0x10846, 0x10847, 0x10848, 0x10849, 0x1084A, 0x1084B, 0x1084C,
      0x1084D, 0x1084E, 0x1084F, 0x10850, 0x10851, 0x10852, 0x10853, 0x10854,
      0x10855, 0x10857, 0x10858, 0x10859, 0x1085A, 0x1085B, 0x1085C, 0x1085D,
      0x1085E, 0x1085F, 0x10900, 0x10901, 0x10902, 0x10903, 0x10904, 0x10905,
      0x10906, 0x10907, 0x10908, 0x10909, 0x1090A, 0x1090B, 0x1090C, 0x1090D,
      0x1090E, 0x1090F, 0x10910, 0x10911, 0x10912, 0x10913, 0x10914, 0x10915,
      0x10916, 0x10917, 0x10918, 0x10919, 0x1091A, 0x1091B, 0x10920, 0x10921,
      0x10922, 0x10923, 0x10924, 0x10925, 0x10926, 0x10927, 0x10928, 0x10929,
      0x1092A, 0x1092B, 0x1092C, 0x1092D, 0x1092E, 0x1092F, 0x10930, 0x10931,
      0x10932, 0x10933, 0x10934, 0x10935, 0x10936, 0x10937, 0x10938, 0x10939,
      0x1093F, 0x10980, 0x10981, 0x10982, 0x10983, 0x10984, 0x10985, 0x10986,
      0x10987, 0x10988, 0x10989, 0x1098A, 0x1098B, 0x1098C, 0x1098D, 0x1098E,
      0x1098F, 0x10990, 0x10991, 0x10992, 0x10993, 0x10994, 0x10995, 0x10996,
      0x10997, 0x10998, 0x10999, 0x1099A, 0x1099B, 0x1099C, 0x1099D, 0x1099E,
      0x1099F, 0x109A0, 0x109A1, 0x109A2, 0x109A3, 0x109A4, 0x109A5, 0x109A6,
      0x109A7, 0x109A8, 0x109A9, 0x109AA, 0x109AB, 0x109AC, 0x109AD, 0x109AE,
      0x109AF, 0x109B0, 0x109B1, 0x109B2, 0x109B3, 0x109B4, 0x109B5, 0x109B6,
      0x109B7, 0x109BE, 0x109BF, 0x10A00, 0x10A10, 0x10A11, 0x10A12, 0x10A13,
      0x10A15, 0x10A16, 0x10A17, 0x10A19, 0x10A1A, 0x10A1B, 0x10A1C, 0x10A1D,
      0x10A1E, 0x10A1F, 0x10A20, 0x10A21, 0x10A22, 0x10A23, 0x10A24, 0x10A25,
      0x10A26, 0x10A27, 0x10A28, 0x10A29, 0x10A2A, 0x10A2B, 0x10A2C, 0x10A2D,
      0x10A2E, 0x10A2F, 0x10A30, 0x10A31, 0x10A32, 0x10A33, 0x10A40, 0x10A41,
      0x10A42, 0x10A43, 0x10A44, 0x10A45, 0x10A46, 0x10A47, 0x10A50, 0x10A51,
      0x10A52, 0x10A53, 0x10A54, 0x10A55, 0x10A56, 0x10A57, 0x10A58, 0x10A60,
      0x10A61, 0x10A62, 0x10A63, 0x10A64, 0x10A65, 0x10A66, 0x10A67, 0x10A68,
      0x10A69, 0x10A6A, 0x10A6B, 0x10A6C, 0x10A6D, 0x10A6E, 0x10A6F, 0x10A70,
      0x10A71, 0x10A72, 0x10A73, 0x10A74, 0x10A75, 0x10A76, 0x10A77, 0x10A78,
      0x10A79, 0x10A7A, 0x10A7B, 0x10A7C, 0x10A7D, 0x10A7E, 0x10A7F, 0x10B00,
      0x10B01, 0x10B02, 0x10B03, 0x10B04, 0x10B05, 0x10B06, 0x10B07, 0x10B08,
      0x10B09, 0x10B0A, 0x10B0B, 0x10B0C, 0x10B0D, 0x10B0E, 0x10B0F, 0x10B10,
      0x10B11, 0x10B12, 0x10B13, 0x10B14, 0x10B15, 0x10B16, 0x10B17, 0x10B18,
      0x10B19, 0x10B1A, 0x10B1B, 0x10B1C, 0x10B1D, 0x10B1E, 0x10B1F, 0x10B20,
      0x10B21, 0x10B22, 0x10B23, 0x10B24, 0x10B25, 0x10B26, 0x10B27, 0x10B28,
      0x10B29, 0x10B2A, 0x10B2B, 0x10B2C, 0x10B2D, 0x10B2E, 0x10B2F, 0x10B30,
      0x10B31, 0x10B32, 0x10B33, 0x10B34, 0x10B35, 0x10B40, 0x10B41, 0x10B42,
      0x10B43, 0x10B44, 0x10B45, 0x10B46, 0x10B47, 0x10B48, 0x10B49, 0x10B4A,
      0x10B4B, 0x10B4C, 0x10B4D, 0x10B4E, 0x10B4F, 0x10B50, 0x10B51, 0x10B52,
      0x10B53, 0x10B54, 0x10B55, 0x10B58, 0x10B59, 0x10B5A, 0x10B5B, 0x10B5C,
      0x10B5D, 0x10B5E, 0x10B5F, 0x10B60, 0x10B61, 0x10B62, 0x10B63, 0x10B64,
      0x10B65, 0x10B66, 0x10B67, 0x10B68, 0x10B69, 0x10B6A, 0x10B6B, 0x10B6C,
      0x10B6D, 0x10B6E, 0x10B6F, 0x10B70, 0x10B71, 0x10B72, 0x10B78, 0x10B79,
      0x10B7A, 0x10B7B, 0x10B7C, 0x10B7D, 0x10B7E, 0x10B7F, 0x10C00, 0x10C01,
      0x10C02, 0x10C03, 0x10C04, 0x10C05, 0x10C06, 0x10C07, 0x10C08, 0x10C09,
      0x10C0A, 0x10C0B, 0x10C0C, 0x10C0D, 0x10C0E, 0x10C0F, 0x10C10, 0x10C11,
      0x10C12, 0x10C13, 0x10C14, 0x10C15, 0x10C16, 0x10C17, 0x10C18, 0x10C19,
      0x10C1A, 0x10C1B, 0x10C1C, 0x10C1D, 0x10C1E, 0x10C1F, 0x10C20, 0x10C21,
      0x10C22, 0x10C23, 0x10C24, 0x10C25, 0x10C26, 0x10C27, 0x10C28, 0x10C29,
      0x10C2A, 0x10C2B, 0x10C2C, 0x10C2D, 0x10C2E, 0x10C2F, 0x10C30, 0x10C31,
      0x10C32, 0x10C33, 0x10C34, 0x10C35, 0x10C36, 0x10C37, 0x10C38, 0x10C39,
      0x10C3A, 0x10C3B, 0x10C3C, 0x10C3D, 0x10C3E, 0x10C3F, 0x10C40, 0x10C41,
      0x10C42, 0x10C43, 0x10C44, 0x10C45, 0x10C46, 0x10C47, 0x10C48, 0x1EE00,
      0x1EE01, 0x1EE02, 0x1EE03, 0x1EE05, 0x1EE06, 0x1EE07, 0x1EE08, 0x1EE09,
      0x1EE0A, 0x1EE0B, 0x1EE0C, 0x1EE0D, 0x1EE0E, 0x1EE0F, 0x1EE10, 0x1EE11,
      0x1EE12, 0x1EE13, 0x1EE14, 0x1EE15, 0x1EE16, 0x1EE17, 0x1EE18, 0x1EE19,
      0x1EE1A, 0x1EE1B, 0x1EE1C, 0x1EE1D, 0x1EE1E, 0x1EE1F, 0x1EE21, 0x1EE22,
      0x1EE24, 0x1EE27, 0x1EE29, 0x1EE2A, 0x1EE2B, 0x1EE2C, 0x1EE2D, 0x1EE2E,
      0x1EE2F, 0x1EE30, 0x1EE31, 0x1EE32, 0x1EE34, 0x1EE35, 0x1EE36, 0x1EE37,
      0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE4D, 0x1EE4E,
      0x1EE4F, 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D,
      0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, 0x1EE67, 0x1EE68, 0x1EE69, 0x1EE6A,
      0x1EE6C, 0x1EE6D, 0x1EE6E, 0x1EE6F, 0x1EE70, 0x1EE71, 0x1EE72, 0x1EE74,
      0x1EE75, 0x1EE76, 0x1EE77, 0x1EE79, 0x1EE7A, 0x1EE7B, 0x1EE7C, 0x1EE7E,
      0x1EE80, 0x1EE81, 0x1EE82, 0x1EE83, 0x1EE84, 0x1EE85, 0x1EE86, 0x1EE87,
      0x1EE88, 0x1EE89, 0x1EE8B, 0x1EE8C, 0x1EE8D, 0x1EE8E, 0x1EE8F, 0x1EE90,
      0x1EE91, 0x1EE92, 0x1EE93, 0x1EE94, 0x1EE95, 0x1EE96, 0x1EE97, 0x1EE98,
      0x1EE99, 0x1EE9A, 0x1EE9B, 0x1EEA1, 0x1EEA2, 0x1EEA3, 0x1EEA5, 0x1EEA6,
      0x1EEA7, 0x1EEA8, 0x1EEA9, 0x1EEAB, 0x1EEAC, 0x1EEAD, 0x1EEAE, 0x1EEAF,
      0x1EEB0, 0x1EEB1, 0x1EEB2, 0x1EEB3, 0x1EEB4, 0x1EEB5, 0x1EEB6, 0x1EEB7,
      0x1EEB8, 0x1EEB9, 0x1EEBA, 0x1EEBB, 0x10FFFD];

  function determineBidi(cueDiv) {
    var nodeStack = [],
        text = "",
        charCode;

    if (!cueDiv || !cueDiv.childNodes) {
      return "ltr";
    }

    function pushNodes(nodeStack, node) {
      for (var i = node.childNodes.length - 1; i >= 0; i--) {
        nodeStack.push(node.childNodes[i]);
      }
    }

    function nextTextNode(nodeStack) {
      if (!nodeStack || !nodeStack.length) {
        return null;
      }

      var node = nodeStack.pop(),
          text = node.textContent || node.innerText;
      if (text) {
        // TODO: This should match all unicode type B characters (paragraph
        // separator characters). See issue #115.
        var m = text.match(/^.*(\n|\r)/);
        if (m) {
          nodeStack.length = 0;
          return m[0];
        }
        return text;
      }
      if (node.tagName === "ruby") {
        return nextTextNode(nodeStack);
      }
      if (node.childNodes) {
        pushNodes(nodeStack, node);
        return nextTextNode(nodeStack);
      }
    }

    pushNodes(nodeStack, cueDiv);
    while ((text = nextTextNode(nodeStack))) {
      for (var i = 0; i < text.length; i++) {
        charCode = text.charCodeAt(i);
        for (var j = 0; j < strongRTLChars.length; j++) {
          if (strongRTLChars[j] === charCode) {
            return "rtl";
          }
        }
      }
    }
    return "ltr";
  }

  function computeLinePos(cue) {
    if (typeof cue.line === "number" &&
        (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
      return cue.line;
    }
    if (!cue.track || !cue.track.textTrackList ||
        !cue.track.textTrackList.mediaElement) {
      return -1;
    }
    var track = cue.track,
        trackList = track.textTrackList,
        count = 0;
    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
      if (trackList[i].mode === "showing") {
        count++;
      }
    }
    return ++count * -1;
  }

  function StyleBox() {
  }

  // Apply styles to a div. If there is no div passed then it defaults to the
  // div on 'this'.
  StyleBox.prototype.applyStyles = function(styles, div) {
    div = div || this.div;
    for (var prop in styles) {
      if (styles.hasOwnProperty(prop)) {
        div.style[prop] = styles[prop];
      }
    }
  };

  StyleBox.prototype.formatStyle = function(val, unit) {
    return val === 0 ? 0 : val + unit;
  };

  // Constructs the computed display state of the cue (a div). Places the div
  // into the overlay which should be a block level element (usually a div).
  function CueStyleBox(window, cue, styleOptions) {
    var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
    var color = "rgba(255, 255, 255, 1)";
    var backgroundColor = "rgba(0, 0, 0, 0.8)";

    if (isIE8) {
      color = "rgb(255, 255, 255)";
      backgroundColor = "rgb(0, 0, 0)";
    }

    StyleBox.call(this);
    this.cue = cue;

    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
    // have inline positioning and will function as the cue background box.
    this.cueDiv = parseContent(window, cue.text);
    var styles = {
      color: color,
      backgroundColor: backgroundColor,
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline"
    };

    if (!isIE8) {
      styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                               : cue.vertical === "lr" ? "vertical-lr"
                                                                       : "vertical-rl";
      styles.unicodeBidi = "plaintext";
    }
    this.applyStyles(styles, this.cueDiv);

    // Create an absolutely positioned div that will be used to position the cue
    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
    // mirrors of them except "middle" which is "center" in CSS.
    this.div = window.document.createElement("div");
    styles = {
      textAlign: cue.align === "middle" ? "center" : cue.align,
      font: styleOptions.font,
      whiteSpace: "pre-line",
      position: "absolute"
    };

    if (!isIE8) {
      styles.direction = determineBidi(this.cueDiv);
      styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                               : cue.vertical === "lr" ? "vertical-lr"
                                                                       : "vertical-rl".
      stylesunicodeBidi =  "plaintext";
    }

    this.applyStyles(styles);

    this.div.appendChild(this.cueDiv);

    // Calculate the distance from the reference edge of the viewport to the text
    // position of the cue box. The reference edge will be resolved later when
    // the box orientation styles are applied.
    var textPos = 0;
    switch (cue.positionAlign) {
    case "start":
      textPos = cue.position;
      break;
    case "middle":
      textPos = cue.position - (cue.size / 2);
      break;
    case "end":
      textPos = cue.position - cue.size;
      break;
    }

    // Horizontal box orientation; textPos is the distance from the left edge of the
    // area to the left edge of the box and cue.size is the distance extending to
    // the right from there.
    if (cue.vertical === "") {
      this.applyStyles({
        left:  this.formatStyle(textPos, "%"),
        width: this.formatStyle(cue.size, "%")
      });
    // Vertical box orientation; textPos is the distance from the top edge of the
    // area to the top edge of the box and cue.size is the height extending
    // downwards from there.
    } else {
      this.applyStyles({
        top: this.formatStyle(textPos, "%"),
        height: this.formatStyle(cue.size, "%")
      });
    }

    this.move = function(box) {
      this.applyStyles({
        top: this.formatStyle(box.top, "px"),
        bottom: this.formatStyle(box.bottom, "px"),
        left: this.formatStyle(box.left, "px"),
        right: this.formatStyle(box.right, "px"),
        height: this.formatStyle(box.height, "px"),
        width: this.formatStyle(box.width, "px")
      });
    };
  }
  CueStyleBox.prototype = _objCreate(StyleBox.prototype);
  CueStyleBox.prototype.constructor = CueStyleBox;

  // Represents the co-ordinates of an Element in a way that we can easily
  // compute things with such as if it overlaps or intersects with another Element.
  // Can initialize it with either a StyleBox or another BoxPosition.
  function BoxPosition(obj) {
    var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);

    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
    // was passed in and we need to copy the results of 'getBoundingClientRect'
    // as the object returned is readonly. All co-ordinate values are in reference
    // to the viewport origin (top left).
    var lh, height, width, top;
    if (obj.div) {
      height = obj.div.offsetHeight;
      width = obj.div.offsetWidth;
      top = obj.div.offsetTop;

      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                  rects.getClientRects && rects.getClientRects();
      obj = obj.div.getBoundingClientRect();
      // In certain cases the outter div will be slightly larger then the sum of
      // the inner div's lines. This could be due to bold text, etc, on some platforms.
      // In this case we should get the average line height and use that. This will
      // result in the desired behaviour.
      lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
                 : 0;

    }
    this.left = obj.left;
    this.right = obj.right;
    this.top = obj.top || top;
    this.height = obj.height || height;
    this.bottom = obj.bottom || (top + (obj.height || height));
    this.width = obj.width || width;
    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;

    if (isIE8 && !this.lineHeight) {
      this.lineHeight = 13;
    }
  }

  // Move the box along a particular axis. Optionally pass in an amount to move
  // the box. If no amount is passed then the default is the line height of the
  // box.
  BoxPosition.prototype.move = function(axis, toMove) {
    toMove = toMove !== undefined ? toMove : this.lineHeight;
    switch (axis) {
    case "+x":
      this.left += toMove;
      this.right += toMove;
      break;
    case "-x":
      this.left -= toMove;
      this.right -= toMove;
      break;
    case "+y":
      this.top += toMove;
      this.bottom += toMove;
      break;
    case "-y":
      this.top -= toMove;
      this.bottom -= toMove;
      break;
    }
  };

  // Check if this box overlaps another box, b2.
  BoxPosition.prototype.overlaps = function(b2) {
    return this.left < b2.right &&
           this.right > b2.left &&
           this.top < b2.bottom &&
           this.bottom > b2.top;
  };

  // Check if this box overlaps any other boxes in boxes.
  BoxPosition.prototype.overlapsAny = function(boxes) {
    for (var i = 0; i < boxes.length; i++) {
      if (this.overlaps(boxes[i])) {
        return true;
      }
    }
    return false;
  };

  // Check if this box is within another box.
  BoxPosition.prototype.within = function(container) {
    return this.top >= container.top &&
           this.bottom <= container.bottom &&
           this.left >= container.left &&
           this.right <= container.right;
  };

  // Check if this box is entirely within the container or it is overlapping
  // on the edge opposite of the axis direction passed. For example, if "+x" is
  // passed and the box is overlapping on the left edge of the container, then
  // return true.
  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
    switch (axis) {
    case "+x":
      return this.left < container.left;
    case "-x":
      return this.right > container.right;
    case "+y":
      return this.top < container.top;
    case "-y":
      return this.bottom > container.bottom;
    }
  };

  // Find the percentage of the area that this box is overlapping with another
  // box.
  BoxPosition.prototype.intersectPercentage = function(b2) {
    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
        intersectArea = x * y;
    return intersectArea / (this.height * this.width);
  };

  // Convert the positions from this box to CSS compatible positions using
  // the reference container's positions. This has to be done because this
  // box's positions are in reference to the viewport origin, whereas, CSS
  // values are in referecne to their respective edges.
  BoxPosition.prototype.toCSSCompatValues = function(reference) {
    return {
      top: this.top - reference.top,
      bottom: reference.bottom - this.bottom,
      left: this.left - reference.left,
      right: reference.right - this.right,
      height: this.height,
      width: this.width
    };
  };

  // Get an object that represents the box's position without anything extra.
  // Can pass a StyleBox, HTMLElement, or another BoxPositon.
  BoxPosition.getSimpleBoxPosition = function(obj) {
    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

    obj = obj.div ? obj.div.getBoundingClientRect() :
                  obj.tagName ? obj.getBoundingClientRect() : obj;
    var ret = {
      left: obj.left,
      right: obj.right,
      top: obj.top || top,
      height: obj.height || height,
      bottom: obj.bottom || (top + (obj.height || height)),
      width: obj.width || width
    };
    return ret;
  };

  // Move a StyleBox to its specified, or next best, position. The containerBox
  // is the box that contains the StyleBox, such as a div. boxPositions are
  // a list of other boxes that the styleBox can't overlap with.
  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

    // Find the best position for a cue box, b, on the video. The axis parameter
    // is a list of axis, the order of which, it will move the box along. For example:
    // Passing ["+x", "-x"] will move the box first along the x axis in the positive
    // direction. If it doesn't find a good position for it there it will then move
    // it along the x axis in the negative direction.
    function findBestPosition(b, axis) {
      var bestPosition,
          specifiedPosition = new BoxPosition(b),
          percentage = 1; // Highest possible so the first thing we get is better.

      for (var i = 0; i < axis.length; i++) {
        while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
               (b.within(containerBox) && b.overlapsAny(boxPositions))) {
          b.move(axis[i]);
        }
        // We found a spot where we aren't overlapping anything. This is our
        // best position.
        if (b.within(containerBox)) {
          return b;
        }
        var p = b.intersectPercentage(containerBox);
        // If we're outside the container box less then we were on our last try
        // then remember this position as the best position.
        if (percentage > p) {
          bestPosition = new BoxPosition(b);
          percentage = p;
        }
        // Reset the box position to the specified position.
        b = new BoxPosition(specifiedPosition);
      }
      return bestPosition || specifiedPosition;
    }

    var boxPosition = new BoxPosition(styleBox),
        cue = styleBox.cue,
        linePos = computeLinePos(cue),
        axis = [];

    // If we have a line number to align the cue to.
    if (cue.snapToLines) {
      var size;
      switch (cue.vertical) {
      case "":
        axis = [ "+y", "-y" ];
        size = "height";
        break;
      case "rl":
        axis = [ "+x", "-x" ];
        size = "width";
        break;
      case "lr":
        axis = [ "-x", "+x" ];
        size = "width";
        break;
      }

      var step = boxPosition.lineHeight,
          position = step * Math.round(linePos),
          maxPosition = containerBox[size] + step,
          initialAxis = axis[0];

      // If the specified intial position is greater then the max position then
      // clamp the box to the amount of steps it would take for the box to
      // reach the max position.
      if (Math.abs(position) > maxPosition) {
        position = position < 0 ? -1 : 1;
        position *= Math.ceil(maxPosition / step) * step;
      }

      // If computed line position returns negative then line numbers are
      // relative to the bottom of the video instead of the top. Therefore, we
      // need to increase our initial position by the length or width of the
      // video, depending on the writing direction, and reverse our axis directions.
      if (linePos < 0) {
        position += cue.vertical === "" ? containerBox.height : containerBox.width;
        axis = axis.reverse();
      }

      // Move the box to the specified position. This may not be its best
      // position.
      boxPosition.move(initialAxis, position);

    } else {
      // If we have a percentage line value for the cue.
      var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

      switch (cue.lineAlign) {
      case "middle":
        linePos -= (calculatedPercentage / 2);
        break;
      case "end":
        linePos -= calculatedPercentage;
        break;
      }

      // Apply initial line position to the cue box.
      switch (cue.vertical) {
      case "":
        styleBox.applyStyles({
          top: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "rl":
        styleBox.applyStyles({
          left: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "lr":
        styleBox.applyStyles({
          right: styleBox.formatStyle(linePos, "%")
        });
        break;
      }

      axis = [ "+y", "-x", "+x", "-y" ];

      // Get the box position again after we've applied the specified positioning
      // to it.
      boxPosition = new BoxPosition(styleBox);
    }

    var bestPosition = findBestPosition(boxPosition, axis);
    styleBox.move(bestPosition.toCSSCompatValues(containerBox));
  }

  function WebVTT() {
    // Nothing
  }

  // Helper to allow strings to be decoded instead of the default binary utf8 data.
  WebVTT.StringDecoder = function() {
    return {
      decode: function(data) {
        if (!data) {
          return "";
        }
        if (typeof data !== "string") {
          throw new Error("Error - expected string data.");
        }
        return decodeURIComponent(encodeURIComponent(data));
      }
    };
  };

  WebVTT.convertCueToDOMTree = function(window, cuetext) {
    if (!window || !cuetext) {
      return null;
    }
    return parseContent(window, cuetext);
  };

  var FONT_SIZE_PERCENT = 0.05;
  var FONT_STYLE = "sans-serif";
  var CUE_BACKGROUND_PADDING = "1.5%";

  // Runs the processing model over the cues and regions passed to it.
  // @param overlay A block level element (usually a div) that the computed cues
  //                and regions will be placed into.
  WebVTT.processCues = function(window, cues, overlay) {
    if (!window || !cues || !overlay) {
      return null;
    }

    // Remove all previous children.
    while (overlay.firstChild) {
      overlay.removeChild(overlay.firstChild);
    }

    var paddedOverlay = window.document.createElement("div");
    paddedOverlay.style.position = "absolute";
    paddedOverlay.style.left = "0";
    paddedOverlay.style.right = "0";
    paddedOverlay.style.top = "0";
    paddedOverlay.style.bottom = "0";
    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
    overlay.appendChild(paddedOverlay);

    // Determine if we need to compute the display states of the cues. This could
    // be the case if a cue's state has been changed since the last computation or
    // if it has not been computed yet.
    function shouldCompute(cues) {
      for (var i = 0; i < cues.length; i++) {
        if (cues[i].hasBeenReset || !cues[i].displayState) {
          return true;
        }
      }
      return false;
    }

    // We don't need to recompute the cues' display states. Just reuse them.
    if (!shouldCompute(cues)) {
      for (var i = 0; i < cues.length; i++) {
        paddedOverlay.appendChild(cues[i].displayState);
      }
      return;
    }

    var boxPositions = [],
        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
    var styleOptions = {
      font: fontSize + "px " + FONT_STYLE
    };

    (function() {
      var styleBox, cue;

      for (var i = 0; i < cues.length; i++) {
        cue = cues[i];

        // Compute the intial position and styles of the cue div.
        styleBox = new CueStyleBox(window, cue, styleOptions);
        paddedOverlay.appendChild(styleBox.div);

        // Move the cue div to it's correct line position.
        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

        // Remember the computed div so that we don't have to recompute it later
        // if we don't have too.
        cue.displayState = styleBox.div;

        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
      }
    })();
  };

  WebVTT.Parser = function(window, vttjs, decoder) {
    if (!decoder) {
      decoder = vttjs;
      vttjs = {};
    }
    if (!vttjs) {
      vttjs = {};
    }

    this.window = window;
    this.vttjs = vttjs;
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = decoder || new TextDecoder("utf8");
    this.regionList = [];
  };

  WebVTT.Parser.prototype = {
    // If the error is a ParsingError then report it to the consumer if
    // possible. If it's not a ParsingError then throw it like normal.
    reportOrThrowError: function(e) {
      if (e instanceof ParsingError) {
        this.onparsingerror && this.onparsingerror(e);
      } else {
        throw e;
      }
    },
    parse: function (data) {
      var self = this;

      // If there is no data then we won't decode it, but will just try to parse
      // whatever is in buffer already. This may occur in circumstances, for
      // example when flush() is called.
      if (data) {
        // Try to decode the data that we received.
        self.buffer += self.decoder.decode(data, {stream: true});
      }

      function collectNextLine() {
        var buffer = self.buffer;
        var pos = 0;
        while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
          ++pos;
        }
        var line = buffer.substr(0, pos);
        // Advance the buffer early in case we fail below.
        if (buffer[pos] === '\r') {
          ++pos;
        }
        if (buffer[pos] === '\n') {
          ++pos;
        }
        self.buffer = buffer.substr(pos);
        return line;
      }

      // 3.4 WebVTT region and WebVTT region settings syntax
      function parseRegion(input) {
        var settings = new Settings();

        parseOptions(input, function (k, v) {
          switch (k) {
          case "id":
            settings.set(k, v);
            break;
          case "width":
            settings.percent(k, v);
            break;
          case "lines":
            settings.integer(k, v);
            break;
          case "regionanchor":
          case "viewportanchor":
            var xy = v.split(',');
            if (xy.length !== 2) {
              break;
            }
            // We have to make sure both x and y parse, so use a temporary
            // settings object here.
            var anchor = new Settings();
            anchor.percent("x", xy[0]);
            anchor.percent("y", xy[1]);
            if (!anchor.has("x") || !anchor.has("y")) {
              break;
            }
            settings.set(k + "X", anchor.get("x"));
            settings.set(k + "Y", anchor.get("y"));
            break;
          case "scroll":
            settings.alt(k, v, ["up"]);
            break;
          }
        }, /=/, /\s/);

        // Create the region, using default values for any values that were not
        // specified.
        if (settings.has("id")) {
          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
          region.width = settings.get("width", 100);
          region.lines = settings.get("lines", 3);
          region.regionAnchorX = settings.get("regionanchorX", 0);
          region.regionAnchorY = settings.get("regionanchorY", 100);
          region.viewportAnchorX = settings.get("viewportanchorX", 0);
          region.viewportAnchorY = settings.get("viewportanchorY", 100);
          region.scroll = settings.get("scroll", "");
          // Register the region.
          self.onregion && self.onregion(region);
          // Remember the VTTRegion for later in case we parse any VTTCues that
          // reference it.
          self.regionList.push({
            id: settings.get("id"),
            region: region
          });
        }
      }

      // 3.2 WebVTT metadata header syntax
      function parseHeader(input) {
        parseOptions(input, function (k, v) {
          switch (k) {
          case "Region":
            // 3.3 WebVTT region metadata header syntax
            parseRegion(v);
            break;
          }
        }, /:/);
      }

      // 5.1 WebVTT file parsing.
      try {
        var line;
        if (self.state === "INITIAL") {
          // We can't start parsing until we have the first line.
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }

          line = collectNextLine();

          var m = line.match(/^WEBVTT([ \t].*)?$/);
          if (!m || !m[0]) {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }

          self.state = "HEADER";
        }

        var alreadyCollectedLine = false;
        while (self.buffer) {
          // We can't parse a line until we have the full line.
          if (!/\r\n|\n/.test(self.buffer)) {
            return this;
          }

          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }

          switch (self.state) {
          case "HEADER":
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = "ID";
            }
            continue;
          case "NOTE":
            // Ignore NOTE blocks.
            if (!line) {
              self.state = "ID";
            }
            continue;
          case "ID":
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = "NOTE";
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
            self.state = "CUE";
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf("-->") === -1) {
              self.cue.id = line;
              continue;
            }
            // Process line as start of a cue.
            /*falls through*/
          case "CUE":
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              self.reportOrThrowError(e);
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = "BADCUE";
              continue;
            }
            self.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var hasSubstring = line.indexOf("-->") !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              self.oncue && self.oncue(self.cue);
              self.cue = null;
              self.state = "ID";
              continue;
            }
            if (self.cue.text) {
              self.cue.text += "\n";
            }
            self.cue.text += line;
            continue;
          case "BADCUE": // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = "ID";
            }
            continue;
          }
        }
      } catch (e) {
        self.reportOrThrowError(e);

        // If we are currently parsing a cue, report what we have.
        if (self.state === "CUETEXT" && self.cue && self.oncue) {
          self.oncue(self.cue);
        }
        self.cue = null;
        // Enter BADWEBVTT state if header was not parsed correctly otherwise
        // another exception occurred so enter BADCUE state.
        self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function () {
      var self = this;
      try {
        // Finish decoding the stream.
        self.buffer += self.decoder.decode();
        // Synthesize the end of the current cue or region.
        if (self.cue || self.state === "HEADER") {
          self.buffer += "\n\n";
          self.parse();
        }
        // If we've flushed, parsed, and we're still on the INITIAL state then
        // that means we don't have enough of the stream to parse the first
        // line.
        if (self.state === "INITIAL") {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
      } catch(e) {
        self.reportOrThrowError(e);
      }
      self.onflush && self.onflush();
      return this;
    }
  };

  global.WebVTT = WebVTT;

}(this, (this.vttjs || {})));


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3ZpZGVvLmpzL2Rpc3QvdmlkZW8uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsMkRBQTJELG1CQUFtQixnREFBZ0QsYUFBYSxLQUFLLE1BQU0sZ0NBQWdDLFNBQVMscUNBQXFDLFNBQVMsbUNBQW1DLE9BQU8sS0FBSyxPQUFPLGlCQUFpQixhQUFhLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsd0JBQXdCLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDM3lCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7QUFDdEksMkNBQTJDLGNBQWM7QUFDekQsQ0FBQyxFQUFFLGlCQUFpQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTtBQUN0SSwyQ0FBMkMsY0FBYztBQUN6RCxDQUFDLEdBQUc7O0FBRUosQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDJCQUEyQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxzQ0FBc0M7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2REFBNkQ7QUFDNUY7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHFDQUFxQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTyxXQUFXO0FBQzdCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxQkFBcUI7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHFDQUFxQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUscUtBQXFLO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxpS0FBaUs7QUFDcEs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0JBQWdCO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSx5QkFBeUI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsRUFBRSxvRUFBb0U7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0JBQWdCO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLG9CQUFvQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0JBQXNCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixHQUFHO0FBQ0gsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUseUhBQXlIO0FBQzVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDREQUE0RDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMkRBQTJEO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQixFQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLG1GQUFtRjtBQUN0Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0JBQWdCO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsOEVBQThFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwSEFBMEg7QUFDN0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDhCQUE4QjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsVUFBVTtBQUNWO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0RBQWdEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0hBQXdIO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLG1EQUFtRDtBQUNuRCw0RUFBNEU7QUFDNUUsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsK01BQStNO0FBQ2xOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CLEdBQUcsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxHQUFHLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXLDhCQUE4QixHQUFHLDRCQUE0QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMkRBQTJEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFlBQVksRUFBRTtBQUN2QyxnQkFBZ0Isc0JBQXNCO0FBQ3RDOztBQUVBLG9CQUFvQjtBQUNwQiw2QkFBNkIsaUJBQWlCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQSwwRkFBMEYsY0FBYztBQUN4RywyQ0FBMkMsYUFBYTs7QUFFeEQ7QUFDQTtBQUNBLCtCQUErQixjQUFjOztBQUU3QztBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0EsMkNBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQyw4QkFBOEIsY0FBYztBQUM1QywwRUFBMEUsY0FBYzs7QUFFeEYsd0dBQXdHLGNBQWM7O0FBRXRIO0FBQ0EsNENBQTRDLGNBQWM7O0FBRTFELDZEQUE2RCxjQUFjOztBQUUzRTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUUsaUJBQWlCO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlEQUFpRDtBQUM3RTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHNEQUFzRDtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSx5RUFBeUU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLEVBQUUsWUFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsOEJBQThCOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBLDhFQUE4RSxxQ0FBcUMsRUFBRTs7QUFFckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHNCQUFzQjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsbUJBQW1CO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxzQkFBc0I7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUJBQW1CO0FBQ3RCLEdBQUcsc0JBQXNCLG1DQUFtQyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsdUNBQXVDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHNCQUFzQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxTQUFTO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMkVBQTJFO0FBQzlFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxpQkFBaUI7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsd0JBQXdCO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUscUNBQXFDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSx5QkFBeUIsZUFBZSxFQUFFOztBQUU5USxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esd0dBQXdHOztBQUV4RztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQSxrSUFBa0k7O0FBRWxJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQscUVBQXFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsdUpBQXVKO0FBQzFKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSx5QkFBeUIsZUFBZSxFQUFFOztBQUU5USxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx3SEFBd0g7QUFDeEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7O0FBRTFFLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsVUFBVTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsOElBQThJO0FBQ2pKOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQ7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsK0JBQStCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHlCQUF5QixlQUFlLEVBQUU7O0FBRTlRLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2Sjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQ0FBa0M7O0FBRXBEO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixjQUFjLFVBQVU7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFxRTtBQUN6RixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHNDQUFzQyxFQUFFO0FBQ3JFLGlDQUFpQywwQ0FBMEMsRUFBRTtBQUM3RSx3QkFBd0IsaUNBQWlDLEVBQUU7QUFDM0QscUNBQXFDLDhDQUE4QyxFQUFFO0FBQ3JGLDhCQUE4Qix1Q0FBdUM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRFQUE0RTs7QUFFNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLGlVQUFpVTtBQUNwVTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsdUZBQXVGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHlCQUF5QixlQUFlLEVBQUU7O0FBRTlRLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFO0FBQzFFLG9GQUFvRjs7QUFFcEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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Q0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxPQUFPO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHdPQUF3TztBQUMzTztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSxPQUFPLGlCQUFpQixtQkFBbUIsdUJBQXVCLDRFQUE0RSxFQUFFLEVBQUUseUJBQXlCLGVBQWUsRUFBRTs7QUFFOVEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHlGQUF5RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHlCQUF5QixlQUFlLEVBQUU7O0FBRTlRLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRTs7QUFFMUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxDQUFDLEVBQUUsMkZBQTJGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1Qyw2QkFBNkIsWUFBWSxFQUFFLE9BQU8saUJBQWlCLG1CQUFtQix1QkFBdUIsNEVBQTRFLEVBQUUsRUFBRSx5QkFBeUIsZUFBZSxFQUFFOztBQUU5USxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBLENBQUMsRUFBRSxpRUFBaUU7QUFDcEU7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHlCQUF5QixlQUFlLEVBQUU7O0FBRTlRLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHlGQUF5RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsc0NBQXNDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUUsdUJBQXVCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSxPQUFPLGlCQUFpQixtQkFBbUIsdUJBQXVCLDRFQUE0RSxFQUFFLEVBQUUseUJBQXlCLGVBQWUsRUFBRTs7QUFFOVEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLG9EQUFvRCxtQkFBbUIsZ0JBQWdCOztBQUV2Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPLGVBQWU7QUFDbEMsWUFBWSxPQUFPLGVBQWU7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSwyRUFBMkU7O0FBRTNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLHVDQUF1QztBQUNyRDtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLCtFQUErRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHlCQUF5QixlQUFlLEVBQUU7O0FBRTlROztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLGFBQWE7QUFDekIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksY0FBYztBQUMxQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxhQUFhO0FBQ3pCLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxDQUFDLEVBQUUsb0ZBQW9GO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLGdCQUFnQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE87QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYTtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsa0NBQWtDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxnQ0FBZ0M7QUFDbkM7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxvQkFBb0I7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLGVBQWU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHNDQUFzQztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNkJBQTZCLFlBQVksRUFBRSxPQUFPLGlCQUFpQixtQkFBbUIsdUJBQXVCLDRFQUE0RSxFQUFFLEVBQUUseUJBQXlCLGVBQWUsRUFBRTs7QUFFOVEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsdUJBQXVCLHdCQUF3QixTQUFTLHNCQUFzQixzQ0FBc0M7QUFDN0s7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0QkFBNEI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxZQUFZLEVBQUU7QUFDZCxZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksYUFBYTtBQUN6QixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLGFBQWE7QUFDekIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxjQUFjO0FBQzFCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPLGVBQWU7QUFDbEMsWUFBWSxPQUFPLGVBQWU7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLHVDQUF1QztBQUNuRCxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksdUNBQXVDO0FBQ25ELFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHFsQkFBcWxCLEVBQUUsR0FBRztBQUM3bEIsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjLHVCQUF1QjtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVCxTQUFTO0FBQ1QsVUFBVTtBQUNWLFVBQVU7QUFDVixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWdEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixpQkFBaUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsd0JBQXdCIiwiZmlsZSI6InZpZGVvanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBWaWRlby5qcyA1LjExLjcgPGh0dHA6Ly92aWRlb2pzLmNvbS8+XG4gKiBDb3B5cmlnaHQgQnJpZ2h0Y292ZSwgSW5jLiA8aHR0cHM6Ly93d3cuYnJpZ2h0Y292ZS5jb20vPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi9tYXN0ZXIvTElDRU5TRT5cbiAqXG4gKiBJbmNsdWRlcyB2dHQuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcz5cbiAqIEF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMFxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICovXG5cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLnZpZGVvanMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IF9kZXJlcV8oJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTluYkc5aVlXd3ZaRzlqZFcxbGJuUXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKMllYSWdkRzl3VEdWMlpXd2dQU0IwZVhCbGIyWWdaMnh2WW1Gc0lDRTlQU0FuZFc1a1pXWnBibVZrSnlBL0lHZHNiMkpoYkNBNlhHNGdJQ0FnZEhsd1pXOW1JSGRwYm1SdmR5QWhQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5QjNhVzVrYjNjZ09pQjdmVnh1ZG1GeUlHMXBia1J2WXlBOUlISmxjWFZwY21Vb0oyMXBiaTFrYjJOMWJXVnVkQ2NwTzF4dVhHNXBaaUFvZEhsd1pXOW1JR1J2WTNWdFpXNTBJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5a2dlMXh1SUNBZ0lHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1pHOWpkVzFsYm5RN1hHNTlJR1ZzYzJVZ2UxeHVJQ0FnSUhaaGNpQmtiMk5qZVNBOUlIUnZjRXhsZG1Wc1d5ZGZYMGRNVDBKQlRGOUVUME5WVFVWT1ZGOURRVU5JUlVBMEoxMDdYRzVjYmlBZ0lDQnBaaUFvSVdSdlkyTjVLU0I3WEc0Z0lDQWdJQ0FnSUdSdlkyTjVJRDBnZEc5d1RHVjJaV3hiSjE5ZlIweFBRa0ZNWDBSUFExVk5SVTVVWDBOQlEwaEZRRFFuWFNBOUlHMXBia1J2WXp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1J2WTJONU8xeHVmVnh1SWwxOVxufSx7XCJtaW4tZG9jdW1lbnRcIjozfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OW5iRzlpWVd3dmQybHVaRzkzTG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWFXWWdLSFI1Y0dWdlppQjNhVzVrYjNjZ0lUMDlJRndpZFc1a1pXWnBibVZrWENJcElIdGNiaUFnSUNCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhkcGJtUnZkenRjYm4wZ1pXeHpaU0JwWmlBb2RIbHdaVzltSUdkc2IySmhiQ0FoUFQwZ1hDSjFibVJsWm1sdVpXUmNJaWtnZTF4dUlDQWdJRzF2WkhWc1pTNWxlSEJ2Y25SeklEMGdaMnh2WW1Gc08xeHVmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdjMlZzWmlBaFBUMGdYQ0oxYm1SbFptbHVaV1JjSWlsN1hHNGdJQ0FnYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0J6Wld4bU8xeHVmU0JsYkhObElIdGNiaUFnSUNCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUh0OU8xeHVmVnh1SWwxOVxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE5hdGl2ZSA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2dldE5hdGl2ZScpO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IGdldE5hdGl2ZShEYXRlLCAnbm93Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gbG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgZnVuY3Rpb24gdG8gYmUgaW52b2tlZFxuICovXG52YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdztcblxufSx7XCIuLi9pbnRlcm5hbC9nZXROYXRpdmVcIjoyMH1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi4vbGFuZy9pc09iamVjdCcpLFxuICAgIG5vdyA9IF9kZXJlcV8oJy4uL2RhdGUvbm93Jyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3RcbiAqIGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmVcbiAqICBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBpbnZva2UgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICogICAnbWF4V2FpdCc6IDEwMDBcbiAqIH0pKTtcbiAqXG4gKiAvLyBjYW5jZWwgYSBkZWJvdW5jZWQgY2FsbFxuICogdmFyIHRvZG9DaGFuZ2VzID0gXy5kZWJvdW5jZShiYXRjaExvZywgMTAwMCk7XG4gKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMudG9kbywgdG9kb0NoYW5nZXMpO1xuICpcbiAqIE9iamVjdC5vYnNlcnZlKG1vZGVscywgZnVuY3Rpb24oY2hhbmdlcykge1xuICogICBpZiAoXy5maW5kKGNoYW5nZXMsIHsgJ3VzZXInOiAndG9kbycsICd0eXBlJzogJ2RlbGV0ZSd9KSkge1xuICogICAgIHRvZG9DaGFuZ2VzLmNhbmNlbCgpO1xuICogICB9XG4gKiB9LCBbJ2RlbGV0ZSddKTtcbiAqXG4gKiAvLyAuLi5hdCBzb21lIHBvaW50IGBtb2RlbHMudG9kb2AgaXMgY2hhbmdlZFxuICogbW9kZWxzLnRvZG8uY29tcGxldGVkID0gdHJ1ZTtcbiAqXG4gKiAvLyAuLi5iZWZvcmUgMSBzZWNvbmQgaGFzIHBhc3NlZCBgbW9kZWxzLnRvZG9gIGlzIGRlbGV0ZWRcbiAqIC8vIHdoaWNoIGNhbmNlbHMgdGhlIGRlYm91bmNlZCBgdG9kb0NoYW5nZXNgIGNhbGxcbiAqIGRlbGV0ZSBtb2RlbHMudG9kbztcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgYXJncyxcbiAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YW1wLFxuICAgICAgdGhpc0FyZyxcbiAgICAgIHRpbWVvdXRJZCxcbiAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB3YWl0IDwgMCA/IDAgOiAoK3dhaXQgfHwgMCk7XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBsYXN0Q2FsbGVkID0gMDtcbiAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZShpc0NhbGxlZCwgaWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfVxuICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGNvbXBsZXRlKHRyYWlsaW5nQ2FsbCwgbWF4VGltZW91dElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heERlbGF5ZWQoKSB7XG4gICAgY29tcGxldGUodHJhaWxpbmcsIHRpbWVvdXRJZCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzdGFtcCA9IG5vdygpO1xuICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgIH1cbiAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiBtYXhXYWl0O1xuXG4gICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgIH1cbiAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgfVxuICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgIGFyZ3MgPSB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cbn0se1wiLi4vZGF0ZS9ub3dcIjo0LFwiLi4vbGFuZy9pc09iamVjdFwiOjMzfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRlYm91bmNlID0gX2RlcmVxXygnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gX2RlcmVxXygnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlXG4gKiB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGVcbiAqIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZ1xuICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIGludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gY2FuY2VsIGEgdHJhaWxpbmcgdGhyb3R0bGVkIGNhbGxcbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICBsZWFkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgeyAnbGVhZGluZyc6IGxlYWRpbmcsICdtYXhXYWl0JzogK3dhaXQsICd0cmFpbGluZyc6IHRyYWlsaW5nIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuXG59LHtcIi4uL2xhbmcvaXNPYmplY3RcIjozMyxcIi4vZGVib3VuY2VcIjo1fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29weShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUNvcHk7XG5cbn0se31dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcblxufSx7fV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcblxufSx7fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNyZWF0ZUJhc2VGb3IgPSBfZGVyZXFfKCcuL2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxufSx7XCIuL2NyZWF0ZUJhc2VGb3JcIjoxOH1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBiYXNlRm9yID0gX2RlcmVxXygnLi9iYXNlRm9yJyksXG4gICAga2V5c0luID0gX2RlcmVxXygnLi4vb2JqZWN0L2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckluYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JJbjtcblxufSx7XCIuLi9vYmplY3Qva2V5c0luXCI6MzksXCIuL2Jhc2VGb3JcIjoxMX1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhcnJheUVhY2ggPSBfZGVyZXFfKCcuL2FycmF5RWFjaCcpLFxuICAgIGJhc2VNZXJnZURlZXAgPSBfZGVyZXFfKCcuL2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc0FycmF5ID0gX2RlcmVxXygnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSBfZGVyZXFfKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3QgPSBfZGVyZXFfKCcuLi9sYW5nL2lzT2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gX2RlcmVxXygnLi9pc09iamVjdExpa2UnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSBfZGVyZXFfKCcuLi9sYW5nL2lzVHlwZWRBcnJheScpLFxuICAgIGtleXMgPSBfZGVyZXFfKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICB2YXIgaXNTcmNBcnIgPSBpc0FycmF5TGlrZShzb3VyY2UpICYmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNUeXBlZEFycmF5KHNvdXJjZSkpLFxuICAgICAgcHJvcHMgPSBpc1NyY0FyciA/IHVuZGVmaW5lZCA6IGtleXMoc291cmNlKTtcblxuICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzcmNWYWx1ZTtcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc09iamVjdExpa2Uoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGlzQ29tbW9uID0gcmVzdWx0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgocmVzdWx0ICE9PSB1bmRlZmluZWQgfHwgKGlzU3JjQXJyICYmICEoa2V5IGluIG9iamVjdCkpKSAmJlxuICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuXG59LHtcIi4uL2xhbmcvaXNBcnJheVwiOjMwLFwiLi4vbGFuZy9pc09iamVjdFwiOjMzLFwiLi4vbGFuZy9pc1R5cGVkQXJyYXlcIjozNixcIi4uL29iamVjdC9rZXlzXCI6MzgsXCIuL2FycmF5RWFjaFwiOjksXCIuL2Jhc2VNZXJnZURlZXBcIjoxNCxcIi4vaXNBcnJheUxpa2VcIjoyMSxcIi4vaXNPYmplY3RMaWtlXCI6MjZ9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYXJyYXlDb3B5ID0gX2RlcmVxXygnLi9hcnJheUNvcHknKSxcbiAgICBpc0FyZ3VtZW50cyA9IF9kZXJlcV8oJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gX2RlcmVxXygnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSBfZGVyZXFfKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNQbGFpbk9iamVjdCA9IF9kZXJlcV8oJy4uL2xhbmcvaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IF9kZXJlcV8oJy4uL2xhbmcvaXNUeXBlZEFycmF5JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IF9kZXJlcV8oJy4uL2xhbmcvdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGgsXG4gICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBzcmNWYWx1ZSkge1xuICAgICAgb2JqZWN0W2tleV0gPSBzdGFja0JbbGVuZ3RoXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgaXNDb21tb24gPSByZXN1bHQgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uoc3JjVmFsdWUpICYmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSkge1xuICAgICAgcmVzdWx0ID0gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IChpc0FycmF5TGlrZSh2YWx1ZSkgPyBhcnJheUNvcHkodmFsdWUpIDogW10pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIHJlc3VsdCA9IGlzQXJndW1lbnRzKHZhbHVlKVxuICAgICAgICA/IHRvUGxhaW5PYmplY3QodmFsdWUpXG4gICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGVcbiAgLy8gaXQgd2l0aCBpdHMgbWVyZ2VkIHZhbHVlLlxuICBzdGFja0EucHVzaChzcmNWYWx1ZSk7XG4gIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgb2JqZWN0W2tleV0gPSBtZXJnZUZ1bmMocmVzdWx0LCBzcmNWYWx1ZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHtcbiAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG5cbn0se1wiLi4vbGFuZy9pc0FyZ3VtZW50c1wiOjI5LFwiLi4vbGFuZy9pc0FycmF5XCI6MzAsXCIuLi9sYW5nL2lzUGxhaW5PYmplY3RcIjozNCxcIi4uL2xhbmcvaXNUeXBlZEFycmF5XCI6MzYsXCIuLi9sYW5nL3RvUGxhaW5PYmplY3RcIjozNyxcIi4vYXJyYXlDb3B5XCI6OCxcIi4vaXNBcnJheUxpa2VcIjoyMX1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0b09iamVjdCA9IF9kZXJlcV8oJy4vdG9PYmplY3QnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiB0b09iamVjdChvYmplY3QpW2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuXG59LHtcIi4vdG9PYmplY3RcIjoyOH1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpZGVudGl0eSA9IF9kZXJlcV8oJy4uL3V0aWxpdHkvaWRlbnRpdHknKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kQ2FsbGJhY2s7XG5cbn0se1wiLi4vdXRpbGl0eS9pZGVudGl0eVwiOjQyfV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJpbmRDYWxsYmFjayA9IF9kZXJlcV8oJy4vYmluZENhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSBfZGVyZXFfKCcuL2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgcmVzdFBhcmFtID0gX2RlcmVxXygnLi4vZnVuY3Rpb24vcmVzdFBhcmFtJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgb3IgYF8ubWVyZ2VgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzW2xlbmd0aCAtIDJdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkLFxuICAgICAgICB0aGlzQXJnID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VzdG9taXplciA9IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCA1KTtcbiAgICAgIGxlbmd0aCAtPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIHRoaXNBcmcgPT0gJ2Z1bmN0aW9uJyA/IHRoaXNBcmcgOiB1bmRlZmluZWQ7XG4gICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgfVxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG5cbn0se1wiLi4vZnVuY3Rpb24vcmVzdFBhcmFtXCI6NixcIi4vYmluZENhbGxiYWNrXCI6MTYsXCIuL2lzSXRlcmF0ZWVDYWxsXCI6MjR9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdG9PYmplY3QgPSBfZGVyZXFfKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaXRlcmFibGUgPSB0b09iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuXG59LHtcIi4vdG9PYmplY3RcIjoyOH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBiYXNlUHJvcGVydHkgPSBfZGVyZXFfKCcuL2Jhc2VQcm9wZXJ0eScpO1xuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldExlbmd0aDtcblxufSx7XCIuL2Jhc2VQcm9wZXJ0eVwiOjE1fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzTmF0aXZlID0gX2RlcmVxXygnLi4vbGFuZy9pc05hdGl2ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxufSx7XCIuLi9sYW5nL2lzTmF0aXZlXCI6MzJ9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZ2V0TGVuZ3RoID0gX2RlcmVxXygnLi9nZXRMZW5ndGgnKSxcbiAgICBpc0xlbmd0aCA9IF9kZXJlcV8oJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG5cbn0se1wiLi9nZXRMZW5ndGhcIjoxOSxcIi4vaXNMZW5ndGhcIjoyNX1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG52YXIgaXNIb3N0T2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIE9iamVjdCh7ICd0b1N0cmluZyc6IDAgfSArICcnKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gSUUgPCA5IHByZXNlbnRzIG1hbnkgaG9zdCBvYmplY3RzIGFzIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlXG4gICAgLy8gdG8gc3RyaW5ncyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKHZhbHVlICsgJycpID09ICdzdHJpbmcnO1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0hvc3RPYmplY3Q7XG5cbn0se31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG59LHt9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNBcnJheUxpa2UgPSBfZGVyZXFfKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IF9kZXJlcV8oJy4vaXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gX2RlcmVxXygnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuXG59LHtcIi4uL2xhbmcvaXNPYmplY3RcIjozMyxcIi4vaXNBcnJheUxpa2VcIjoyMSxcIi4vaXNJbmRleFwiOjIzfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxufSx7fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxufSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzQXJndW1lbnRzID0gX2RlcmVxXygnLi4vbGFuZy9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSBfZGVyZXFfKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gX2RlcmVxXygnLi9pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSBfZGVyZXFfKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNTdHJpbmcgPSBfZGVyZXFfKCcuLi9sYW5nL2lzU3RyaW5nJyksXG4gICAga2V5c0luID0gX2RlcmVxXygnLi4vb2JqZWN0L2tleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XG5cbiAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkgfHwgaXNTdHJpbmcob2JqZWN0KSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hpbUtleXM7XG5cbn0se1wiLi4vbGFuZy9pc0FyZ3VtZW50c1wiOjI5LFwiLi4vbGFuZy9pc0FycmF5XCI6MzAsXCIuLi9sYW5nL2lzU3RyaW5nXCI6MzUsXCIuLi9vYmplY3Qva2V5c0luXCI6MzksXCIuL2lzSW5kZXhcIjoyMyxcIi4vaXNMZW5ndGhcIjoyNX1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBpc1N0cmluZyA9IF9kZXJlcV8oJy4uL2xhbmcvaXNTdHJpbmcnKSxcbiAgICBzdXBwb3J0ID0gX2RlcmVxXygnLi4vc3VwcG9ydCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gT2JqZWN0KHZhbHVlKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvT2JqZWN0O1xuXG59LHtcIi4uL2xhbmcvaXNPYmplY3RcIjozMyxcIi4uL2xhbmcvaXNTdHJpbmdcIjozNSxcIi4uL3N1cHBvcnRcIjo0MX1dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0FycmF5TGlrZSA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gX2RlcmVxXygnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cbn0se1wiLi4vaW50ZXJuYWwvaXNBcnJheUxpa2VcIjoyMSxcIi4uL2ludGVybmFsL2lzT2JqZWN0TGlrZVwiOjI2fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdldE5hdGl2ZSA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2dldE5hdGl2ZScpLFxuICAgIGlzTGVuZ3RoID0gX2RlcmVxXygnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxufSx7XCIuLi9pbnRlcm5hbC9nZXROYXRpdmVcIjoyMCxcIi4uL2ludGVybmFsL2lzTGVuZ3RoXCI6MjUsXCIuLi9pbnRlcm5hbC9pc09iamVjdExpa2VcIjoyNn1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cbn0se1wiLi9pc09iamVjdFwiOjMzfV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzRnVuY3Rpb24gPSBfZGVyZXFfKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0hvc3RPYmplY3QgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAoaXNIb3N0T2JqZWN0KHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3IpLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmF0aXZlO1xuXG59LHtcIi4uL2ludGVybmFsL2lzSG9zdE9iamVjdFwiOjIyLFwiLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlXCI6MjYsXCIuL2lzRnVuY3Rpb25cIjozMX1dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cbn0se31dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBiYXNlRm9ySW4gPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9iYXNlRm9ySW4nKSxcbiAgICBpc0FyZ3VtZW50cyA9IF9kZXJlcV8oJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0hvc3RPYmplY3QgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKSxcbiAgICBzdXBwb3J0ID0gX2RlcmVxXygnLi4vc3VwcG9ydCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYXNzdW1lcyBvYmplY3RzIGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yXG4gKiBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgdmFyIEN0b3I7XG5cbiAgLy8gRXhpdCBlYXJseSBmb3Igbm9uIGBPYmplY3RgIG9iamVjdHMuXG4gIGlmICghKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3QodmFsdWUpICYmICFpc0FyZ3VtZW50cyh2YWx1ZSkpIHx8XG4gICAgICAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjb25zdHJ1Y3RvcicpICYmIChDdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgIShDdG9yIGluc3RhbmNlb2YgQ3RvcikpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gIHZhciByZXN1bHQ7XG4gIGlmIChzdXBwb3J0Lm93bkxhc3QpIHtcbiAgICBiYXNlRm9ySW4odmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gZmFsc2U7XG4gIH1cbiAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICBiYXNlRm9ySW4odmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHQgPSBrZXk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG59LHtcIi4uL2ludGVybmFsL2Jhc2VGb3JJblwiOjEyLFwiLi4vaW50ZXJuYWwvaXNIb3N0T2JqZWN0XCI6MjIsXCIuLi9pbnRlcm5hbC9pc09iamVjdExpa2VcIjoyNixcIi4uL3N1cHBvcnRcIjo0MSxcIi4vaXNBcmd1bWVudHNcIjoyOX1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc09iamVjdExpa2UgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxufSx7XCIuLi9pbnRlcm5hbC9pc09iamVjdExpa2VcIjoyNn1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0xlbmd0aCA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gX2RlcmVxXygnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuXG59LHtcIi4uL2ludGVybmFsL2lzTGVuZ3RoXCI6MjUsXCIuLi9pbnRlcm5hbC9pc09iamVjdExpa2VcIjoyNn1dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBiYXNlQ29weSA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2Jhc2VDb3B5JyksXG4gICAga2V5c0luID0gX2RlcmVxXygnLi4vb2JqZWN0L2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZVxuICogcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNvcHkodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG5cbn0se1wiLi4vaW50ZXJuYWwvYmFzZUNvcHlcIjoxMCxcIi4uL29iamVjdC9rZXlzSW5cIjozOX1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnZXROYXRpdmUgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9nZXROYXRpdmUnKSxcbiAgICBpc0FycmF5TGlrZSA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3QgPSBfZGVyZXFfKCcuLi9sYW5nL2lzT2JqZWN0JyksXG4gICAgc2hpbUtleXMgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9zaGltS2V5cycpLFxuICAgIHN1cHBvcnQgPSBfZGVyZXFfKCcuLi9zdXBwb3J0Jyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbnZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ID09ICdmdW5jdGlvbicgPyBzdXBwb3J0LmVudW1Qcm90b3R5cGVzIDogaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG59LHtcIi4uL2ludGVybmFsL2dldE5hdGl2ZVwiOjIwLFwiLi4vaW50ZXJuYWwvaXNBcnJheUxpa2VcIjoyMSxcIi4uL2ludGVybmFsL3NoaW1LZXlzXCI6MjcsXCIuLi9sYW5nL2lzT2JqZWN0XCI6MzMsXCIuLi9zdXBwb3J0XCI6NDF9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYXJyYXlFYWNoID0gX2RlcmVxXygnLi4vaW50ZXJuYWwvYXJyYXlFYWNoJyksXG4gICAgaXNBcmd1bWVudHMgPSBfZGVyZXFfKCcuLi9sYW5nL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IF9kZXJlcV8oJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzRnVuY3Rpb24gPSBfZGVyZXFfKCcuLi9sYW5nL2lzRnVuY3Rpb24nKSxcbiAgICBpc0luZGV4ID0gX2RlcmVxXygnLi4vaW50ZXJuYWwvaXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gX2RlcmVxXygnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdCA9IF9kZXJlcV8oJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBpc1N0cmluZyA9IF9kZXJlcV8oJy4uL2xhbmcvaXNTdHJpbmcnKSxcbiAgICBzdXBwb3J0ID0gX2RlcmVxXygnLi4vc3VwcG9ydCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKiBVc2VkIHRvIGZpeCB0aGUgSlNjcmlwdCBgW1tEb250RW51bV1dYCBidWcuICovXG52YXIgc2hhZG93UHJvcHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXG5dO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGVycm9yUHJvdG8gPSBFcnJvci5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gYXZvaWQgaXRlcmF0aW5nIG92ZXIgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbiBJRSA8IDkuICovXG52YXIgbm9uRW51bVByb3BzID0ge307XG5ub25FbnVtUHJvcHNbYXJyYXlUYWddID0gbm9uRW51bVByb3BzW2RhdGVUYWddID0gbm9uRW51bVByb3BzW251bWJlclRhZ10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUsICd0b0xvY2FsZVN0cmluZyc6IHRydWUsICd0b1N0cmluZyc6IHRydWUsICd2YWx1ZU9mJzogdHJ1ZSB9O1xubm9uRW51bVByb3BzW2Jvb2xUYWddID0gbm9uRW51bVByb3BzW3N0cmluZ1RhZ10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUsICd0b1N0cmluZyc6IHRydWUsICd2YWx1ZU9mJzogdHJ1ZSB9O1xubm9uRW51bVByb3BzW2Vycm9yVGFnXSA9IG5vbkVudW1Qcm9wc1tmdW5jVGFnXSA9IG5vbkVudW1Qcm9wc1tyZWdleHBUYWddID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlIH07XG5ub25FbnVtUHJvcHNbb2JqZWN0VGFnXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSB9O1xuXG5hcnJheUVhY2goc2hhZG93UHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICBmb3IgKHZhciB0YWcgaW4gbm9uRW51bVByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwobm9uRW51bVByb3BzLCB0YWcpKSB7XG4gICAgICB2YXIgcHJvcHMgPSBub25FbnVtUHJvcHNbdGFnXTtcbiAgICAgIHByb3BzW2tleV0gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG5cbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpIHx8IGlzU3RyaW5nKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBwcm90byA9IChpc0Z1bmN0aW9uKEN0b3IpICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byxcbiAgICAgIGlzUHJvdG8gPSBwcm90byA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMCxcbiAgICAgIHNraXBFcnJvclByb3BzID0gc3VwcG9ydC5lbnVtRXJyb3JQcm9wcyAmJiAob2JqZWN0ID09PSBlcnJvclByb3RvIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVycm9yKSxcbiAgICAgIHNraXBQcm90byA9IHN1cHBvcnQuZW51bVByb3RvdHlwZXMgJiYgaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICAvLyBsb2Rhc2ggc2tpcHMgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgd2hlbiBpdCBpbmZlcnMgaXQncyBpdGVyYXRpbmdcbiAgLy8gb3ZlciBhIGBwcm90b3R5cGVgIG9iamVjdCBiZWNhdXNlIElFIDwgOSBjYW4ndCBzZXQgdGhlIGBbW0VudW1lcmFibGVdXWBcbiAgLy8gYXR0cmlidXRlIG9mIGFuIGV4aXN0aW5nIHByb3BlcnR5IGFuZCB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBvZiBhXG4gIC8vIHByb3RvdHlwZSBkZWZhdWx0cyB0byBub24tZW51bWVyYWJsZS5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBQcm90byAmJiBrZXkgPT0gJ3Byb3RvdHlwZScpICYmXG4gICAgICAgICEoc2tpcEVycm9yUHJvcHMgJiYgKGtleSA9PSAnbWVzc2FnZScgfHwga2V5ID09ICduYW1lJykpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChzdXBwb3J0Lm5vbkVudW1TaGFkb3dzICYmIG9iamVjdCAhPT0gb2JqZWN0UHJvdG8pIHtcbiAgICB2YXIgdGFnID0gb2JqZWN0ID09PSBzdHJpbmdQcm90byA/IHN0cmluZ1RhZyA6IChvYmplY3QgPT09IGVycm9yUHJvdG8gPyBlcnJvclRhZyA6IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KSksXG4gICAgICAgIG5vbkVudW1zID0gbm9uRW51bVByb3BzW3RhZ10gfHwgbm9uRW51bVByb3BzW29iamVjdFRhZ107XG5cbiAgICBpZiAodGFnID09IG9iamVjdFRhZykge1xuICAgICAgcHJvdG8gPSBvYmplY3RQcm90bztcbiAgICB9XG4gICAgbGVuZ3RoID0gc2hhZG93UHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAga2V5ID0gc2hhZG93UHJvcHNbbGVuZ3RoXTtcbiAgICAgIHZhciBub25FbnVtID0gbm9uRW51bXNba2V5XTtcbiAgICAgIGlmICghKGlzUHJvdG8gJiYgbm9uRW51bSkgJiZcbiAgICAgICAgICAobm9uRW51bSA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIDogb2JqZWN0W2tleV0gIT09IHByb3RvW2tleV0pKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuXG59LHtcIi4uL2ludGVybmFsL2FycmF5RWFjaFwiOjksXCIuLi9pbnRlcm5hbC9pc0luZGV4XCI6MjMsXCIuLi9pbnRlcm5hbC9pc0xlbmd0aFwiOjI1LFwiLi4vbGFuZy9pc0FyZ3VtZW50c1wiOjI5LFwiLi4vbGFuZy9pc0FycmF5XCI6MzAsXCIuLi9sYW5nL2lzRnVuY3Rpb25cIjozMSxcIi4uL2xhbmcvaXNPYmplY3RcIjozMyxcIi4uL2xhbmcvaXNTdHJpbmdcIjozNSxcIi4uL3N1cHBvcnRcIjo0MX1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBiYXNlTWVyZ2UgPSBfZGVyZXFfKCcuLi9pbnRlcm5hbC9iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IF9kZXJlcV8oJy4uL2ludGVybmFsL2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAqIHByb3ZpZGVkIGl0J3MgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmRcbiAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAqIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAqIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gKiB9O1xuICpcbiAqIHZhciBhZ2VzID0ge1xuICogICAnZGF0YSc6IFt7ICdhZ2UnOiAzNiB9LCB7ICdhZ2UnOiA0MCB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKHVzZXJzLCBhZ2VzKTtcbiAqIC8vID0+IHsgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICogICBpZiAoXy5pc0FycmF5KGEpKSB7XG4gKiAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICogICB9XG4gKiB9KTtcbiAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdCddIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoYmFzZU1lcmdlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxufSx7XCIuLi9pbnRlcm5hbC9iYXNlTWVyZ2VcIjoxMyxcIi4uL2ludGVybmFsL2NyZWF0ZUFzc2lnbmVyXCI6MTd9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZXJyb3JQcm90byA9IEVycm9yLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBBbiBvYmplY3QgZW52aXJvbm1lbnQgZmVhdHVyZSBmbGFncy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUgT2JqZWN0XG4gKi9cbnZhciBzdXBwb3J0ID0ge307XG5cbihmdW5jdGlvbih4KSB7XG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IHg7IH0sXG4gICAgICBvYmplY3QgPSB7ICcwJzogeCwgJ2xlbmd0aCc6IHggfSxcbiAgICAgIHByb3BzID0gW107XG5cbiAgQ3Rvci5wcm90b3R5cGUgPSB7ICd2YWx1ZU9mJzogeCwgJ3knOiB4IH07XG4gIGZvciAodmFyIGtleSBpbiBuZXcgQ3RvcikgeyBwcm9wcy5wdXNoKGtleSk7IH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGBuYW1lYCBvciBgbWVzc2FnZWAgcHJvcGVydGllcyBvZiBgRXJyb3IucHJvdG90eXBlYCBhcmVcbiAgICogZW51bWVyYWJsZSBieSBkZWZhdWx0IChJRSA8IDksIFNhZmFyaSA8IDUuMSkuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICogQHR5cGUgYm9vbGVhblxuICAgKi9cbiAgc3VwcG9ydC5lbnVtRXJyb3JQcm9wcyA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXJyb3JQcm90bywgJ21lc3NhZ2UnKSB8fFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXJyb3JQcm90bywgJ25hbWUnKTtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGBwcm90b3R5cGVgIHByb3BlcnRpZXMgYXJlIGVudW1lcmFibGUgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogRmlyZWZveCA8IDMuNiwgT3BlcmEgPiA5LjUwIC0gT3BlcmEgPCAxMS42MCwgYW5kIFNhZmFyaSA8IDUuMVxuICAgKiAoaWYgdGhlIHByb3RvdHlwZSBvciBhIHByb3BlcnR5IG9uIHRoZSBwcm90b3R5cGUgaGFzIGJlZW4gc2V0KVxuICAgKiBpbmNvcnJlY3RseSBzZXQgdGhlIGBbW0VudW1lcmFibGVdXWAgdmFsdWUgb2YgYSBmdW5jdGlvbidzIGBwcm90b3R5cGVgXG4gICAqIHByb3BlcnR5IHRvIGB0cnVlYC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICBzdXBwb3J0LmVudW1Qcm90b3R5cGVzID0gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChDdG9yLCAncHJvdG90eXBlJyk7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBwcm9wZXJ0aWVzIHNoYWRvd2luZyB0aG9zZSBvbiBgT2JqZWN0LnByb3RvdHlwZWAgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiBJbiBJRSA8IDkgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMsIHNoYWRvd2luZyBub24tZW51bWVyYWJsZSBvbmVzLFxuICAgKiBhcmUgbWFkZSBub24tZW51bWVyYWJsZSBhcyB3ZWxsIChhLmsuYSB0aGUgSlNjcmlwdCBgW1tEb250RW51bV1dYCBidWcpLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQubm9uRW51bVNoYWRvd3MgPSAhL3ZhbHVlT2YvLnRlc3QocHJvcHMpO1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGFmdGVyIGluaGVyaXRlZCBwcm9wZXJ0aWVzIChJRSA8IDkpLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQub3duTGFzdCA9IHByb3BzWzBdICE9ICd4JztcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGBBcnJheSNzaGlmdGAgYW5kIGBBcnJheSNzcGxpY2VgIGF1Z21lbnQgYXJyYXktbGlrZSBvYmplY3RzXG4gICAqIGNvcnJlY3RseS5cbiAgICpcbiAgICogRmlyZWZveCA8IDEwLCBjb21wYXRpYmlsaXR5IG1vZGVzIG9mIElFIDgsIGFuZCBJRSA8IDkgaGF2ZSBidWdneSBBcnJheVxuICAgKiBgc2hpZnQoKWAgYW5kIGBzcGxpY2UoKWAgZnVuY3Rpb25zIHRoYXQgZmFpbCB0byByZW1vdmUgdGhlIGxhc3QgZWxlbWVudCxcbiAgICogYHZhbHVlWzBdYCwgb2YgYXJyYXktbGlrZSBvYmplY3RzIGV2ZW4gdGhvdWdoIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IGlzXG4gICAqIHNldCB0byBgMGAuIFRoZSBgc2hpZnQoKWAgbWV0aG9kIGlzIGJ1Z2d5IGluIGNvbXBhdGliaWxpdHkgbW9kZXMgb2YgSUUgOCxcbiAgICogd2hpbGUgYHNwbGljZSgpYCBpcyBidWdneSByZWdhcmRsZXNzIG9mIG1vZGUgaW4gSUUgPCA5LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQuc3BsaWNlT2JqZWN0cyA9IChzcGxpY2UuY2FsbChvYmplY3QsIDAsIDEpLCAhb2JqZWN0WzBdKTtcblxuICAvKipcbiAgICogRGV0ZWN0IGxhY2sgb2Ygc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgKlxuICAgKiBJRSA8IDggY2FuJ3QgYWNjZXNzIGNoYXJhY3RlcnMgYnkgaW5kZXguIElFIDggY2FuIG9ubHkgYWNjZXNzIGNoYXJhY3RlcnNcbiAgICogYnkgaW5kZXggb24gc3RyaW5nIGxpdGVyYWxzLCBub3Qgc3RyaW5nIG9iamVjdHMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICogQHR5cGUgYm9vbGVhblxuICAgKi9cbiAgc3VwcG9ydC51bmluZGV4ZWRDaGFycyA9ICgneCdbMF0gKyBPYmplY3QoJ3gnKVswXSkgIT0gJ3h4Jztcbn0oMSwgMCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnQ7XG5cbn0se31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxufSx7fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IF9kZXJlcV8oJ29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoT2JqZWN0KHN5bSkgaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKGtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxufSx7XCJvYmplY3Qta2V5c1wiOjUwfV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczYtc2hpbVxudmFyIGtleXMgPSBfZGVyZXFfKCdvYmplY3Qta2V5cycpO1xudmFyIGJpbmQgPSBfZGVyZXFfKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgY2FuQmVPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiB0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJiBvYmogIT09IG51bGw7XG59O1xudmFyIGhhc1N5bWJvbHMgPSBfZGVyZXFfKCcuL2hhc1N5bWJvbHMnKSgpO1xudmFyIHRvT2JqZWN0ID0gT2JqZWN0O1xudmFyIHB1c2ggPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLnB1c2gpO1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlMSkge1xuXHRpZiAoIWNhbkJlT2JqZWN0KHRhcmdldCkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7IH1cblx0dmFyIG9ialRhcmdldCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzLCBzb3VyY2UsIGksIHByb3BzLCBzeW1zLCB2YWx1ZSwga2V5O1xuXHRmb3IgKHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgKytzKSB7XG5cdFx0c291cmNlID0gdG9PYmplY3QoYXJndW1lbnRzW3NdKTtcblx0XHRwcm9wcyA9IGtleXMoc291cmNlKTtcblx0XHRpZiAoaGFzU3ltYm9scyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHN5bXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0a2V5ID0gc3ltc1tpXTtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdFx0cHVzaChwcm9wcywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGtleSA9IHByb3BzW2ldO1xuXHRcdFx0dmFsdWUgPSBzb3VyY2Vba2V5XTtcblx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRvYmpUYXJnZXRba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gb2JqVGFyZ2V0O1xufTtcblxufSx7XCIuL2hhc1N5bWJvbHNcIjo0MyxcImZ1bmN0aW9uLWJpbmRcIjo0OSxcIm9iamVjdC1rZXlzXCI6NTB9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX2RlcmVxXygnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gX2RlcmVxXygnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gX2RlcmVxXygnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSBfZGVyZXFfKCcuL3NoaW0nKTtcblxuZGVmaW5lUHJvcGVydGllcyhpbXBsZW1lbnRhdGlvbiwge1xuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW1wbGVtZW50YXRpb247XG5cbn0se1wiLi9pbXBsZW1lbnRhdGlvblwiOjQ0LFwiLi9wb2x5ZmlsbFwiOjUyLFwiLi9zaGltXCI6NTMsXCJkZWZpbmUtcHJvcGVydGllc1wiOjQ2fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IF9kZXJlcV8oJ29iamVjdC1rZXlzJyk7XG52YXIgZm9yZWFjaCA9IF9kZXJlcV8oJ2ZvcmVhY2gnKTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvYmogPSB7fTtcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAneCcsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICAgICAgICBmb3IgKHZhciBfIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cblx0XHRyZXR1cm4gb2JqLnggPT09IG9iajtcblx0fSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIElFIDguICovXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCAmJiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IHByb3BzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvcmVhY2gocHJvcHMsIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIHByZWRpY2F0ZXNbbmFtZV0pO1xuXHR9KTtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuXG59LHtcImZvcmVhY2hcIjo0NyxcIm9iamVjdC1rZXlzXCI6NTB9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG59LHt9XSw0ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcblxufSx7fV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGltcGxlbWVudGF0aW9uID0gX2RlcmVxXygnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuXG59LHtcIi4vaW1wbGVtZW50YXRpb25cIjo0OH1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSBfZGVyZXFfKCcuL2lzQXJndW1lbnRzJyk7XG52YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xudmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG52YXIgZG9udEVudW1zID0gW1xuXHQndG9TdHJpbmcnLFxuXHQndG9Mb2NhbGVTdHJpbmcnLFxuXHQndmFsdWVPZicsXG5cdCdoYXNPd25Qcm9wZXJ0eScsXG5cdCdpc1Byb3RvdHlwZU9mJyxcblx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0J2NvbnN0cnVjdG9yJ1xuXTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG59O1xudmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0JGNvbnNvbGU6IHRydWUsXG5cdCRleHRlcm5hbDogdHJ1ZSxcblx0JGZyYW1lOiB0cnVlLFxuXHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHQkZnJhbWVzOiB0cnVlLFxuXHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdCRpbm5lcldpZHRoOiB0cnVlLFxuXHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdCRvdXRlcldpZHRoOiB0cnVlLFxuXHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0JHBhcmVudDogdHJ1ZSxcblx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdCRzY3JvbGxUb3A6IHRydWUsXG5cdCRzY3JvbGxYOiB0cnVlLFxuXHQkc2Nyb2xsWTogdHJ1ZSxcblx0JHNlbGY6IHRydWUsXG5cdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0JHdpbmRvdzogdHJ1ZVxufTtcbnZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHQvKiBnbG9iYWwgd2luZG93ICovXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIga2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0fVxuXG5cdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhlS2V5cztcbn07XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHJldHVybiAoT2JqZWN0LmtleXMoYXJndW1lbnRzKSB8fCAnJykubGVuZ3RoID09PSAyO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0dmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cbn0se1wiLi9pc0FyZ3VtZW50c1wiOjUxfV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cbn0se31dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gX2RlcmVxXygnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgbGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly8gdjgsIHNwZWNpZmljYWxseSBpbiBub2RlIDQueCwgaGFzIGEgYnVnIHdpdGggaW5jb3JyZWN0IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyXG5cdC8vIG5vdGU6IHRoaXMgZG9lcyBub3QgZGV0ZWN0IHRoZSBidWcgdW5sZXNzIHRoZXJlJ3MgMjAgY2hhcmFjdGVyc1xuXHR2YXIgc3RyID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0Jztcblx0dmFyIGxldHRlcnMgPSBzdHIuc3BsaXQoJycpO1xuXHR2YXIgbWFwID0ge307XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7ICsraSkge1xuXHRcdG1hcFtsZXR0ZXJzW2ldXSA9IGxldHRlcnNbaV07XG5cdH1cblx0dmFyIG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIG1hcCk7XG5cdHZhciBhY3R1YWwgPSAnJztcblx0Zm9yICh2YXIgayBpbiBvYmopIHtcblx0XHRhY3R1YWwgKz0gaztcblx0fVxuXHRyZXR1cm4gc3RyICE9PSBhY3R1YWw7XG59O1xuXG52YXIgYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICghT2JqZWN0LmFzc2lnbiB8fCAhT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIEZpcmVmb3ggMzcgc3RpbGwgaGFzIFwicGVuZGluZyBleGNlcHRpb25cIiBsb2dpYyBpbiBpdHMgT2JqZWN0LmFzc2lnbiBpbXBsZW1lbnRhdGlvbixcblx0Ly8gd2hpY2ggaXMgNzIlIHNsb3dlciB0aGFuIG91ciBzaGltLCBhbmQgRmlyZWZveCA0MCdzIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cblx0dmFyIHRocm93ZXIgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoeyAxOiAyIH0pO1xuXHR0cnkge1xuXHRcdE9iamVjdC5hc3NpZ24odGhyb3dlciwgJ3h5Jyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gdGhyb3dlclsxXSA9PT0gJ3knO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG5cdH1cblx0aWYgKGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlcigpKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdGlmIChhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucygpKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdHJldHVybiBPYmplY3QuYXNzaWduO1xufTtcblxufSx7XCIuL2ltcGxlbWVudGF0aW9uXCI6NDR9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSBfZGVyZXFfKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gX2RlcmVxXygnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1Bc3NpZ24oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShcblx0XHRPYmplY3QsXG5cdFx0eyBhc3NpZ246IHBvbHlmaWxsIH0sXG5cdFx0eyBhc3NpZ246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24gIT09IHBvbHlmaWxsOyB9IH1cblx0KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxufSx7XCIuL3BvbHlmaWxsXCI6NTIsXCJkZWZpbmUtcHJvcGVydGllc1wiOjQ2fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTYWZlUGFyc2VUdXBsZVxuXG5mdW5jdGlvbiBTYWZlUGFyc2VUdXBsZShvYmosIHJldml2ZXIpIHtcbiAgICB2YXIganNvblxuICAgIHZhciBlcnJvciA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKG9iaiwgcmV2aXZlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4gW2Vycm9yLCBqc29uXVxufVxuXG59LHt9XSw1NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBjbGVhbiAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXG5cXHI/XFxzKi9nLCAnJylcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRzbWwgKHNhKSB7XG4gIHZhciBzID0gJydcbiAgICAsIGkgPSAwXG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgcyArPSBjbGVhbihzYVtpXSkgKyAoYXJndW1lbnRzW2kgKyAxXSB8fCAnJylcblxuICByZXR1cm4gc1xufVxufSx7fV0sNTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gX2RlcmVxXyhcImdsb2JhbC93aW5kb3dcIilcbnZhciBvbmNlID0gX2RlcmVxXyhcIm9uY2VcIilcbnZhciBpc0Z1bmN0aW9uID0gX2RlcmVxXyhcImlzLWZ1bmN0aW9uXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gX2RlcmVxXyhcInBhcnNlLWhlYWRlcnNcIilcbnZhciB4dGVuZCA9IF9kZXJlcV8oXCJ4dGVuZFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3BcbmNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKSkgPyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxuZm9yRWFjaEFycmF5KFtcImdldFwiLCBcInB1dFwiLCBcInBvc3RcIiwgXCJwYXRjaFwiLCBcImhlYWRcIiwgXCJkZWxldGVcIl0sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGNyZWF0ZVhIUlttZXRob2QgPT09IFwiZGVsZXRlXCIgPyBcImRlbFwiIDogbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgICAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxuICAgIH1cbn0pXG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmope1xuICAgIGZvcih2YXIgaSBpbiBvYmope1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gdXJpXG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt1cmk6dXJpfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0geHRlbmQob3B0aW9ucywge3VyaTogdXJpfSlcbiAgICB9XG5cbiAgICBwYXJhbXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHJldHVybiBwYXJhbXNcbn1cblxuZnVuY3Rpb24gY3JlYXRlWEhSKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVYSFIob3B0aW9ucykge1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2tcbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgbG9hZEZ1bmMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcInRleHRcIiB8fCAheGhyLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgeGhyLnJlc3BvbnNlWE1MXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG5cbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgIHZhciBzdGF0dXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9JRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcblxuICAgIH1cblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgYWJvcnRlZFxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGEgfHwgbnVsbFxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlXG4gICAgdmFyIHRpbWVvdXRUaW1lclxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiYWNjZXB0XCJdIHx8IGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gfHwgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZClcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgaWYoIXN5bmMpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gICAgLy8gbm90IHNldHRpbmcgdGltZW91dCBvbiB0aGUgeGhyIG9iamVjdCwgYmVjYXVzZSBvZiBvbGQgd2Via2l0cyBldGMuIG5vdCBoYW5kbGluZyB0aGF0IGNvcnJlY3RseVxuICAgIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xuICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBhYm9ydGVkPXRydWUvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXG4gICAgICAgICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IHRpbWVvdXRcIilcbiAgICAgICAgICAgIGUuY29kZSA9IFwiRVRJTUVET1VUXCJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKVxuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQgKVxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzICYmICFpc0VtcHR5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSlcblxuICAgIHJldHVybiB4aHJcblxuXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG59LHtcImdsb2JhbC93aW5kb3dcIjoyLFwiaXMtZnVuY3Rpb25cIjo1NyxcIm9uY2VcIjo1OCxcInBhcnNlLWhlYWRlcnNcIjo2MSxcInh0ZW5kXCI6NjJ9XSw1NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG5cbn0se31dLDU4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG59LHt9XSw1OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNGdW5jdGlvbiA9IF9kZXJlcV8oJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxufSx7XCJpcy1mdW5jdGlvblwiOjU3fV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHJpbSA9IF9kZXJlcV8oJ3RyaW0nKVxuICAsIGZvckVhY2ggPSBfZGVyZXFfKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn1cbn0se1wiZm9yLWVhY2hcIjo1OSxcInRyaW1cIjo2MH1dLDYyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG5cbn0se31dLDYzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgYmlnLXBsYXktYnV0dG9uLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9idXR0b25KcyA9IF9kZXJlcV8oJy4vYnV0dG9uLmpzJyk7XG5cbnZhciBfYnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnV0dG9uSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbi8qKlxuICogSW5pdGlhbCBwbGF5IGJ1dHRvbi4gU2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxuICogYmlnIHBsYXkgYnV0dG9uIGlzIGRvbmUgdmlhIENTUyBhbmQgcGxheWVyIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWVyICBNYWluIFBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICogQGV4dGVuZHMgQnV0dG9uXG4gKiBAY2xhc3MgQmlnUGxheUJ1dHRvblxuICovXG5cbnZhciBCaWdQbGF5QnV0dG9uID0gKGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIF9pbmhlcml0cyhCaWdQbGF5QnV0dG9uLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBCaWdQbGF5QnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCaWdQbGF5QnV0dG9uKTtcblxuICAgIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqIEBtZXRob2QgYnVpbGRDU1NDbGFzc1xuICAgKi9cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1iaWctcGxheS1idXR0b24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNsaWNrIGZvciBwbGF5XG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcbiAgICovXG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICB9O1xuXG4gIHJldHVybiBCaWdQbGF5QnV0dG9uO1xufSkoX2J1dHRvbkpzMlsnZGVmYXVsdCddKTtcblxuQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXkgVmlkZW8nO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0JpZ1BsYXlCdXR0b24nLCBCaWdQbGF5QnV0dG9uKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJpZ1BsYXlCdXR0b247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL2J1dHRvbi5qc1wiOjY0LFwiLi9jb21wb25lbnQuanNcIjo2N31dLDY0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgYnV0dG9uLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jbGlja2FibGVDb21wb25lbnRKcyA9IF9kZXJlcV8oJy4vY2xpY2thYmxlLWNvbXBvbmVudC5qcycpO1xuXG52YXIgX2NsaWNrYWJsZUNvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsaWNrYWJsZUNvbXBvbmVudEpzKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG52YXIgX3V0aWxzRXZlbnRzSnMgPSBfZGVyZXFfKCcuL3V0aWxzL2V2ZW50cy5qcycpO1xuXG52YXIgRXZlbnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRXZlbnRzSnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNMb2dKcyA9IF9kZXJlcV8oJy4vdXRpbHMvbG9nLmpzJyk7XG5cbnZhciBfdXRpbHNMb2dKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0xvZ0pzKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QuYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWVyICBNYWluIFBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKiBAY2xhc3MgQnV0dG9uXG4gKi9cblxudmFyIEJ1dHRvbiA9IChmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQnV0dG9uLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbik7XG5cbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gdHlwZSBFbGVtZW50J3Mgbm9kZSB0eXBlLiBlLmcuICdkaXYnXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcHMgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gYXR0cmlidXRlcyBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICdidXR0b24nIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICBwcm9wcyA9IF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10oe1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0sIHByb3BzKTtcblxuICAgIGlmICh0YWcgIT09ICdidXR0b24nKSB7XG4gICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS53YXJuKCdDcmVhdGluZyBhIEJ1dHRvbiB3aXRoIGFuIEhUTUwgZWxlbWVudCBvZiAnICsgdGFnICsgJyBpcyBkZXByZWNhdGVkOyB1c2UgQ2xpY2thYmxlQ29tcG9uZW50IGluc3RlYWQuJyk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGZvciBjbGlja2FibGUgZWxlbWVudCB3aGljaCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b25cbiAgICAgIHByb3BzID0gX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSh7XG4gICAgICAgIHRhYkluZGV4OiAwXG4gICAgICB9LCBwcm9wcyk7XG5cbiAgICAgIC8vIEFkZCBBUklBIGF0dHJpYnV0ZXMgZm9yIGNsaWNrYWJsZSBlbGVtZW50IHdoaWNoIGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvblxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10oe1xuICAgICAgICByb2xlOiAnYnV0dG9uJ1xuICAgICAgfSwgYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGF0dHJpYnV0ZXMgZm9yIGJ1dHRvbiBlbGVtZW50XG4gICAgYXR0cmlidXRlcyA9IF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10oe1xuICAgICAgdHlwZTogJ2J1dHRvbicsIC8vIE5lY2Vzc2FyeSBzaW5jZSB0aGUgZGVmYXVsdCBidXR0b24gdHlwZSBpcyBcInN1Ym1pdFwiXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZScgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBidXR0b24gbWF5IGNoYW5nZVxuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIGVsID0gX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCBjb21wb25lbnQgaW5zaWRlIHRoaXMgYnV0dG9uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfENvbXBvbmVudH0gY2hpbGQgVGhlIGNsYXNzIG5hbWUgb3IgaW5zdGFuY2Ugb2YgYSBjaGlsZCB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMsIGluY2x1ZGluZyBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBjaGlsZHJlbiBvZiB0aGUgY2hpbGQuXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhlIGNoaWxkIGNvbXBvbmVudCAoY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MgaWYgYSBzdHJpbmcgd2FzIHVzZWQpXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICovXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10ud2FybignQWRkaW5nIGFuIGFjdGlvbmFibGUgKHVzZXIgY29udHJvbGxhYmxlKSBjaGlsZCB0byBhIEJ1dHRvbiAoJyArIGNsYXNzTmFtZSArICcpIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIENsaWNrYWJsZUNvbXBvbmVudCBpbnN0ZWFkLicpO1xuXG4gICAgLy8gQXZvaWQgdGhlIGVycm9yIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IENsaWNrYWJsZUNvbXBvbmVudCdzIGFkZENoaWxkIG1ldGhvZFxuICAgIHJldHVybiBfY29tcG9uZW50MlsnZGVmYXVsdCddLnByb3RvdHlwZS5hZGRDaGlsZC5jYWxsKHRoaXMsIGNoaWxkLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIEtleVByZXNzIChkb2N1bWVudCBsZXZlbCkgLSBFeHRlbmQgd2l0aCBzcGVjaWZpYyBmdW5jdGlvbmFsaXR5IGZvciBidXR0b25cbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVLZXlQcmVzc1xuICAgKi9cblxuICBCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgU3BhY2UgKDMyKSBvciBFbnRlciAoMTMpIGtleSBvcGVyYXRpb24sIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhlIGJyb3dzZXIgZm9yIGEgYnV0dG9uLlxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7fSBlbHNlIHtcbiAgICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpOyAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBCdXR0b247XG59KShfY2xpY2thYmxlQ29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50MlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdCdXR0b24nLCBCdXR0b24pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gQnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi9jbGlja2FibGUtY29tcG9uZW50LmpzXCI6NjUsXCIuL2NvbXBvbmVudFwiOjY3LFwiLi91dGlscy9ldmVudHMuanNcIjoxNDMsXCIuL3V0aWxzL2ZuLmpzXCI6MTQ0LFwiLi91dGlscy9sb2cuanNcIjoxNDcsXCJnbG9iYWwvZG9jdW1lbnRcIjoxLFwib2JqZWN0LmFzc2lnblwiOjQ1fV0sNjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBidXR0b24uanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudCA9IF9kZXJlcV8oJy4vY29tcG9uZW50Jyk7XG5cbnZhciBfY29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudCk7XG5cbnZhciBfdXRpbHNEb21KcyA9IF9kZXJlcV8oJy4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbnZhciBfdXRpbHNFdmVudHNKcyA9IF9kZXJlcV8oJy4vdXRpbHMvZXZlbnRzLmpzJyk7XG5cbnZhciBFdmVudHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNFdmVudHNKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF91dGlsc0xvZ0pzID0gX2RlcmVxXygnLi91dGlscy9sb2cuanMnKTtcblxudmFyIF91dGlsc0xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTG9nSnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IF9kZXJlcV8oJ29iamVjdC5hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxuLyoqXG4gKiBDbGlja2FibGUgQ29tcG9uZW50IHdoaWNoIGlzIGNsaWNrYWJsZSBvciBrZXlib2FyZCBhY3Rpb25hYmxlLCBidXQgaXMgbm90IGEgbmF0aXZlIEhUTUwgYnV0dG9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXllciAgTWFpbiBQbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBDbGlja2FibGVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKENsaWNrYWJsZUNvbXBvbmVudCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ2xpY2thYmxlQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlja2FibGVDb21wb25lbnQpO1xuXG4gICAgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmVtaXRUYXBFdmVudHMoKTtcblxuICAgIHRoaXMub24oJ3RhcCcsIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gdHlwZSBFbGVtZW50J3Mgbm9kZSB0eXBlLiBlLmcuICdkaXYnXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcHMgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gYXR0cmlidXRlcyBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICdkaXYnIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICBwcm9wcyA9IF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10oe1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIHRhYkluZGV4OiAwXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLmVycm9yKCdDcmVhdGluZyBhIENsaWNrYWJsZUNvbXBvbmVudCB3aXRoIGFuIEhUTUwgZWxlbWVudCBvZiAnICsgdGFnICsgJyBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBCdXR0b24gaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIGZvciBjbGlja2FibGUgZWxlbWVudCB3aGljaCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b25cbiAgICBhdHRyaWJ1dGVzID0gX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSh7XG4gICAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJyAvLyBsZXQgdGhlIHNjcmVlbiByZWFkZXIgdXNlciBrbm93IHRoYXQgdGhlIHRleHQgb2YgdGhlIGVsZW1lbnQgbWF5IGNoYW5nZVxuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBjb250cm9sIHRleHRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBQYXJlbnQgZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgdGV4dFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNvbnRyb2xUZXh0XG4gICAqL1xuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlQ29udHJvbFRleHRFbCA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xUZXh0RWwoZWwpIHtcbiAgICB0aGlzLmNvbnRyb2xUZXh0RWxfID0gRG9tLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCdcbiAgICB9KTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250cm9sVGV4dEVsXyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sVGV4dCh0aGlzLmNvbnRyb2xUZXh0XywgZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udHJvbFRleHRFbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHRleHQgLSBib3RoIHJlcXVlc3QgYW5kIGxvY2FsaXplXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgdGV4dCBUZXh0IGZvciBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudD19IGVsIEVsZW1lbnQgdG8gc2V0IHRoZSB0aXRsZSBvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBtZXRob2QgY29udHJvbFRleHRcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcbiAgICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0aGlzLmVsKCkgOiBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoIXRleHQpIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0XyB8fCAnTmVlZCBUZXh0JztcblxuICAgIHZhciBsb2NhbGl6ZWRUZXh0ID0gdGhpcy5sb2NhbGl6ZSh0ZXh0KTtcblxuICAgIHRoaXMuY29udHJvbFRleHRfID0gdGV4dDtcbiAgICB0aGlzLmNvbnRyb2xUZXh0RWxfLmlubmVySFRNTCA9IGxvY2FsaXplZFRleHQ7XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxvY2FsaXplZFRleHQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93cyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jb250cm9sIHZqcy1idXR0b24gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIGNoaWxkIGNvbXBvbmVudCBpbnNpZGUgdGhpcyBjbGlja2FibGUtY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfENvbXBvbmVudH0gY2hpbGQgVGhlIGNsYXNzIG5hbWUgb3IgaW5zdGFuY2Ugb2YgYSBjaGlsZCB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMsIGluY2x1ZGluZyBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBjaGlsZHJlbiBvZiB0aGUgY2hpbGQuXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhlIGNoaWxkIGNvbXBvbmVudCAoY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MgaWYgYSBzdHJpbmcgd2FzIHVzZWQpXG4gICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIC8vIFRPRE86IEZpeCBhZGRpbmcgYW4gYWN0aW9uYWJsZSBjaGlsZCB0byBhIENsaWNrYWJsZUNvbXBvbmVudDsgY3VycmVudGx5XG4gICAgLy8gaXQgd2lsbCBjYXVzZSBpc3N1ZXMgd2l0aCBhc3Npc3RpdmUgdGVjaG5vbG9neSAoZS5nLiBzY3JlZW4gcmVhZGVycylcbiAgICAvLyB3aGljaCBzdXBwb3J0IEFSSUEsIHNpbmNlIGFuIGVsZW1lbnQgd2l0aCByb2xlPVwiYnV0dG9uXCIgY2Fubm90IGhhdmVcbiAgICAvLyBhY3Rpb25hYmxlIGNoaWxkIGVsZW1lbnRzLlxuXG4gICAgLy9sZXQgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIC8vbG9nLndhcm4oYEFkZGluZyBhIGNoaWxkIHRvIGEgQ2xpY2thYmxlQ29tcG9uZW50ICgke2NsYXNzTmFtZX0pIGNhbiBjYXVzZSBpc3N1ZXMgd2l0aCBhc3Npc3RpdmUgdGVjaG5vbG9neSB3aGljaCBzdXBwb3J0cyBBUklBLCBzaW5jZSBhbiBlbGVtZW50IHdpdGggcm9sZT1cImJ1dHRvblwiIGNhbm5vdCBoYXZlIGFjdGlvbmFibGUgY2hpbGQgZWxlbWVudHMuYCk7XG5cbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgY29tcG9uZW50IGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgKi9cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgY29tcG9uZW50IGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIGRpc2FibGVcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgQ2xpY2sgLSBPdmVycmlkZSB3aXRoIHNwZWNpZmljIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudFxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAqL1xuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgRm9jdXMgLSBBZGQga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSB0byBlbGVtZW50XG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlRm9jdXNcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCkge1xuICAgIEV2ZW50cy5vbihfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10sICdrZXlkb3duJywgRm4uYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBLZXlQcmVzcyAoZG9jdW1lbnQgbGV2ZWwpIC0gVHJpZ2dlciBjbGljayB3aGVuIFNwYWNlIG9yIEVudGVyIGtleSBpcyBwcmVzc2VkXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlS2V5UHJlc3NcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2soZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MpIHtcbiAgICAgIF9Db21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpOyAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgQmx1ciAtIFJlbW92ZSBrZXlib2FyZCB0cmlnZ2Vyc1xuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUJsdXJcbiAgICovXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgICBFdmVudHMub2ZmKF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXSwgJ2tleWRvd24nLCBGbi5iaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICByZXR1cm4gQ2xpY2thYmxlQ29tcG9uZW50O1xufSkoX2NvbXBvbmVudDJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnQyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0NsaWNrYWJsZUNvbXBvbmVudCcsIENsaWNrYWJsZUNvbXBvbmVudCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBDbGlja2FibGVDb21wb25lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL2NvbXBvbmVudFwiOjY3LFwiLi91dGlscy9kb20uanNcIjoxNDIsXCIuL3V0aWxzL2V2ZW50cy5qc1wiOjE0MyxcIi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuL3V0aWxzL2xvZy5qc1wiOjE0NyxcImdsb2JhbC9kb2N1bWVudFwiOjEsXCJvYmplY3QuYXNzaWduXCI6NDV9XSw2NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfYnV0dG9uID0gX2RlcmVxXygnLi9idXR0b24nKTtcblxudmFyIF9idXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnV0dG9uKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBgQ2xvc2VCdXR0b25gIGNvbXBvbmVudCBpcyBhIGJ1dHRvbiB3aGljaCBmaXJlcyBhIFwiY2xvc2VcIiBldmVudFxuICogd2hlbiBpdCBpcyBhY3RpdmF0ZWQuXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKiBAY2xhc3MgQ2xvc2VCdXR0b25cbiAqL1xuXG52YXIgQ2xvc2VCdXR0b24gPSAoZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgX2luaGVyaXRzKENsb3NlQnV0dG9uLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBDbG9zZUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvc2VCdXR0b24pO1xuXG4gICAgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgdGhpcy5sb2NhbGl6ZSgnQ2xvc2UnKSk7XG4gIH1cblxuICBDbG9zZUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2xvc2UtYnV0dG9uICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Nsb3NlJywgYnViYmxlczogZmFsc2UgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENsb3NlQnV0dG9uO1xufSkoX2J1dHRvbjJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnQyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0Nsb3NlQnV0dG9uJywgQ2xvc2VCdXR0b24pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gQ2xvc2VCdXR0b247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL2J1dHRvblwiOjY0LFwiLi9jb21wb25lbnRcIjo2N31dLDY3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgY29tcG9uZW50LmpzXG4gKlxuICogUGxheWVyIENvbXBvbmVudCAtIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBvYmplY3RzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG52YXIgX3V0aWxzR3VpZEpzID0gX2RlcmVxXygnLi91dGlscy9ndWlkLmpzJyk7XG5cbnZhciBHdWlkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzR3VpZEpzKTtcblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi91dGlscy9ldmVudHMuanMnKTtcblxudmFyIEV2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0V2ZW50c0pzKTtcblxudmFyIF91dGlsc0xvZ0pzID0gX2RlcmVxXygnLi91dGlscy9sb2cuanMnKTtcblxudmFyIF91dGlsc0xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTG9nSnMpO1xuXG52YXIgX3V0aWxzVG9UaXRsZUNhc2VKcyA9IF9kZXJlcV8oJy4vdXRpbHMvdG8tdGl0bGUtY2FzZS5qcycpO1xuXG52YXIgX3V0aWxzVG9UaXRsZUNhc2VKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc1RvVGl0bGVDYXNlSnMpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zSnMgPSBfZGVyZXFfKCcuL3V0aWxzL21lcmdlLW9wdGlvbnMuanMnKTtcblxudmFyIF91dGlsc01lcmdlT3B0aW9uc0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTWVyZ2VPcHRpb25zSnMpO1xuXG4vKipcbiAqIEJhc2UgVUkgQ29tcG9uZW50IGNsYXNzXG4gKiBDb21wb25lbnRzIGFyZSBlbWJlZGRhYmxlIFVJIG9iamVjdHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgYnkgYm90aCBhXG4gKiBqYXZhc2NyaXB0IG9iamVjdCBhbmQgYW4gZWxlbWVudCBpbiB0aGUgRE9NLiBUaGV5IGNhbiBiZSBjaGlsZHJlbiBvZiBvdGhlclxuICogY29tcG9uZW50cywgYW5kIGNhbiBoYXZlIG1hbnkgY2hpbGRyZW4gdGhlbXNlbHZlcy5cbiAqIGBgYGpzXG4gKiAgICAgLy8gYWRkaW5nIGEgYnV0dG9uIHRvIHRoZSBwbGF5ZXJcbiAqICAgICB2YXIgYnV0dG9uID0gcGxheWVyLmFkZENoaWxkKCdidXR0b24nKTtcbiAqICAgICBidXR0b24uZWwoKTsgLy8gLT4gYnV0dG9uIGVsZW1lbnRcbiAqIGBgYFxuICogYGBgaHRtbFxuICogICAgIDxkaXYgY2xhc3M9XCJ2aWRlby1qc1wiPlxuICogICAgICAgPGRpdiBjbGFzcz1cInZqcy1idXR0b25cIj5CdXR0b248L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqIGBgYFxuICogQ29tcG9uZW50cyBhcmUgYWxzbyBldmVudCB0YXJnZXRzLlxuICogYGBganNcbiAqICAgICBidXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdCdXR0b24gQ2xpY2tlZCEnKTtcbiAqICAgICB9KTtcbiAqICAgICBidXR0b24udHJpZ2dlcignY3VzdG9tZXZlbnQnKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXIgIE1haW4gUGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gcmVhZHkgICAgUmVhZHkgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBjbGFzcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50KTtcblxuICAgIC8vIFRoZSBjb21wb25lbnQgbWlnaHQgYmUgdGhlIHBsYXllciBpdHNlbGYgYW5kIHdlIGNhbid0IHBhc3MgYHRoaXNgIHRvIHN1cGVyXG4gICAgaWYgKCFwbGF5ZXIgJiYgdGhpcy5wbGF5KSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXIgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfID0gcGxheWVyO1xuICAgICAgfVxuXG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgcHJvdG90eXBlLm9wdGlvbnNfIHRvIHByb3RlY3QgYWdhaW5zdCBvdmVycmlkaW5nIGRlZmF1bHRzXG4gICAgdGhpcy5vcHRpb25zXyA9IF91dGlsc01lcmdlT3B0aW9uc0pzMlsnZGVmYXVsdCddKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIFVwZGF0ZWQgb3B0aW9ucyB3aXRoIHN1cHBsaWVkIG9wdGlvbnNcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXyA9IF91dGlsc01lcmdlT3B0aW9uc0pzMlsnZGVmYXVsdCddKHRoaXMub3B0aW9uc18sIG9wdGlvbnMpO1xuXG4gICAgLy8gR2V0IElEIGZyb20gb3B0aW9ucyBvciBvcHRpb25zIGVsZW1lbnQgaWYgb25lIGlzIHN1cHBsaWVkXG4gICAgdGhpcy5pZF8gPSBvcHRpb25zLmlkIHx8IG9wdGlvbnMuZWwgJiYgb3B0aW9ucy5lbC5pZDtcblxuICAgIC8vIElmIHRoZXJlIHdhcyBubyBJRCBmcm9tIHRoZSBvcHRpb25zLCBnZW5lcmF0ZSBvbmVcbiAgICBpZiAoIXRoaXMuaWRfKSB7XG4gICAgICAvLyBEb24ndCByZXF1aXJlIHRoZSBwbGF5ZXIgSUQgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2YgbW9jayBwbGF5ZXJzXG4gICAgICB2YXIgaWQgPSBwbGF5ZXIgJiYgcGxheWVyLmlkICYmIHBsYXllci5pZCgpIHx8ICdub19wbGF5ZXInO1xuXG4gICAgICB0aGlzLmlkXyA9IGlkICsgJ19jb21wb25lbnRfJyArIEd1aWQubmV3R1VJRCgpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcblxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGlmIG9uZSB3YXNuJ3QgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLmVsXyA9IG9wdGlvbnMuZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZUVsICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbF8gPSB0aGlzLmNyZWF0ZUVsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0ge307XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSB7fTtcblxuICAgIC8vIEFkZCBhbnkgY2hpbGQgY29tcG9uZW50cyBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaW5pdENoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbml0Q2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5KHJlYWR5KTtcbiAgICAvLyBEb24ndCB3YW50IHRvIHRyaWdnZXIgcmVhZHkgaGVyZSBvciBpdCB3aWxsIGJlZm9yZSBpbml0IGlzIGFjdHVhbGx5XG4gICAgLy8gZmluaXNoZWQgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJ1biB0aGlzIGNvbnN0cnVjdG9yXG5cbiAgICBpZiAob3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbmFibGVUb3VjaEFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGNvbXBvbmVudCBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHNcbiAgICpcbiAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Rpc3Bvc2UnLCBidWJibGVzOiBmYWxzZSB9KTtcblxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuLlxuICAgIGlmICh0aGlzLmNoaWxkcmVuXykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGNoaWxkIHJlZmVyZW5jZXNcbiAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSBudWxsO1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgdGhpcy5vZmYoKTtcblxuICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgaWYgKHRoaXMuZWxfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xuICAgIH1cblxuICAgIERvbS5yZW1vdmVFbERhdGEodGhpcy5lbF8pO1xuICAgIHRoaXMuZWxfID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb21wb25lbnQncyBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKiBAbWV0aG9kIHBsYXllclxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLnBsYXllciA9IGZ1bmN0aW9uIHBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWVwIG1lcmdlIG9mIG9wdGlvbnMgb2JqZWN0c1xuICAgKiBXaGVuZXZlciBhIHByb3BlcnR5IGlzIGFuIG9iamVjdCBvbiBib3RoIG9wdGlvbnMgb2JqZWN0c1xuICAgKiB0aGUgdHdvIHByb3BlcnRpZXMgd2lsbCBiZSBtZXJnZWQgdXNpbmcgbWVyZ2VPcHRpb25zLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgICAgUGFyZW50LnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgICogICAgICAgb3B0aW9uU2V0OiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JhcicsICdhc2RmJzogJ2Zkc2EnIH0sXG4gICAqICAgICAgICAgJ2NoaWxkVHdvJzoge30sXG4gICAqICAgICAgICAgJ2NoaWxkVGhyZWUnOiB7fVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgICBuZXdPcHRpb25zID0ge1xuICAgKiAgICAgICBvcHRpb25TZXQ6IHtcbiAgICogICAgICAgICAnY2hpbGRPbmUnOiB7ICdmb28nOiAnYmF6JywgJ2FiYyc6ICcxMjMnIH1cbiAgICogICAgICAgICAnY2hpbGRUd28nOiBudWxsLFxuICAgKiAgICAgICAgICdjaGlsZEZvdXInOiB7fVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICB0aGlzLm9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAqIGBgYFxuICAgKiBSRVNVTFRcbiAgICogYGBganNcbiAgICogICAgIHtcbiAgICogICAgICAgb3B0aW9uU2V0OiB7XG4gICAqICAgICAgICAgJ2NoaWxkT25lJzogeyAnZm9vJzogJ2JheicsICdhc2RmJzogJ2Zkc2EnLCAnYWJjJzogJzEyMycgfSxcbiAgICogICAgICAgICAnY2hpbGRUd28nOiBudWxsLCAvLyBEaXNhYmxlZC4gV29uJ3QgYmUgaW5pdGlhbGl6ZWQuXG4gICAqICAgICAgICAgJ2NoaWxkVGhyZWUnOiB7fSxcbiAgICogICAgICAgICAnY2hpbGRGb3VyJzoge31cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmogT2JqZWN0IG9mIG5ldyBvcHRpb24gdmFsdWVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgIEEgTkVXIG9iamVjdCBvZiB0aGlzLm9wdGlvbnNfIGFuZCBvYmogbWVyZ2VkXG4gICAqIEBtZXRob2Qgb3B0aW9uc1xuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiBvcHRpb25zKG9iaikge1xuICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLndhcm4oJ3RoaXMub3B0aW9ucygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgbW92ZWQgdG8gdGhlIGNvbnN0cnVjdG9yIGluIDYuMCcpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9uc18gPSBfdXRpbHNNZXJnZU9wdGlvbnNKczJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnNfLCBvYmopO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqIGBgYGpzXG4gICAqICAgICB2YXIgZG9tRWwgPSBteUNvbXBvbmVudC5lbCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBlbFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZz19IHRhZ05hbWUgIEVsZW1lbnQncyBub2RlIHR5cGUuIGUuZy4gJ2RpdidcbiAgICogQHBhcmFtICB7T2JqZWN0PX0gcHJvcGVydGllcyBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXRcbiAgICogQHBhcmFtICB7T2JqZWN0PX0gYXR0cmlidXRlcyBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXRcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBEb20uY3JlYXRlRWwodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2NhbGl6ZSA9IGZ1bmN0aW9uIGxvY2FsaXplKHN0cmluZykge1xuICAgIHZhciBjb2RlID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZSgpO1xuICAgIHZhciBsYW5ndWFnZXMgPSB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZXMoKTtcblxuICAgIGlmICghY29kZSB8fCAhbGFuZ3VhZ2VzKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZSA9IGxhbmd1YWdlc1tjb2RlXTtcblxuICAgIGlmIChsYW5ndWFnZSAmJiBsYW5ndWFnZVtzdHJpbmddKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2Vbc3RyaW5nXTtcbiAgICB9XG5cbiAgICB2YXIgcHJpbWFyeUNvZGUgPSBjb2RlLnNwbGl0KCctJylbMF07XG4gICAgdmFyIHByaW1hcnlMYW5nID0gbGFuZ3VhZ2VzW3ByaW1hcnlDb2RlXTtcblxuICAgIGlmIChwcmltYXJ5TGFuZyAmJiBwcmltYXJ5TGFuZ1tzdHJpbmddKSB7XG4gICAgICByZXR1cm4gcHJpbWFyeUxhbmdbc3RyaW5nXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50IHdoZXJlIGNoaWxkcmVuIGFyZSBpbnNlcnRlZC5cbiAgICogV2lsbCBlaXRoZXIgYmUgdGhlIHNhbWUgYXMgZWwoKSBvciBhIG5ldyBlbGVtZW50IGRlZmluZWQgaW4gY3JlYXRlRWwoKS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjb250ZW50RWxcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jb250ZW50RWwgPSBmdW5jdGlvbiBjb250ZW50RWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudEVsXyB8fCB0aGlzLmVsXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQncyBJRFxuICAgKiBgYGBqc1xuICAgKiAgICAgdmFyIGlkID0gbXlDb21wb25lbnQuaWQoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQG1ldGhvZCBpZFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCdzIG5hbWUuIFRoZSBuYW1lIGlzIG9mdGVuIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBjb21wb25lbnQuXG4gICAqIGBgYGpzXG4gICAqICAgICB2YXIgbmFtZSA9IG15Q29tcG9uZW50Lm5hbWUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQG1ldGhvZCBuYW1lXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgKiBgYGBqc1xuICAgKiAgICAgdmFyIGtpZHMgPSBteUNvbXBvbmVudC5jaGlsZHJlbigpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBjaGlsZHJlblxuICAgKiBAbWV0aG9kIGNoaWxkcmVuXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjaGlsZCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgSURcbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIGdldENoaWxkQnlJZFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uIGdldENoaWxkQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhfW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNoaWxkIGNvbXBvbmVudCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQG1ldGhvZCBnZXRDaGlsZFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIGNoaWxkIGNvbXBvbmVudCBpbnNpZGUgdGhpcyBjb21wb25lbnRcbiAgICogYGBganNcbiAgICogICAgIG15Q29tcG9uZW50LmVsKCk7XG4gICAqICAgICAvLyAtPiA8ZGl2IGNsYXNzPSdteS1jb21wb25lbnQnPjwvZGl2PlxuICAgKiAgICAgbXlDb21wb25lbnQuY2hpbGRyZW4oKTtcbiAgICogICAgIC8vIFtlbXB0eSBhcnJheV1cbiAgICpcbiAgICogICAgIHZhciBteUJ1dHRvbiA9IG15Q29tcG9uZW50LmFkZENoaWxkKCdNeUJ1dHRvbicpO1xuICAgKiAgICAgLy8gLT4gPGRpdiBjbGFzcz0nbXktY29tcG9uZW50Jz48ZGl2IGNsYXNzPVwibXktYnV0dG9uXCI+bXlCdXR0b248ZGl2PjwvZGl2PlxuICAgKiAgICAgLy8gLT4gbXlCdXR0b24gPT09IG15Q29tcG9uZW50LmNoaWxkcmVuKClbMF07XG4gICAqIGBgYFxuICAgKiBQYXNzIGluIG9wdGlvbnMgZm9yIGNoaWxkIGNvbnN0cnVjdG9ycyBhbmQgb3B0aW9ucyBmb3IgY2hpbGRyZW4gb2YgdGhlIGNoaWxkXG4gICAqIGBgYGpzXG4gICAqICAgICB2YXIgbXlCdXR0b24gPSBteUNvbXBvbmVudC5hZGRDaGlsZCgnTXlCdXR0b24nLCB7XG4gICAqICAgICAgIHRleHQ6ICdQcmVzcyBNZScsXG4gICAqICAgICAgIGJ1dHRvbkNoaWxkRXhhbXBsZToge1xuICAgKiAgICAgICAgIGJ1dHRvbkNoaWxkT3B0aW9uOiB0cnVlXG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8Q29tcG9uZW50fSBjaGlsZCBUaGUgY2xhc3MgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucywgaW5jbHVkaW5nIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGNoaWxkcmVuIG9mIHRoZSBjaGlsZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IGludG8gb3VyIGNoaWxkcmVuIGFycmF5IHRvIGF0dGVtcHQgdG8gYWRkIHRoZSBjaGlsZFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoZSBjaGlsZCBjb21wb25lbnQgKGNyZWF0ZWQgYnkgdGhpcyBwcm9jZXNzIGlmIGEgc3RyaW5nIHdhcyB1c2VkKVxuICAgKiBAbWV0aG9kIGFkZENoaWxkXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIDogYXJndW1lbnRzWzJdO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIGNoaWxkIGlzIGEgc3RyaW5nLCBjcmVhdGUgbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjaGlsZDtcblxuICAgICAgLy8gT3B0aW9ucyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBib29sZWFuLCBzbyBjb252ZXJ0IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBmYWxzZS5cbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCB0cnVlIGlzIGRlcHJlY2F0ZWQgc28gc2hvdyBhIHdhcm5pbmcuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS53YXJuKCdJbml0aWFsaXppbmcgYSBjaGlsZCBjb21wb25lbnQgd2l0aCBgdHJ1ZWAgaXMgZGVwcmVjYXRlZC4gQ2hpbGRyZW4gc2hvdWxkIGJlIGRlZmluZWQgaW4gYW4gYXJyYXkgd2hlbiBwb3NzaWJsZSwgYnV0IGlmIG5lY2Vzc2FyeSB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYHRydWVgLicpO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGNvbXBvbmVudENsYXNzIGluIG9wdGlvbnMsIGFzc3VtZSBjb21wb25lbnRDbGFzcyBpcyB0aGUgbmFtZSBsb3dlcmNhc2VkXG4gICAgICAvLyAoZS5nLiBwbGF5QnV0dG9uKVxuICAgICAgdmFyIGNvbXBvbmVudENsYXNzTmFtZSA9IG9wdGlvbnMuY29tcG9uZW50Q2xhc3MgfHwgX3V0aWxzVG9UaXRsZUNhc2VKczJbJ2RlZmF1bHQnXShjb21wb25lbnROYW1lKTtcblxuICAgICAgLy8gU2V0IG5hbWUgdGhyb3VnaCBvcHRpb25zXG4gICAgICBvcHRpb25zLm5hbWUgPSBjb21wb25lbnROYW1lO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0ICYgZWxlbWVudCBmb3IgdGhpcyBjb250cm9scyBzZXRcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gLnBsYXllcl8sIHRoaXMgaXMgYSBwbGF5ZXJcbiAgICAgIHZhciBDb21wb25lbnRDbGFzcyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY29tcG9uZW50Q2xhc3NOYW1lKTtcblxuICAgICAgaWYgKCFDb21wb25lbnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCAnICsgY29tcG9uZW50Q2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBkYXRhIHN0b3JlZCBkaXJlY3RseSBvbiB0aGUgdmlkZW9qcyBvYmplY3QgbWF5IGJlXG4gICAgICAvLyBtaXNpZGVudGlmaWVkIGFzIGEgY29tcG9uZW50IHRvIHJldGFpblxuICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCA0LnguIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgaW5zdGFudGlhdGVkLlxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKHRoaXMucGxheWVyXyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gY2hpbGQgaXMgYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQgPSBjaGlsZDtcbiAgICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5hbWUgd2Fzbid0IHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQsIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgY29tcG9uZW50Lm5hbWUgJiYgY29tcG9uZW50Lm5hbWUoKTtcblxuICAgIGlmIChjb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnROYW1lXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIFVJIG9iamVjdCdzIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lciBkaXYgKGJveClcbiAgICAvLyBIYXZpbmcgYW4gZWxlbWVudCBpcyBub3QgcmVxdWlyZWRcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5lbCA9PT0gJ2Z1bmN0aW9uJyAmJiBjb21wb25lbnQuZWwoKSkge1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmNvbnRlbnRFbCgpLmNoaWxkcmVuO1xuICAgICAgdmFyIHJlZk5vZGUgPSBjaGlsZE5vZGVzW2luZGV4XSB8fCBudWxsO1xuICAgICAgdGhpcy5jb250ZW50RWwoKS5pbnNlcnRCZWZvcmUoY29tcG9uZW50LmVsKCksIHJlZk5vZGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBjb21wb25lbnQgZnJvbSB0aGlzIGNvbXBvbmVudCdzIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZCB0aGVcbiAgICogY2hpbGQgY29tcG9uZW50J3MgZWxlbWVudCBmcm9tIHRoaXMgY29tcG9uZW50J3MgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVtb3ZlXG4gICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNvbXBvbmVudCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkRm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRGb3VuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnQubmFtZSgpXSA9IG51bGw7XG5cbiAgICB2YXIgY29tcEVsID0gY29tcG9uZW50LmVsKCk7XG5cbiAgICBpZiAoY29tcEVsICYmIGNvbXBFbC5wYXJlbnROb2RlID09PSB0aGlzLmNvbnRlbnRFbCgpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLnJlbW92ZUNoaWxkKGNvbXBvbmVudC5lbCgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbmQgaW5pdGlhbGl6ZSBkZWZhdWx0IGNoaWxkIGNvbXBvbmVudHMgZnJvbSBvcHRpb25zXG4gICAqIGBgYGpzXG4gICAqICAgICAvLyB3aGVuIGFuIGluc3RhbmNlIG9mIE15Q29tcG9uZW50IGlzIGNyZWF0ZWQsIGFsbCBjaGlsZHJlbiBpbiBvcHRpb25zXG4gICAqICAgICAvLyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbnN0YW5jZSBieSB0aGVpciBuYW1lIHN0cmluZ3MgYW5kIG9wdGlvbnNcbiAgICogICAgIE15Q29tcG9uZW50LnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgICogICAgICAgY2hpbGRyZW46IFtcbiAgICogICAgICAgICAnbXlDaGlsZENvbXBvbmVudCdcbiAgICogICAgICAgXSxcbiAgICogICAgICAgbXlDaGlsZENvbXBvbmVudDoge1xuICAgKiAgICAgICAgIG15Q2hpbGRPcHRpb246IHRydWVcbiAgICogICAgICAgfVxuICAgKiAgICAgfTtcbiAgICpcbiAgICogICAgIC8vIE9yIHdoZW4gY3JlYXRpbmcgdGhlIGNvbXBvbmVudFxuICAgKiAgICAgdmFyIG15Q29tcCA9IG5ldyBNeUNvbXBvbmVudChwbGF5ZXIsIHtcbiAgICogICAgICAgY2hpbGRyZW46IFtcbiAgICogICAgICAgICAnbXlDaGlsZENvbXBvbmVudCdcbiAgICogICAgICAgXSxcbiAgICogICAgICAgbXlDaGlsZENvbXBvbmVudDoge1xuICAgKiAgICAgICAgIG15Q2hpbGRPcHRpb246IHRydWVcbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqIGBgYFxuICAgKiBUaGUgY2hpbGRyZW4gb3B0aW9uIGNhbiBhbHNvIGJlIGFuIGFycmF5IG9mXG4gICAqIGNoaWxkIG9wdGlvbnMgb2JqZWN0cyAodGhhdCBhbHNvIGluY2x1ZGUgYSAnbmFtZScga2V5KS5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpZiB5b3UgaGF2ZSB0d28gY2hpbGQgY29tcG9uZW50cyBvZiB0aGVcbiAgICogc2FtZSB0eXBlIHRoYXQgbmVlZCBkaWZmZXJlbnQgb3B0aW9ucy5cbiAgICogYGBganNcbiAgICogICAgIHZhciBteUNvbXAgPSBuZXcgTXlDb21wb25lbnQocGxheWVyLCB7XG4gICAqICAgICAgIGNoaWxkcmVuOiBbXG4gICAqICAgICAgICAgJ2J1dHRvbicsXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgbmFtZTogJ2J1dHRvbicsXG4gICAqICAgICAgICAgICBzb21lT3RoZXJPcHRpb246IHRydWVcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgIG5hbWU6ICdidXR0b24nLFxuICAgKiAgICAgICAgICAgc29tZU90aGVyT3B0aW9uOiBmYWxzZVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWV0aG9kIGluaXRDaGlsZHJlblxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmluaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGluaXRDaGlsZHJlbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5vcHRpb25zXy5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYHRoaXNgIGlzIGBwYXJlbnRgXG4gICAgICAgIHZhciBwYXJlbnRPcHRpb25zID0gX3RoaXMub3B0aW9uc187XG5cbiAgICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChjaGlsZCkge1xuICAgICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgICB2YXIgb3B0cyA9IGNoaWxkLm9wdHM7XG5cbiAgICAgICAgICAvLyBBbGxvdyBvcHRpb25zIGZvciBjaGlsZHJlbiB0byBiZSBzZXQgYXQgdGhlIHBhcmVudCBvcHRpb25zXG4gICAgICAgICAgLy8gZS5nLiB2aWRlb2pzKGlkLCB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICAgIC8vIGluc3RlYWQgb2YgdmlkZW9qcyhpZCwgeyBjaGlsZHJlbjogeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgICBpZiAocGFyZW50T3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRzID0gcGFyZW50T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBbGxvdyBmb3IgZGlzYWJsaW5nIGRlZmF1bHQgY29tcG9uZW50c1xuICAgICAgICAgIC8vIGUuZy4gb3B0aW9uc1snY2hpbGRyZW4nXVsncG9zdGVySW1hZ2UnXSA9IGZhbHNlXG4gICAgICAgICAgaWYgKG9wdHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWxsb3cgb3B0aW9ucyB0byBiZSBwYXNzZWQgYXMgYSBzaW1wbGUgYm9vbGVhbiBpZiBubyBjb25maWd1cmF0aW9uXG4gICAgICAgICAgLy8gaXMgbmVjZXNzYXJ5LlxuICAgICAgICAgIGlmIChvcHRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2UgYWxzbyB3YW50IHRvIHBhc3MgdGhlIG9yaWdpbmFsIHBsYXllciBvcHRpb25zIHRvIGVhY2ggY29tcG9uZW50IGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgLy8gcmVhY2ggYmFjayBpbnRvIHRoZSBwbGF5ZXIgZm9yIG9wdGlvbnMgbGF0ZXIuXG4gICAgICAgICAgb3B0cy5wbGF5ZXJPcHRpb25zID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucztcblxuICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgICAgLy8gQWRkIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgYnkgbmFtZSBvbiB0aGUgcGFyZW50IGluc3RhbmNlLlxuICAgICAgICAgIC8vIElmIHR3byBvZiB0aGUgc2FtZSBjb21wb25lbnQgYXJlIHVzZWQsIGRpZmZlcmVudCBuYW1lcyBzaG91bGQgYmUgc3VwcGxpZWRcbiAgICAgICAgICAvLyBmb3IgZWFjaFxuICAgICAgICAgIHZhciBuZXdDaGlsZCA9IF90aGlzLmFkZENoaWxkKG5hbWUsIG9wdHMpO1xuICAgICAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICAgICAgX3RoaXNbbmFtZV0gPSBuZXdDaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWxsb3cgZm9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIGRldGFpbHMgdG8gcGFzc2VkIGluIHRoZSBvcHRpb25zXG4gICAgICAgIHZhciB3b3JraW5nQ2hpbGRyZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBUZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnVGVjaCcpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtpbmdDaGlsZHJlblxuICAgICAgICAvLyBjaGlsZHJlbiB0aGF0IGFyZSBpbiB0aGlzLm9wdGlvbnNfIGJ1dCBhbHNvIGluIHdvcmtpbmdDaGlsZHJlbiAgd291bGRcbiAgICAgICAgLy8gZ2l2ZSB1cyBleHRyYSBjaGlsZHJlbiB3ZSBkbyBub3Qgd2FudC4gU28sIHdlIHdhbnQgdG8gZmlsdGVyIHRoZW0gb3V0LlxuICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKF90aGlzLm9wdGlvbnNfKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuICF3b3JraW5nQ2hpbGRyZW4uc29tZShmdW5jdGlvbiAod2NoaWxkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkID09PSB3Y2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHZhciBuYW1lID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBvcHRzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjaGlsZDtcbiAgICAgICAgICAgIG9wdHMgPSBjaGlsZHJlbltuYW1lXSB8fCBfdGhpcy5vcHRpb25zX1tuYW1lXSB8fCB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgICBvcHRzID0gY2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgb3B0czogb3B0cyB9O1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgLy8gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBjaGlsZC5uYW1lIGlzbid0IGluIHRoZSB0ZWNoT3JkZXIgc2luY2VcbiAgICAgICAgICAvLyB0ZWNocyBhcmUgcmVnaXN0ZXJkIGFzIENvbXBvbmVudHMgYnV0IGNhbid0IGFyZW4ndCBjb21wYXRpYmxlXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNzcyXG4gICAgICAgICAgdmFyIGMgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNoaWxkLm9wdHMuY29tcG9uZW50Q2xhc3MgfHwgX3V0aWxzVG9UaXRsZUNhc2VKczJbJ2RlZmF1bHQnXShjaGlsZC5uYW1lKSk7XG4gICAgICAgICAgcmV0dXJuIGMgJiYgIVRlY2guaXNUZWNoKGMpO1xuICAgICAgICB9KS5mb3JFYWNoKGhhbmRsZUFkZCk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqIEBtZXRob2QgYnVpbGRDU1NDbGFzc1xuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIC8vIENoaWxkIGNsYXNzZXMgY2FuIGluY2x1ZGUgYSBmdW5jdGlvbiB0aGF0IGRvZXM6XG4gICAgLy8gcmV0dXJuICdDTEFTUyBOQU1FJyArIHRoaXMuX3N1cGVyKCk7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqIGBgYGpzXG4gICAqICAgICB2YXIgbXlGdW5jID0gZnVuY3Rpb24oKXtcbiAgICogICAgICAgdmFyIG15Q29tcG9uZW50ID0gdGhpcztcbiAgICogICAgICAgLy8gRG8gc29tZXRoaW5nIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgbXlDb21wb25lbnQub24oJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqIGBgYFxuICAgKiBUaGUgY29udGV4dCBvZiBteUZ1bmMgd2lsbCBiZSBteUNvbXBvbmVudCB1bmxlc3MgcHJldmlvdXNseSBib3VuZC5cbiAgICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBhZGQgYSBsaXN0ZW5lciB0byBhbm90aGVyIGVsZW1lbnQgb3IgY29tcG9uZW50LlxuICAgKiBgYGBqc1xuICAgKiAgICAgbXlDb21wb25lbnQub24ob3RoZXJFbGVtZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICogICAgIG15Q29tcG9uZW50Lm9uKG90aGVyQ29tcG9uZW50LCAnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICogYGBgXG4gICAqIFRoZSBiZW5lZml0IG9mIHVzaW5nIHRoaXMgb3ZlciBgVmpzRXZlbnRzLm9uKG90aGVyRWxlbWVudCwgJ2V2ZW50TmFtZScsIG15RnVuYylgXG4gICAqIGFuZCBgb3RoZXJDb21wb25lbnQub24oJ2V2ZW50TmFtZScsIG15RnVuYylgIGlzIHRoYXQgdGhpcyB3YXkgdGhlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCB3aGVuIGVpdGhlciBjb21wb25lbnQgaXMgZGlzcG9zZWQuXG4gICAqIEl0IHdpbGwgYWxzbyBiaW5kIG15Q29tcG9uZW50IGFzIHRoZSBjb250ZXh0IG9mIG15RnVuYy5cbiAgICogKipOT1RFKio6IFdoZW4gdXNpbmcgdGhpcyBvbiBlbGVtZW50cyBpbiB0aGUgcGFnZSBvdGhlciB0aGFuIHdpbmRvd1xuICAgKiBhbmQgZG9jdW1lbnQgKGJvdGggcGVybWFuZW50KSwgaWYgeW91IHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICogeW91IG5lZWQgdG8gY2FsbCBgbXlDb21wb25lbnQudHJpZ2dlcihlbCwgJ2Rpc3Bvc2UnKWAgb24gaXQgdG8gY2xlYW4gdXBcbiAgICogcmVmZXJlbmNlcyB0byBpdCBhbmQgYWxsb3cgdGhlIGJyb3dzZXIgdG8gZ2FyYmFnZSBjb2xsZWN0IGl0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8Q29tcG9uZW50fSBmaXJzdCAgIFRoZSBldmVudCB0eXBlIG9yIG90aGVyIGNvbXBvbmVudFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbnxTdHJpbmd9ICAgICAgc2Vjb25kICBUaGUgZXZlbnQgaGFuZGxlciBvciBldmVudCB0eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICB0aGlyZCAgIFRoZSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQG1ldGhvZCBvblxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICBFdmVudHMub24odGhpcy5lbF8sIGZpcnN0LCBGbi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGZpcnN0O1xuICAgICAgICAgIHZhciB0eXBlID0gc2Vjb25kO1xuICAgICAgICAgIHZhciBmbiA9IEZuLmJpbmQoX3RoaXMyLCB0aGlyZCk7XG5cbiAgICAgICAgICAvLyBXaGVuIHRoaXMgY29tcG9uZW50IGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gdGhlIG90aGVyIGNvbXBvbmVudFxuICAgICAgICAgIHZhciByZW1vdmVPbkRpc3Bvc2UgPSBmdW5jdGlvbiByZW1vdmVPbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLm9mZih0YXJnZXQsIHR5cGUsIGZuKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIgaXQgdXNpbmcgdGhlIElEXG4gICAgICAgICAgLy8gb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyXG4gICAgICAgICAgcmVtb3ZlT25EaXNwb3NlLmd1aWQgPSBmbi5ndWlkO1xuICAgICAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIHJlbW92ZU9uRGlzcG9zZSk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgb3RoZXIgY29tcG9uZW50IGlzIGRpc3Bvc2VkIGZpcnN0IHdlIG5lZWQgdG8gY2xlYW4gdGhlIHJlZmVyZW5jZVxuICAgICAgICAgIC8vIHRvIHRoZSBvdGhlciBjb21wb25lbnQgaW4gdGhpcyBjb21wb25lbnQncyByZW1vdmVPbkRpc3Bvc2UgbGlzdGVuZXJcbiAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY3JlYXRlIGEgbWVtb3J5IGxlYWsuXG4gICAgICAgICAgdmFyIGNsZWFuUmVtb3ZlciA9IGZ1bmN0aW9uIGNsZWFuUmVtb3ZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIub2ZmKCdkaXNwb3NlJywgcmVtb3ZlT25EaXNwb3NlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQWRkIHRoZSBzYW1lIGZ1bmN0aW9uIElEIHNvIHdlIGNhbiBlYXNpbHkgcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgICAgY2xlYW5SZW1vdmVyLmd1aWQgPSBmbi5ndWlkO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIERPTSBub2RlXG4gICAgICAgICAgaWYgKGZpcnN0Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxpc3RlbmVyIHRvIHRoZSBvdGhlciBlbGVtZW50XG4gICAgICAgICAgICBFdmVudHMub24odGFyZ2V0LCB0eXBlLCBmbik7XG4gICAgICAgICAgICBFdmVudHMub24odGFyZ2V0LCAnZGlzcG9zZScsIGNsZWFuUmVtb3Zlcik7XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBhIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gTm90IHVzaW5nIGBpbnN0YW5jZW9mIENvbXBvbmVudGAgYmVjYXVzZSBpdCBtYWtlcyBtb2NrIHBsYXllcnMgZGlmZmljdWx0XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3Qub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0byB0aGUgb3RoZXIgY29tcG9uZW50XG4gICAgICAgICAgICAgIHRhcmdldC5vbih0eXBlLCBmbik7XG4gICAgICAgICAgICAgIHRhcmdldC5vbignZGlzcG9zZScsIGNsZWFuUmVtb3Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAqIGBgYGpzXG4gICAqICAgICBteUNvbXBvbmVudC5vZmYoJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqIGBgYFxuICAgKiBJZiBteUZ1bmMgaXMgZXhjbHVkZWQsIEFMTCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogSWYgZXZlbnRUeXBlIGlzIGV4Y2x1ZGVkLCBBTEwgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjb21wb25lbnQuXG4gICAqIEFsdGVybmF0aXZlbHkgeW91IGNhbiB1c2UgYG9mZmAgdG8gcmVtb3ZlIGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdG8gb3RoZXJcbiAgICogZWxlbWVudHMgb3IgY29tcG9uZW50cyB1c2luZyBgbXlDb21wb25lbnQub24ob3RoZXJDb21wb25lbnQuLi5gLlxuICAgKiBJbiB0aGlzIGNhc2UgYm90aCB0aGUgZXZlbnQgdHlwZSBhbmQgbGlzdGVuZXIgZnVuY3Rpb24gYXJlIFJFUVVJUkVELlxuICAgKiBgYGBqc1xuICAgKiAgICAgbXlDb21wb25lbnQub2ZmKG90aGVyRWxlbWVudCwgJ2V2ZW50VHlwZScsIG15RnVuYyk7XG4gICAqICAgICBteUNvbXBvbmVudC5vZmYob3RoZXJDb21wb25lbnQsICdldmVudFR5cGUnLCBteUZ1bmMpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nPXxDb21wb25lbnR9ICBmaXJzdCAgVGhlIGV2ZW50IHR5cGUgb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9uPXxTdHJpbmd9ICAgICAgIHNlY29uZCBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbj19ICAgICAgICAgICAgICB0aGlyZCAgVGhlIGxpc3RlbmVyIGZvciBvdGhlciBjb21wb25lbnRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIG9mZlxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmICghZmlyc3QgfHwgdHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGZpcnN0KSkge1xuICAgICAgRXZlbnRzLm9mZih0aGlzLmVsXywgZmlyc3QsIHNlY29uZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSBmaXJzdDtcbiAgICAgIHZhciB0eXBlID0gc2Vjb25kO1xuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3QgYSBndWlkLCBldmVuIGlmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgYmVlbiB1c2VkXG4gICAgICB2YXIgZm4gPSBGbi5iaW5kKHRoaXMsIHRoaXJkKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBkaXNwb3NlIGxpc3RlbmVyIG9uIHRoaXMgY29tcG9uZW50LFxuICAgICAgLy8gd2hpY2ggd2FzIGdpdmVuIHRoZSBzYW1lIGd1aWQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGZuKTtcblxuICAgICAgaWYgKGZpcnN0Lm5vZGVOYW1lKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgICAgRXZlbnRzLm9mZih0YXJnZXQsIHR5cGUsIGZuKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW5lciBmb3IgY2xlYW5pbmcgdGhlIGRpc3Bvc2UgbGlzdGVuZXJcbiAgICAgICAgRXZlbnRzLm9mZih0YXJnZXQsICdkaXNwb3NlJywgZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Lm9mZih0eXBlLCBmbik7XG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBmbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBiZSB0cmlnZ2VyZWQgb25seSBvbmNlIGFuZCB0aGVuIHJlbW92ZWRcbiAgICogYGBganNcbiAgICogICAgIG15Q29tcG9uZW50Lm9uZSgnZXZlbnROYW1lJywgbXlGdW5jKTtcbiAgICogYGBgXG4gICAqIEFsdGVybmF0aXZlbHkgeW91IGNhbiBhZGQgYSBsaXN0ZW5lciB0byBhbm90aGVyIGVsZW1lbnQgb3IgY29tcG9uZW50XG4gICAqIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgb25seSBvbmNlLlxuICAgKiBgYGBqc1xuICAgKiAgICAgbXlDb21wb25lbnQub25lKG90aGVyRWxlbWVudCwgJ2V2ZW50TmFtZScsIG15RnVuYyk7XG4gICAqICAgICBteUNvbXBvbmVudC5vbmUob3RoZXJDb21wb25lbnQsICdldmVudE5hbWUnLCBteUZ1bmMpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfENvbXBvbmVudH0gIGZpcnN0ICAgVGhlIGV2ZW50IHR5cGUgb3Igb3RoZXIgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufFN0cmluZ30gICAgICAgc2Vjb25kICBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbj19ICAgICAgICAgICAgIHRoaXJkICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBvdGhlciBjb21wb25lbnRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIG9uZVxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uIG9uZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzLFxuICAgICAgICBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIEV2ZW50cy5vbmUodGhpcy5lbF8sIGZpcnN0LCBGbi5iaW5kKHRoaXMsIHNlY29uZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZmlyc3Q7XG4gICAgICAgIHZhciB0eXBlID0gc2Vjb25kO1xuICAgICAgICB2YXIgZm4gPSBGbi5iaW5kKF90aGlzMywgdGhpcmQpO1xuXG4gICAgICAgIHZhciBuZXdGdW5jID0gZnVuY3Rpb24gbmV3RnVuYygpIHtcbiAgICAgICAgICBfdGhpczMub2ZmKHRhcmdldCwgdHlwZSwgbmV3RnVuYyk7XG4gICAgICAgICAgZm4uYXBwbHkobnVsbCwgX2FyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gS2VlcCB0aGUgc2FtZSBmdW5jdGlvbiBJRCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgIG5ld0Z1bmMuZ3VpZCA9IGZuLmd1aWQ7XG5cbiAgICAgICAgX3RoaXMzLm9uKHRhcmdldCwgdHlwZSwgbmV3RnVuYyk7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIGFuIGVsZW1lbnRcbiAgICogYGBganNcbiAgICogICAgIG15Q29tcG9uZW50LnRyaWdnZXIoJ2V2ZW50TmFtZScpO1xuICAgKiAgICAgbXlDb21wb25lbnQudHJpZ2dlcih7J3R5cGUnOidldmVudE5hbWUnfSk7XG4gICAqICAgICBteUNvbXBvbmVudC50cmlnZ2VyKCdldmVudE5hbWUnLCB7ZGF0YTogJ3NvbWUgZGF0YSd9KTtcbiAgICogICAgIG15Q29tcG9uZW50LnRyaWdnZXIoeyd0eXBlJzonZXZlbnROYW1lJ30sIHtkYXRhOiAnc29tZSBkYXRhJ30pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7RXZlbnR8T2JqZWN0fFN0cmluZ30gZXZlbnQgIEEgc3RyaW5nICh0aGUgdHlwZSkgb3IgYW4gZXZlbnQgb2JqZWN0IHdpdGggYSB0eXBlIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtoYXNoXSBkYXRhIGhhc2ggdG8gcGFzcyBhbG9uZyB3aXRoIHRoZSBldmVudFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9ICAgICAgIHNlbGZcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQsIGhhc2gpIHtcbiAgICBFdmVudHMudHJpZ2dlcih0aGlzLmVsXywgZXZlbnQsIGhhc2gpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIGEgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJlYWR5IHN0YXRlLlxuICAgKiBEaWZmZXJlbnQgZnJvbSBldmVudCBsaXN0ZW5lcnMgaW4gdGhhdCBpZiB0aGUgcmVhZHkgZXZlbnQgaGFzIGFscmVhZHkgaGFwcGVuZWRcbiAgICogaXQgd2lsbCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuIFJlYWR5IGxpc3RlbmVyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHN5bmMgRXhlYyB0aGUgbGlzdGVuZXIgc3luY2hyb25vdXNseSBpZiBjb21wb25lbnQgaXMgcmVhZHlcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIHJlYWR5XG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIHZhciBzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZHlfKSB7XG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvbiBhc3luY2hyb25vdXNseSBieSBkZWZhdWx0IGZvciBjb25zaXN0ZW5jeVxuICAgICAgICAgIHRoaXMuc2V0VGltZW91dChmbiwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSB0aGlzLnJlYWR5UXVldWVfIHx8IFtdO1xuICAgICAgICB0aGlzLnJlYWR5UXVldWVfLnB1c2goZm4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgcmVhZHkgbGlzdGVuZXJzXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQG1ldGhvZCB0cmlnZ2VyUmVhZHlcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVhZHkgPSBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5XyA9IHRydWU7XG5cbiAgICAvLyBFbnN1cmUgcmVhZHkgaXMgdHJpZ2dlcmQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlYWR5UXVldWUgPSB0aGlzLnJlYWR5UXVldWVfO1xuXG4gICAgICAvLyBSZXNldCBSZWFkeSBRdWV1ZVxuICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IFtdO1xuXG4gICAgICBpZiAocmVhZHlRdWV1ZSAmJiByZWFkeVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVhZHlRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBmb3IgdXNpbmcgZXZlbnQgbGlzdGVuZXJzIGFsc29cbiAgICAgIHRoaXMudHJpZ2dlcigncmVhZHknKTtcbiAgICB9LCAxKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYSBzaW5nbGUgRE9NIGVsZW1lbnQgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIGNvbXBvbmVudCdzXG4gICAqIGBjb250ZW50RWxgIG9yIGFub3RoZXIgY3VzdG9tIGNvbnRleHQuXG4gICAqXG4gICAqIEBtZXRob2QgJFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yYC5cbiAgICpcbiAgICogQHBhcmFtICB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICAgKiAgICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gICAqICAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gICAqICAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAgICogICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS4kID0gZnVuY3Rpb24gJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiBEb20uJChzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRlbnRFbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYSBhbGwgRE9NIGVsZW1lbnRzIG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBjb21wb25lbnQnc1xuICAgKiBgY29udGVudEVsYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAbWV0aG9kICQkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICAgKlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fFN0cmluZ30gW2NvbnRleHQ9ZG9jdW1lbnRdXG4gICAqICAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3JcbiAgICogICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcbiAgICogICAgICAgICBhcyBjb250ZXh0LiBJZiBtaXNzaW5nIChvciBubyBlbGVtZW50IG1hdGNoZXMgc2VsZWN0b3IpLCBmYWxsc1xuICAgKiAgICAgICAgIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZUxpc3R9XG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuJCQgPSBmdW5jdGlvbiAkJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiBEb20uJCQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0NoZWNrIENsYXNzbmFtZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBtZXRob2QgaGFzQ2xhc3NcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzVG9DaGVjaykge1xuICAgIHJldHVybiBEb20uaGFzRWxDbGFzcyh0aGlzLmVsXywgY2xhc3NUb0NoZWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBtZXRob2QgYWRkQ2xhc3NcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzVG9BZGQpIHtcbiAgICBEb20uYWRkRWxDbGFzcyh0aGlzLmVsXywgY2xhc3NUb0FkZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9SZW1vdmUgQ2xhc3NuYW1lIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBtZXRob2QgcmVtb3ZlQ2xhc3NcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzVG9SZW1vdmUpIHtcbiAgICBEb20ucmVtb3ZlRWxDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1JlbW92ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBjb21wb25lbnQncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICAgKiBAcGFyYW0gIHtCb29sZWFufEZ1bmN0aW9ufSBbcHJlZGljYXRlXVxuICAgKiAgICAgICAgIENhbiBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIEJvb2xlYW4uIElmIGB0cnVlYCwgdGhlIGNsYXNzXG4gICAqICAgICAgICAgd2lsbCBiZSBhZGRlZDsgaWYgYGZhbHNlYCwgdGhlIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgbm90XG4gICAqICAgICAgICAgZ2l2ZW4sIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIGlmIG5vdCBwcmVzZW50IGFuZCB2aWNlIHZlcnNhLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBtZXRob2QgdG9nZ2xlQ2xhc3NcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSkge1xuICAgIERvbS50b2dnbGVFbENsYXNzKHRoaXMuZWxfLCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQgZWxlbWVudCBpZiBoaWRkZW5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAbWV0aG9kIHNob3dcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlmIGN1cnJlbnRseSBzaG93aW5nXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQG1ldGhvZCBoaWRlXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NrIGFuIGl0ZW0gaW4gaXRzIHZpc2libGUgc3RhdGVcbiAgICogVG8gYmUgdXNlZCB3aXRoIGZhZGVJbi9mYWRlT3V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgbG9ja1Nob3dpbmdcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2NrU2hvd2luZyA9IGZ1bmN0aW9uIGxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5sb2NrIGFuIGl0ZW0gdG8gYmUgaGlkZGVuXG4gICAqIFRvIGJlIHVzZWQgd2l0aCBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIHVubG9ja1Nob3dpbmdcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS51bmxvY2tTaG93aW5nID0gZnVuY3Rpb24gdW5sb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgdGhlIHdpZHRoIG9mIHRoZSBjb21wb25lbnQgKENTUyB2YWx1ZXMpXG4gICAqIFNldHRpbmcgdGhlIHZpZGVvIHRhZyBkaW1lbnNpb24gdmFsdWVzIG9ubHkgd29ya3Mgd2l0aCB2YWx1ZXMgaW4gcGl4ZWxzLlxuICAgKiBQZXJjZW50IHZhbHVlcyB3aWxsIG5vdCB3b3JrLlxuICAgKiBTb21lIHBlcmNlbnRzIGNhbiBiZSB1c2VkLCBidXQgd2lkdGgoKS9oZWlnaHQoKSB3aWxsIHJldHVybiB0aGUgbnVtYmVyICsgJSxcbiAgICogbm90IHRoZSBhY3R1YWwgY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nPX0gbnVtICAgT3B0aW9uYWwgd2lkdGggbnVtYmVyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBMaXN0ZW5lcnMgU2tpcCB0aGUgJ3Jlc2l6ZScgZXZlbnQgdHJpZ2dlclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9IFRoaXMgY29tcG9uZW50LCB3aGVuIHNldHRpbmcgdGhlIHdpZHRoXG4gICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IFRoZSB3aWR0aCwgd2hlbiBnZXR0aW5nXG4gICAqIEBtZXRob2Qgd2lkdGhcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCAoQ1NTIHZhbHVlcylcbiAgICogU2V0dGluZyB0aGUgdmlkZW8gdGFnIGRpbWVuc2lvbiB2YWx1ZXMgb25seSB3b3JrcyB3aXRoIHZhbHVlcyBpbiBwaXhlbHMuXG4gICAqIFBlcmNlbnQgdmFsdWVzIHdpbGwgbm90IHdvcmsuXG4gICAqIFNvbWUgcGVyY2VudHMgY2FuIGJlIHVzZWQsIGJ1dCB3aWR0aCgpL2hlaWdodCgpIHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgKyAlLFxuICAgKiBub3QgdGhlIGFjdHVhbCBjb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmc9fSBudW0gICAgIE5ldyBjb21wb25lbnQgaGVpZ2h0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW49fSBza2lwTGlzdGVuZXJzIFNraXAgdGhlIHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhpcyBjb21wb25lbnQsIHdoZW4gc2V0dGluZyB0aGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IFRoZSBoZWlnaHQsIHdoZW4gZ2V0dGluZ1xuICAgKiBAbWV0aG9kIGhlaWdodFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodChudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ2hlaWdodCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXQgdGhlIHNhbWUgdGltZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSB3aWR0aCBXaWR0aCBvZiBwbGF5ZXJcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gaGVpZ2h0IEhlaWdodCBvZiBwbGF5ZXJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSBUaGUgY29tcG9uZW50XG4gICAqIEBtZXRob2QgZGltZW5zaW9uc1xuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBTa2lwIHJlc2l6ZSBsaXN0ZW5lcnMgb24gd2lkdGggZm9yIG9wdGltaXphdGlvblxuICAgIHJldHVybiB0aGlzLndpZHRoKHdpZHRoLCB0cnVlKS5oZWlnaHQoaGVpZ2h0KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB3aWR0aCBvciBoZWlnaHRcbiAgICogVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoZSB3aWR0aCgpIGFuZCBoZWlnaHQoKSBtZXRob2RzLlxuICAgKiBBbGwgZm9yIGFuIGludGVnZXIsIGludGVnZXIgKyAncHgnIG9yIGludGVnZXIgKyAnJSc7XG4gICAqIEtub3duIGlzc3VlOiBIaWRkZW4gZWxlbWVudHMgb2ZmaWNpYWxseSBoYXZlIGEgd2lkdGggb2YgMC4gV2UncmUgZGVmYXVsdGluZ1xuICAgKiB0byB0aGUgc3R5bGUud2lkdGggdmFsdWUgYW5kIGZhbGxpbmcgYmFjayB0byBjb21wdXRlZFN0eWxlIHdoaWNoIGhhcyB0aGVcbiAgICogaGlkZGVuIGVsZW1lbnQgaXNzdWUuIEluZm8sIGJ1dCBwcm9iYWJseSBub3QgYW4gZWZmaWNpZW50IGZpeDpcbiAgICogaHR0cDovL3d3dy5mb2xpb3Rlay5jb20vZGV2YmxvZy9nZXR0aW5nLXRoZS13aWR0aC1vZi1hLWhpZGRlbi1lbGVtZW50LXdpdGgtanF1ZXJ5LXVzaW5nLXdpZHRoL1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHdpZHRoT3JIZWlnaHQgICd3aWR0aCcgb3IgJ2hlaWdodCdcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZz19IG51bSAgICAgTmV3IGRpbWVuc2lvblxuICAgKiBAcGFyYW0gIHtCb29sZWFuPX0gc2tpcExpc3RlbmVycyBTa2lwIHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhlIGNvbXBvbmVudCBpZiBhIGRpbWVuc2lvbiB3YXMgc2V0XG4gICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IFRoZSBkaW1lbnNpb24gaWYgbm90aGluZyB3YXMgc2V0XG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgZGltZW5zaW9uXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIGlmIChudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2V0IHRvIHplcm8gaWYgbnVsbCBvciBsaXRlcmFsbHkgTmFOIChOYU4gIT09IE5hTilcbiAgICAgIGlmIChudW0gPT09IG51bGwgfHwgbnVtICE9PSBudW0pIHtcbiAgICAgICAgbnVtID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNpbmcgY3NzIHdpZHRoL2hlaWdodCAoJSBvciBweCkgYW5kIGFkanVzdFxuICAgICAgaWYgKCgnJyArIG51bSkuaW5kZXhPZignJScpICE9PSAtMSB8fCAoJycgKyBudW0pLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtO1xuICAgICAgfSBlbHNlIGlmIChudW0gPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW0gKyAncHgnO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgICAgaWYgKCFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBjb21wb25lbnRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIE5vdCBzZXR0aW5nIGEgdmFsdWUsIHNvIGdldHRpbmcgaXRcbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudCBleGlzdHNcbiAgICBpZiAoIXRoaXMuZWxfKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBHZXQgZGltZW5zaW9uIHZhbHVlIGZyb20gc3R5bGVcbiAgICB2YXIgdmFsID0gdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgdmFyIHB4SW5kZXggPSB2YWwuaW5kZXhPZigncHgnKTtcblxuICAgIGlmIChweEluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBwaXhlbCB2YWx1ZSB3aXRoIG5vICdweCdcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWwuc2xpY2UoMCwgcHhJbmRleCksIDEwKTtcbiAgICB9XG5cbiAgICAvLyBObyBweCBzbyB1c2luZyAlIG9yIG5vIHN0eWxlIHdhcyBzZXQsIHNvIGZhbGxpbmcgYmFjayB0byBvZmZzZXRXaWR0aC9oZWlnaHRcbiAgICAvLyBJZiBjb21wb25lbnQgaGFzIGRpc3BsYXk6bm9uZSwgb2Zmc2V0IHdpbGwgcmV0dXJuIDBcbiAgICAvLyBUT0RPOiBoYW5kbGUgZGlzcGxheTpub25lIGFuZCBubyBkaW1lbnNpb24gc3R5bGUgdXNpbmcgcHhcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5lbF9bJ29mZnNldCcgKyBfdXRpbHNUb1RpdGxlQ2FzZUpzMlsnZGVmYXVsdCddKHdpZHRoT3JIZWlnaHQpXSwgMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2lkdGggb3IgaGVpZ2h0IG9mIGNvbXB1dGVkIHN0eWxlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gd2lkdGhPckhlaWdodCAgJ3dpZHRoJyBvciAnaGVpZ2h0J1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ8Qm9vbGVhbn0gVGhlIGJvbGVhbiBmYWxzZSBpZiBub3RoaW5nIHdhcyBzZXRcbiAgICogQG1ldGhvZCBjdXJyZW50RGltZW5zaW9uXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudERpbWVuc2lvbiA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb24od2lkdGhPckhlaWdodCkge1xuICAgIHZhciBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSAwO1xuXG4gICAgaWYgKHdpZHRoT3JIZWlnaHQgIT09ICd3aWR0aCcgJiYgd2lkdGhPckhlaWdodCAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudERpbWVuc2lvbiBvbmx5IGFjY2VwdHMgd2lkdGggb3IgaGVpZ2h0IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxfKTtcbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh3aWR0aE9ySGVpZ2h0KSB8fCBjb21wdXRlZFN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lbF8uY3VycmVudFN0eWxlKSB7XG4gICAgICAvLyBpZSA4IGRvZXNuJ3Qgc3VwcG9ydCBjb21wdXRlZCBzdHlsZSwgc2hpbSBpdFxuICAgICAgLy8gcmV0dXJuIGNsaWVudFdpZHRoIG9yIGNsaWVudEhlaWdodCBpbnN0ZWFkIGZvciBiZXR0ZXIgYWNjdXJhY3lcbiAgICAgIHZhciBydWxlID0gJ29mZnNldCcgKyBfdXRpbHNUb1RpdGxlQ2FzZUpzMlsnZGVmYXVsdCddKHdpZHRoT3JIZWlnaHQpO1xuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gdGhpcy5lbF9bcnVsZV07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlICdweCcgZnJvbSB2YXJpYWJsZSBhbmQgcGFyc2UgYXMgaW50ZWdlclxuICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0KTtcbiAgICByZXR1cm4gY29tcHV0ZWRXaWR0aE9ySGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIG9mIGNvbXB1dGVkIHN0eWxlXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRpbWVuc2lvbnMgb2YgZWxlbWVudFxuICAgKiBAbWV0aG9kIGN1cnJlbnREaW1lbnNpb25zXG4gICAqL1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudERpbWVuc2lvbnMgPSBmdW5jdGlvbiBjdXJyZW50RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMuY3VycmVudERpbWVuc2lvbignd2lkdGgnKSxcbiAgICAgIGhlaWdodDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCdoZWlnaHQnKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB3aWR0aCBvZiBjb21wdXRlZCBzdHlsZVxuICAgKiBAcmV0dXJuIHtJbnRlZ2VyfVxuICAgKiBAbWV0aG9kIGN1cnJlbnRXaWR0aFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRXaWR0aCA9IGZ1bmN0aW9uIGN1cnJlbnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RGltZW5zaW9uKCd3aWR0aCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaGVpZ2h0IG9mIGNvbXB1dGVkIHN0eWxlXG4gICAqIEByZXR1cm4ge0ludGVnZXJ9XG4gICAqIEBtZXRob2QgY3VycmVudEhlaWdodFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRIZWlnaHQgPSBmdW5jdGlvbiBjdXJyZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbWl0ICd0YXAnIGV2ZW50cyB3aGVuIHRvdWNoIGV2ZW50cyBhcmUgc3VwcG9ydGVkXG4gICAqIFRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHRvZ2dsaW5nIHRoZSBjb250cm9scyB0aHJvdWdoIGEgdGFwIG9uIHRoZSB2aWRlby5cbiAgICogV2UncmUgcmVxdWlyaW5nIHRoZW0gdG8gYmUgZW5hYmxlZCBiZWNhdXNlIG90aGVyd2lzZSBldmVyeSBjb21wb25lbnQgd291bGRcbiAgICogaGF2ZSB0aGlzIGV4dHJhIG92ZXJoZWFkIHVubmVjZXNzYXJpbHksIG9uIG1vYmlsZSBkZXZpY2VzIHdoZXJlIGV4dHJhXG4gICAqIG92ZXJoZWFkIGlzIGVzcGVjaWFsbHkgYmFkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGVtaXRUYXBFdmVudHNcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbWl0VGFwRXZlbnRzID0gZnVuY3Rpb24gZW1pdFRhcEV2ZW50cygpIHtcbiAgICAvLyBUcmFjayB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGhvdyBsb25nIHRoZSB0b3VjaCBsYXN0ZWRcbiAgICB2YXIgdG91Y2hTdGFydCA9IDA7XG4gICAgdmFyIGZpcnN0VG91Y2ggPSBudWxsO1xuXG4gICAgLy8gTWF4aW11bSBtb3ZlbWVudCBhbGxvd2VkIGR1cmluZyBhIHRvdWNoIGV2ZW50IHRvIHN0aWxsIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAvLyBPdGhlciBwb3B1bGFyIGxpYnMgdXNlIGFueXdoZXJlIGZyb20gMiAoaGFtbWVyLmpzKSB0byAxNSwgc28gMTAgc2VlbXMgbGlrZSBhIG5pY2UsIHJvdW5kIG51bWJlci5cbiAgICB2YXIgdGFwTW92ZW1lbnRUaHJlc2hvbGQgPSAxMDtcblxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXG4gICAgdmFyIHRvdWNoVGltZVRocmVzaG9sZCA9IDIwMDtcblxuICAgIHZhciBjb3VsZEJlVGFwID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENvcHkgcGFnZVgvcGFnZVkgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgIGZpcnN0VG91Y2ggPSB7XG4gICAgICAgICAgcGFnZVg6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVjb3JkIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVjdCBhIHRhcCB2cy4gXCJ0b3VjaCBhbmQgaG9sZFwiXG4gICAgICAgIHRvdWNoU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gUmVzZXQgY291bGRCZVRhcCB0cmFja2luZ1xuICAgICAgICBjb3VsZEJlVGFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgLy8gU29tZSBkZXZpY2VzIHdpbGwgdGhyb3cgdG91Y2htb3ZlcyBmb3IgYWxsIGJ1dCB0aGUgc2xpZ2h0ZXN0IG9mIHRhcHMuXG4gICAgICAgIC8vIFNvLCBpZiB3ZSBtb3ZlZCBvbmx5IGEgc21hbGwgZGlzdGFuY2UsIHRoaXMgY291bGQgc3RpbGwgYmUgYSB0YXBcbiAgICAgICAgdmFyIHhkaWZmID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGZpcnN0VG91Y2gucGFnZVg7XG4gICAgICAgIHZhciB5ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBmaXJzdFRvdWNoLnBhZ2VZO1xuICAgICAgICB2YXIgdG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG5cbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5vVGFwID0gZnVuY3Rpb24gbm9UYXAoKSB7XG4gICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IExpc3RlbiB0byB0aGUgb3JpZ2luYWwgdGFyZ2V0LiBodHRwOi8veW91dHUuYmUvRHVqZnBYT0tVcDg/dD0xM204c1xuICAgIHRoaXMub24oJ3RvdWNobGVhdmUnLCBub1RhcCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCBub1RhcCk7XG5cbiAgICAvLyBXaGVuIHRoZSB0b3VjaCBlbmRzLCBtZWFzdXJlIGhvdyBsb25nIGl0IHRvb2sgYW5kIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZmlyc3RUb3VjaCA9IG51bGw7XG4gICAgICAvLyBQcm9jZWVkIG9ubHkgaWYgdGhlIHRvdWNobW92ZS9sZWF2ZS9jYW5jZWwgZXZlbnQgZGlkbid0IGhhcHBlblxuICAgICAgaWYgKGNvdWxkQmVUYXAgPT09IHRydWUpIHtcbiAgICAgICAgLy8gTWVhc3VyZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgICAgIHZhciB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgICAgICBpZiAodG91Y2hUaW1lIDwgdG91Y2hUaW1lVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGJyb3dzZXIgdHVybiB0aGlzIGludG8gYSBjbGlja1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gRXZlbnRzLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9ydCB1c2VyIHRvdWNoIGFjdGl2aXR5IHdoZW4gdG91Y2ggZXZlbnRzIG9jY3VyXG4gICAqIFVzZXIgYWN0aXZpdHkgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hlbiBjb250cm9scyBzaG91bGQgc2hvdy9oaWRlLiBJdCdzXG4gICAqIHJlbGF0aXZlbHkgc2ltcGxlIHdoZW4gaXQgY29tZXMgdG8gbW91c2UgZXZlbnRzLCBiZWNhdXNlIGFueSBtb3VzZSBldmVudFxuICAgKiBzaG91bGQgc2hvdyB0aGUgY29udHJvbHMuIFNvIHdlIGNhcHR1cmUgbW91c2UgZXZlbnRzIHRoYXQgYnViYmxlIHVwIHRvIHRoZVxuICAgKiBwbGF5ZXIgYW5kIHJlcG9ydCBhY3Rpdml0eSB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICogV2l0aCB0b3VjaCBldmVudHMgaXQgaXNuJ3QgYXMgZWFzeS4gV2UgY2FuJ3QgcmVseSBvbiB0b3VjaCBldmVudHMgYXQgdGhlXG4gICAqIHBsYXllciBsZXZlbCwgYmVjYXVzZSBhIHRhcCAodG91Y2hzdGFydCArIHRvdWNoZW5kKSBvbiB0aGUgdmlkZW8gaXRzZWxmIG9uXG4gICAqIG1vYmlsZSBkZXZpY2VzIGlzIG1lYW50IHRvIHR1cm4gY29udHJvbHMgb2ZmIChhbmQgb24pLiBVc2VyIGFjdGl2aXR5IGlzXG4gICAqIGNoZWNrZWQgYXN5bmNocm9ub3VzbHksIHNvIHdoYXQgY291bGQgaGFwcGVuIGlzIGEgdGFwIGV2ZW50IG9uIHRoZSB2aWRlb1xuICAgKiB0dXJucyB0aGUgY29udHJvbHMgb2ZmLCB0aGVuIHRoZSB0b3VjaGVuZCBldmVudCBidWJibGVzIHVwIHRvIHRoZSBwbGF5ZXIsXG4gICAqIHdoaWNoIGlmIGl0IHJlcG9ydGVkIHVzZXIgYWN0aXZpdHksIHdvdWxkIHR1cm4gdGhlIGNvbnRyb2xzIHJpZ2h0IGJhY2sgb24uXG4gICAqIChXZSBhbHNvIGRvbid0IHdhbnQgdG8gY29tcGxldGVseSBibG9jayB0b3VjaCBldmVudHMgZnJvbSBidWJibGluZyB1cClcbiAgICogQWxzbyBhIHRvdWNobW92ZSwgdG91Y2graG9sZCwgYW5kIGFueXRoaW5nIG90aGVyIHRoYW4gYSB0YXAgaXMgbm90IHN1cHBvc2VkXG4gICAqIHRvIHR1cm4gdGhlIGNvbnRyb2xzIGJhY2sgb24gb24gYSBtb2JpbGUgZGV2aWNlLlxuICAgKiBIZXJlIHdlJ3JlIHNldHRpbmcgdGhlIGRlZmF1bHQgY29tcG9uZW50IGJlaGF2aW9yIHRvIHJlcG9ydCB1c2VyIGFjdGl2aXR5XG4gICAqIHdoZW5ldmVyIHRvdWNoIGV2ZW50cyBoYXBwZW4sIGFuZCB0aGlzIGNhbiBiZSB0dXJuZWQgb2ZmIGJ5IGNvbXBvbmVudHMgdGhhdFxuICAgKiB3YW50IHRvdWNoIGV2ZW50cyB0byBhY3QgZGlmZmVyZW50bHkuXG4gICAqXG4gICAqIEBtZXRob2QgZW5hYmxlVG91Y2hBY3Rpdml0eVxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZVRvdWNoQWN0aXZpdHkgPSBmdW5jdGlvbiBlbmFibGVUb3VjaEFjdGl2aXR5KCkge1xuICAgIC8vIERvbid0IGNvbnRpbnVlIGlmIHRoZSByb290IHBsYXllciBkb2Vzbid0IHN1cHBvcnQgcmVwb3J0aW5nIHVzZXIgYWN0aXZpdHlcbiAgICBpZiAoIXRoaXMucGxheWVyKCkgfHwgIXRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbGlzdGVuZXIgZm9yIHJlcG9ydGluZyB0aGF0IHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgIHZhciByZXBvcnQgPSBGbi5iaW5kKHRoaXMucGxheWVyKCksIHRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIHZhciB0b3VjaEhvbGRpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgICAvLyByZXBvcnQgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYXMgYWN0aXZpdHlDaGVja1xuICAgICAgdG91Y2hIb2xkaW5nID0gdGhpcy5zZXRJbnRlcnZhbChyZXBvcnQsIDI1MCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdG91Y2hFbmQgPSBmdW5jdGlvbiB0b3VjaEVuZChldmVudCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBzdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgdG91Y2ggaXMgaG9sZGluZ1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIHJlcG9ydCk7XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCB0b3VjaEVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGltZW91dCBhbmQgc2V0cyB1cCBkaXNwb3NhbCBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSB0aW1lb3V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBOdW1iZXIgb2YgbXMgdG8gZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgdGltZW91dCBJRFxuICAgKiBAbWV0aG9kIHNldFRpbWVvdXRcbiAgICovXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gc2V0VGltZW91dChmbiwgdGltZW91dCkge1xuICAgIGZuID0gRm4uYmluZCh0aGlzLCBmbik7XG5cbiAgICAvLyB3aW5kb3cuc2V0VGltZW91dCB3b3VsZCBiZSBwcmVmZXJhYmxlIGhlcmUsIGJ1dCBkdWUgdG8gc29tZSBiaXphcnJlIGlzc3VlIHdpdGggU2lub24gYW5kL29yIFBoYW50b21qcywgd2UgY2FuJ3QuXG4gICAgdmFyIHRpbWVvdXRJZCA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uc2V0VGltZW91dChmbiwgdGltZW91dCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXRpbWVvdXQtJyArIHRpbWVvdXRJZDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGEgdGltZW91dCBhbmQgcmVtb3ZlcyB0aGUgYXNzb2NpYXRlZCBkaXNwb3NlIGxpc3RlbmVyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SWQgVGhlIGlkIG9mIHRoZSB0aW1lb3V0IHRvIGNsZWFyXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgdGltZW91dCBJRFxuICAgKiBAbWV0aG9kIGNsZWFyVGltZW91dFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpIHtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHt9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXRpbWVvdXQtJyArIHRpbWVvdXRJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW50ZXJ2YWwgYW5kIHNldHMgdXAgZGlzcG9zYWwgYXV0b21hdGljYWxseS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBldmVyeSBOIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCBOdW1iZXIgb2YgbXMgdG8gZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgaW50ZXJ2YWwgSURcbiAgICogQG1ldGhvZCBzZXRJbnRlcnZhbFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XG4gICAgZm4gPSBGbi5iaW5kKHRoaXMsIGZuKTtcblxuICAgIHZhciBpbnRlcnZhbElkID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5zZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLWludGVydmFsLScgKyBpbnRlcnZhbElkO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFuIGludGVydmFsIGFuZCByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIGRpc3Bvc2UgbGlzdGVuZXJcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsSWQgVGhlIGlkIG9mIHRoZSBpbnRlcnZhbCB0byBjbGVhclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGludGVydmFsIElEXG4gICAqIEBtZXRob2QgY2xlYXJJbnRlcnZhbFxuICAgKi9cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtaW50ZXJ2YWwtJyArIGludGVydmFsSWQ7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcCBUaGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyXG4gICAqIEBzdGF0aWNcbiAgICogQG1ldGhvZCByZWdpc3RlckNvbXBvbmVudFxuICAgKi9cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudChuYW1lLCBjb21wKSB7XG4gICAgaWYgKCFDb21wb25lbnQuY29tcG9uZW50c18pIHtcbiAgICAgIENvbXBvbmVudC5jb21wb25lbnRzXyA9IHt9O1xuICAgIH1cblxuICAgIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXSA9IGNvbXA7XG4gICAgcmV0dXJuIGNvbXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBjb21wb25lbnQgYnkgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0XG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQHN0YXRpY1xuICAgKiBAbWV0aG9kIGdldENvbXBvbmVudFxuICAgKi9cblxuICBDb21wb25lbnQuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0Q29tcG9uZW50KG5hbWUpIHtcbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHNfICYmIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXSkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXSAmJiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnZpZGVvanMgJiYgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS52aWRlb2pzW25hbWVdKSB7XG4gICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS53YXJuKCdUaGUgJyArIG5hbWUgKyAnIGNvbXBvbmVudCB3YXMgYWRkZWQgdG8gdGhlIHZpZGVvanMgb2JqZWN0IHdoZW4gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpJyk7XG4gICAgICByZXR1cm4gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgY29uc3RydWN0b3IgdXNpbmcgdGhlIHN1cHBsaWVkIGluaXQgbWV0aG9kXG4gICAqIG9yIHVzZXMgdGhlIGluaXQgb2YgdGhlIHBhcmVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG1ldGhvZCBleHRlbmRcbiAgICovXG5cbiAgQ29tcG9uZW50LmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS53YXJuKCdDb21wb25lbnQuZXh0ZW5kKHt9KSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgdmlkZW9qcy5leHRlbmQoQ29tcG9uZW50LCB7fSkgaW5zdGVhZCcpO1xuXG4gICAgLy8gU2V0IHVwIHRoZSBjb25zdHJ1Y3RvciB1c2luZyB0aGUgc3VwcGxpZWQgaW5pdCBtZXRob2RcbiAgICAvLyBvciB1c2luZyB0aGUgaW5pdCBvZiB0aGUgcGFyZW50IG9iamVjdFxuICAgIC8vIE1ha2Ugc3VyZSB0byBjaGVjayB0aGUgdW5vYmZ1c2NhdGVkIHZlcnNpb24gZm9yIGV4dGVybmFsIGxpYnNcbiAgICB2YXIgaW5pdCA9IHByb3BzLmluaXQgfHwgcHJvcHMuaW5pdCB8fCB0aGlzLnByb3RvdHlwZS5pbml0IHx8IHRoaXMucHJvdG90eXBlLmluaXQgfHwgZnVuY3Rpb24gKCkge307XG4gICAgLy8gSW4gUmVzaWcncyBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2UgKHByZXZpb3VzbHkgdXNlZCkgdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gIGlzIGEgZnVuY3Rpb24gdGhhdCBjYWxscyBgdGhpcy5pbml0LmFwcGx5KGFyZ3VtZW50cylgXG4gICAgLy8gSG93ZXZlciB0aGF0IHdvdWxkIHByZXZlbnQgdXMgZnJvbSB1c2luZyBgUGFyZW50T2JqZWN0LmNhbGwodGhpcyk7YFxuICAgIC8vICBpbiBhIENoaWxkIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhlIGB0aGlzYCBpbiBgdGhpcy5pbml0YFxuICAgIC8vICB3b3VsZCBzdGlsbCByZWZlciB0byB0aGUgQ2hpbGQgYW5kIGNhdXNlIGFuIGluZmluaXRlIGxvb3AuXG4gICAgLy8gV2Ugd291bGQgaW5zdGVhZCBoYXZlIHRvIGRvXG4gICAgLy8gICAgYFBhcmVudE9iamVjdC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO2BcbiAgICAvLyAgQmxlaC4gV2UncmUgbm90IGNyZWF0aW5nIGEgX3N1cGVyKCkgZnVuY3Rpb24sIHNvIGl0J3MgZ29vZCB0byBrZWVwXG4gICAgLy8gIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgcmVmZXJlbmNlIHNpbXBsZS5cbiAgICB2YXIgc3ViT2JqID0gZnVuY3Rpb24gc3ViT2JqKCkge1xuICAgICAgaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvLyBJbmhlcml0IGZyb20gdGhpcyBvYmplY3QncyBwcm90b3R5cGVcbiAgICBzdWJPYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgLy8gUmVzZXQgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5IGZvciBzdWJPYmogb3RoZXJ3aXNlXG4gICAgLy8gaW5zdGFuY2VzIG9mIHN1Yk9iaiB3b3VsZCBoYXZlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGFyZW50IE9iamVjdFxuICAgIHN1Yk9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJPYmo7XG5cbiAgICAvLyBNYWtlIHRoZSBjbGFzcyBleHRlbmRhYmxlXG4gICAgc3ViT2JqLmV4dGVuZCA9IENvbXBvbmVudC5leHRlbmQ7XG5cbiAgICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgICBmb3IgKHZhciBfbmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KF9uYW1lKSkge1xuICAgICAgICBzdWJPYmoucHJvdG90eXBlW19uYW1lXSA9IHByb3BzW19uYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ViT2JqO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KSgpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NvbXBvbmVudCcsIENvbXBvbmVudCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBDb21wb25lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4vdXRpbHMvZXZlbnRzLmpzXCI6MTQzLFwiLi91dGlscy9mbi5qc1wiOjE0NCxcIi4vdXRpbHMvZ3VpZC5qc1wiOjE0NixcIi4vdXRpbHMvbG9nLmpzXCI6MTQ3LFwiLi91dGlscy9tZXJnZS1vcHRpb25zLmpzXCI6MTQ4LFwiLi91dGlscy90by10aXRsZS1jYXNlLmpzXCI6MTUxLFwiZ2xvYmFsL3dpbmRvd1wiOjJ9XSw2ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLWJ1dHRvbi5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdHJhY2tCdXR0b25KcyA9IF9kZXJlcV8oJy4uL3RyYWNrLWJ1dHRvbi5qcycpO1xuXG52YXIgX3RyYWNrQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tCdXR0b25Kcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfYXVkaW9UcmFja01lbnVJdGVtSnMgPSBfZGVyZXFfKCcuL2F1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qcycpO1xuXG52YXIgX2F1ZGlvVHJhY2tNZW51SXRlbUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F1ZGlvVHJhY2tNZW51SXRlbUpzKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB0ZXh0IHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcylcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBUcmFja0J1dHRvblxuICogQGNsYXNzIEF1ZGlvVHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQXVkaW9UcmFja0J1dHRvbiA9IChmdW5jdGlvbiAoX1RyYWNrQnV0dG9uKSB7XG4gIF9pbmhlcml0cyhBdWRpb1RyYWNrQnV0dG9uLCBfVHJhY2tCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrQnV0dG9uKTtcblxuICAgIG9wdGlvbnMudHJhY2tzID0gcGxheWVyLmF1ZGlvVHJhY2tzICYmIHBsYXllci5hdWRpb1RyYWNrcygpO1xuXG4gICAgX1RyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdBdWRpbyBNZW51Jyk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIGNsYXNzIG5hbWVcbiAgICogQG1ldGhvZCBidWlsZENTU0NsYXNzXG4gICAqL1xuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWF1ZGlvLWJ1dHRvbiAnICsgX1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCBhdWRpbyB0cmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKiBAbWV0aG9kIGNyZWF0ZUl0ZW1zXG4gICAqL1xuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzICYmIHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpdGVtcy5wdXNoKG5ldyBfYXVkaW9UcmFja01lbnVJdGVtSnMyWydkZWZhdWx0J10odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgJ3NlbGVjdGFibGUnOiB0cnVlLFxuICAgICAgICAndHJhY2snOiB0cmFja1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja0J1dHRvbjtcbn0pKF90cmFja0J1dHRvbkpzMlsnZGVmYXVsdCddKTtcblxuQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0F1ZGlvIFRyYWNrJztcbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja0J1dHRvbicsIEF1ZGlvVHJhY2tCdXR0b24pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gQXVkaW9UcmFja0J1dHRvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vLi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuLi90cmFjay1idXR0b24uanNcIjo5OCxcIi4vYXVkaW8tdHJhY2stbWVudS1pdGVtLmpzXCI6Njl9XSw2OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbWVudU1lbnVJdGVtSnMgPSBfZGVyZXFfKCcuLi8uLi9tZW51L21lbnUtaXRlbS5qcycpO1xuXG52YXIgX21lbnVNZW51SXRlbUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVNZW51SXRlbUpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxuLyoqXG4gKiBUaGUgYXVkaW8gdHJhY2sgbWVudSBpdGVtXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqIEBjbGFzcyBBdWRpb1RyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgQXVkaW9UcmFja01lbnVJdGVtID0gKGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgX2luaGVyaXRzKEF1ZGlvVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICBmdW5jdGlvbiBBdWRpb1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5lbmFibGVkO1xuXG4gICAgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gRm4uYmluZChfdGhpcywgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKTtcblxuICAgICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2sgb24gYXVkaW8gdHJhY2tcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgaWYgKCF0cmFja3MpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cmFjayA9PT0gdGhpcy50cmFjaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhdWRpbyB0cmFjayBjaGFuZ2VcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVUcmFja3NDaGFuZ2VcbiAgICovXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMudHJhY2suZW5hYmxlZCk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tNZW51SXRlbTtcbn0pKF9tZW51TWVudUl0ZW1KczJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja01lbnVJdGVtJywgQXVkaW9UcmFja01lbnVJdGVtKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEF1ZGlvVHJhY2tNZW51SXRlbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vLi4vbWVudS9tZW51LWl0ZW0uanNcIjoxMTAsXCIuLi8uLi91dGlscy9mbi5qc1wiOjE0NH1dLDcwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgY29udHJvbC1iYXIuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuXG52YXIgX3BsYXlUb2dnbGVKcyA9IF9kZXJlcV8oJy4vcGxheS10b2dnbGUuanMnKTtcblxudmFyIF9wbGF5VG9nZ2xlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheVRvZ2dsZUpzKTtcblxudmFyIF90aW1lQ29udHJvbHNDdXJyZW50VGltZURpc3BsYXlKcyA9IF9kZXJlcV8oJy4vdGltZS1jb250cm9scy9jdXJyZW50LXRpbWUtZGlzcGxheS5qcycpO1xuXG52YXIgX3RpbWVDb250cm9sc0N1cnJlbnRUaW1lRGlzcGxheUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVDb250cm9sc0N1cnJlbnRUaW1lRGlzcGxheUpzKTtcblxudmFyIF90aW1lQ29udHJvbHNEdXJhdGlvbkRpc3BsYXlKcyA9IF9kZXJlcV8oJy4vdGltZS1jb250cm9scy9kdXJhdGlvbi1kaXNwbGF5LmpzJyk7XG5cbnZhciBfdGltZUNvbnRyb2xzRHVyYXRpb25EaXNwbGF5SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZUNvbnRyb2xzRHVyYXRpb25EaXNwbGF5SnMpO1xuXG52YXIgX3RpbWVDb250cm9sc1RpbWVEaXZpZGVySnMgPSBfZGVyZXFfKCcuL3RpbWUtY29udHJvbHMvdGltZS1kaXZpZGVyLmpzJyk7XG5cbnZhciBfdGltZUNvbnRyb2xzVGltZURpdmlkZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lQ29udHJvbHNUaW1lRGl2aWRlckpzKTtcblxudmFyIF90aW1lQ29udHJvbHNSZW1haW5pbmdUaW1lRGlzcGxheUpzID0gX2RlcmVxXygnLi90aW1lLWNvbnRyb2xzL3JlbWFpbmluZy10aW1lLWRpc3BsYXkuanMnKTtcblxudmFyIF90aW1lQ29udHJvbHNSZW1haW5pbmdUaW1lRGlzcGxheUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVDb250cm9sc1JlbWFpbmluZ1RpbWVEaXNwbGF5SnMpO1xuXG52YXIgX2xpdmVEaXNwbGF5SnMgPSBfZGVyZXFfKCcuL2xpdmUtZGlzcGxheS5qcycpO1xuXG52YXIgX2xpdmVEaXNwbGF5SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGl2ZURpc3BsYXlKcyk7XG5cbnZhciBfcHJvZ3Jlc3NDb250cm9sUHJvZ3Jlc3NDb250cm9sSnMgPSBfZGVyZXFfKCcuL3Byb2dyZXNzLWNvbnRyb2wvcHJvZ3Jlc3MtY29udHJvbC5qcycpO1xuXG52YXIgX3Byb2dyZXNzQ29udHJvbFByb2dyZXNzQ29udHJvbEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb2dyZXNzQ29udHJvbFByb2dyZXNzQ29udHJvbEpzKTtcblxudmFyIF9mdWxsc2NyZWVuVG9nZ2xlSnMgPSBfZGVyZXFfKCcuL2Z1bGxzY3JlZW4tdG9nZ2xlLmpzJyk7XG5cbnZhciBfZnVsbHNjcmVlblRvZ2dsZUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Z1bGxzY3JlZW5Ub2dnbGVKcyk7XG5cbnZhciBfdm9sdW1lQ29udHJvbFZvbHVtZUNvbnRyb2xKcyA9IF9kZXJlcV8oJy4vdm9sdW1lLWNvbnRyb2wvdm9sdW1lLWNvbnRyb2wuanMnKTtcblxudmFyIF92b2x1bWVDb250cm9sVm9sdW1lQ29udHJvbEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZvbHVtZUNvbnRyb2xWb2x1bWVDb250cm9sSnMpO1xuXG52YXIgX3ZvbHVtZU1lbnVCdXR0b25KcyA9IF9kZXJlcV8oJy4vdm9sdW1lLW1lbnUtYnV0dG9uLmpzJyk7XG5cbnZhciBfdm9sdW1lTWVudUJ1dHRvbkpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZvbHVtZU1lbnVCdXR0b25Kcyk7XG5cbnZhciBfbXV0ZVRvZ2dsZUpzID0gX2RlcmVxXygnLi9tdXRlLXRvZ2dsZS5qcycpO1xuXG52YXIgX211dGVUb2dnbGVKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tdXRlVG9nZ2xlSnMpO1xuXG52YXIgX3RleHRUcmFja0NvbnRyb2xzQ2hhcHRlcnNCdXR0b25KcyA9IF9kZXJlcV8oJy4vdGV4dC10cmFjay1jb250cm9scy9jaGFwdGVycy1idXR0b24uanMnKTtcblxudmFyIF90ZXh0VHJhY2tDb250cm9sc0NoYXB0ZXJzQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrQ29udHJvbHNDaGFwdGVyc0J1dHRvbkpzKTtcblxudmFyIF90ZXh0VHJhY2tDb250cm9sc0Rlc2NyaXB0aW9uc0J1dHRvbkpzID0gX2RlcmVxXygnLi90ZXh0LXRyYWNrLWNvbnRyb2xzL2Rlc2NyaXB0aW9ucy1idXR0b24uanMnKTtcblxudmFyIF90ZXh0VHJhY2tDb250cm9sc0Rlc2NyaXB0aW9uc0J1dHRvbkpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHRUcmFja0NvbnRyb2xzRGVzY3JpcHRpb25zQnV0dG9uSnMpO1xuXG52YXIgX3RleHRUcmFja0NvbnRyb2xzU3VidGl0bGVzQnV0dG9uSnMgPSBfZGVyZXFfKCcuL3RleHQtdHJhY2stY29udHJvbHMvc3VidGl0bGVzLWJ1dHRvbi5qcycpO1xuXG52YXIgX3RleHRUcmFja0NvbnRyb2xzU3VidGl0bGVzQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrQ29udHJvbHNTdWJ0aXRsZXNCdXR0b25Kcyk7XG5cbnZhciBfdGV4dFRyYWNrQ29udHJvbHNDYXB0aW9uc0J1dHRvbkpzID0gX2RlcmVxXygnLi90ZXh0LXRyYWNrLWNvbnRyb2xzL2NhcHRpb25zLWJ1dHRvbi5qcycpO1xuXG52YXIgX3RleHRUcmFja0NvbnRyb2xzQ2FwdGlvbnNCdXR0b25KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0VHJhY2tDb250cm9sc0NhcHRpb25zQnV0dG9uSnMpO1xuXG52YXIgX2F1ZGlvVHJhY2tDb250cm9sc0F1ZGlvVHJhY2tCdXR0b25KcyA9IF9kZXJlcV8oJy4vYXVkaW8tdHJhY2stY29udHJvbHMvYXVkaW8tdHJhY2stYnV0dG9uLmpzJyk7XG5cbnZhciBfYXVkaW9UcmFja0NvbnRyb2xzQXVkaW9UcmFja0J1dHRvbkpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F1ZGlvVHJhY2tDb250cm9sc0F1ZGlvVHJhY2tCdXR0b25Kcyk7XG5cbnZhciBfcGxheWJhY2tSYXRlTWVudVBsYXliYWNrUmF0ZU1lbnVCdXR0b25KcyA9IF9kZXJlcV8oJy4vcGxheWJhY2stcmF0ZS1tZW51L3BsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanMnKTtcblxudmFyIF9wbGF5YmFja1JhdGVNZW51UGxheWJhY2tSYXRlTWVudUJ1dHRvbkpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXliYWNrUmF0ZU1lbnVQbGF5YmFja1JhdGVNZW51QnV0dG9uSnMpO1xuXG52YXIgX3NwYWNlckNvbnRyb2xzQ3VzdG9tQ29udHJvbFNwYWNlckpzID0gX2RlcmVxXygnLi9zcGFjZXItY29udHJvbHMvY3VzdG9tLWNvbnRyb2wtc3BhY2VyLmpzJyk7XG5cbnZhciBfc3BhY2VyQ29udHJvbHNDdXN0b21Db250cm9sU3BhY2VySnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3BhY2VyQ29udHJvbHNDdXN0b21Db250cm9sU3BhY2VySnMpO1xuXG4vKipcbiAqIENvbnRhaW5lciBvZiBtYWluIGNvbnRyb2xzXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgQ29udHJvbEJhclxuICovXG5cbnZhciBDb250cm9sQmFyID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhDb250cm9sQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sQmFyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sQmFyKTtcblxuICAgIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgQ29udHJvbEJhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtYmFyJyxcbiAgICAgIGRpcjogJ2x0cidcbiAgICB9LCB7XG4gICAgICAncm9sZSc6ICdncm91cCcgLy8gVGhlIGNvbnRyb2wgYmFyIGlzIGEgZ3JvdXAsIHNvIGl0IGNhbiBjb250YWluIG1lbnVpdGVtc1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBDb250cm9sQmFyO1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3BsYXlUb2dnbGUnLCAndm9sdW1lTWVudUJ1dHRvbicsICdjdXJyZW50VGltZURpc3BsYXknLCAndGltZURpdmlkZXInLCAnZHVyYXRpb25EaXNwbGF5JywgJ3Byb2dyZXNzQ29udHJvbCcsICdsaXZlRGlzcGxheScsICdyZW1haW5pbmdUaW1lRGlzcGxheScsICdjdXN0b21Db250cm9sU3BhY2VyJywgJ3BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCAnY2hhcHRlcnNCdXR0b24nLCAnZGVzY3JpcHRpb25zQnV0dG9uJywgJ3N1YnRpdGxlc0J1dHRvbicsICdjYXB0aW9uc0J1dHRvbicsICdhdWRpb1RyYWNrQnV0dG9uJywgJ2Z1bGxzY3JlZW5Ub2dnbGUnXVxufTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBDb250cm9sQmFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuL2F1ZGlvLXRyYWNrLWNvbnRyb2xzL2F1ZGlvLXRyYWNrLWJ1dHRvbi5qc1wiOjY4LFwiLi9mdWxsc2NyZWVuLXRvZ2dsZS5qc1wiOjcxLFwiLi9saXZlLWRpc3BsYXkuanNcIjo3MixcIi4vbXV0ZS10b2dnbGUuanNcIjo3MyxcIi4vcGxheS10b2dnbGUuanNcIjo3NCxcIi4vcGxheWJhY2stcmF0ZS1tZW51L3BsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanNcIjo3NSxcIi4vcHJvZ3Jlc3MtY29udHJvbC9wcm9ncmVzcy1jb250cm9sLmpzXCI6ODAsXCIuL3NwYWNlci1jb250cm9scy9jdXN0b20tY29udHJvbC1zcGFjZXIuanNcIjo4MyxcIi4vdGV4dC10cmFjay1jb250cm9scy9jYXB0aW9ucy1idXR0b24uanNcIjo4NixcIi4vdGV4dC10cmFjay1jb250cm9scy9jaGFwdGVycy1idXR0b24uanNcIjo4NyxcIi4vdGV4dC10cmFjay1jb250cm9scy9kZXNjcmlwdGlvbnMtYnV0dG9uLmpzXCI6ODksXCIuL3RleHQtdHJhY2stY29udHJvbHMvc3VidGl0bGVzLWJ1dHRvbi5qc1wiOjkxLFwiLi90aW1lLWNvbnRyb2xzL2N1cnJlbnQtdGltZS1kaXNwbGF5LmpzXCI6OTQsXCIuL3RpbWUtY29udHJvbHMvZHVyYXRpb24tZGlzcGxheS5qc1wiOjk1LFwiLi90aW1lLWNvbnRyb2xzL3JlbWFpbmluZy10aW1lLWRpc3BsYXkuanNcIjo5NixcIi4vdGltZS1jb250cm9scy90aW1lLWRpdmlkZXIuanNcIjo5NyxcIi4vdm9sdW1lLWNvbnRyb2wvdm9sdW1lLWNvbnRyb2wuanNcIjoxMDAsXCIuL3ZvbHVtZS1tZW51LWJ1dHRvbi5qc1wiOjEwMn1dLDcxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgZnVsbHNjcmVlbi10b2dnbGUuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2J1dHRvbkpzID0gX2RlcmVxXygnLi4vYnV0dG9uLmpzJyk7XG5cbnZhciBfYnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnV0dG9uSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKiBAY2xhc3MgRnVsbHNjcmVlblRvZ2dsZVxuICovXG5cbnZhciBGdWxsc2NyZWVuVG9nZ2xlID0gKGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIF9pbmhlcml0cyhGdWxsc2NyZWVuVG9nZ2xlLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBGdWxsc2NyZWVuVG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGdWxsc2NyZWVuVG9nZ2xlKTtcblxuICAgIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMub24ocGxheWVyLCAnZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIGNsYXNzIG5hbWVcbiAgICogQG1ldGhvZCBidWlsZENTU0NsYXNzXG4gICAqL1xuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWZ1bGxzY3JlZW4tY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIEZ1bGxzY3JlZW5jaGFuZ2Ugb24gdGhlIGNvbXBvbmVudCBhbmQgY2hhbmdlIGNvbnRyb2wgdGV4dCBhY2NvcmRpbmdseVxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VcbiAgICovXG5cbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayBmb3IgZnVsbCBzY3JlZW5cbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBGdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGdWxsc2NyZWVuVG9nZ2xlO1xufSkoX2J1dHRvbkpzMlsnZGVmYXVsdCddKTtcblxuRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0Z1bGxzY3JlZW4nO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0Z1bGxzY3JlZW5Ub2dnbGUnLCBGdWxsc2NyZWVuVG9nZ2xlKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEZ1bGxzY3JlZW5Ub2dnbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi9idXR0b24uanNcIjo2NCxcIi4uL2NvbXBvbmVudC5qc1wiOjY3fV0sNzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBsaXZlLWRpc3BsYXkuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudCA9IF9kZXJlcV8oJy4uL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG52YXIgX3V0aWxzRG9tSnMgPSBfZGVyZXFfKCcuLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgbGl2ZSBpbmRpY2F0b3JcbiAqIFRPRE8gLSBGdXR1cmUgbWFrZSBpdCBjbGljayB0byBzbmFwIHRvIGxpdmVcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBMaXZlRGlzcGxheVxuICovXG5cbnZhciBMaXZlRGlzcGxheSA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTGl2ZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpdmVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaXZlRGlzcGxheSk7XG5cbiAgICBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlU2hvd2luZygpO1xuICAgIHRoaXMub24odGhpcy5wbGF5ZXIoKSwgJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy51cGRhdGVTaG93aW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IERvbS5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSgnU3RyZWFtIFR5cGUnKSArICc8L3NwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xJVkUnKVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVNob3dpbmcgPSBmdW5jdGlvbiB1cGRhdGVTaG93aW5nKCkge1xuICAgIGlmICh0aGlzLnBsYXllcigpLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMaXZlRGlzcGxheTtcbn0pKF9jb21wb25lbnQyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50MlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdMaXZlRGlzcGxheScsIExpdmVEaXNwbGF5KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExpdmVEaXNwbGF5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50XCI6NjcsXCIuLi91dGlscy9kb20uanNcIjoxNDJ9XSw3MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIG11dGUtdG9nZ2xlLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9idXR0b24gPSBfZGVyZXFfKCcuLi9idXR0b24nKTtcblxudmFyIF9idXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnV0dG9uKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb21wb25lbnQnKTtcblxudmFyIF9jb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50KTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbi8qKlxuICogQSBidXR0b24gY29tcG9uZW50IGZvciBtdXRpbmcgdGhlIGF1ZGlvXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgQnV0dG9uXG4gKiBAY2xhc3MgTXV0ZVRvZ2dsZVxuICovXG5cbnZhciBNdXRlVG9nZ2xlID0gKGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIF9pbmhlcml0cyhNdXRlVG9nZ2xlLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBNdXRlVG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdXRlVG9nZ2xlKTtcblxuICAgIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd2b2x1bWVjaGFuZ2UnLCB0aGlzLnVwZGF0ZSk7XG5cbiAgICAvLyBoaWRlIG11dGUgdG9nZ2xlIGlmIHRoZSBjdXJyZW50IHRlY2ggZG9lc24ndCBzdXBwb3J0IHZvbHVtZSBjb250cm9sXG4gICAgaWYgKHBsYXllci50ZWNoXyAmJiBwbGF5ZXIudGVjaF9bJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cblxuICAgIHRoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy51cGRhdGUoKTsgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIGJ1dHRvbiB0byBhY2NvdW50IGZvciBhIGRlZmF1bHQgbXV0ZWQgc3RhdGUuXG5cbiAgICAgIGlmIChwbGF5ZXIudGVjaF9bJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIGNsYXNzIG5hbWVcbiAgICogQG1ldGhvZCBidWlsZENTU0NsYXNzXG4gICAqL1xuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLW11dGUtY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2sgb24gbXV0ZVxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAqL1xuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLm11dGVkKHRoaXMucGxheWVyXy5tdXRlZCgpID8gZmFsc2UgOiB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHZvbHVtZVxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKi9cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKSxcbiAgICAgICAgbGV2ZWwgPSAzO1xuXG4gICAgaWYgKHZvbCA9PT0gMCB8fCB0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC4zMykge1xuICAgICAgbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xuICAgICAgbGV2ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIERvbid0IHJld3JpdGUgdGhlIGJ1dHRvbiB0ZXh0IGlmIHRoZSBhY3R1YWwgdGV4dCBkb2Vzbid0IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNhdXNlcyB1bm5lY2Vzc2FyeSBhbmQgY29uZnVzaW5nIGluZm9ybWF0aW9uIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB2b2x1bWUgbGV2ZWwgaXMgY2hhbmdlZC5cbiAgICB2YXIgdG9NdXRlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAnVW5tdXRlJyA6ICdNdXRlJztcbiAgICBpZiAodGhpcy5jb250cm9sVGV4dCgpICE9PSB0b011dGUpIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQodG9NdXRlKTtcbiAgICB9XG5cbiAgICAvKiBUT0RPIGltcHJvdmUgbXV0ZWQgaWNvbiBjbGFzc2VzICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIERvbS5yZW1vdmVFbENsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgaSk7XG4gICAgfVxuICAgIERvbS5hZGRFbENsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgbGV2ZWwpO1xuICB9O1xuXG4gIHJldHVybiBNdXRlVG9nZ2xlO1xufSkoX2J1dHRvbjJbJ2RlZmF1bHQnXSk7XG5cbk11dGVUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdNdXRlJztcblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnTXV0ZVRvZ2dsZScsIE11dGVUb2dnbGUpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gTXV0ZVRvZ2dsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2J1dHRvblwiOjY0LFwiLi4vY29tcG9uZW50XCI6NjcsXCIuLi91dGlscy9kb20uanNcIjoxNDJ9XSw3NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHBsYXktdG9nZ2xlLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9idXR0b25KcyA9IF9kZXJlcV8oJy4uL2J1dHRvbi5qcycpO1xuXG52YXIgX2J1dHRvbkpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1dHRvbkpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxuLyoqXG4gKiBCdXR0b24gdG8gdG9nZ2xlIGJldHdlZW4gcGxheSBhbmQgcGF1c2VcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqIEBjbGFzcyBQbGF5VG9nZ2xlXG4gKi9cblxudmFyIFBsYXlUb2dnbGUgPSAoZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgX2luaGVyaXRzKFBsYXlUb2dnbGUsIF9CdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFBsYXlUb2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlUb2dnbGUpO1xuXG4gICAgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9uKHBsYXllciwgJ3BsYXknLCB0aGlzLmhhbmRsZVBsYXkpO1xuICAgIHRoaXMub24ocGxheWVyLCAncGF1c2UnLCB0aGlzLmhhbmRsZVBhdXNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICovXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGljayB0byB0b2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZVxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAqL1xuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1wbGF5aW5nIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZVBsYXlcbiAgICovXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGxheSA9IGZ1bmN0aW9uIGhhbmRsZVBsYXkoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5jb250cm9sVGV4dCgnUGF1c2UnKTsgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlBhdXNlXCJcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtcGF1c2VkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZVBhdXNlXG4gICAqL1xuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVBhdXNlID0gZnVuY3Rpb24gaGFuZGxlUGF1c2UoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5jb250cm9sVGV4dCgnUGxheScpOyAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGxheVwiXG4gIH07XG5cbiAgcmV0dXJuIFBsYXlUb2dnbGU7XG59KShfYnV0dG9uSnMyWydkZWZhdWx0J10pO1xuXG5QbGF5VG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheSc7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnUGxheVRvZ2dsZScsIFBsYXlUb2dnbGUpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gUGxheVRvZ2dsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2J1dHRvbi5qc1wiOjY0LFwiLi4vY29tcG9uZW50LmpzXCI6Njd9XSw3NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX21lbnVNZW51QnV0dG9uSnMgPSBfZGVyZXFfKCcuLi8uLi9tZW51L21lbnUtYnV0dG9uLmpzJyk7XG5cbnZhciBfbWVudU1lbnVCdXR0b25KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW51TWVudUJ1dHRvbkpzKTtcblxudmFyIF9tZW51TWVudUpzID0gX2RlcmVxXygnLi4vLi4vbWVudS9tZW51LmpzJyk7XG5cbnZhciBfbWVudU1lbnVKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW51TWVudUpzKTtcblxudmFyIF9wbGF5YmFja1JhdGVNZW51SXRlbUpzID0gX2RlcmVxXygnLi9wbGF5YmFjay1yYXRlLW1lbnUtaXRlbS5qcycpO1xuXG52YXIgX3BsYXliYWNrUmF0ZU1lbnVJdGVtSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheWJhY2tSYXRlTWVudUl0ZW1Kcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfdXRpbHNEb21KcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2RvbS5qcycpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tSnMpO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSBwbGF5YmFjayByYXRlXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgTWVudUJ1dHRvblxuICogQGNsYXNzIFBsYXliYWNrUmF0ZU1lbnVCdXR0b25cbiAqL1xuXG52YXIgUGxheWJhY2tSYXRlTWVudUJ1dHRvbiA9IChmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgX2luaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVCdXR0b24sIF9NZW51QnV0dG9uKTtcblxuICBmdW5jdGlvbiBQbGF5YmFja1JhdGVNZW51QnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuICAgIF9NZW51QnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgdGhpcy51cGRhdGVWaXNpYmlsaXR5KTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCB0aGlzLnVwZGF0ZUxhYmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgZWwgPSBfTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMubGFiZWxFbF8gPSBEb20uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5YmFjay1yYXRlLXZhbHVlJyxcbiAgICAgIGlubmVySFRNTDogMS4wXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsRWxfKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIGNsYXNzIG5hbWVcbiAgICogQG1ldGhvZCBidWlsZENTU0NsYXNzXG4gICAqL1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXBsYXliYWNrLXJhdGUgJyArIF9NZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgcGxheWJhY2sgcmF0ZSBtZW51XG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9IE1lbnUgb2JqZWN0IHBvcHVsYXRlZCB3aXRoIGl0ZW1zXG4gICAqIEBtZXRob2QgY3JlYXRlTWVudVxuICAgKi9cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgbWVudSA9IG5ldyBfbWVudU1lbnVKczJbJ2RlZmF1bHQnXSh0aGlzLnBsYXllcigpKTtcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcblxuICAgIGlmIChyYXRlcykge1xuICAgICAgZm9yICh2YXIgaSA9IHJhdGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG1lbnUuYWRkQ2hpbGQobmV3IF9wbGF5YmFja1JhdGVNZW51SXRlbUpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyKCksIHsgJ3JhdGUnOiByYXRlc1tpXSArICd4JyB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVBUklBQXR0cmlidXRlc1xuICAgKi9cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgIC8vIEN1cnJlbnQgcGxheWJhY2sgcmF0ZVxuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1lbnUgaXRlbSBjbGlja1xuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAqL1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgLy8gc2VsZWN0IG5leHQgcmF0ZSBvcHRpb25cbiAgICB2YXIgY3VycmVudFJhdGUgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgLy8gdGhpcyB3aWxsIHNlbGVjdCBmaXJzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgIHZhciBuZXdSYXRlID0gcmF0ZXNbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJhdGVzW2ldID4gY3VycmVudFJhdGUpIHtcbiAgICAgICAgbmV3UmF0ZSA9IHJhdGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUobmV3UmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUG9zc2libGUgcGxheWJhY2sgcmF0ZXNcbiAgICogQG1ldGhvZCBwbGF5YmFja1JhdGVzXG4gICAqL1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZXMgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfWydwbGF5YmFja1JhdGVzJ10gfHwgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zICYmIHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9uc1sncGxheWJhY2tSYXRlcyddO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBwbGF5YmFjayByYXRlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHRlY2hcbiAgICogYW5kIGFuIGFycmF5IG9mIHBsYXliYWNrIHJhdGVzIGV4aXN0c1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGNoYW5naW5nIHBsYXliYWNrIHJhdGUgaXMgc3VwcG9ydGVkXG4gICAqIEBtZXRob2QgcGxheWJhY2tSYXRlU3VwcG9ydGVkXG4gICAqL1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIHBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddICYmIHRoaXMucGxheWJhY2tSYXRlcygpICYmIHRoaXMucGxheWJhY2tSYXRlcygpLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgcGxheWJhY2sgcmF0ZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm8gcGxheWJhY2sgcmF0ZSBvcHRpb25zIHRvIHNlbGVjdFxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVZpc2liaWxpdHlcbiAgICovXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGJ1dHRvbiBsYWJlbCB3aGVuIHJhdGUgY2hhbmdlZFxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZUxhYmVsXG4gICAqL1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlTGFiZWwoKSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMubGFiZWxFbF8uaW5uZXJIVE1MID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSArICd4JztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XG59KShfbWVudU1lbnVCdXR0b25KczJbJ2RlZmF1bHQnXSk7XG5cblBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5YmFjayBSYXRlJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51QnV0dG9uJywgUGxheWJhY2tSYXRlTWVudUJ1dHRvbik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBQbGF5YmFja1JhdGVNZW51QnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi9tZW51L21lbnUtYnV0dG9uLmpzXCI6MTA5LFwiLi4vLi4vbWVudS9tZW51LmpzXCI6MTExLFwiLi4vLi4vdXRpbHMvZG9tLmpzXCI6MTQyLFwiLi9wbGF5YmFjay1yYXRlLW1lbnUtaXRlbS5qc1wiOjc2fV0sNzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBwbGF5YmFjay1yYXRlLW1lbnUtaXRlbS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbWVudU1lbnVJdGVtSnMgPSBfZGVyZXFfKCcuLi8uLi9tZW51L21lbnUtaXRlbS5qcycpO1xuXG52YXIgX21lbnVNZW51SXRlbUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVNZW51SXRlbUpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIHBsYXliYWNrIHJhdGVcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICogQGNsYXNzIFBsYXliYWNrUmF0ZU1lbnVJdGVtXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVJdGVtID0gKGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgX2luaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIGZ1bmN0aW9uIFBsYXliYWNrUmF0ZU1lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XG5cbiAgICB2YXIgbGFiZWwgPSBvcHRpb25zWydyYXRlJ107XG4gICAgdmFyIHJhdGUgPSBwYXJzZUZsb2F0KGxhYmVsLCAxMCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zWydsYWJlbCddID0gbGFiZWw7XG4gICAgb3B0aW9uc1snc2VsZWN0ZWQnXSA9IHJhdGUgPT09IDE7XG4gICAgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnJhdGUgPSByYXRlO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdyYXRlY2hhbmdlJywgdGhpcy51cGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGljayBvbiBtZW51IGl0ZW1cbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBQbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUodGhpcy5yYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHBsYXliYWNrIHJhdGUgd2l0aCBzZWxlY3RlZCByYXRlXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqL1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51SXRlbTtcbn0pKF9tZW51TWVudUl0ZW1KczJbJ2RlZmF1bHQnXSk7XG5cblBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS5jb250ZW50RWxUeXBlID0gJ2J1dHRvbic7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUl0ZW0nLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBQbGF5YmFja1JhdGVNZW51SXRlbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vLi4vbWVudS9tZW51LWl0ZW0uanNcIjoxMTB9XSw3NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGxvYWQtcHJvZ3Jlc3MtYmFyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbi8qKlxuICogU2hvd3MgbG9hZCBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIExvYWRQcm9ncmVzc0JhclxuICovXG5cbnZhciBMb2FkUHJvZ3Jlc3NCYXIgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExvYWRQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9hZFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkUHJvZ3Jlc3NCYXIpO1xuXG4gICAgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdwcm9ncmVzcycsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZC1wcm9ncmVzcycsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48c3Bhbj4nICsgdGhpcy5sb2NhbGl6ZSgnTG9hZGVkJykgKyAnPC9zcGFuPjogMCU8L3NwYW4+J1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqL1xuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMucGxheWVyXy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHZhciBidWZmZXJlZEVuZCA9IHRoaXMucGxheWVyXy5idWZmZXJlZEVuZCgpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZWxfLmNoaWxkcmVuO1xuXG4gICAgLy8gZ2V0IHRoZSBwZXJjZW50IHdpZHRoIG9mIGEgdGltZSBjb21wYXJlZCB0byB0aGUgdG90YWwgZW5kXG4gICAgdmFyIHBlcmNlbnRpZnkgPSBmdW5jdGlvbiBwZXJjZW50aWZ5KHRpbWUsIGVuZCkge1xuICAgICAgdmFyIHBlcmNlbnQgPSB0aW1lIC8gZW5kIHx8IDA7IC8vIG5vIE5hTlxuICAgICAgcmV0dXJuIChwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudCkgKiAxMDAgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIHZhciBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoRG9tLmNyZWF0ZUVsKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHBlcmNlbnQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXIgKGJ1ZmZlcmVkRW5kKVxuICAgICAgcGFydC5zdHlsZS5sZWZ0ID0gcGVyY2VudGlmeShzdGFydCwgYnVmZmVyZWRFbmQpO1xuICAgICAgcGFydC5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoZW5kIC0gc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW51c2VkIGJ1ZmZlcmVkIHJhbmdlIGVsZW1lbnRzXG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgaS0tKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChjaGlsZHJlbltpIC0gMV0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTG9hZFByb2dyZXNzQmFyO1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdMb2FkUHJvZ3Jlc3NCYXInLCBMb2FkUHJvZ3Jlc3NCYXIpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gTG9hZFByb2dyZXNzQmFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi91dGlscy9kb20uanNcIjoxNDJ9XSw3ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIG1vdXNlLXRpbWUtZGlzcGxheS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gX2RlcmVxXygnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3V0aWxzRG9tSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF91dGlsc0Zvcm1hdFRpbWVKcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzJyk7XG5cbnZhciBfdXRpbHNGb3JtYXRUaW1lSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNGb3JtYXRUaW1lSnMpO1xuXG52YXIgX2xvZGFzaENvbXBhdEZ1bmN0aW9uVGhyb3R0bGUgPSBfZGVyZXFfKCdsb2Rhc2gtY29tcGF0L2Z1bmN0aW9uL3Rocm90dGxlJyk7XG5cbnZhciBfbG9kYXNoQ29tcGF0RnVuY3Rpb25UaHJvdHRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hDb21wYXRGdW5jdGlvblRocm90dGxlKTtcblxuLyoqXG4gKiBUaGUgTW91c2UgVGltZSBEaXNwbGF5IGNvbXBvbmVudCBzaG93cyB0aGUgdGltZSB5b3Ugd2lsbCBzZWVrIHRvXG4gKiB3aGVuIGhvdmVyaW5nIG92ZXIgdGhlIHByb2dyZXNzIGJhclxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIE1vdXNlVGltZURpc3BsYXlcbiAqL1xuXG52YXIgTW91c2VUaW1lRGlzcGxheSA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTW91c2VUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW91c2VUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdXNlVGltZURpc3BsYXkpO1xuXG4gICAgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5wbGF5ZXJPcHRpb25zICYmIG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyICYmIG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyLnByb2dyZXNzQ29udHJvbCAmJiBvcHRpb25zLnBsYXllck9wdGlvbnMuY29udHJvbEJhci5wcm9ncmVzc0NvbnRyb2wua2VlcFRvb2x0aXBzSW5zaWRlKSB7XG4gICAgICB0aGlzLmtlZXBUb29sdGlwc0luc2lkZSA9IG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyLnByb2dyZXNzQ29udHJvbC5rZWVwVG9vbHRpcHNJbnNpZGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2VlcFRvb2x0aXBzSW5zaWRlKSB7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBEb20uY3JlYXRlRWwoJ2RpdicsIHsgY2xhc3NOYW1lOiAndmpzLXRpbWUtdG9vbHRpcCcgfSk7XG4gICAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1rZWVwLXRvb2x0aXBzLWluc2lkZScpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlKDAsIDApO1xuXG4gICAgcGxheWVyLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uKHBsYXllci5jb250cm9sQmFyLnByb2dyZXNzQ29udHJvbC5lbCgpLCAnbW91c2Vtb3ZlJywgX2xvZGFzaENvbXBhdEZ1bmN0aW9uVGhyb3R0bGUyWydkZWZhdWx0J10oRm4uYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKSwgMjUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1vdXNlLWRpc3BsYXknXG4gICAgfSk7XG4gIH07XG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIG5ld1RpbWUgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSAqIGR1cmF0aW9uO1xuICAgIHZhciBwb3NpdGlvbiA9IGV2ZW50LnBhZ2VYIC0gRG9tLmZpbmRFbFBvc2l0aW9uKHRoaXMuZWwoKS5wYXJlbnROb2RlKS5sZWZ0O1xuXG4gICAgdGhpcy51cGRhdGUobmV3VGltZSwgcG9zaXRpb24pO1xuICB9O1xuXG4gIE1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShuZXdUaW1lLCBwb3NpdGlvbikge1xuICAgIHZhciB0aW1lID0gX3V0aWxzRm9ybWF0VGltZUpzMlsnZGVmYXVsdCddKG5ld1RpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcblxuICAgIHRoaXMuZWwoKS5zdHlsZS5sZWZ0ID0gcG9zaXRpb24gKyAncHgnO1xuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2RhdGEtY3VycmVudC10aW1lJywgdGltZSk7XG5cbiAgICBpZiAodGhpcy5rZWVwVG9vbHRpcHNJbnNpZGUpIHtcbiAgICAgIHZhciBjbGFtcGVkUG9zaXRpb24gPSB0aGlzLmNsYW1wUG9zaXRpb25fKHBvc2l0aW9uKTtcbiAgICAgIHZhciBkaWZmZXJlbmNlID0gcG9zaXRpb24gLSBjbGFtcGVkUG9zaXRpb24gKyAxO1xuICAgICAgdmFyIHRvb2x0aXBXaWR0aCA9IHBhcnNlRmxvYXQoX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5nZXRDb21wdXRlZFN0eWxlKHRoaXMudG9vbHRpcCkud2lkdGgpO1xuICAgICAgdmFyIHRvb2x0aXBXaWR0aEhhbGYgPSB0b29sdGlwV2lkdGggLyAyO1xuXG4gICAgICB0aGlzLnRvb2x0aXAuaW5uZXJIVE1MID0gdGltZTtcbiAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5yaWdodCA9ICctJyArICh0b29sdGlwV2lkdGhIYWxmIC0gZGlmZmVyZW5jZSkgKyAncHgnO1xuICAgIH1cbiAgfTtcblxuICBNb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS5jYWxjdWxhdGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgcmV0dXJuIERvbS5nZXRQb2ludGVyUG9zaXRpb24odGhpcy5lbCgpLnBhcmVudE5vZGUsIGV2ZW50KS54O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHRha2VzIGluIGEgaG9yaXpvbnRhbCBwb3NpdGlvbiBmb3IgdGhlIGJhciBhbmQgcmV0dXJucyBhIGNsYW1wZWQgcG9zaXRpb24uXG4gICAqIENsYW1wZWQgcG9zaXRpb24gbWVhbnMgdGhhdCBpdCB3aWxsIGtlZXAgdGhlIHBvc2l0aW9uIGdyZWF0ZXIgdGhhbiBoYWxmIHRoZSB3aWR0aFxuICAgKiBvZiB0aGUgdG9vbHRpcCBhbmQgc21hbGxlciB0aGFuIHRoZSBwbGF5ZXIgd2lkdGggbWludXMgaGFsZiB0aGUgd2lkdGggbyB0aGUgdG9vbHRpcC5cbiAgICogSXQgd2lsbCBvbmx5IGNsYW1wIHRoZSBwb3NpdGlvbiBpZiBga2VlcFRvb2x0aXBzSW5zaWRlYCBvcHRpb24gaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIHRoZSBiYXIgd2FudHMgdG8gYmVcbiAgICogQHJldHVybiB7TnVtYmVyfSBuZXdQb3NpdGlvbiB0aGUgKHBvdGVudGlhbGx5KSBjbGFtcGVkIHBvc2l0aW9uXG4gICAqIEBtZXRob2QgY2xhbXBQb3NpdGlvbl9cbiAgICovXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuY2xhbXBQb3NpdGlvbl8gPSBmdW5jdGlvbiBjbGFtcFBvc2l0aW9uXyhwb3NpdGlvbikge1xuICAgIGlmICghdGhpcy5rZWVwVG9vbHRpcHNJbnNpZGUpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgcGxheWVyV2lkdGggPSBwYXJzZUZsb2F0KF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnBsYXllcigpLmVsKCkpLndpZHRoKTtcbiAgICB2YXIgdG9vbHRpcFdpZHRoID0gcGFyc2VGbG9hdChfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmdldENvbXB1dGVkU3R5bGUodGhpcy50b29sdGlwKS53aWR0aCk7XG4gICAgdmFyIHRvb2x0aXBXaWR0aEhhbGYgPSB0b29sdGlwV2lkdGggLyAyO1xuICAgIHZhciBhY3R1YWxQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uIDwgdG9vbHRpcFdpZHRoSGFsZikge1xuICAgICAgYWN0dWFsUG9zaXRpb24gPSBNYXRoLmNlaWwodG9vbHRpcFdpZHRoSGFsZik7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHBsYXllcldpZHRoIC0gdG9vbHRpcFdpZHRoSGFsZikge1xuICAgICAgYWN0dWFsUG9zaXRpb24gPSBNYXRoLmZsb29yKHBsYXllcldpZHRoIC0gdG9vbHRpcFdpZHRoSGFsZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdHVhbFBvc2l0aW9uO1xuICB9O1xuXG4gIHJldHVybiBNb3VzZVRpbWVEaXNwbGF5O1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdNb3VzZVRpbWVEaXNwbGF5JywgTW91c2VUaW1lRGlzcGxheSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBNb3VzZVRpbWVEaXNwbGF5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi91dGlscy9kb20uanNcIjoxNDIsXCIuLi8uLi91dGlscy9mbi5qc1wiOjE0NCxcIi4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzXCI6MTQ1LFwiZ2xvYmFsL3dpbmRvd1wiOjIsXCJsb2Rhc2gtY29tcGF0L2Z1bmN0aW9uL3Rocm90dGxlXCI6N31dLDc5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgcGxheS1wcm9ncmVzcy1iYXIuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG52YXIgX3V0aWxzRG9tSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0Zvcm1hdFRpbWVKcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzJyk7XG5cbnZhciBfdXRpbHNGb3JtYXRUaW1lSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNGb3JtYXRUaW1lSnMpO1xuXG4vKipcbiAqIFNob3dzIHBsYXkgcHJvZ3Jlc3NcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBQbGF5UHJvZ3Jlc3NCYXJcbiAqL1xuXG52YXIgUGxheVByb2dyZXNzQmFyID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQbGF5UHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBsYXlQcm9ncmVzc0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheVByb2dyZXNzQmFyKTtcblxuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlRGF0YUF0dHIoKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCB0aGlzLnVwZGF0ZURhdGFBdHRyKTtcbiAgICBwbGF5ZXIucmVhZHkoRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURhdGFBdHRyKSk7XG5cbiAgICBpZiAob3B0aW9ucy5wbGF5ZXJPcHRpb25zICYmIG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyICYmIG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyLnByb2dyZXNzQ29udHJvbCAmJiBvcHRpb25zLnBsYXllck9wdGlvbnMuY29udHJvbEJhci5wcm9ncmVzc0NvbnRyb2wua2VlcFRvb2x0aXBzSW5zaWRlKSB7XG4gICAgICB0aGlzLmtlZXBUb29sdGlwc0luc2lkZSA9IG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyLnByb2dyZXNzQ29udHJvbC5rZWVwVG9vbHRpcHNJbnNpZGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2VlcFRvb2x0aXBzSW5zaWRlKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMta2VlcC10b29sdGlwcy1pbnNpZGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXktcHJvZ3Jlc3MgdmpzLXNsaWRlci1iYXInLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzJykgKyAnPC9zcGFuPjogMCU8L3NwYW4+J1xuICAgIH0pO1xuICB9O1xuXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlRGF0YUF0dHIgPSBmdW5jdGlvbiB1cGRhdGVEYXRhQXR0cigpIHtcbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdkYXRhLWN1cnJlbnQtdGltZScsIF91dGlsc0Zvcm1hdFRpbWVKczJbJ2RlZmF1bHQnXSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5UHJvZ3Jlc3NCYXI7XG59KShfY29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXlQcm9ncmVzc0JhcicsIFBsYXlQcm9ncmVzc0Jhcik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBQbGF5UHJvZ3Jlc3NCYXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2NyxcIi4uLy4uL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4uLy4uL3V0aWxzL2ZuLmpzXCI6MTQ0LFwiLi4vLi4vdXRpbHMvZm9ybWF0LXRpbWUuanNcIjoxNDV9XSw4MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHByb2dyZXNzLWNvbnRyb2wuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3NlZWtCYXJKcyA9IF9kZXJlcV8oJy4vc2Vlay1iYXIuanMnKTtcblxudmFyIF9zZWVrQmFySnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2Vla0JhckpzKTtcblxudmFyIF9tb3VzZVRpbWVEaXNwbGF5SnMgPSBfZGVyZXFfKCcuL21vdXNlLXRpbWUtZGlzcGxheS5qcycpO1xuXG52YXIgX21vdXNlVGltZURpc3BsYXlKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb3VzZVRpbWVEaXNwbGF5SnMpO1xuXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIFByb2dyZXNzQ29udHJvbFxuICovXG5cbnZhciBQcm9ncmVzc0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb2dyZXNzQ29udHJvbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUHJvZ3Jlc3NDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wcm9ncmVzcy1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQcm9ncmVzc0NvbnRyb2w7XG59KShfY29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFByb2dyZXNzQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi9tb3VzZS10aW1lLWRpc3BsYXkuanNcIjo3OCxcIi4vc2Vlay1iYXIuanNcIjo4MX1dLDgxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgc2Vlay1iYXIuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF9zbGlkZXJTbGlkZXJKcyA9IF9kZXJlcV8oJy4uLy4uL3NsaWRlci9zbGlkZXIuanMnKTtcblxudmFyIF9zbGlkZXJTbGlkZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGlkZXJTbGlkZXJKcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfbG9hZFByb2dyZXNzQmFySnMgPSBfZGVyZXFfKCcuL2xvYWQtcHJvZ3Jlc3MtYmFyLmpzJyk7XG5cbnZhciBfbG9hZFByb2dyZXNzQmFySnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9hZFByb2dyZXNzQmFySnMpO1xuXG52YXIgX3BsYXlQcm9ncmVzc0JhckpzID0gX2RlcmVxXygnLi9wbGF5LXByb2dyZXNzLWJhci5qcycpO1xuXG52YXIgX3BsYXlQcm9ncmVzc0JhckpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXlQcm9ncmVzc0JhckpzKTtcblxudmFyIF90b29sdGlwUHJvZ3Jlc3NCYXJKcyA9IF9kZXJlcV8oJy4vdG9vbHRpcC1wcm9ncmVzcy1iYXIuanMnKTtcblxudmFyIF90b29sdGlwUHJvZ3Jlc3NCYXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b29sdGlwUHJvZ3Jlc3NCYXJKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNGb3JtYXRUaW1lSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qcycpO1xuXG52YXIgX3V0aWxzRm9ybWF0VGltZUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzRm9ybWF0VGltZUpzKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QuYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbi8qKlxuICogU2VlayBCYXIgYW5kIGhvbGRlciBmb3IgdGhlIHByb2dyZXNzIGJhcnNcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqIEBjbGFzcyBTZWVrQmFyXG4gKi9cblxudmFyIFNlZWtCYXIgPSAoZnVuY3Rpb24gKF9TbGlkZXIpIHtcbiAgX2luaGVyaXRzKFNlZWtCYXIsIF9TbGlkZXIpO1xuXG4gIGZ1bmN0aW9uIFNlZWtCYXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlZWtCYXIpO1xuXG4gICAgX1NsaWRlci5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVQcm9ncmVzcyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdlbmRlZCcsIHRoaXMudXBkYXRlUHJvZ3Jlc3MpO1xuICAgIHBsYXllci5yZWFkeShGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlUHJvZ3Jlc3MpKTtcblxuICAgIGlmIChvcHRpb25zLnBsYXllck9wdGlvbnMgJiYgb3B0aW9ucy5wbGF5ZXJPcHRpb25zLmNvbnRyb2xCYXIgJiYgb3B0aW9ucy5wbGF5ZXJPcHRpb25zLmNvbnRyb2xCYXIucHJvZ3Jlc3NDb250cm9sICYmIG9wdGlvbnMucGxheWVyT3B0aW9ucy5jb250cm9sQmFyLnByb2dyZXNzQ29udHJvbC5rZWVwVG9vbHRpcHNJbnNpZGUpIHtcbiAgICAgIHRoaXMua2VlcFRvb2x0aXBzSW5zaWRlID0gb3B0aW9ucy5wbGF5ZXJPcHRpb25zLmNvbnRyb2xCYXIucHJvZ3Jlc3NDb250cm9sLmtlZXBUb29sdGlwc0luc2lkZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZWVwVG9vbHRpcHNJbnNpZGUpIHtcbiAgICAgIHRoaXMudG9vbHRpcFByb2dyZXNzQmFyID0gdGhpcy5hZGRDaGlsZCgnVG9vbHRpcFByb2dyZXNzQmFyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBTZWVrQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtaG9sZGVyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogJ3Byb2dyZXNzIGJhcidcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIEFSSUEgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlQVJJQUF0dHJpYnV0ZXNcbiAgICovXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUudXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcygpIHtcbiAgICB0aGlzLnVwZGF0ZUFyaWFBdHRyaWJ1dGVzKHRoaXMuZWxfKTtcblxuICAgIGlmICh0aGlzLmtlZXBUb29sdGlwc0luc2lkZSkge1xuICAgICAgdGhpcy51cGRhdGVBcmlhQXR0cmlidXRlcyh0aGlzLnRvb2x0aXBQcm9ncmVzc0Jhci5lbF8pO1xuICAgICAgdGhpcy50b29sdGlwUHJvZ3Jlc3NCYXIuZWxfLnN0eWxlLndpZHRoID0gdGhpcy5iYXIuZWxfLnN0eWxlLndpZHRoO1xuXG4gICAgICB2YXIgcGxheWVyV2lkdGggPSBwYXJzZUZsb2F0KF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnBsYXllcigpLmVsKCkpLndpZHRoKTtcbiAgICAgIHZhciB0b29sdGlwV2lkdGggPSBwYXJzZUZsb2F0KF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnRvb2x0aXBQcm9ncmVzc0Jhci50b29sdGlwKS53aWR0aCk7XG4gICAgICB2YXIgdG9vbHRpcFN0eWxlID0gdGhpcy50b29sdGlwUHJvZ3Jlc3NCYXIuZWwoKS5zdHlsZTtcbiAgICAgIHRvb2x0aXBTdHlsZS5tYXhXaWR0aCA9IE1hdGguZmxvb3IocGxheWVyV2lkdGggLSB0b29sdGlwV2lkdGggLyAyKSArICdweCc7XG4gICAgICB0b29sdGlwU3R5bGUubWluV2lkdGggPSBNYXRoLmNlaWwodG9vbHRpcFdpZHRoIC8gMikgKyAncHgnO1xuICAgICAgdG9vbHRpcFN0eWxlLnJpZ2h0ID0gJy0nICsgdG9vbHRpcFdpZHRoIC8gMiArICdweCc7XG4gICAgfVxuICB9O1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLnVwZGF0ZUFyaWFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQXJpYUF0dHJpYnV0ZXMoZWwpIHtcbiAgICAvLyBBbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXG4gICAgdmFyIHRpbWUgPSB0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsICh0aGlzLmdldFBlcmNlbnQoKSAqIDEwMCkudG9GaXhlZCgyKSk7IC8vIG1hY2hpbmUgcmVhZGFibGUgdmFsdWUgb2YgcHJvZ3Jlc3MgYmFyIChwZXJjZW50YWdlIGNvbXBsZXRlKVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBfdXRpbHNGb3JtYXRUaW1lSnMyWydkZWZhdWx0J10odGltZSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpKTsgLy8gaHVtYW4gcmVhZGFibGUgdmFsdWUgb2YgcHJvZ3Jlc3MgYmFyICh0aW1lIGNvbXBsZXRlKVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcGVyY2VudGFnZSBvZiB2aWRlbyBwbGF5ZWRcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBQZXJjZW50YWdlIHBsYXllZFxuICAgKiBAbWV0aG9kIGdldFBlcmNlbnRcbiAgICovXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uIGdldFBlcmNlbnQoKSB7XG4gICAgdmFyIHBlcmNlbnQgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHJldHVybiBwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gc2VlayBiYXJcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVNb3VzZURvd25cbiAgICovXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyh0cnVlKTtcblxuICAgIHRoaXMudmlkZW9XYXNQbGF5aW5nID0gIXRoaXMucGxheWVyXy5wYXVzZWQoKTtcbiAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIG1vdmUgb24gc2VlayBiYXJcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVNb3VzZU1vdmVcbiAgICovXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIG5ld1RpbWUgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSAqIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHZpZGVvIGVuZCB3aGlsZSBzY3J1YmJpbmcuXG4gICAgaWYgKG5ld1RpbWUgPT09IHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICBuZXdUaW1lID0gbmV3VGltZSAtIDAuMTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbmV3IHRpbWUgKHRlbGwgcGxheWVyIHRvIHNlZWsgdG8gbmV3IHRpbWUpXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKG5ld1RpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgdXAgb24gc2VlayBiYXJcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVNb3VzZVVwXG4gICAqL1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKlxuICAgKiBAbWV0aG9kIHN0ZXBGb3J3YXJkXG4gICAqL1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgNSk7IC8vIG1vcmUgcXVpY2tseSBmYXN0IGZvcndhcmQgZm9yIGtleWJvYXJkLW9ubHkgdXNlcnNcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgcmV3aW5kIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gICAqXG4gICAqIEBtZXRob2Qgc3RlcEJhY2tcbiAgICovXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSA1KTsgLy8gbW9yZSBxdWlja2x5IHJld2luZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICB9O1xuXG4gIHJldHVybiBTZWVrQmFyO1xufSkoX3NsaWRlclNsaWRlckpzMlsnZGVmYXVsdCddKTtcblxuU2Vla0Jhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ2xvYWRQcm9ncmVzc0JhcicsICdtb3VzZVRpbWVEaXNwbGF5JywgJ3BsYXlQcm9ncmVzc0JhciddLFxuICAnYmFyTmFtZSc6ICdwbGF5UHJvZ3Jlc3NCYXInXG59O1xuXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBTZWVrQmFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi9zbGlkZXIvc2xpZGVyLmpzXCI6MTE5LFwiLi4vLi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qc1wiOjE0NSxcIi4vbG9hZC1wcm9ncmVzcy1iYXIuanNcIjo3NyxcIi4vcGxheS1wcm9ncmVzcy1iYXIuanNcIjo3OSxcIi4vdG9vbHRpcC1wcm9ncmVzcy1iYXIuanNcIjo4MixcImdsb2JhbC93aW5kb3dcIjoyLFwib2JqZWN0LmFzc2lnblwiOjQ1fV0sODI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBwbGF5LXByb2dyZXNzLWJhci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNEb21KcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2RvbS5qcycpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tSnMpO1xuXG52YXIgX3V0aWxzRm9ybWF0VGltZUpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZm9ybWF0LXRpbWUuanMnKTtcblxudmFyIF91dGlsc0Zvcm1hdFRpbWVKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0Zvcm1hdFRpbWVKcyk7XG5cbi8qKlxuICogU2hvd3MgcGxheSBwcm9ncmVzc1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIFBsYXlQcm9ncmVzc0JhclxuICovXG5cbnZhciBUb29sdGlwUHJvZ3Jlc3NCYXIgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRvb2x0aXBQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVG9vbHRpcFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwUHJvZ3Jlc3NCYXIpO1xuXG4gICAgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy51cGRhdGVEYXRhQXR0cigpO1xuICAgIHRoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIHRoaXMudXBkYXRlRGF0YUF0dHIpO1xuICAgIHBsYXllci5yZWFkeShGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGF0YUF0dHIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgVG9vbHRpcFByb2dyZXNzQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10b29sdGlwLXByb2dyZXNzLWJhciB2anMtc2xpZGVyLWJhcicsXG4gICAgICBpbm5lckhUTUw6ICc8ZGl2IGNsYXNzPVwidmpzLXRpbWUtdG9vbHRpcFwiPjwvZGl2PlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzJykgKyAnPC9zcGFuPjogMCU8L3NwYW4+J1xuICAgIH0pO1xuXG4gICAgdGhpcy50b29sdGlwID0gZWwucXVlcnlTZWxlY3RvcignLnZqcy10aW1lLXRvb2x0aXAnKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBUb29sdGlwUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnVwZGF0ZURhdGFBdHRyID0gZnVuY3Rpb24gdXBkYXRlRGF0YUF0dHIoKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gX3V0aWxzRm9ybWF0VGltZUpzMlsnZGVmYXVsdCddKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2RhdGEtY3VycmVudC10aW1lJywgZm9ybWF0dGVkVGltZSk7XG4gICAgdGhpcy50b29sdGlwLmlubmVySFRNTCA9IGZvcm1hdHRlZFRpbWU7XG4gIH07XG5cbiAgcmV0dXJuIFRvb2x0aXBQcm9ncmVzc0Jhcjtcbn0pKF9jb21wb25lbnRKczJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnVG9vbHRpcFByb2dyZXNzQmFyJywgVG9vbHRpcFByb2dyZXNzQmFyKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRvb2x0aXBQcm9ncmVzc0Jhcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vLi4vdXRpbHMvZG9tLmpzXCI6MTQyLFwiLi4vLi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qc1wiOjE0NX1dLDgzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgY3VzdG9tLWNvbnRyb2wtc3BhY2VyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9zcGFjZXJKcyA9IF9kZXJlcV8oJy4vc3BhY2VyLmpzJyk7XG5cbnZhciBfc3BhY2VySnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3BhY2VySnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG4vKipcbiAqIFNwYWNlciBzcGVjaWZpY2FsbHkgbWVhbnQgdG8gYmUgdXNlZCBhcyBhbiBpbnNlcnRpb24gcG9pbnQgZm9yIG5ldyBwbHVnaW5zLCBldGMuXG4gKlxuICogQGV4dGVuZHMgU3BhY2VyXG4gKiBAY2xhc3MgQ3VzdG9tQ29udHJvbFNwYWNlclxuICovXG5cbnZhciBDdXN0b21Db250cm9sU3BhY2VyID0gKGZ1bmN0aW9uIChfU3BhY2VyKSB7XG4gIF9pbmhlcml0cyhDdXN0b21Db250cm9sU3BhY2VyLCBfU3BhY2VyKTtcblxuICBmdW5jdGlvbiBDdXN0b21Db250cm9sU3BhY2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Db250cm9sU3BhY2VyKTtcblxuICAgIF9TcGFjZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICovXG5cbiAgQ3VzdG9tQ29udHJvbFNwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY3VzdG9tLWNvbnRyb2wtc3BhY2VyICcgKyBfU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBDdXN0b21Db250cm9sU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IF9TcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuXG4gICAgLy8gTm8tZmxleC90YWJsZS1jZWxsIG1vZGUgcmVxdWlyZXMgdGhlcmUgYmUgc29tZSBjb250ZW50XG4gICAgLy8gaW4gdGhlIGNlbGwgdG8gZmlsbCB0aGUgcmVtYWluaW5nIHNwYWNlIG9mIHRoZSB0YWJsZS5cbiAgICBlbC5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUNvbnRyb2xTcGFjZXI7XG59KShfc3BhY2VySnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0N1c3RvbUNvbnRyb2xTcGFjZXInLCBDdXN0b21Db250cm9sU3BhY2VyKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEN1c3RvbUNvbnRyb2xTcGFjZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2NyxcIi4vc3BhY2VyLmpzXCI6ODR9XSw4NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHNwYWNlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbi8qKlxuICogSnVzdCBhbiBlbXB0eSBzcGFjZXIgZWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGFwcGVuZCBwb2ludCBmb3IgcGx1Z2lucywgZXRjLlxuICogQWxzbyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBTcGFjZXJcbiAqL1xuXG52YXIgU3BhY2VyID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTcGFjZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNwYWNlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhY2VyKTtcblxuICAgIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICovXG5cbiAgU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zcGFjZXIgJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIFNwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTcGFjZXI7XG59KShfY29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ1NwYWNlcicsIFNwYWNlcik7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNwYWNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3fV0sODU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBjYXB0aW9uLXNldHRpbmdzLW1lbnUtaXRlbS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdGV4dFRyYWNrTWVudUl0ZW1KcyA9IF9kZXJlcV8oJy4vdGV4dC10cmFjay1tZW51LWl0ZW0uanMnKTtcblxudmFyIF90ZXh0VHJhY2tNZW51SXRlbUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHRUcmFja01lbnVJdGVtSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG4vKipcbiAqIFRoZSBtZW51IGl0ZW0gZm9yIGNhcHRpb24gdHJhY2sgc2V0dGluZ3MgbWVudVxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXG4gKiBAY2xhc3MgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0gPSAoZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xuICBfaW5oZXJpdHMoQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgZnVuY3Rpb24gQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKTtcblxuICAgIG9wdGlvbnNbJ3RyYWNrJ10gPSB7XG4gICAgICAna2luZCc6IG9wdGlvbnNbJ2tpbmQnXSxcbiAgICAgICdwbGF5ZXInOiBwbGF5ZXIsXG4gICAgICAnbGFiZWwnOiBvcHRpb25zWydraW5kJ10gKyAnIHNldHRpbmdzJyxcbiAgICAgICdzZWxlY3RhYmxlJzogZmFsc2UsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICAvLyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBoYXMgbm8gY29uY2VwdCBvZiAnc2VsZWN0ZWQnXG4gICAgb3B0aW9uc1snc2VsZWN0YWJsZSddID0gZmFsc2U7XG5cbiAgICBfVGV4dFRyYWNrTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy10ZXh0dHJhY2stc2V0dGluZ3MnKTtcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCcsIG9wZW5zICcgKyBvcHRpb25zWydraW5kJ10gKyAnIHNldHRpbmdzIGRpYWxvZycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGljayBvbiBtZW51IGl0ZW1cbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnBsYXllcigpLmdldENoaWxkKCd0ZXh0VHJhY2tTZXR0aW5ncycpLnNob3coKTtcbiAgICB0aGlzLnBsYXllcigpLmdldENoaWxkKCd0ZXh0VHJhY2tTZXR0aW5ncycpLmVsXy5mb2N1cygpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbTtcbn0pKF90ZXh0VHJhY2tNZW51SXRlbUpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbScsIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENhcHRpb25TZXR0aW5nc01lbnVJdGVtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzXCI6OTN9XSw4NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGNhcHRpb25zLWJ1dHRvbi5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMgPSBfZGVyZXFfKCcuL3RleHQtdHJhY2stYnV0dG9uLmpzJyk7XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrQnV0dG9uSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX2NhcHRpb25TZXR0aW5nc01lbnVJdGVtSnMgPSBfZGVyZXFfKCcuL2NhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzJyk7XG5cbnZhciBfY2FwdGlvblNldHRpbmdzTWVudUl0ZW1KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYXB0aW9uU2V0dGluZ3NNZW51SXRlbUpzKTtcblxuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9uc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXIgIFBsYXllciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKiBAY2xhc3MgQ2FwdGlvbnNCdXR0b25cbiAqL1xuXG52YXIgQ2FwdGlvbnNCdXR0b24gPSAoZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgX2luaGVyaXRzKENhcHRpb25zQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICBmdW5jdGlvbiBDYXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRpb25zQnV0dG9uKTtcblxuICAgIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2FwdGlvbnMgTWVudScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqIEBtZXRob2QgYnVpbGRDU1NDbGFzc1xuICAgKi9cblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2FwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjYXB0aW9uIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICovXG5cbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gMjtcbiAgICBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIGlmIG5hdGl2ZSwgdGhlbiB0aHJlc2hvbGQgaXMgMSBiZWNhdXNlIG5vIHNldHRpbmdzIGJ1dHRvblxuICAgIGlmICh0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF9bJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY2FwdGlvbiBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBtZW51IGl0ZW1zXG4gICAqIEBtZXRob2QgY3JlYXRlSXRlbXNcbiAgICovXG5cbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF9bJ2ZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyddKSkge1xuICAgICAgaXRlbXMucHVzaChuZXcgX2NhcHRpb25TZXR0aW5nc01lbnVJdGVtSnMyWydkZWZhdWx0J10odGhpcy5wbGF5ZXJfLCB7ICdraW5kJzogdGhpcy5raW5kXyB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uc0J1dHRvbjtcbn0pKF90ZXh0VHJhY2tCdXR0b25KczJbJ2RlZmF1bHQnXSk7XG5cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjYXB0aW9ucyc7XG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0NhcHRpb25zJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uc0J1dHRvbicsIENhcHRpb25zQnV0dG9uKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENhcHRpb25zQnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuL2NhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzXCI6ODUsXCIuL3RleHQtdHJhY2stYnV0dG9uLmpzXCI6OTJ9XSw4NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGNoYXB0ZXJzLWJ1dHRvbi5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMgPSBfZGVyZXFfKCcuL3RleHQtdHJhY2stYnV0dG9uLmpzJyk7XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrQnV0dG9uSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3RleHRUcmFja01lbnVJdGVtSnMgPSBfZGVyZXFfKCcuL3RleHQtdHJhY2stbWVudS1pdGVtLmpzJyk7XG5cbnZhciBfdGV4dFRyYWNrTWVudUl0ZW1KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0VHJhY2tNZW51SXRlbUpzKTtcblxudmFyIF9jaGFwdGVyc1RyYWNrTWVudUl0ZW1KcyA9IF9kZXJlcV8oJy4vY2hhcHRlcnMtdHJhY2stbWVudS1pdGVtLmpzJyk7XG5cbnZhciBfY2hhcHRlcnNUcmFja01lbnVJdGVtSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hhcHRlcnNUcmFja01lbnVJdGVtSnMpO1xuXG52YXIgX21lbnVNZW51SnMgPSBfZGVyZXFfKCcuLi8uLi9tZW51L21lbnUuanMnKTtcblxudmFyIF9tZW51TWVudUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVNZW51SnMpO1xuXG52YXIgX3V0aWxzRG9tSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF91dGlsc1RvVGl0bGVDYXNlSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy90by10aXRsZS1jYXNlLmpzJyk7XG5cbnZhciBfdXRpbHNUb1RpdGxlQ2FzZUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzVG9UaXRsZUNhc2VKcyk7XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gX2RlcmVxXygnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNoYXB0ZXJzXG4gKiBDaGFwdGVycyBhY3QgbXVjaCBkaWZmZXJlbnRseSB0aGFuIG90aGVyIHRleHQgdHJhY2tzXG4gKiBDdWVzIGFyZSBuYXZpZ2F0aW9uIHZzLiBvdGhlciB0cmFja3Mgb2YgYWx0ZXJuYXRpdmUgbGFuZ3VhZ2VzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXllciAgUGxheWVyIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5ICAgIFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqIEBjbGFzcyBDaGFwdGVyc0J1dHRvblxuICovXG5cbnZhciBDaGFwdGVyc0J1dHRvbiA9IChmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBfaW5oZXJpdHMoQ2hhcHRlcnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIENoYXB0ZXJzQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhcHRlcnNCdXR0b24pO1xuXG4gICAgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdDaGFwdGVycyBNZW51Jyk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIGNsYXNzIG5hbWVcbiAgICogQG1ldGhvZCBidWlsZENTU0NsYXNzXG4gICAqL1xuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jaGFwdGVycy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIG1lbnUgaXRlbXNcbiAgICogQG1ldGhvZCBjcmVhdGVJdGVtc1xuICAgKi9cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgaXRlbXMucHVzaChuZXcgX3RleHRUcmFja01lbnVJdGVtSnMyWydkZWZhdWx0J10odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgJ3RyYWNrJzogdHJhY2tcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIG1lbnUgZnJvbSBjaGFwdGVyIGJ1dHRvbnNcbiAgICpcbiAgICogQHJldHVybiB7TWVudX0gTWVudSBvZiBjaGFwdGVyIGJ1dHRvbnNcbiAgICogQG1ldGhvZCBjcmVhdGVNZW51XG4gICAqL1xuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCkgfHwgW107XG4gICAgdmFyIGNoYXB0ZXJzVHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuICAgICAgLy8gV2Ugd2lsbCBhbHdheXMgY2hvb3NlIHRoZSBsYXN0IHRyYWNrIGFzIG91ciBjaGFwdGVyc1RyYWNrXG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFja1sna2luZCddID09PSB0aGlzLmtpbmRfKSB7XG4gICAgICAgIGNoYXB0ZXJzVHJhY2sgPSB0cmFjaztcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWVudSA9IHRoaXMubWVudTtcbiAgICBpZiAobWVudSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZW51ID0gbmV3IF9tZW51TWVudUpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyXyk7XG4gICAgICB2YXIgdGl0bGUgPSBEb20uY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogX3V0aWxzVG9UaXRsZUNhc2VKczJbJ2RlZmF1bHQnXSh0aGlzLmtpbmRfKSxcbiAgICAgICAgdGFiSW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICAgIG1lbnUuY2hpbGRyZW5fLnVuc2hpZnQodGl0bGUpO1xuICAgICAgRG9tLmluc2VydEVsRmlyc3QodGl0bGUsIG1lbnUuY29udGVudEVsKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3aWxsIGVtcHR5IG91dCB0aGUgbWVudSBjaGlsZHJlbiBlYWNoIHRpbWUgYmVjYXVzZSB3ZSB3YW50IGFcbiAgICAgIC8vIGZyZXNoIG5ldyBtZW51IGNoaWxkIGxpc3QgZWFjaCB0aW1lXG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBtZW51LnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICAvLyBFbXB0eSBvdXQgdGhlIENoYXB0ZXJzQnV0dG9uIG1lbnUgaXRlbXMgYmVjYXVzZSB3ZSBubyBsb25nZXIgbmVlZCB0aGVtXG4gICAgICBpdGVtcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChjaGFwdGVyc1RyYWNrICYmIGNoYXB0ZXJzVHJhY2suY3VlcyA9PSBudWxsKSB7XG4gICAgICBjaGFwdGVyc1RyYWNrWydtb2RlJ10gPSAnaGlkZGVuJztcblxuICAgICAgdmFyIHJlbW90ZVRleHRUcmFja0VsID0gdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKGNoYXB0ZXJzVHJhY2spO1xuXG4gICAgICBpZiAocmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgcmVtb3RlVGV4dFRyYWNrRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYXB0ZXJzVHJhY2sgJiYgY2hhcHRlcnNUcmFjay5jdWVzICYmIGNoYXB0ZXJzVHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgY3VlcyA9IGNoYXB0ZXJzVHJhY2tbJ2N1ZXMnXSxcbiAgICAgICAgICBjdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgICB2YXIgbWkgPSBuZXcgX2NoYXB0ZXJzVHJhY2tNZW51SXRlbUpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyXywge1xuICAgICAgICAgICd0cmFjayc6IGNoYXB0ZXJzVHJhY2ssXG4gICAgICAgICAgJ2N1ZSc6IGN1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtcy5wdXNoKG1pKTtcblxuICAgICAgICBtZW51LmFkZENoaWxkKG1pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIC8vIEFzc2lnbmluZyB0aGUgdmFsdWUgb2YgaXRlbXMgYmFjayB0byB0aGlzLml0ZW1zIGZvciBuZXh0IGl0ZXJhdGlvblxuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICByZXR1cm4gbWVudTtcbiAgfTtcblxuICByZXR1cm4gQ2hhcHRlcnNCdXR0b247XG59KShfdGV4dFRyYWNrQnV0dG9uSnMyWydkZWZhdWx0J10pO1xuXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2hhcHRlcnMnO1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDaGFwdGVycyc7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNCdXR0b24nLCBDaGFwdGVyc0J1dHRvbik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBDaGFwdGVyc0J1dHRvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vLi4vbWVudS9tZW51LmpzXCI6MTExLFwiLi4vLi4vdXRpbHMvZG9tLmpzXCI6MTQyLFwiLi4vLi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuLi8uLi91dGlscy90by10aXRsZS1jYXNlLmpzXCI6MTUxLFwiLi9jaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanNcIjo4OCxcIi4vdGV4dC10cmFjay1idXR0b24uanNcIjo5MixcIi4vdGV4dC10cmFjay1tZW51LWl0ZW0uanNcIjo5MyxcImdsb2JhbC93aW5kb3dcIjoyfV0sODg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBjaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX21lbnVNZW51SXRlbUpzID0gX2RlcmVxXygnLi4vLi4vbWVudS9tZW51LWl0ZW0uanMnKTtcblxudmFyIF9tZW51TWVudUl0ZW1KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW51TWVudUl0ZW1Kcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbi8qKlxuICogVGhlIGNoYXB0ZXIgdHJhY2sgbWVudSBpdGVtXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqIEBjbGFzcyBDaGFwdGVyc1RyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2hhcHRlcnNUcmFja01lbnVJdGVtID0gKGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgX2luaGVyaXRzKENoYXB0ZXJzVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICBmdW5jdGlvbiBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zWyd0cmFjayddO1xuICAgIHZhciBjdWUgPSBvcHRpb25zWydjdWUnXTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSBjdWUudGV4dDtcbiAgICBvcHRpb25zWydzZWxlY3RlZCddID0gY3VlWydzdGFydFRpbWUnXSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZVsnZW5kVGltZSddO1xuICAgIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgdGhpcy5jdWUgPSBjdWU7XG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGljayBvbiBtZW51IGl0ZW1cbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuY3VlLnN0YXJ0VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjaGFwdGVyIG1lbnUgaXRlbVxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKi9cblxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgY3VlID0gdGhpcy5jdWU7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyB2anMubG9nKGN1cnJlbnRUaW1lLCBjdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnNlbGVjdGVkKGN1ZVsnc3RhcnRUaW1lJ10gPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWVbJ2VuZFRpbWUnXSk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbn0pKF9tZW51TWVudUl0ZW1KczJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNUcmFja01lbnVJdGVtJywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vLi4vbWVudS9tZW51LWl0ZW0uanNcIjoxMTAsXCIuLi8uLi91dGlscy9mbi5qc1wiOjE0NH1dLDg5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgZGVzY3JpcHRpb25zLWJ1dHRvbi5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMgPSBfZGVyZXFfKCcuL3RleHQtdHJhY2stYnV0dG9uLmpzJyk7XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrQnV0dG9uSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGRlc2NyaXB0aW9uc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXIgIFBsYXllciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKiBAY2xhc3MgRGVzY3JpcHRpb25zQnV0dG9uXG4gKi9cblxudmFyIERlc2NyaXB0aW9uc0J1dHRvbiA9IChmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBfaW5oZXJpdHMoRGVzY3JpcHRpb25zQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICBmdW5jdGlvbiBEZXNjcmlwdGlvbnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVzY3JpcHRpb25zQnV0dG9uKTtcblxuICAgIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnRGVzY3JpcHRpb25zIE1lbnUnKTtcblxuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKHRyYWNrcykge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBGbi5iaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZVRyYWNrc0NoYW5nZVxuICAgKi9cblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIHdoZXRoZXIgYSB0cmFjayBvZiBhIGRpZmZlcmVudCBraW5kIGlzIHNob3dpbmdcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgIGlmICh0cmFja1sna2luZCddICE9PSB0aGlzLmtpbmRfICYmIHRyYWNrWydtb2RlJ10gPT09ICdzaG93aW5nJykge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFub3RoZXIgdHJhY2sgaXMgc2hvd2luZywgZGlzYWJsZSB0aGlzIG1lbnUgYnV0dG9uXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqIEBtZXRob2QgYnVpbGRDU1NDbGFzc1xuICAgKi9cblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gRGVzY3JpcHRpb25zQnV0dG9uO1xufSkoX3RleHRUcmFja0J1dHRvbkpzMlsnZGVmYXVsdCddKTtcblxuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdkZXNjcmlwdGlvbnMnO1xuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRGVzY3JpcHRpb25zJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdEZXNjcmlwdGlvbnNCdXR0b24nLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gRGVzY3JpcHRpb25zQnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi91dGlscy9mbi5qc1wiOjE0NCxcIi4vdGV4dC10cmFjay1idXR0b24uanNcIjo5Mn1dLDkwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgb2ZmLXRleHQtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90ZXh0VHJhY2tNZW51SXRlbUpzID0gX2RlcmVxXygnLi90ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcycpO1xuXG52YXIgX3RleHRUcmFja01lbnVJdGVtSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrTWVudUl0ZW1Kcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbi8qKlxuICogQSBzcGVjaWFsIG1lbnUgaXRlbSBmb3IgdHVybmluZyBvZiBhIHNwZWNpZmljIHR5cGUgb2YgdGV4dCB0cmFja1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXG4gKiBAY2xhc3MgT2ZmVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgT2ZmVGV4dFRyYWNrTWVudUl0ZW0gPSAoZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xuICBfaW5oZXJpdHMoT2ZmVGV4dFRyYWNrTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgZnVuY3Rpb24gT2ZmVGV4dFRyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcblxuICAgIC8vIENyZWF0ZSBwc2V1ZG8gdHJhY2sgaW5mb1xuICAgIC8vIFJlcXVpcmVzIG9wdGlvbnNbJ2tpbmQnXVxuICAgIG9wdGlvbnNbJ3RyYWNrJ10gPSB7XG4gICAgICAna2luZCc6IG9wdGlvbnNbJ2tpbmQnXSxcbiAgICAgICdwbGF5ZXInOiBwbGF5ZXIsXG4gICAgICAnbGFiZWwnOiBvcHRpb25zWydraW5kJ10gKyAnIG9mZicsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgJ21vZGUnOiAnZGlzYWJsZWQnXG4gICAgfTtcblxuICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICBvcHRpb25zWydzZWxlY3RhYmxlJ10gPSB0cnVlO1xuXG4gICAgX1RleHRUcmFja01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqIEBtZXRob2QgaGFuZGxlVHJhY2tzQ2hhbmdlXG4gICAqL1xuXG4gIE9mZlRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIHNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHRyYWNrWydraW5kJ10gPT09IHRoaXMudHJhY2tbJ2tpbmQnXSAmJiB0cmFja1snbW9kZSddID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XG4gIH07XG5cbiAgcmV0dXJuIE9mZlRleHRUcmFja01lbnVJdGVtO1xufSkoX3RleHRUcmFja01lbnVJdGVtSnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ09mZlRleHRUcmFja01lbnVJdGVtJywgT2ZmVGV4dFRyYWNrTWVudUl0ZW0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gT2ZmVGV4dFRyYWNrTWVudUl0ZW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2NyxcIi4vdGV4dC10cmFjay1tZW51LWl0ZW0uanNcIjo5M31dLDkxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgc3VidGl0bGVzLWJ1dHRvbi5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMgPSBfZGVyZXFfKCcuL3RleHQtdHJhY2stYnV0dG9uLmpzJyk7XG5cbnZhciBfdGV4dFRyYWNrQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrQnV0dG9uSnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIHN1YnRpdGxlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXIgIFBsYXllciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKiBAY2xhc3MgU3VidGl0bGVzQnV0dG9uXG4gKi9cblxudmFyIFN1YnRpdGxlc0J1dHRvbiA9IChmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBfaW5oZXJpdHMoU3VidGl0bGVzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICBmdW5jdGlvbiBTdWJ0aXRsZXNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJ0aXRsZXNCdXR0b24pO1xuXG4gICAgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdTdWJ0aXRsZXMgTWVudScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqIEBtZXRob2QgYnVpbGRDU1NDbGFzc1xuICAgKi9cblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gU3VidGl0bGVzQnV0dG9uO1xufSkoX3RleHRUcmFja0J1dHRvbkpzMlsnZGVmYXVsdCddKTtcblxuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdzdWJ0aXRsZXMnO1xuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnU3VidGl0bGVzJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gU3VidGl0bGVzQnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuL3RleHQtdHJhY2stYnV0dG9uLmpzXCI6OTJ9XSw5MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stYnV0dG9uLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90cmFja0J1dHRvbkpzID0gX2RlcmVxXygnLi4vdHJhY2stYnV0dG9uLmpzJyk7XG5cbnZhciBfdHJhY2tCdXR0b25KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja0J1dHRvbkpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF90ZXh0VHJhY2tNZW51SXRlbUpzID0gX2RlcmVxXygnLi90ZXh0LXRyYWNrLW1lbnUtaXRlbS5qcycpO1xuXG52YXIgX3RleHRUcmFja01lbnVJdGVtSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFRyYWNrTWVudUl0ZW1Kcyk7XG5cbnZhciBfb2ZmVGV4dFRyYWNrTWVudUl0ZW1KcyA9IF9kZXJlcV8oJy4vb2ZmLXRleHQtdHJhY2stbWVudS1pdGVtLmpzJyk7XG5cbnZhciBfb2ZmVGV4dFRyYWNrTWVudUl0ZW1KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZUZXh0VHJhY2tNZW51SXRlbUpzKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB0ZXh0IHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcylcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKiBAY2xhc3MgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFRleHRUcmFja0J1dHRvbiA9IChmdW5jdGlvbiAoX1RyYWNrQnV0dG9uKSB7XG4gIF9pbmhlcml0cyhUZXh0VHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgZnVuY3Rpb24gVGV4dFRyYWNrQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQnV0dG9uKTtcblxuICAgIG9wdGlvbnMudHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcblxuICAgIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIG1lbnUgaXRlbXNcbiAgICogQG1ldGhvZCBjcmVhdGVJdGVtc1xuICAgKi9cblxuICBUZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMF07XG5cbiAgICAvLyBBZGQgYW4gT0ZGIG1lbnUgaXRlbSB0byB0dXJuIGFsbCB0cmFja3Mgb2ZmXG4gICAgaXRlbXMucHVzaChuZXcgX29mZlRleHRUcmFja01lbnVJdGVtSnMyWydkZWZhdWx0J10odGhpcy5wbGF5ZXJfLCB7ICdraW5kJzogdGhpcy5raW5kXyB9KSk7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgdHJhY2tzIHRoYXQgYXJlIG9mIHRoZSBhcHByb3ByaWF0ZSBraW5kIGFuZCBoYXZlIGEgbGFiZWxcbiAgICAgIGlmICh0cmFja1sna2luZCddID09PSB0aGlzLmtpbmRfKSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobmV3IF90ZXh0VHJhY2tNZW51SXRlbUpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyXywge1xuICAgICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgICAnc2VsZWN0YWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3RyYWNrJzogdHJhY2tcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrQnV0dG9uO1xufSkoX3RyYWNrQnV0dG9uSnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0J1dHRvbicsIFRleHRUcmFja0J1dHRvbik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBUZXh0VHJhY2tCdXR0b247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2NyxcIi4uLy4uL3V0aWxzL2ZuLmpzXCI6MTQ0LFwiLi4vdHJhY2stYnV0dG9uLmpzXCI6OTgsXCIuL29mZi10ZXh0LXRyYWNrLW1lbnUtaXRlbS5qc1wiOjkwLFwiLi90ZXh0LXRyYWNrLW1lbnUtaXRlbS5qc1wiOjkzfV0sOTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbWVudU1lbnVJdGVtSnMgPSBfZGVyZXFfKCcuLi8uLi9tZW51L21lbnUtaXRlbS5qcycpO1xuXG52YXIgX21lbnVNZW51SXRlbUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVNZW51SXRlbUpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQgPSBfZGVyZXFfKCdnbG9iYWwvZG9jdW1lbnQnKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxEb2N1bWVudCk7XG5cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICogQGNsYXNzIFRleHRUcmFja01lbnVJdGVtXG4gKi9cblxudmFyIFRleHRUcmFja01lbnVJdGVtID0gKGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgX2luaGVyaXRzKFRleHRUcmFja01lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIGZ1bmN0aW9uIFRleHRUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9uc1sndHJhY2snXTtcbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnNbJ2xhYmVsJ10gPSB0cmFja1snbGFiZWwnXSB8fCB0cmFja1snbGFuZ3VhZ2UnXSB8fCAnVW5rbm93bic7XG4gICAgb3B0aW9uc1snc2VsZWN0ZWQnXSA9IHRyYWNrWydkZWZhdWx0J10gfHwgdHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnO1xuXG4gICAgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFja3MpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gRm4uYmluZChfdGhpcywgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKTtcblxuICAgICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIC8vIGlPUzcgZG9lc24ndCBkaXNwYXRjaCBjaGFuZ2UgZXZlbnRzIHRvIFRleHRUcmFja0xpc3RzIHdoZW4gYW5cbiAgICAvLyBhc3NvY2lhdGVkIHRyYWNrJ3MgbW9kZSBjaGFuZ2VzLiBXaXRob3V0IHNvbWV0aGluZyBsaWtlXG4gICAgLy8gT2JqZWN0Lm9ic2VydmUoKSAoYWxzbyBub3QgcHJlc2VudCBvbiBpT1M3KSwgaXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSB0byBkZXRlY3QgY2hhbmdlcyB0byB0aGUgbW9kZSBhdHRyaWJ1dGUgYW5kIHBvbHlmaWxsXG4gICAgLy8gdGhlIGNoYW5nZSBldmVudC4gQXMgYSBwb29yIHN1YnN0aXR1dGUsIHdlIG1hbnVhbGx5IGRpc3BhdGNoXG4gICAgLy8gY2hhbmdlIGV2ZW50cyB3aGVuZXZlciB0aGUgY29udHJvbHMgbW9kaWZ5IHRoZSBtb2RlLlxuICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLm9uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBfdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLkV2ZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gQW5kcm9pZCAyLjMgdGhyb3dzIGFuIElsbGVnYWwgQ29uc3RydWN0b3IgZXJyb3IgZm9yIHdpbmRvdy5FdmVudFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5FdmVudCgnY2hhbmdlJyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyYWNrcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2sgb24gdGV4dCB0cmFja1xuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAqL1xuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIGtpbmQgPSB0aGlzLnRyYWNrWydraW5kJ107XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgaWYgKCF0cmFja3MpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFja1sna2luZCddICE9PSBraW5kKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2spIHtcbiAgICAgICAgdHJhY2tbJ21vZGUnXSA9ICdzaG93aW5nJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNrWydtb2RlJ10gPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgY2hhbmdlXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlVHJhY2tzQ2hhbmdlXG4gICAqL1xuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMudHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnKTtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTWVudUl0ZW07XG59KShfbWVudU1lbnVJdGVtSnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja01lbnVJdGVtJywgVGV4dFRyYWNrTWVudUl0ZW0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gVGV4dFRyYWNrTWVudUl0ZW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2NyxcIi4uLy4uL21lbnUvbWVudS1pdGVtLmpzXCI6MTEwLFwiLi4vLi4vdXRpbHMvZm4uanNcIjoxNDQsXCJnbG9iYWwvZG9jdW1lbnRcIjoxLFwiZ2xvYmFsL3dpbmRvd1wiOjJ9XSw5NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGN1cnJlbnQtdGltZS1kaXNwbGF5LmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbnZhciBfdXRpbHNGb3JtYXRUaW1lSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qcycpO1xuXG52YXIgX3V0aWxzRm9ybWF0VGltZUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzRm9ybWF0VGltZUpzKTtcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgY3VycmVudCB0aW1lXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgQ3VycmVudFRpbWVEaXNwbGF5XG4gKi9cblxudmFyIEN1cnJlbnRUaW1lRGlzcGxheSA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ3VycmVudFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDdXJyZW50VGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnJlbnRUaW1lRGlzcGxheSk7XG5cbiAgICBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIHRoaXMudXBkYXRlQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIEN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY3VycmVudC10aW1lIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBEb20uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jdXJyZW50LXRpbWUtZGlzcGxheScsXG4gICAgICAvLyBsYWJlbCB0aGUgY3VycmVudCB0aW1lIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj5DdXJyZW50IFRpbWUgPC9zcGFuPicgKyAnMDowMCdcbiAgICB9LCB7XG4gICAgICAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGN1cnJlbnQgdGltZSBkaXNwbGF5XG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlQ29udGVudFxuICAgKi9cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KCkge1xuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKCdDdXJyZW50IFRpbWUnKTtcbiAgICB2YXIgZm9ybWF0dGVkVGltZSA9IF91dGlsc0Zvcm1hdFRpbWVKczJbJ2RlZmF1bHQnXSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gICAgaWYgKGZvcm1hdHRlZFRpbWUgIT09IHRoaXMuZm9ybWF0dGVkVGltZV8pIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXR0ZWRUaW1lO1xuICAgICAgdGhpcy5jb250ZW50RWxfLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgbG9jYWxpemVkVGV4dCArICc8L3NwYW4+ICcgKyBmb3JtYXR0ZWRUaW1lO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ3VycmVudFRpbWVEaXNwbGF5O1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gQ3VycmVudFRpbWVEaXNwbGF5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi91dGlscy9kb20uanNcIjoxNDIsXCIuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qc1wiOjE0NX1dLDk1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgZHVyYXRpb24tZGlzcGxheS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi8uLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfdXRpbHNEb21KcyA9IF9kZXJlcV8oJy4uLy4uL3V0aWxzL2RvbS5qcycpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tSnMpO1xuXG52YXIgX3V0aWxzRm9ybWF0VGltZUpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZm9ybWF0LXRpbWUuanMnKTtcblxudmFyIF91dGlsc0Zvcm1hdFRpbWVKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0Zvcm1hdFRpbWVKcyk7XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGR1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgRHVyYXRpb25EaXNwbGF5XG4gKi9cblxudmFyIER1cmF0aW9uRGlzcGxheSA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRHVyYXRpb25EaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEdXJhdGlvbkRpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIER1cmF0aW9uRGlzcGxheSk7XG5cbiAgICBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMub24ocGxheWVyLCAnZHVyYXRpb25jaGFuZ2UnLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBEb20uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1kdXJhdGlvbi1kaXNwbGF5JyxcbiAgICAgIC8vIGxhYmVsIHRoZSBkdXJhdGlvbiB0aW1lIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSgnRHVyYXRpb24gVGltZScpICsgJzwvc3Bhbj4gMDowMCdcbiAgICB9LCB7XG4gICAgICAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGR1cmF0aW9uIHRpbWUgZGlzcGxheVxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZUNvbnRlbnRcbiAgICovXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudCgpIHtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICBpZiAoZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbl8gIT09IGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmR1cmF0aW9uXyA9IGR1cmF0aW9uO1xuICAgICAgdmFyIGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKCdEdXJhdGlvbiBUaW1lJyk7XG4gICAgICB2YXIgZm9ybWF0dGVkVGltZSA9IF91dGlsc0Zvcm1hdFRpbWVKczJbJ2RlZmF1bHQnXShkdXJhdGlvbik7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPicgKyBsb2NhbGl6ZWRUZXh0ICsgJzwvc3Bhbj4gJyArIGZvcm1hdHRlZFRpbWU7IC8vIGxhYmVsIHRoZSBkdXJhdGlvbiB0aW1lIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEdXJhdGlvbkRpc3BsYXk7XG59KShfY29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0R1cmF0aW9uRGlzcGxheScsIER1cmF0aW9uRGlzcGxheSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBEdXJhdGlvbkRpc3BsYXk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2NyxcIi4uLy4uL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4uLy4uL3V0aWxzL2Zvcm1hdC10aW1lLmpzXCI6MTQ1fV0sOTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSByZW1haW5pbmctdGltZS1kaXNwbGF5LmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbnZhciBfdXRpbHNGb3JtYXRUaW1lSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qcycpO1xuXG52YXIgX3V0aWxzRm9ybWF0VGltZUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzRm9ybWF0VGltZUpzKTtcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIFJlbWFpbmluZ1RpbWVEaXNwbGF5XG4gKi9cblxudmFyIFJlbWFpbmluZ1RpbWVEaXNwbGF5ID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSZW1haW5pbmdUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVtYWluaW5nVGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGVDb250ZW50KTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy51cGRhdGVDb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXJlbWFpbmluZy10aW1lIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBEb20uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZS1kaXNwbGF5JyxcbiAgICAgIC8vIGxhYmVsIHRoZSByZW1haW5pbmcgdGltZSBmb3Igc2NyZWVuIHJlYWRlciB1c2Vyc1xuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUoJ1JlbWFpbmluZyBUaW1lJykgKyAnPC9zcGFuPiAtMDowMCdcbiAgICB9LCB7XG4gICAgICAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXlcbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVDb250ZW50XG4gICAqL1xuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHZhciBsb2NhbGl6ZWRUZXh0ID0gdGhpcy5sb2NhbGl6ZSgnUmVtYWluaW5nIFRpbWUnKTtcbiAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gX3V0aWxzRm9ybWF0VGltZUpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lKCkpO1xuICAgICAgaWYgKGZvcm1hdHRlZFRpbWUgIT09IHRoaXMuZm9ybWF0dGVkVGltZV8pIHtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRUaW1lXyA9IGZvcm1hdHRlZFRpbWU7XG4gICAgICAgIHRoaXMuY29udGVudEVsXy5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JyArIGxvY2FsaXplZFRleHQgKyAnPC9zcGFuPiAtJyArIGZvcm1hdHRlZFRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIC8vIHZhciB0aW1lID0gKHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICAgIC8vIHRoaXMuY29udGVudEVsXy5pbm5lckhUTUwgPSB2anMuZm9ybWF0VGltZSh0aW1lLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdSZW1haW5pbmdUaW1lRGlzcGxheScsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi91dGlscy9kb20uanNcIjoxNDIsXCIuLi8uLi91dGlscy9mb3JtYXQtdGltZS5qc1wiOjE0NX1dLDk3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgdGltZS1kaXZpZGVyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxuLyoqXG4gKiBUaGUgc2VwYXJhdG9yIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgZHVyYXRpb24uXG4gKiBDYW4gYmUgaGlkZGVuIGlmIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZGVzaWduLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIFRpbWVEaXZpZGVyXG4gKi9cblxudmFyIFRpbWVEaXZpZGVyID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhUaW1lRGl2aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGltZURpdmlkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXZpZGVyKTtcblxuICAgIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgVGltZURpdmlkZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLWNvbnRyb2wgdmpzLXRpbWUtZGl2aWRlcicsXG4gICAgICBpbm5lckhUTUw6ICc8ZGl2PjxzcGFuPi88L3NwYW4+PC9kaXY+J1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUaW1lRGl2aWRlcjtcbn0pKF9jb21wb25lbnRKczJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpdmlkZXInLCBUaW1lRGl2aWRlcik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBUaW1lRGl2aWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3fV0sOTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB0cmFjay1idXR0b24uanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX21lbnVNZW51QnV0dG9uSnMgPSBfZGVyZXFfKCcuLi9tZW51L21lbnUtYnV0dG9uLmpzJyk7XG5cbnZhciBfbWVudU1lbnVCdXR0b25KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW51TWVudUJ1dHRvbkpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB0ZXh0IHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcylcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKiBAY2xhc3MgVHJhY2tCdXR0b25cbiAqL1xuXG52YXIgVHJhY2tCdXR0b24gPSAoZnVuY3Rpb24gKF9NZW51QnV0dG9uKSB7XG4gIF9pbmhlcml0cyhUcmFja0J1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFRyYWNrQnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0J1dHRvbik7XG5cbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICBfTWVudUJ1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPD0gMSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSGFuZGxlciA9IEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGUpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuXG4gICAgdGhpcy5wbGF5ZXJfLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBUcmFja0J1dHRvbjtcbn0pKF9tZW51TWVudUJ1dHRvbkpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdUcmFja0J1dHRvbicsIFRyYWNrQnV0dG9uKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRyYWNrQnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi9tZW51L21lbnUtYnV0dG9uLmpzXCI6MTA5LFwiLi4vdXRpbHMvZm4uanNcIjoxNDR9XSw5OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHZvbHVtZS1iYXIuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3NsaWRlclNsaWRlckpzID0gX2RlcmVxXygnLi4vLi4vc2xpZGVyL3NsaWRlci5qcycpO1xuXG52YXIgX3NsaWRlclNsaWRlckpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NsaWRlclNsaWRlckpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi8uLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxuLy8gUmVxdWlyZWQgY2hpbGRyZW5cblxudmFyIF92b2x1bWVMZXZlbEpzID0gX2RlcmVxXygnLi92b2x1bWUtbGV2ZWwuanMnKTtcblxudmFyIF92b2x1bWVMZXZlbEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZvbHVtZUxldmVsSnMpO1xuXG4vKipcbiAqIFRoZSBiYXIgdGhhdCBjb250YWlucyB0aGUgdm9sdW1lIGxldmVsIGFuZCBjYW4gYmUgY2xpY2tlZCBvbiB0byBhZGp1c3QgdGhlIGxldmVsXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgU2xpZGVyXG4gKiBAY2xhc3MgVm9sdW1lQmFyXG4gKi9cblxudmFyIFZvbHVtZUJhciA9IChmdW5jdGlvbiAoX1NsaWRlcikge1xuICBfaW5oZXJpdHMoVm9sdW1lQmFyLCBfU2xpZGVyKTtcblxuICBmdW5jdGlvbiBWb2x1bWVCYXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XG5cbiAgICBfU2xpZGVyLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIHRoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpO1xuICAgIHBsYXllci5yZWFkeShGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWJhciB2anMtc2xpZGVyLWJhcidcbiAgICB9LCB7XG4gICAgICAnYXJpYS1sYWJlbCc6ICd2b2x1bWUgbGV2ZWwnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBtb3ZlIG9uIHZvbHVtZSBiYXJcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVNb3VzZU1vdmVcbiAgICovXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpKTtcbiAgfTtcblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNoZWNrTXV0ZWQgPSBmdW5jdGlvbiBjaGVja011dGVkKCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwZXJjZW50IG9mIHZvbHVtZSBsZXZlbFxuICAgKlxuICAgKiBAcmV0dW4ge051bWJlcn0gVm9sdW1lIGxldmVsIHBlcmNlbnRcbiAgICogQG1ldGhvZCBnZXRQZXJjZW50XG4gICAqL1xuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uIGdldFBlcmNlbnQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHZvbHVtZSBsZXZlbCBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICpcbiAgICogQG1ldGhvZCBzdGVwRm9yd2FyZFxuICAgKi9cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgKyAwLjEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqXG4gICAqIEBtZXRob2Qgc3RlcEJhY2tcbiAgICovXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5zdGVwQmFjayA9IGZ1bmN0aW9uIHN0ZXBCYWNrKCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpIC0gMC4xKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIEFSSUEgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlQVJJQUF0dHJpYnV0ZXNcbiAgICovXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgIC8vIEN1cnJlbnQgdmFsdWUgb2Ygdm9sdW1lIGJhciBhcyBhIHBlcmNlbnRhZ2VcbiAgICB2YXIgdm9sdW1lID0gKHRoaXMucGxheWVyXy52b2x1bWUoKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB2b2x1bWUpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCB2b2x1bWUgKyAnJScpO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVCYXI7XG59KShfc2xpZGVyU2xpZGVySnMyWydkZWZhdWx0J10pO1xuXG5Wb2x1bWVCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd2b2x1bWVMZXZlbCddLFxuICAnYmFyTmFtZSc6ICd2b2x1bWVMZXZlbCdcbn07XG5cblZvbHVtZUJhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndm9sdW1lY2hhbmdlJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVCYXInLCBWb2x1bWVCYXIpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gVm9sdW1lQmFyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi8uLi9zbGlkZXIvc2xpZGVyLmpzXCI6MTE5LFwiLi4vLi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuL3ZvbHVtZS1sZXZlbC5qc1wiOjEwMX1dLDEwMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHZvbHVtZS1jb250cm9sLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uLy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxuLy8gUmVxdWlyZWQgY2hpbGRyZW5cblxudmFyIF92b2x1bWVCYXJKcyA9IF9kZXJlcV8oJy4vdm9sdW1lLWJhci5qcycpO1xuXG52YXIgX3ZvbHVtZUJhckpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZvbHVtZUJhckpzKTtcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgdm9sdW1lIGxldmVsXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgVm9sdW1lQ29udHJvbFxuICovXG5cbnZhciBWb2x1bWVDb250cm9sID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhWb2x1bWVDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBWb2x1bWVDb250cm9sKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVDb250cm9sKTtcblxuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gaGlkZSB2b2x1bWUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICAgIGlmIChwbGF5ZXIudGVjaF8gJiYgcGxheWVyLnRlY2hfWydmZWF0dXJlc1ZvbHVtZUNvbnRyb2wnXSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG4gICAgdGhpcy5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfWydmZWF0dXJlc1ZvbHVtZUNvbnRyb2wnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUNvbnRyb2w7XG59KShfY29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5Wb2x1bWVDb250cm9sLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndm9sdW1lQmFyJ11cbn07XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gVm9sdW1lQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uLy4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi92b2x1bWUtYmFyLmpzXCI6OTl9XSwxMDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB2b2x1bWUtbGV2ZWwuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG4vKipcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICogQGNsYXNzIFZvbHVtZUxldmVsXG4gKi9cblxudmFyIFZvbHVtZUxldmVsID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhWb2x1bWVMZXZlbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVm9sdW1lTGV2ZWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUxldmVsKTtcblxuICAgIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgVm9sdW1lTGV2ZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtbGV2ZWwnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lTGV2ZWw7XG59KShfY29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUxldmVsJywgVm9sdW1lTGV2ZWwpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gVm9sdW1lTGV2ZWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi9jb21wb25lbnQuanNcIjo2N31dLDEwMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHZvbHVtZS1tZW51LWJ1dHRvbi5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfcG9wdXBQb3B1cEpzID0gX2RlcmVxXygnLi4vcG9wdXAvcG9wdXAuanMnKTtcblxudmFyIF9wb3B1cFBvcHVwSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9wdXBQb3B1cEpzKTtcblxudmFyIF9wb3B1cFBvcHVwQnV0dG9uSnMgPSBfZGVyZXFfKCcuLi9wb3B1cC9wb3B1cC1idXR0b24uanMnKTtcblxudmFyIF9wb3B1cFBvcHVwQnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9wdXBQb3B1cEJ1dHRvbkpzKTtcblxudmFyIF9tdXRlVG9nZ2xlSnMgPSBfZGVyZXFfKCcuL211dGUtdG9nZ2xlLmpzJyk7XG5cbnZhciBfbXV0ZVRvZ2dsZUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX211dGVUb2dnbGVKcyk7XG5cbnZhciBfdm9sdW1lQ29udHJvbFZvbHVtZUJhckpzID0gX2RlcmVxXygnLi92b2x1bWUtY29udHJvbC92b2x1bWUtYmFyLmpzJyk7XG5cbnZhciBfdm9sdW1lQ29udHJvbFZvbHVtZUJhckpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZvbHVtZUNvbnRyb2xWb2x1bWVCYXJKcyk7XG5cbi8qKlxuICogQnV0dG9uIGZvciB2b2x1bWUgcG9wdXBcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBQb3B1cEJ1dHRvblxuICogQGNsYXNzIFZvbHVtZU1lbnVCdXR0b25cbiAqL1xuXG52YXIgVm9sdW1lTWVudUJ1dHRvbiA9IChmdW5jdGlvbiAoX1BvcHVwQnV0dG9uKSB7XG4gIF9pbmhlcml0cyhWb2x1bWVNZW51QnV0dG9uLCBfUG9wdXBCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFZvbHVtZU1lbnVCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVNZW51QnV0dG9uKTtcblxuICAgIC8vIERlZmF1bHQgdG8gaW5saW5lXG4gICAgaWYgKG9wdGlvbnMuaW5saW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmVydGljYWwgb3B0aW9uIGlzbid0IHBhc3NlZCBhdCBhbGwsIGRlZmF1bHQgdG8gdHJ1ZS5cbiAgICBpZiAob3B0aW9ucy52ZXJ0aWNhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBhbiBpbmxpbmUgdm9sdW1lTWVudUJ1dHRvbiBpcyB1c2VkLCB3ZSBzaG91bGQgZGVmYXVsdCB0byB1c2luZ1xuICAgICAgLy8gYSBob3Jpem9udGFsIHNsaWRlciBmb3Igb2J2aW91cyByZWFzb25zLlxuICAgICAgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIG9wdGlvbnMudmVydGljYWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMudmVydGljYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSB2ZXJ0aWNhbCBvcHRpb24gbmVlZHMgdG8gYmUgc2V0IG9uIHRoZSB2b2x1bWVCYXIgYXMgd2VsbCxcbiAgICAvLyBzaW5jZSB0aGF0IHdpbGwgbmVlZCB0byBiZSBwYXNzZWQgYWxvbmcgdG8gdGhlIFZvbHVtZUJhciBjb25zdHJ1Y3RvclxuICAgIG9wdGlvbnMudm9sdW1lQmFyID0gb3B0aW9ucy52b2x1bWVCYXIgfHwge307XG4gICAgb3B0aW9ucy52b2x1bWVCYXIudmVydGljYWwgPSAhIW9wdGlvbnMudmVydGljYWw7XG5cbiAgICBfUG9wdXBCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2FtZSBsaXN0ZW5lcnMgYXMgTXV0ZVRvZ2dsZVxuICAgIHRoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgdGhpcy52b2x1bWVVcGRhdGUpO1xuICAgIHRoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgdGhpcy52b2x1bWVVcGRhdGUpO1xuXG4gICAgLy8gaGlkZSBtdXRlIHRvZ2dsZSBpZiB0aGUgY3VycmVudCB0ZWNoIGRvZXNuJ3Qgc3VwcG9ydCB2b2x1bWUgY29udHJvbFxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfICYmIHBsYXllci50ZWNoX1snZmVhdHVyZXNWb2x1bWVDb250cm9sJ10gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVWaXNpYmlsaXR5LmNhbGwodGhpcyk7XG4gICAgdGhpcy5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCB1cGRhdGVWaXNpYmlsaXR5KTtcblxuICAgIHRoaXMub24odGhpcy52b2x1bWVCYXIsIFsnc2xpZGVyYWN0aXZlJywgJ2ZvY3VzJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKHRoaXMudm9sdW1lQmFyLCBbJ3NsaWRlcmluYWN0aXZlJywgJ2JsdXInXSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy52b2x1bWVCYXIsIFsnZm9jdXMnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWxvY2stc2hvd2luZycpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbih0aGlzLnZvbHVtZUJhciwgWydibHVyJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICovXG5cbiAgVm9sdW1lTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAnJztcbiAgICBpZiAoISF0aGlzLm9wdGlvbnNfLnZlcnRpY2FsKSB7XG4gICAgICBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtbWVudS1idXR0b24tdmVydGljYWwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtbWVudS1idXR0b24taG9yaXpvbnRhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICd2anMtdm9sdW1lLW1lbnUtYnV0dG9uICcgKyBfUG9wdXBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKSArICcgJyArIG9yaWVudGF0aW9uQ2xhc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtQb3B1cH0gVGhlIHZvbHVtZSBwb3B1cCBidXR0b25cbiAgICogQG1ldGhvZCBjcmVhdGVQb3B1cFxuICAgKi9cblxuICBWb2x1bWVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVQb3B1cCA9IGZ1bmN0aW9uIGNyZWF0ZVBvcHVwKCkge1xuICAgIHZhciBwb3B1cCA9IG5ldyBfcG9wdXBQb3B1cEpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyXywge1xuICAgICAgY29udGVudEVsVHlwZTogJ2RpdidcbiAgICB9KTtcblxuICAgIHZhciB2YiA9IG5ldyBfdm9sdW1lQ29udHJvbFZvbHVtZUJhckpzMlsnZGVmYXVsdCddKHRoaXMucGxheWVyXywgdGhpcy5vcHRpb25zXy52b2x1bWVCYXIpO1xuXG4gICAgcG9wdXAuYWRkQ2hpbGQodmIpO1xuXG4gICAgdGhpcy5tZW51Q29udGVudCA9IHBvcHVwO1xuICAgIHRoaXMudm9sdW1lQmFyID0gdmI7XG5cbiAgICB0aGlzLmF0dGFjaFZvbHVtZUJhckV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHBvcHVwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2sgb24gdm9sdW1lIHBvcHVwIGFuZCBjYWxscyBzdXBlclxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG4gICAqL1xuXG4gIFZvbHVtZU1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgX211dGVUb2dnbGVKczJbJ2RlZmF1bHQnXS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzKTtcbiAgICBfUG9wdXBCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgVm9sdW1lTWVudUJ1dHRvbi5wcm90b3R5cGUuYXR0YWNoVm9sdW1lQmFyRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoVm9sdW1lQmFyRXZlbnRzKCkge1xuICAgIHRoaXMubWVudUNvbnRlbnQub24oWydtb3VzZWRvd24nLCAndG91Y2hkb3duJ10sIEZuLmJpbmQodGhpcywgdGhpcy5oYW5kbGVNb3VzZURvd24pKTtcbiAgfTtcblxuICBWb2x1bWVNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB0aGlzLm9uKFsnbW91c2Vtb3ZlJywgJ3RvdWNobW92ZSddLCBGbi5iaW5kKHRoaXMudm9sdW1lQmFyLCB0aGlzLnZvbHVtZUJhci5oYW5kbGVNb3VzZU1vdmUpKTtcbiAgICB0aGlzLm9uKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsIFsnbW91c2V1cCcsICd0b3VjaGVuZCddLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICB9O1xuXG4gIFZvbHVtZU1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgdGhpcy5vZmYoWydtb3VzZW1vdmUnLCAndG91Y2htb3ZlJ10sIEZuLmJpbmQodGhpcy52b2x1bWVCYXIsIHRoaXMudm9sdW1lQmFyLmhhbmRsZU1vdXNlTW92ZSkpO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVNZW51QnV0dG9uO1xufSkoX3BvcHVwUG9wdXBCdXR0b25KczJbJ2RlZmF1bHQnXSk7XG5cblZvbHVtZU1lbnVCdXR0b24ucHJvdG90eXBlLnZvbHVtZVVwZGF0ZSA9IF9tdXRlVG9nZ2xlSnMyWydkZWZhdWx0J10ucHJvdG90eXBlLnVwZGF0ZTtcblZvbHVtZU1lbnVCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdNdXRlJztcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVNZW51QnV0dG9uJywgVm9sdW1lTWVudUJ1dHRvbik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBWb2x1bWVNZW51QnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi9wb3B1cC9wb3B1cC1idXR0b24uanNcIjoxMTUsXCIuLi9wb3B1cC9wb3B1cC5qc1wiOjExNixcIi4uL3V0aWxzL2ZuLmpzXCI6MTQ0LFwiLi9tdXRlLXRvZ2dsZS5qc1wiOjczLFwiLi92b2x1bWUtY29udHJvbC92b2x1bWUtYmFyLmpzXCI6OTl9XSwxMDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBlcnJvci1kaXNwbGF5LmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG52YXIgX21vZGFsRGlhbG9nID0gX2RlcmVxXygnLi9tb2RhbC1kaWFsb2cnKTtcblxudmFyIF9tb2RhbERpYWxvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2RhbERpYWxvZyk7XG5cbnZhciBfdXRpbHNEb20gPSBfZGVyZXFfKCcuL3V0aWxzL2RvbScpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tKTtcblxudmFyIF91dGlsc01lcmdlT3B0aW9ucyA9IF9kZXJlcV8oJy4vdXRpbHMvbWVyZ2Utb3B0aW9ucycpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTWVyZ2VPcHRpb25zKTtcblxuLyoqXG4gKiBEaXNwbGF5IHRoYXQgYW4gZXJyb3IgaGFzIG9jY3VycmVkIG1ha2luZyB0aGUgdmlkZW8gdW5wbGF5YWJsZS5cbiAqXG4gKiBAZXh0ZW5kcyBNb2RhbERpYWxvZ1xuICogQGNsYXNzIEVycm9yRGlzcGxheVxuICovXG5cbnZhciBFcnJvckRpc3BsYXkgPSAoZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBfaW5oZXJpdHMoRXJyb3JEaXNwbGF5LCBfTW9kYWxEaWFsb2cpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgZXJyb3IgZGlzcGxheSBtb2RhbC5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgZnVuY3Rpb24gRXJyb3JEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcnJvckRpc3BsYXkpO1xuXG4gICAgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLm9uKHBsYXllciwgJ2Vycm9yJywgdGhpcy5vcGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHRoZSBvbGQgY2xhc3MgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHJlbW92ZWQgaW4gNi4wLlxuICAgKlxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBFcnJvckRpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWVycm9yLWRpc3BsYXkgJyArIF9Nb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIG1vZGFsIGNvbnRlbnQgYmFzZWQgb24gdGhlIHBsYXllciBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfE51bGx9XG4gICAqL1xuXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5wbGF5ZXIoKS5lcnJvcigpO1xuICAgIHJldHVybiBlcnJvciA/IHRoaXMubG9jYWxpemUoZXJyb3IubWVzc2FnZSkgOiAnJztcbiAgfTtcblxuICByZXR1cm4gRXJyb3JEaXNwbGF5O1xufSkoX21vZGFsRGlhbG9nMlsnZGVmYXVsdCddKTtcblxuRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IF91dGlsc01lcmdlT3B0aW9uczJbJ2RlZmF1bHQnXShfbW9kYWxEaWFsb2cyWydkZWZhdWx0J10ucHJvdG90eXBlLm9wdGlvbnNfLCB7XG4gIGZpbGxBbHdheXM6IHRydWUsXG4gIHRlbXBvcmFyeTogZmFsc2UsXG4gIHVuY2xvc2VhYmxlOiB0cnVlXG59KTtcblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEVycm9yRGlzcGxheTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4vY29tcG9uZW50XCI6NjcsXCIuL21vZGFsLWRpYWxvZ1wiOjExMixcIi4vdXRpbHMvZG9tXCI6MTQyLFwiLi91dGlscy9tZXJnZS1vcHRpb25zXCI6MTQ4fV0sMTA0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgZXZlbnQtdGFyZ2V0LmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi91dGlscy9ldmVudHMuanMnKTtcblxudmFyIEV2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0V2ZW50c0pzKTtcblxudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7fTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge307XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRXZlbnRzLm9uKHRoaXMsIHR5cGUsIGZuKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gYWVsO1xufTtcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uO1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIEV2ZW50cy5vZmYodGhpcywgdHlwZSwgZm4pO1xufTtcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9mZjtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRXZlbnRzLm9uZSh0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0ge1xuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbiAgZXZlbnQgPSBFdmVudHMuZml4RXZlbnQoZXZlbnQpO1xuXG4gIGlmICh0aGlzLmFsbG93ZWRFdmVudHNfW3R5cGVdICYmIHRoaXNbJ29uJyArIHR5cGVdKSB7XG4gICAgdGhpc1snb24nICsgdHlwZV0oZXZlbnQpO1xuICB9XG5cbiAgRXZlbnRzLnRyaWdnZXIodGhpcywgZXZlbnQpO1xufTtcbi8vIFRoZSBzdGFuZGFyZCBET00gRXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudCgpIGlzIGFsaWFzZWQgdG8gdHJpZ2dlcigpXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBFdmVudFRhcmdldDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4vdXRpbHMvZXZlbnRzLmpzXCI6MTQzfV0sMTA1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3V0aWxzTG9nID0gX2RlcmVxXygnLi91dGlscy9sb2cnKTtcblxudmFyIF91dGlsc0xvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0xvZyk7XG5cbi8qXG4gKiBAZmlsZSBleHRlbmQuanNcbiAqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIG5vZGUgaW5oZXJpdHMgYW5kIGJhYmVsJ3MgaW5oZXJpdHMgKGFmdGVyIHRyYW5zcGlsZSkuXG4gKiBCb3RoIHdvcmsgdGhlIHNhbWUgYnV0IG5vZGUgYWRkcyBgc3VwZXJfYCB0byB0aGUgc3ViQ2xhc3NcbiAqIGFuZCBCYWJsZSBhZGRzIHRoZSBzdXBlckNsYXNzIGFzIF9fcHJvdG9fXy4gQm90aCBzZWVtIHVzZWZ1bC5cbiAqL1xudmFyIF9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKlxuICogRnVuY3Rpb24gZm9yIHN1YmNsYXNzaW5nIHVzaW5nIHRoZSBzYW1lIGluaGVyaXRhbmNlIHRoYXRcbiAqIHZpZGVvanMgdXNlcyBpbnRlcm5hbGx5XG4gKiBgYGBqc1xuICogdmFyIEJ1dHRvbiA9IHZpZGVvanMuZ2V0Q29tcG9uZW50KCdCdXR0b24nKTtcbiAqIGBgYFxuICogYGBganNcbiAqIHZhciBNeUJ1dHRvbiA9IHZpZGVvanMuZXh0ZW5kKEJ1dHRvbiwge1xuICogICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ocGxheWVyLCBvcHRpb25zKSB7XG4gKiAgICAgQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcbiAqICAgfSxcbiAqICAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gZG9Tb21ldGhpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xudmFyIGV4dGVuZEZuID0gZnVuY3Rpb24gZXh0ZW5kRm4oc3VwZXJDbGFzcykge1xuICB2YXIgc3ViQ2xhc3NNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHN1YkNsYXNzID0gZnVuY3Rpb24gc3ViQ2xhc3MoKSB7XG4gICAgc3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gIGlmICh0eXBlb2Ygc3ViQ2xhc3NNZXRob2RzID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh0eXBlb2Ygc3ViQ2xhc3NNZXRob2RzLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF91dGlsc0xvZzJbJ2RlZmF1bHQnXS53YXJuKCdDb25zdHJ1Y3RvciBsb2dpYyB2aWEgaW5pdCgpIGlzIGRlcHJlY2F0ZWQ7IHBsZWFzZSB1c2UgY29uc3RydWN0b3IoKSBpbnN0ZWFkLicpO1xuICAgICAgc3ViQ2xhc3NNZXRob2RzLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3NNZXRob2RzLmluaXQ7XG4gICAgfVxuICAgIGlmIChzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3IgIT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBtZXRob2RzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJDbGFzc01ldGhvZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJDbGFzcyA9IHN1YkNsYXNzTWV0aG9kcztcbiAgfVxuXG4gIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG5cbiAgLy8gRXh0ZW5kIHN1Yk9iaidzIHByb3RvdHlwZSB3aXRoIGZ1bmN0aW9ucyBhbmQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHByb3BzXG4gIGZvciAodmFyIG5hbWUgaW4gbWV0aG9kcykge1xuICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzdWJDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJDbGFzcztcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGV4dGVuZEZuO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi91dGlscy9sb2dcIjoxNDd9XSwxMDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLWFwaS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxuLypcbiAqIFN0b3JlIHRoZSBicm93c2VyLXNwZWNpZmljIG1ldGhvZHMgZm9yIHRoZSBmdWxsc2NyZWVuIEFQSVxuICogQHR5cGUge09iamVjdHx1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRnVsbHNjcmVlbkFwaSA9IHt9O1xuXG4vLyBicm93c2VyIEFQSSBtZXRob2RzXG4vLyBtYXAgYXBwcm9hY2ggZnJvbSBTY3JlZW5mdWwuanMgLSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3NjcmVlbmZ1bGwuanNcbnZhciBhcGlNYXAgPSBbXG4vLyBTcGVjOiBodHRwczovL2R2Y3MudzMub3JnL2hnL2Z1bGxzY3JlZW4vcmF3LWZpbGUvdGlwL092ZXJ2aWV3Lmh0bWxcblsncmVxdWVzdEZ1bGxzY3JlZW4nLCAnZXhpdEZ1bGxzY3JlZW4nLCAnZnVsbHNjcmVlbkVsZW1lbnQnLCAnZnVsbHNjcmVlbkVuYWJsZWQnLCAnZnVsbHNjcmVlbmNoYW5nZScsICdmdWxsc2NyZWVuZXJyb3InXSxcbi8vIFdlYktpdFxuWyd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gT2xkIFdlYktpdCAoU2FmYXJpIDUuMSlcblsnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQnLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTW96aWxsYVxuWydtb3pSZXF1ZXN0RnVsbFNjcmVlbicsICdtb3pDYW5jZWxGdWxsU2NyZWVuJywgJ21vekZ1bGxTY3JlZW5FbGVtZW50JywgJ21vekZ1bGxTY3JlZW5FbmFibGVkJywgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCAnbW96ZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBNaWNyb3NvZnRcblsnbXNSZXF1ZXN0RnVsbHNjcmVlbicsICdtc0V4aXRGdWxsc2NyZWVuJywgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLCAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCAnTVNGdWxsc2NyZWVuRXJyb3InXV07XG5cbnZhciBzcGVjQXBpID0gYXBpTWFwWzBdO1xudmFyIGJyb3dzZXJBcGkgPSB1bmRlZmluZWQ7XG5cbi8vIGRldGVybWluZSB0aGUgc3VwcG9ydGVkIHNldCBvZiBmdW5jdGlvbnNcbmZvciAodmFyIGkgPSAwOyBpIDwgYXBpTWFwLmxlbmd0aDsgaSsrKSB7XG4gIC8vIGNoZWNrIGZvciBleGl0RnVsbHNjcmVlbiBmdW5jdGlvblxuICBpZiAoYXBpTWFwW2ldWzFdIGluIF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXSkge1xuICAgIGJyb3dzZXJBcGkgPSBhcGlNYXBbaV07XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gbWFwIHRoZSBicm93c2VyIEFQSSBuYW1lcyB0byB0aGUgc3BlYyBBUEkgbmFtZXNcbmlmIChicm93c2VyQXBpKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnJvd3NlckFwaS5sZW5ndGg7IGkrKykge1xuICAgIEZ1bGxzY3JlZW5BcGlbc3BlY0FwaVtpXV0gPSBicm93c2VyQXBpW2ldO1xuICB9XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEZ1bGxzY3JlZW5BcGk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCJnbG9iYWwvZG9jdW1lbnRcIjoxfV0sMTA3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgbG9hZGluZy1zcGlubmVyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG4vKiBMb2FkaW5nIFNwaW5uZXJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKipcbiAqIExvYWRpbmcgc3Bpbm5lciBmb3Igd2FpdGluZyBldmVudHNcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBMb2FkaW5nU3Bpbm5lclxuICovXG5cbnZhciBMb2FkaW5nU3Bpbm5lciA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTG9hZGluZ1NwaW5uZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExvYWRpbmdTcGlubmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkaW5nU3Bpbm5lcik7XG5cbiAgICBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIExvYWRpbmdTcGlubmVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZGluZy1zcGlubmVyJyxcbiAgICAgIGRpcjogJ2x0cidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTG9hZGluZ1NwaW5uZXI7XG59KShfY29tcG9uZW50MlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnTG9hZGluZ1NwaW5uZXInLCBMb2FkaW5nU3Bpbm5lcik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBMb2FkaW5nU3Bpbm5lcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4vY29tcG9uZW50XCI6Njd9XSwxMDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBtZWRpYS1lcnJvci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9vYmplY3RBc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QuYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbi8qXG4gKiBDdXN0b20gTWVkaWFFcnJvciBjbGFzcyB3aGljaCBtaW1pY3MgdGhlIHN0YW5kYXJkIEhUTUw1IE1lZGlhRXJyb3IgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdHxNZWRpYUVycm9yfSB2YWx1ZVxuICogICAgICAgIFRoaXMgY2FuIGJlIG9mIG11bHRpcGxlIHR5cGVzOlxuICogICAgICAgIC0gTnVtYmVyOiBzaG91bGQgYmUgYSBzdGFuZGFyZCBlcnJvciBjb2RlXG4gKiAgICAgICAgLSBTdHJpbmc6IGFuIGVycm9yIG1lc3NhZ2UgKHRoZSBjb2RlIHdpbGwgYmUgMClcbiAqICAgICAgICAtIE9iamVjdDogYXJiaXRyYXJ5IHByb3BlcnRpZXNcbiAqICAgICAgICAtIE1lZGlhRXJyb3IgKG5hdGl2ZSk6IHVzZWQgdG8gcG9wdWxhdGUgYSB2aWRlby5qcyBNZWRpYUVycm9yIG9iamVjdFxuICogICAgICAgIC0gTWVkaWFFcnJvciAodmlkZW8uanMpOiB3aWxsIHJldHVybiBpdHNlbGYgaWYgaXQncyBhbHJlYWR5IGFcbiAqICAgICAgICAgIHZpZGVvLmpzIE1lZGlhRXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBNZWRpYUVycm9yKHZhbHVlKSB7XG5cbiAgLy8gQWxsb3cgcmVkdW5kYW50IGNhbGxzIHRvIHRoaXMgY29uc3RydWN0b3IgdG8gYXZvaWQgaGF2aW5nIGBpbnN0YW5jZW9mYFxuICAvLyBjaGVja3MgcGVwcGVyZWQgYXJvdW5kIHRoZSBjb2RlLlxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZWRpYUVycm9yKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCBjb2RlIGlzIHplcm8sIHNvIHRoaXMgaXMgYSBjdXN0b20gZXJyb3JcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cbiAgICAvLyBXZSBhc3NpZ24gdGhlIGBjb2RlYCBwcm9wZXJ0eSBtYW51YWxseSBiZWNhdXNlIG5hdGl2ZSBNZWRpYUVycm9yIG9iamVjdHNcbiAgICAvLyBkbyBub3QgZXhwb3NlIGl0IGFzIGFuIG93bi9lbnVtZXJhYmxlIHByb3BlcnR5IG9mIHRoZSBvYmplY3QuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5jb2RlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb2RlID0gdmFsdWUuY29kZTtcbiAgICB9XG5cbiAgICBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXNbdGhpcy5jb2RlXSB8fCAnJztcbiAgfVxufVxuXG4vKlxuICogVGhlIGVycm9yIGNvZGUgdGhhdCByZWZlcnMgdHdvIG9uZSBvZiB0aGUgZGVmaW5lZFxuICogTWVkaWFFcnJvciB0eXBlc1xuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLmNvZGUgPSAwO1xuXG4vKlxuICogQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBiZSBzaG93biB3aXRoIHRoZSBlcnJvci5cbiAqIE1lc3NhZ2UgaXMgbm90IHBhcnQgb2YgdGhlIEhUTUw1IHZpZGVvIHNwZWNcbiAqIGJ1dCBhbGxvd3MgZm9yIG1vcmUgaW5mb3JtYXRpdmUgY3VzdG9tIGVycm9ycy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qXG4gKiBBbiBvcHRpb25hbCBzdGF0dXMgY29kZSB0aGF0IGNhbiBiZSBzZXQgYnkgcGx1Z2luc1xuICogdG8gYWxsb3cgZXZlbiBtb3JlIGRldGFpbCBhYm91dCB0aGUgZXJyb3IuXG4gKiBGb3IgZXhhbXBsZSB0aGUgSExTIHBsdWdpbiBtaWdodCBwcm92aWRlIHRoZSBzcGVjaWZpY1xuICogSFRUUCBzdGF0dXMgY29kZSB0aGF0IHdhcyByZXR1cm5lZCB3aGVuIHRoZSBlcnJvclxuICogb2NjdXJyZWQsIHRoZW4gYWxsb3dpbmcgYSBjdXN0b20gZXJyb3Igb3ZlcmxheVxuICogdG8gZGlzcGxheSBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUuc3RhdHVzID0gbnVsbDtcblxuTWVkaWFFcnJvci5lcnJvclR5cGVzID0gWydNRURJQV9FUlJfQ1VTVE9NJywgLy8gPSAwXG4nTUVESUFfRVJSX0FCT1JURUQnLCAvLyA9IDFcbidNRURJQV9FUlJfTkVUV09SSycsIC8vID0gMlxuJ01FRElBX0VSUl9ERUNPREUnLCAvLyA9IDNcbidNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQnLCAvLyA9IDRcbidNRURJQV9FUlJfRU5DUllQVEVEJyAvLyA9IDVcbl07XG5cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIG1lZGlhIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIG1lZGlhIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSBtZWRpYSBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgbWVkaWEgdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgbWVkaWEgY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gTWVkaWFFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIm9iamVjdC5hc3NpZ25cIjo0NX1dLDEwOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIG1lbnUtYnV0dG9uLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jbGlja2FibGVDb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uL2NsaWNrYWJsZS1jb21wb25lbnQuanMnKTtcblxudmFyIF9jbGlja2FibGVDb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGlja2FibGVDb21wb25lbnRKcyk7XG5cbnZhciBfY29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfbWVudUpzID0gX2RlcmVxXygnLi9tZW51LmpzJyk7XG5cbnZhciBfbWVudUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVKcyk7XG5cbnZhciBfdXRpbHNEb21KcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2RvbS5qcycpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tSnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG52YXIgX3V0aWxzVG9UaXRsZUNhc2VKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL3RvLXRpdGxlLWNhc2UuanMnKTtcblxudmFyIF91dGlsc1RvVGl0bGVDYXNlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNUb1RpdGxlQ2FzZUpzKTtcblxuLyoqXG4gKiBBIGJ1dHRvbiBjbGFzcyB3aXRoIGEgcG9wdXAgbWVudVxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIEJ1dHRvblxuICogQGNsYXNzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgTWVudUJ1dHRvbiA9IChmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTWVudUJ1dHRvbiwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVudUJ1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVCdXR0b24pO1xuXG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG5cbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCAndHJ1ZScpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbScpO1xuICAgIHRoaXMub24oJ2tleWRvd24nLCB0aGlzLmhhbmRsZVN1Ym1lbnVLZXlQcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG1lbnVcbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICovXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBtZW51ID0gdGhpcy5jcmVhdGVNZW51KCk7XG5cbiAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMubWVudSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZW51ID0gbWVudTtcbiAgICB0aGlzLmFkZENoaWxkKG1lbnUpO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBtZW51IGJ1dHRvblxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgbWVudVxuICAgKlxuICAgKiBAcmV0dXJuIHtNZW51fSBUaGUgY29uc3RydWN0ZWQgbWVudVxuICAgKiBAbWV0aG9kIGNyZWF0ZU1lbnVcbiAgICovXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XG4gICAgdmFyIG1lbnUgPSBuZXcgX21lbnVKczJbJ2RlZmF1bHQnXSh0aGlzLnBsYXllcl8pO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlID0gRG9tLmNyZWF0ZUVsKCdsaScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtdGl0bGUnLFxuICAgICAgICBpbm5lckhUTUw6IF91dGlsc1RvVGl0bGVDYXNlSnMyWydkZWZhdWx0J10odGhpcy5vcHRpb25zXy50aXRsZSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgICBtZW51LmNoaWxkcmVuXy51bnNoaWZ0KHRpdGxlKTtcbiAgICAgIERvbS5pbnNlcnRFbEZpcnN0KHRpdGxlLCBtZW51LmNvbnRlbnRFbCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLml0ZW1zID0gdGhpc1snY3JlYXRlSXRlbXMnXSgpO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIC8vIEFkZCBtZW51IGl0ZW1zIHRvIHRoZSBtZW51XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVudS5hZGRJdGVtKHRoaXMuaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZW51O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGxpc3Qgb2YgbWVudSBpdGVtcy4gU3BlY2lmaWMgdG8gZWFjaCBzdWJjbGFzcy5cbiAgICpcbiAgICogQG1ldGhvZCBjcmVhdGVJdGVtc1xuICAgKi9cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBjbGFzcyBuYW1lXG4gICAqIEBtZXRob2QgYnVpbGRDU1NDbGFzc1xuICAgKi9cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHlvdSBjbGljayB0aGUgYnV0dG9uIGl0IGFkZHMgZm9jdXMsIHdoaWNoXG4gICAqIHdpbGwgc2hvdyB0aGUgbWVudSBpbmRlZmluaXRlbHkuXG4gICAqIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi5cbiAgICogRm9jdXMgaXMgbmVlZGVkIGZvciB0YWIgbmF2aWdhdGlvbi5cbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcbiAgICovXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLm9uZSh0aGlzLm1lbnUuY29udGVudEVsKCksICdtb3VzZWxlYXZlJywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgICB0aGlzLmVsXy5ibHVyKCk7XG4gICAgfSkpO1xuICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVzc0J1dHRvbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGtleSBwcmVzcyBvbiBtZW51XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBLZXkgcHJlc3MgZXZlbnRcbiAgICogQG1ldGhvZCBoYW5kbGVLZXlQcmVzc1xuICAgKi9cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIC8vIFVwICgzOCkga2V5IG9yIERvd24gKDQwKSBrZXkgcHJlc3MgdGhlICdidXR0b24nXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XG4gICAgICAgIGlmICghdGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGtleSBwcmVzcyBvbiBzdWJtZW51XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBLZXkgcHJlc3MgZXZlbnRcbiAgICogQG1ldGhvZCBoYW5kbGVTdWJtZW51S2V5UHJlc3NcbiAgICovXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlU3VibWVudUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlU3VibWVudUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2VzIGNoYW5nZXMgYmFzZWQgb24gYnV0dG9uIHByZXNzZWRcbiAgICpcbiAgICogQG1ldGhvZCBwcmVzc0J1dHRvblxuICAgKi9cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5wcmVzc0J1dHRvbiA9IGZ1bmN0aW9uIHByZXNzQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWRfKSB7XG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMubWVudS5sb2NrU2hvd2luZygpO1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgIHRoaXMubWVudS5mb2N1cygpOyAvLyBzZXQgdGhlIGZvY3VzIGludG8gdGhlIHN1Ym1lbnVcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2VzIGNoYW5nZXMgYmFzZWQgb24gYnV0dG9uIHVucHJlc3NlZFxuICAgKlxuICAgKiBAbWV0aG9kIHVucHJlc3NCdXR0b25cbiAgICovXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUudW5wcmVzc0J1dHRvbiA9IGZ1bmN0aW9uIHVucHJlc3NCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZF8pIHtcbiAgICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICAgIHRoaXMubWVudS51bmxvY2tTaG93aW5nKCk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgIHRoaXMuZWxfLmZvY3VzKCk7IC8vIFNldCBmb2N1cyBiYWNrIHRvIHRoaXMgbWVudSBidXR0b25cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIG1lbnUgYnV0dG9uXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQG1ldGhvZCBkaXNhYmxlXG4gICAqL1xuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIC8vIFVucHJlc3MsIGJ1dCBkb24ndCBmb3JjZSBmb2N1cyBvbiB0aGlzIGJ1dHRvblxuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm1lbnUudW5sb2NrU2hvd2luZygpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBtZW51IGJ1dHRvblxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBtZXRob2QgZGlzYWJsZVxuICAgKi9cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG5cbiAgICByZXR1cm4gX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVCdXR0b247XG59KShfY2xpY2thYmxlQ29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVCdXR0b24nLCBNZW51QnV0dG9uKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1lbnVCdXR0b247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi9jbGlja2FibGUtY29tcG9uZW50LmpzXCI6NjUsXCIuLi9jb21wb25lbnQuanNcIjo2NyxcIi4uL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4uL3V0aWxzL2ZuLmpzXCI6MTQ0LFwiLi4vdXRpbHMvdG8tdGl0bGUtY2FzZS5qc1wiOjE1MSxcIi4vbWVudS5qc1wiOjExMX1dLDExMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIG1lbnUtaXRlbS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY2xpY2thYmxlQ29tcG9uZW50SnMgPSBfZGVyZXFfKCcuLi9jbGlja2FibGUtY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY2xpY2thYmxlQ29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xpY2thYmxlQ29tcG9uZW50SnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IF9kZXJlcV8oJ29iamVjdC5hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBhIG1lbnUgaXRlbS4gYDxsaT5gXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ8T2JqZWN0fSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICogQGV4dGVuZHMgQnV0dG9uXG4gKiBAY2xhc3MgTWVudUl0ZW1cbiAqL1xuXG52YXIgTWVudUl0ZW0gPSAoZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbnVJdGVtLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUl0ZW0pO1xuXG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNlbGVjdGFibGUgPSBvcHRpb25zWydzZWxlY3RhYmxlJ107XG5cbiAgICB0aGlzLnNlbGVjdGVkKG9wdGlvbnNbJ3NlbGVjdGVkJ10pO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgLy8gVE9ETzogTWF5IG5lZWQgdG8gYmUgZWl0aGVyIG1lbnVpdGVtY2hlY2tib3ggb3IgbWVudWl0ZW1yYWRpbyxcbiAgICAgIC8vICAgICAgIGFuZCBtYXkgbmVlZCBsb2dpY2FsIGdyb3VwaW5nIG9mIG1lbnUgaXRlbXMuXG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW1jaGVja2JveCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IHR5cGUgRGVzY1xuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BzIERlc2NcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0eXBlLCBwcm9wcywgYXR0cnMpIHtcbiAgICByZXR1cm4gX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnbGknLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWl0ZW0nLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc19bJ2xhYmVsJ10pLFxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZW51IGl0ZW0sIGFuZCBzZXQgaXQgdG8gc2VsZWN0ZWRcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyBtZW51IGl0ZW0gYXMgc2VsZWN0ZWQgb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBtZXRob2Qgc2VsZWN0ZWRcbiAgICovXG5cbiAgTWVudUl0ZW0ucHJvdG90eXBlLnNlbGVjdGVkID0gZnVuY3Rpb24gc2VsZWN0ZWQoX3NlbGVjdGVkKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgaWYgKF9zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAndHJ1ZScpO1xuICAgICAgICAvLyBhcmlhLWNoZWNrZWQgaXNuJ3QgZnVsbHkgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzL3NjcmVlbiByZWFkZXJzLFxuICAgICAgICAvLyBzbyBpbmRpY2F0ZSBzZWxlY3RlZCBzdGF0ZSB0byBzY3JlZW4gcmVhZGVyIGluIHRoZSBjb250cm9sIHRleHQuXG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJywgc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWxlY3RlZCcpO1xuICAgICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsICdmYWxzZScpO1xuICAgICAgICAvLyBJbmRpY2F0ZSB1bi1zZWxlY3RlZCBzdGF0ZSB0byBzY3JlZW4gcmVhZGVyXG4gICAgICAgIC8vIE5vdGUgdGhhdCBhIHNwYWNlIGNsZWFycyBvdXQgdGhlIHNlbGVjdGVkIHN0YXRlIHRleHRcbiAgICAgICAgdGhpcy5jb250cm9sVGV4dCgnICcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWVudUl0ZW07XG59KShfY2xpY2thYmxlQ29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gTWVudUl0ZW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi9jbGlja2FibGUtY29tcG9uZW50LmpzXCI6NjUsXCIuLi9jb21wb25lbnQuanNcIjo2NyxcIm9iamVjdC5hc3NpZ25cIjo0NX1dLDExMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIG1lbnUuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3V0aWxzRG9tSnMgPSBfZGVyZXFfKCcuLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi4vdXRpbHMvZXZlbnRzLmpzJyk7XG5cbnZhciBFdmVudHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNFdmVudHNKcyk7XG5cbi8qKlxuICogVGhlIE1lbnUgY29tcG9uZW50IGlzIHVzZWQgdG8gYnVpbGQgcG9wIHVwIG1lbnVzLCBpbmNsdWRpbmcgc3VidGl0bGUgYW5kXG4gKiBjYXB0aW9ucyBzZWxlY3Rpb24gbWVudXMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgTWVudVxuICovXG5cbnZhciBNZW51ID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNZW51LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW51KHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51KTtcblxuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5mb2N1c2VkQ2hpbGRfID0gLTE7XG5cbiAgICB0aGlzLm9uKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbWVudSBpdGVtIHRvIHRoZSBtZW51XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29tcG9uZW50IENvbXBvbmVudCBvciBjb21wb25lbnQgdHlwZSB0byBhZGRcbiAgICogQG1ldGhvZCBhZGRJdGVtXG4gICAqL1xuXG4gIE1lbnUucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbiBhZGRJdGVtKGNvbXBvbmVudCkge1xuICAgIHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQub24oJ2NsaWNrJywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnVubG9ja1Nob3dpbmcoKTtcbiAgICAgIC8vVE9ETzogTmVlZCB0byBzZXQga2V5Ym9hcmQgZm9jdXMgYmFjayB0byB0aGUgbWVudUJ1dHRvblxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIE1lbnUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGNvbnRlbnRFbFR5cGUgPSB0aGlzLm9wdGlvbnNfLmNvbnRlbnRFbFR5cGUgfHwgJ3VsJztcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBEb20uY3JlYXRlRWwoY29udGVudEVsVHlwZSwge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtY29udGVudCdcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRlbnRFbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnUnKTtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBhcHBlbmQ6IHRoaXMuY29udGVudEVsXyxcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51J1xuICAgIH0pO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuXG4gICAgLy8gUHJldmVudCBjbGlja3MgZnJvbSBidWJibGluZyB1cC4gTmVlZGVkIGZvciBNZW51IEJ1dHRvbnMsXG4gICAgLy8gd2hlcmUgYSBjbGljayBvbiB0aGUgcGFyZW50IGlzIHNpZ25pZmljYW50XG4gICAgRXZlbnRzLm9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGtleSBwcmVzcyBmb3IgbWVudVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqIEBtZXRob2QgaGFuZGxlS2V5UHJlc3NcbiAgICovXG5cbiAgTWVudS5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzcgfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XG4gICAgICAvLyBMZWZ0IGFuZCBEb3duIEFycm93c1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gMzkpIHtcbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIG5leHQgKGxvd2VyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqXG4gICAqIEBtZXRob2Qgc3RlcEZvcndhcmRcbiAgICovXG5cbiAgTWVudS5wcm90b3R5cGUuc3RlcEZvcndhcmQgPSBmdW5jdGlvbiBzdGVwRm9yd2FyZCgpIHtcbiAgICB2YXIgc3RlcENoaWxkID0gMDtcblxuICAgIGlmICh0aGlzLmZvY3VzZWRDaGlsZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RlcENoaWxkID0gdGhpcy5mb2N1c2VkQ2hpbGRfICsgMTtcbiAgICB9XG4gICAgdGhpcy5mb2N1cyhzdGVwQ2hpbGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIHByZXZpb3VzIChoaWdoZXIpIG1lbnUgaXRlbSBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICpcbiAgICogQG1ldGhvZCBzdGVwQmFja1xuICAgKi9cblxuICBNZW51LnByb3RvdHlwZS5zdGVwQmFjayA9IGZ1bmN0aW9uIHN0ZXBCYWNrKCkge1xuICAgIHZhciBzdGVwQ2hpbGQgPSAwO1xuXG4gICAgaWYgKHRoaXMuZm9jdXNlZENoaWxkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGVwQ2hpbGQgPSB0aGlzLmZvY3VzZWRDaGlsZF8gLSAxO1xuICAgIH1cbiAgICB0aGlzLmZvY3VzKHN0ZXBDaGlsZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBmb2N1cyBvbiBhIG1lbnUgaXRlbSBpbiB0aGUgbWVudVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGl0ZW0gSW5kZXggb2YgY2hpbGQgaXRlbSBzZXQgZm9jdXMgb25cbiAgICogQG1ldGhvZCBmb2N1c1xuICAgKi9cblxuICBNZW51LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKS5zbGljZSgpO1xuICAgIHZhciBoYXZlVGl0bGUgPSBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bMF0uY2xhc3NOYW1lICYmIC92anMtbWVudS10aXRsZS8udGVzdChjaGlsZHJlblswXS5jbGFzc05hbWUpO1xuXG4gICAgaWYgKGhhdmVUaXRsZSkge1xuICAgICAgY2hpbGRyZW4uc2hpZnQoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGl0ZW0gPCAwKSB7XG4gICAgICAgIGl0ZW0gPSAwO1xuICAgICAgfSBlbHNlIGlmIChpdGVtID49IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1c2VkQ2hpbGRfID0gaXRlbTtcblxuICAgICAgY2hpbGRyZW5baXRlbV0uZWxfLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNZW51O1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51JywgTWVudSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi91dGlscy9kb20uanNcIjoxNDIsXCIuLi91dGlscy9ldmVudHMuanNcIjoxNDMsXCIuLi91dGlscy9mbi5qc1wiOjE0NH1dLDExMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIG1vZGFsLWRpYWxvZy5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdXRpbHNEb20gPSBfZGVyZXFfKCcuL3V0aWxzL2RvbScpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tKTtcblxudmFyIF91dGlsc0ZuID0gX2RlcmVxXygnLi91dGlscy9mbicpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbik7XG5cbnZhciBfdXRpbHNMb2cgPSBfZGVyZXFfKCcuL3V0aWxzL2xvZycpO1xuXG52YXIgX3V0aWxzTG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTG9nKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG52YXIgX2Nsb3NlQnV0dG9uID0gX2RlcmVxXygnLi9jbG9zZS1idXR0b24nKTtcblxudmFyIF9jbG9zZUJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZUJ1dHRvbik7XG5cbnZhciBNT0RBTF9DTEFTU19OQU1FID0gJ3Zqcy1tb2RhbC1kaWFsb2cnO1xudmFyIEVTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBgTW9kYWxEaWFsb2dgIGRpc3BsYXlzIG92ZXIgdGhlIHZpZGVvIGFuZCBpdHMgY29udHJvbHMsIHdoaWNoIGJsb2Nrc1xuICogaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGxheWVyIHVudGlsIGl0IGlzIGNsb3NlZC5cbiAqXG4gKiBNb2RhbCBkaWFsb2dzIGluY2x1ZGUgYSBcIkNsb3NlXCIgYnV0dG9uIGFuZCB3aWxsIGNsb3NlIHdoZW4gdGhhdCBidXR0b25cbiAqIGlzIGFjdGl2YXRlZCAtIG9yIHdoZW4gRVNDIGlzIHByZXNzZWQgYW55d2hlcmUuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgTW9kYWxEaWFsb2cgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1vZGFsRGlhbG9nLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIG1vZGFscy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtICB7TWl4ZWR9IFtvcHRpb25zLmNvbnRlbnQ9dW5kZWZpbmVkXVxuICAgKiAgICAgICAgIFByb3ZpZGUgY3VzdG9taXplZCBjb250ZW50IGZvciB0aGlzIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXVxuICAgKiAgICAgICAgIEEgdGV4dCBkZXNjcmlwdGlvbiBmb3IgdGhlIG1vZGFsLCBwcmltYXJpbHkgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZpbGxBbHdheXM9ZmFsc2VdXG4gICAqICAgICAgICAgTm9ybWFsbHksIG1vZGFscyBhcmUgYXV0b21hdGljYWxseSBmaWxsZWQgb25seSB0aGUgZmlyc3QgdGltZVxuICAgKiAgICAgICAgIHRoZXkgb3Blbi4gVGhpcyB0ZWxscyB0aGUgbW9kYWwgdG8gcmVmcmVzaCBpdHMgY29udGVudFxuICAgKiAgICAgICAgIGV2ZXJ5IHRpbWUgaXQgb3BlbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMubGFiZWxdXG4gICAqICAgICAgICAgQSB0ZXh0IGxhYmVsIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMudGVtcG9yYXJ5PXRydWVdXG4gICAqICAgICAgICAgSWYgYHRydWVgLCB0aGUgbW9kYWwgY2FuIG9ubHkgYmUgb3BlbmVkIG9uY2U7IGl0IHdpbGwgYmVcbiAgICogICAgICAgICBkaXNwb3NlZCBhcyBzb29uIGFzIGl0J3MgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy51bmNsb3NlYWJsZT1mYWxzZV1cbiAgICogICAgICAgICBJZiBgdHJ1ZWAsIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gY2xvc2UgdGhlIG1vZGFsXG4gICAqICAgICAgICAgdGhyb3VnaCB0aGUgVUkgaW4gdGhlIG5vcm1hbCB3YXlzLiBQcm9ncmFtbWF0aWMgY2xvc2luZyBpc1xuICAgKiAgICAgICAgIHN0aWxsIHBvc3NpYmxlLlxuICAgKlxuICAgKi9cblxuICBmdW5jdGlvbiBNb2RhbERpYWxvZyhwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxEaWFsb2cpO1xuXG4gICAgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcGVuZWRfID0gdGhpcy5oYXNCZWVuT3BlbmVkXyA9IHRoaXMuaGFzQmVlbkZpbGxlZF8gPSBmYWxzZTtcblxuICAgIHRoaXMuY2xvc2VhYmxlKCF0aGlzLm9wdGlvbnNfLnVuY2xvc2VhYmxlKTtcbiAgICB0aGlzLmNvbnRlbnQodGhpcy5vcHRpb25zXy5jb250ZW50KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGVudEVsIGlzIGRlZmluZWQgQUZURVIgYW55IGNoaWxkcmVuIGFyZSBpbml0aWFsaXplZFxuICAgIC8vIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRoZSBjb250ZW50cyBvZiB0aGUgbW9kYWwgaW4gdGhlIGNvbnRlbnRFbFxuICAgIC8vIChub3QgdGhlIFVJIGVsZW1lbnRzIGxpa2UgdGhlIGNsb3NlIGJ1dHRvbikuXG4gICAgdGhpcy5jb250ZW50RWxfID0gRG9tLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IE1PREFMX0NMQVNTX05BTUUgKyAnLWNvbnRlbnQnXG4gICAgfSwge1xuICAgICAgcm9sZTogJ2RvY3VtZW50J1xuICAgIH0pO1xuXG4gICAgdGhpcy5kZXNjRWxfID0gRG9tLmNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1kZXNjcmlwdGlvbiB2anMtb2Zmc2NyZWVuJyxcbiAgICAgIGlkOiB0aGlzLmVsKCkuZ2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICB9KTtcblxuICAgIERvbS50ZXh0Q29udGVudCh0aGlzLmRlc2NFbF8sIHRoaXMuZGVzY3JpcHRpb24oKSk7XG4gICAgdGhpcy5lbF8uYXBwZW5kQ2hpbGQodGhpcy5kZXNjRWxfKTtcbiAgICB0aGlzLmVsXy5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICB9XG5cbiAgLypcbiAgICogTW9kYWwgZGlhbG9nIGRlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbW9kYWwncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSwge1xuICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLmlkKCkgKyAnX2Rlc2NyaXB0aW9uJyxcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sYWJlbCgpLFxuICAgICAgcm9sZTogJ2RpYWxvZydcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGQgdGhlIG1vZGFsJ3MgQ1NTIGNsYXNzLlxuICAgKlxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIE1PREFMX0NMQVNTX05BTUUgKyAnIHZqcy1oaWRkZW4gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXkgcHJlc3NlcyBvbiB0aGUgZG9jdW1lbnQsIGxvb2tpbmcgZm9yIEVTQywgd2hpY2ggY2xvc2VzXG4gICAqIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVLZXlQcmVzc1xuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKi9cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhlKSB7XG4gICAgaWYgKGUud2hpY2ggPT09IEVTQyAmJiB0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYWJlbCBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLmxhYmVsIHx8IHRoaXMubG9jYWxpemUoJ01vZGFsIFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvclxuICAgKiBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHZhciBkZXNjID0gdGhpcy5vcHRpb25zXy5kZXNjcmlwdGlvbiB8fCB0aGlzLmxvY2FsaXplKCdUaGlzIGlzIGEgbW9kYWwgd2luZG93LicpO1xuXG4gICAgLy8gQXBwZW5kIGEgdW5pdmVyc2FsIGNsb3NlYWJpbGl0eSBtZXNzYWdlIGlmIHRoZSBtb2RhbCBpcyBjbG9zZWFibGUuXG4gICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIGRlc2MgKz0gJyAnICsgdGhpcy5sb2NhbGl6ZSgnVGhpcyBtb2RhbCBjYW4gYmUgY2xvc2VkIGJ5IHByZXNzaW5nIHRoZSBFc2NhcGUga2V5IG9yIGFjdGl2YXRpbmcgdGhlIGNsb3NlIGJ1dHRvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzYztcbiAgfTtcblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAbWV0aG9kIG9wZW5cbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkXykge1xuICAgICAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyKCk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxvcGVuJyk7XG4gICAgICB0aGlzLm9wZW5lZF8gPSB0cnVlO1xuXG4gICAgICAvLyBGaWxsIGNvbnRlbnQgaWYgdGhlIG1vZGFsIGhhcyBuZXZlciBvcGVuZWQgYmVmb3JlIGFuZFxuICAgICAgLy8gbmV2ZXIgYmVlbiBmaWxsZWQuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5maWxsQWx3YXlzIHx8ICF0aGlzLmhhc0JlZW5PcGVuZWRfICYmICF0aGlzLmhhc0JlZW5GaWxsZWRfKSB7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcGxheWVyIHdhcyBwbGF5aW5nLCBwYXVzZSBpdCBhbmQgdGFrZSBub3RlIG9mIGl0cyBwcmV2aW91c2x5XG4gICAgICAvLyBwbGF5aW5nIHN0YXRlLlxuICAgICAgdGhpcy53YXNQbGF5aW5nXyA9ICFwbGF5ZXIucGF1c2VkKCk7XG5cbiAgICAgIGlmICh0aGlzLndhc1BsYXlpbmdfKSB7XG4gICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgICB0aGlzLm9uKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgRm4uYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gICAgICB9XG5cbiAgICAgIHBsYXllci5jb250cm9scyhmYWxzZSk7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ21vZGFsb3BlbicpO1xuICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkXyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kYWwgaXMgb3BlbmVkIGN1cnJlbnRseS5cbiAgICpcbiAgICogQG1ldGhvZCBvcGVuZWRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGdpdmVuLCBpdCB3aWxsIG9wZW4gKGB0cnVlYCkgb3IgY2xvc2UgKGBmYWxzZWApIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW5lZCA9IGZ1bmN0aW9uIG9wZW5lZCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpc1t2YWx1ZSA/ICdvcGVuJyA6ICdjbG9zZSddKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wZW5lZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEBtZXRob2QgY2xvc2VcbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZF8pIHtcbiAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsY2xvc2UnKTtcbiAgICAgIHRoaXMub3BlbmVkXyA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy53YXNQbGF5aW5nXykge1xuICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgICB0aGlzLm9mZih0aGlzLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIEZuLmJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIuY29udHJvbHModHJ1ZSk7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignbW9kYWxjbG9zZScpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy50ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kYWwgaXMgY2xvc2VhYmxlIHZpYSB0aGUgVUkuXG4gICAqXG4gICAqIEBtZXRob2QgY2xvc2VhYmxlXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBnaXZlbiBhcyBhIEJvb2xlYW4sIGl0IHdpbGwgc2V0IHRoZSBgY2xvc2VhYmxlYCBvcHRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZWFibGUgPSBmdW5jdGlvbiBjbG9zZWFibGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHZhciBjbG9zZWFibGUgPSB0aGlzLmNsb3NlYWJsZV8gPSAhIXZhbHVlO1xuICAgICAgdmFyIF9jbG9zZSA9IHRoaXMuZ2V0Q2hpbGQoJ2Nsb3NlQnV0dG9uJyk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSBjbG9zZWFibGUgYW5kIGhhcyBubyBjbG9zZSBidXR0b24sIGFkZCBvbmUuXG4gICAgICBpZiAoY2xvc2VhYmxlICYmICFfY2xvc2UpIHtcblxuICAgICAgICAvLyBUaGUgY2xvc2UgYnV0dG9uIHNob3VsZCBiZSBhIGNoaWxkIG9mIHRoZSBtb2RhbCAtIG5vdCBpdHNcbiAgICAgICAgLy8gY29udGVudCBlbGVtZW50LCBzbyB0ZW1wb3JhcmlseSBjaGFuZ2UgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmNvbnRlbnRFbF87XG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRoaXMuZWxfO1xuICAgICAgICBfY2xvc2UgPSB0aGlzLmFkZENoaWxkKCdjbG9zZUJ1dHRvbicsIHsgY29udHJvbFRleHQ6ICdDbG9zZSBNb2RhbCBEaWFsb2cnIH0pO1xuICAgICAgICB0aGlzLmNvbnRlbnRFbF8gPSB0ZW1wO1xuICAgICAgICB0aGlzLm9uKF9jbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSB1bmNsb3NlYWJsZSBhbmQgaGFzIGEgY2xvc2UgYnV0dG9uLCByZW1vdmUgaXQuXG4gICAgICBpZiAoIWNsb3NlYWJsZSAmJiBfY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vZmYoX2Nsb3NlLCAnY2xvc2UnLCB0aGlzLmNsb3NlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChfY2xvc2UpO1xuICAgICAgICBfY2xvc2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZWFibGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIHRoZSBtb2RhbCdzIFwiY29udGVudFwiIG9wdGlvbi5cbiAgICpcbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKlxuICAgKiBAbWV0aG9kIGZpbGxcbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsV2l0aCh0aGlzLmNvbnRlbnQoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIG1vZGFsJ3MgY29udGVudCBlbGVtZW50IHdpdGggYXJiaXRyYXJ5IGNvbnRlbnQuXG4gICAqXG4gICAqIFRoZSBjb250ZW50IGVsZW1lbnQgd2lsbCBiZSBlbXB0aWVkIGJlZm9yZSB0aGlzIGNoYW5nZSB0YWtlcyBwbGFjZS5cbiAgICpcbiAgICogQG1ldGhvZCBmaWxsV2l0aFxuICAgKiBAcGFyYW0gIHtNaXhlZH0gW2NvbnRlbnRdXG4gICAqICAgICAgICAgVGhlIHNhbWUgcnVsZXMgYXBwbHkgdG8gdGhpcyBhcyBhcHBseSB0byB0aGUgYGNvbnRlbnRgIG9wdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsV2l0aCA9IGZ1bmN0aW9uIGZpbGxXaXRoKGNvbnRlbnQpIHtcbiAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwoKTtcbiAgICB2YXIgcGFyZW50RWwgPSBjb250ZW50RWwucGFyZW50Tm9kZTtcbiAgICB2YXIgbmV4dFNpYmxpbmdFbCA9IGNvbnRlbnRFbC5uZXh0U2libGluZztcblxuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxmaWxsJyk7XG4gICAgdGhpcy5oYXNCZWVuRmlsbGVkXyA9IHRydWU7XG5cbiAgICAvLyBEZXRhY2ggdGhlIGNvbnRlbnQgZWxlbWVudCBmcm9tIHRoZSBET00gYmVmb3JlIHBlcmZvcm1pbmdcbiAgICAvLyBtYW5pcHVsYXRpb24gdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBsaXZlIERPTSBtdWx0aXBsZSB0aW1lcy5cbiAgICBwYXJlbnRFbC5yZW1vdmVDaGlsZChjb250ZW50RWwpO1xuICAgIHRoaXMuZW1wdHkoKTtcbiAgICBEb20uaW5zZXJ0Q29udGVudChjb250ZW50RWwsIGNvbnRlbnQpO1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxmaWxsJyk7XG5cbiAgICAvLyBSZS1pbmplY3QgdGhlIHJlLWZpbGxlZCBjb250ZW50IGVsZW1lbnQuXG4gICAgaWYgKG5leHRTaWJsaW5nRWwpIHtcbiAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShjb250ZW50RWwsIG5leHRTaWJsaW5nRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbXB0aWVzIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqXG4gICAqIFRoaXMgaGFwcGVucyBhdXRvbWF0aWNhbGx5IGFueXRpbWUgdGhlIG1vZGFsIGlzIGZpbGxlZC5cbiAgICpcbiAgICogQG1ldGhvZCBlbXB0eVxuICAgKiBAcmV0dXJuIHtNb2RhbERpYWxvZ31cbiAgICovXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGVtcHR5Jyk7XG4gICAgRG9tLmVtcHR5RWwodGhpcy5jb250ZW50RWwoKSk7XG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGVtcHR5Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbW9kYWwgY29udGVudCwgd2hpY2ggZ2V0cyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiByZW5kZXJlZCBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIFRoaXMgZG9lcyBub3QgdXBkYXRlIHRoZSBET00gb3IgZmlsbCB0aGUgbW9kYWwsIGJ1dCBpdCBpcyBjYWxsZWQgZHVyaW5nXG4gICAqIHRoYXQgcHJvY2Vzcy5cbiAgICpcbiAgICogQG1ldGhvZCBjb250ZW50XG4gICAqIEBwYXJhbSAge01peGVkfSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZGVmaW5lZCwgc2V0cyB0aGUgaW50ZXJuYWwgY29udGVudCB2YWx1ZSB0byBiZSB1c2VkIG9uIHRoZVxuICAgKiAgICAgICAgIG5leHQgY2FsbChzKSB0byBgZmlsbGAuIFRoaXMgdmFsdWUgaXMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogICAgICAgICBpbnNlcnRlZC4gVG8gXCJjbGVhclwiIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlLCBwYXNzIGBudWxsYC5cbiAgICpcbiAgICogQHJldHVybiB7TWl4ZWR9XG4gICAqL1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmNvbnRlbnRfID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRfO1xuICB9O1xuXG4gIHJldHVybiBNb2RhbERpYWxvZztcbn0pKF9jb21wb25lbnQyWydkZWZhdWx0J10pO1xuXG5Nb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIHRlbXBvcmFyeTogdHJ1ZVxufTtcblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnTW9kYWxEaWFsb2cnLCBNb2RhbERpYWxvZyk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBNb2RhbERpYWxvZztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4vY2xvc2UtYnV0dG9uXCI6NjYsXCIuL2NvbXBvbmVudFwiOjY3LFwiLi91dGlscy9kb21cIjoxNDIsXCIuL3V0aWxzL2ZuXCI6MTQ0LFwiLi91dGlscy9sb2dcIjoxNDd9XSwxMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBwbGF5ZXIuanNcbiAqL1xuLy8gU3ViY2xhc3NlcyBDb21wb25lbnRcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi91dGlscy9ldmVudHMuanMnKTtcblxudmFyIEV2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0V2ZW50c0pzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG52YXIgX3V0aWxzR3VpZEpzID0gX2RlcmVxXygnLi91dGlscy9ndWlkLmpzJyk7XG5cbnZhciBHdWlkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzR3VpZEpzKTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4vdXRpbHMvYnJvd3Nlci5qcycpO1xuXG52YXIgYnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0Jyb3dzZXJKcyk7XG5cbnZhciBfdXRpbHNMb2dKcyA9IF9kZXJlcV8oJy4vdXRpbHMvbG9nLmpzJyk7XG5cbnZhciBfdXRpbHNMb2dKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0xvZ0pzKTtcblxudmFyIF91dGlsc1RvVGl0bGVDYXNlSnMgPSBfZGVyZXFfKCcuL3V0aWxzL3RvLXRpdGxlLWNhc2UuanMnKTtcblxudmFyIF91dGlsc1RvVGl0bGVDYXNlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNUb1RpdGxlQ2FzZUpzKTtcblxudmFyIF91dGlsc1RpbWVSYW5nZXNKcyA9IF9kZXJlcV8oJy4vdXRpbHMvdGltZS1yYW5nZXMuanMnKTtcblxudmFyIF91dGlsc0J1ZmZlckpzID0gX2RlcmVxXygnLi91dGlscy9idWZmZXIuanMnKTtcblxudmFyIF91dGlsc1N0eWxlc2hlZXRKcyA9IF9kZXJlcV8oJy4vdXRpbHMvc3R5bGVzaGVldC5qcycpO1xuXG52YXIgc3R5bGVzaGVldCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc1N0eWxlc2hlZXRKcyk7XG5cbnZhciBfZnVsbHNjcmVlbkFwaUpzID0gX2RlcmVxXygnLi9mdWxsc2NyZWVuLWFwaS5qcycpO1xuXG52YXIgX2Z1bGxzY3JlZW5BcGlKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mdWxsc2NyZWVuQXBpSnMpO1xuXG52YXIgX21lZGlhRXJyb3JKcyA9IF9kZXJlcV8oJy4vbWVkaWEtZXJyb3IuanMnKTtcblxudmFyIF9tZWRpYUVycm9ySnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVkaWFFcnJvckpzKTtcblxudmFyIF9zYWZlSnNvblBhcnNlVHVwbGUgPSBfZGVyZXFfKCdzYWZlLWpzb24tcGFyc2UvdHVwbGUnKTtcblxudmFyIF9zYWZlSnNvblBhcnNlVHVwbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2FmZUpzb25QYXJzZVR1cGxlKTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QuYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfdXRpbHNNZXJnZU9wdGlvbnNKcyA9IF9kZXJlcV8oJy4vdXRpbHMvbWVyZ2Utb3B0aW9ucy5qcycpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNNZXJnZU9wdGlvbnNKcyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrTGlzdENvbnZlcnRlckpzID0gX2RlcmVxXygnLi90cmFja3MvdGV4dC10cmFjay1saXN0LWNvbnZlcnRlci5qcycpO1xuXG52YXIgX3RyYWNrc1RleHRUcmFja0xpc3RDb252ZXJ0ZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja3NUZXh0VHJhY2tMaXN0Q29udmVydGVySnMpO1xuXG52YXIgX3RyYWNrc0F1ZGlvVHJhY2tMaXN0SnMgPSBfZGVyZXFfKCcuL3RyYWNrcy9hdWRpby10cmFjay1saXN0LmpzJyk7XG5cbnZhciBfdHJhY2tzQXVkaW9UcmFja0xpc3RKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja3NBdWRpb1RyYWNrTGlzdEpzKTtcblxudmFyIF90cmFja3NWaWRlb1RyYWNrTGlzdEpzID0gX2RlcmVxXygnLi90cmFja3MvdmlkZW8tdHJhY2stbGlzdC5qcycpO1xuXG52YXIgX3RyYWNrc1ZpZGVvVHJhY2tMaXN0SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzVmlkZW9UcmFja0xpc3RKcyk7XG5cbi8vIEluY2x1ZGUgcmVxdWlyZWQgY2hpbGQgY29tcG9uZW50cyAoaW1wb3J0aW5nIGFsc28gcmVnaXN0ZXJzIHRoZW0pXG5cbnZhciBfdGVjaExvYWRlckpzID0gX2RlcmVxXygnLi90ZWNoL2xvYWRlci5qcycpO1xuXG52YXIgX3RlY2hMb2FkZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZWNoTG9hZGVySnMpO1xuXG52YXIgX3Bvc3RlckltYWdlSnMgPSBfZGVyZXFfKCcuL3Bvc3Rlci1pbWFnZS5qcycpO1xuXG52YXIgX3Bvc3RlckltYWdlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zdGVySW1hZ2VKcyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrRGlzcGxheUpzID0gX2RlcmVxXygnLi90cmFja3MvdGV4dC10cmFjay1kaXNwbGF5LmpzJyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrRGlzcGxheUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYWNrc1RleHRUcmFja0Rpc3BsYXlKcyk7XG5cbnZhciBfbG9hZGluZ1NwaW5uZXJKcyA9IF9kZXJlcV8oJy4vbG9hZGluZy1zcGlubmVyLmpzJyk7XG5cbnZhciBfbG9hZGluZ1NwaW5uZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkaW5nU3Bpbm5lckpzKTtcblxudmFyIF9iaWdQbGF5QnV0dG9uSnMgPSBfZGVyZXFfKCcuL2JpZy1wbGF5LWJ1dHRvbi5qcycpO1xuXG52YXIgX2JpZ1BsYXlCdXR0b25KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaWdQbGF5QnV0dG9uSnMpO1xuXG52YXIgX2NvbnRyb2xCYXJDb250cm9sQmFySnMgPSBfZGVyZXFfKCcuL2NvbnRyb2wtYmFyL2NvbnRyb2wtYmFyLmpzJyk7XG5cbnZhciBfY29udHJvbEJhckNvbnRyb2xCYXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250cm9sQmFyQ29udHJvbEJhckpzKTtcblxudmFyIF9lcnJvckRpc3BsYXlKcyA9IF9kZXJlcV8oJy4vZXJyb3ItZGlzcGxheS5qcycpO1xuXG52YXIgX2Vycm9yRGlzcGxheUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Vycm9yRGlzcGxheUpzKTtcblxudmFyIF90cmFja3NUZXh0VHJhY2tTZXR0aW5nc0pzID0gX2RlcmVxXygnLi90cmFja3MvdGV4dC10cmFjay1zZXR0aW5ncy5qcycpO1xuXG52YXIgX3RyYWNrc1RleHRUcmFja1NldHRpbmdzSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzVGV4dFRyYWNrU2V0dGluZ3NKcyk7XG5cbnZhciBfbW9kYWxEaWFsb2cgPSBfZGVyZXFfKCcuL21vZGFsLWRpYWxvZycpO1xuXG52YXIgX21vZGFsRGlhbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZGFsRGlhbG9nKTtcblxuLy8gUmVxdWlyZSBodG1sNSB0ZWNoLCBhdCBsZWFzdCBmb3IgZGlzcG9zaW5nIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWdcblxudmFyIF90ZWNoVGVjaEpzID0gX2RlcmVxXygnLi90ZWNoL3RlY2guanMnKTtcblxudmFyIF90ZWNoVGVjaEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RlY2hUZWNoSnMpO1xuXG52YXIgX3RlY2hIdG1sNUpzID0gX2RlcmVxXygnLi90ZWNoL2h0bWw1LmpzJyk7XG5cbnZhciBfdGVjaEh0bWw1SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGVjaEh0bWw1SnMpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBgUGxheWVyYCBjbGFzcyBpcyBjcmVhdGVkIHdoZW4gYW55IG9mIHRoZSBWaWRlby5qcyBzZXR1cCBtZXRob2RzIGFyZSB1c2VkIHRvIGluaXRpYWxpemUgYSB2aWRlby5cbiAqIGBgYGpzXG4gKiB2YXIgbXlQbGF5ZXIgPSB2aWRlb2pzKCdleGFtcGxlX3ZpZGVvXzEnKTtcbiAqIGBgYFxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB0aGUgYGRhdGEtc2V0dXBgIGF0dHJpYnV0ZSB0ZWxscyB0aGUgVmlkZW8uanMgbGlicmFyeSB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2Ugd2hlbiB0aGUgbGlicmFyeSBpcyByZWFkeS5cbiAqIGBgYGh0bWxcbiAqIDx2aWRlbyBpZD1cImV4YW1wbGVfdmlkZW9fMVwiIGRhdGEtc2V0dXA9J3t9JyBjb250cm9scz5cbiAqICAgPHNvdXJjZSBzcmM9XCJteS1zb3VyY2UubXA0XCIgdHlwZT1cInZpZGVvL21wNFwiPlxuICogPC92aWRlbz5cbiAqIGBgYFxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgdXNpbmcgYFZpZGVvKCdleGFtcGxlX3ZpZGVvXzEnKWAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YWcgICAgICAgIFRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgdXNlZCBmb3IgY29uZmlndXJpbmcgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5ICAgIFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBQbGF5ZXJcbiAqL1xuXG52YXIgUGxheWVyID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQbGF5ZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBwbGF5ZXIncyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgKlxuICAgKiBAY29uc3RydWN0c1xuICAgKiBAbWV0aG9kIGluaXRcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWcgICAgICAgIFRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgdXNlZCBmb3IgY29uZmlndXJpbmcgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgICAgUGxheWVyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5ICAgIFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFBsYXllcih0YWcsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5ZXIpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRhZyBJRCBleGlzdHNcbiAgICB0YWcuaWQgPSB0YWcuaWQgfHwgJ3Zqc192aWRlb18nICsgR3VpZC5uZXdHVUlEKCk7XG5cbiAgICAvLyBTZXQgT3B0aW9uc1xuICAgIC8vIFRoZSBvcHRpb25zIGFyZ3VtZW50IG92ZXJyaWRlcyBvcHRpb25zIHNldCBpbiB0aGUgdmlkZW8gdGFnXG4gICAgLy8gd2hpY2ggb3ZlcnJpZGVzIGdsb2JhbGx5IHNldCBvcHRpb25zLlxuICAgIC8vIFRoaXMgbGF0dGVyIHBhcnQgY29pbmNpZGVzIHdpdGggdGhlIGxvYWQgb3JkZXJcbiAgICAvLyAodGFnIG11c3QgZXhpc3QgYmVmb3JlIFBsYXllcilcbiAgICBvcHRpb25zID0gX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXShQbGF5ZXIuZ2V0VGFnU2V0dGluZ3ModGFnKSwgb3B0aW9ucyk7XG5cbiAgICAvLyBEZWxheSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGRyZW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHNldCB1cFxuICAgIC8vIHBsYXllciBwcm9wZXJ0aWVzIGZpcnN0LCBhbmQgY2FuJ3QgdXNlIGB0aGlzYCBiZWZvcmUgYHN1cGVyKClgXG4gICAgb3B0aW9ucy5pbml0Q2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIC8vIFNhbWUgd2l0aCBjcmVhdGluZyB0aGUgZWxlbWVudFxuICAgIG9wdGlvbnMuY3JlYXRlRWwgPSBmYWxzZTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHBsYXllciB0byByZXBvcnQgdG91Y2ggYWN0aXZpdHkgb24gaXRzZWxmXG4gICAgLy8gc2VlIGVuYWJsZVRvdWNoQWN0aXZpdHkgaW4gQ29tcG9uZW50XG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG5cbiAgICAvLyBJZiBsYW5ndWFnZSBpcyBub3Qgc2V0LCBnZXQgdGhlIGNsb3Nlc3QgbGFuZyBhdHRyaWJ1dGVcbiAgICBpZiAoIW9wdGlvbnMubGFuZ3VhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnLmNsb3Nlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSB0YWcuY2xvc2VzdCgnW2xhbmddJyk7XG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGFnO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgaWYgKERvbS5nZXRFbEF0dHJpYnV0ZXMoZWxlbWVudCkuaGFzT3duUHJvcGVydHkoJ2xhbmcnKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1biBiYXNlIGNvbXBvbmVudCBpbml0aWFsaXppbmcgd2l0aCBuZXcgb3B0aW9uc1xuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgICAvLyBpZiB0aGUgZ2xvYmFsIG9wdGlvbiBvYmplY3Qgd2FzIGFjY2lkZW50YWxseSBibG93biBhd2F5IGJ5XG4gICAgLy8gc29tZW9uZSwgYmFpbCBlYXJseSB3aXRoIGFuIGluZm9ybWF0aXZlIGVycm9yXG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfIHx8ICF0aGlzLm9wdGlvbnNfLnRlY2hPcmRlciB8fCAhdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRlY2hPcmRlciBzcGVjaWZpZWQuIERpZCB5b3Ugb3ZlcndyaXRlICcgKyAndmlkZW9qcy5vcHRpb25zIGluc3RlYWQgb2YganVzdCBjaGFuZ2luZyB0aGUgJyArICdwcm9wZXJ0aWVzIHlvdSB3YW50IHRvIG92ZXJyaWRlPycpO1xuICAgIH1cblxuICAgIHRoaXMudGFnID0gdGFnOyAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgdGFnIHVzZWQgdG8gc2V0IG9wdGlvbnNcblxuICAgIC8vIFN0b3JlIHRoZSB0YWcgYXR0cmlidXRlcyB1c2VkIHRvIHJlc3RvcmUgaHRtbDUgZWxlbWVudFxuICAgIHRoaXMudGFnQXR0cmlidXRlcyA9IHRhZyAmJiBEb20uZ2V0RWxBdHRyaWJ1dGVzKHRhZyk7XG5cbiAgICAvLyBVcGRhdGUgY3VycmVudCBsYW5ndWFnZVxuICAgIHRoaXMubGFuZ3VhZ2UodGhpcy5vcHRpb25zXy5sYW5ndWFnZSk7XG5cbiAgICAvLyBVcGRhdGUgU3VwcG9ydGVkIExhbmd1YWdlc1xuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlcykge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm9ybWFsaXNlIHBsYXllciBvcHRpb24gbGFuZ3VhZ2VzIHRvIGxvd2VyY2FzZVxuICAgICAgICB2YXIgbGFuZ3VhZ2VzVG9Mb3dlciA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMubGFuZ3VhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgbGFuZ3VhZ2VzVG9Mb3dlcltuYW1lLnRvTG93ZXJDYXNlKCldID0gb3B0aW9ucy5sYW5ndWFnZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5sYW5ndWFnZXNfID0gbGFuZ3VhZ2VzVG9Mb3dlcjtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzXyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzO1xuICAgIH1cblxuICAgIC8vIENhY2hlIGZvciB2aWRlbyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgdGhpcy5jYWNoZV8gPSB7fTtcblxuICAgIC8vIFNldCBwb3N0ZXJcbiAgICB0aGlzLnBvc3Rlcl8gPSBvcHRpb25zLnBvc3RlciB8fCAnJztcblxuICAgIC8vIFNldCBjb250cm9sc1xuICAgIHRoaXMuY29udHJvbHNfID0gISFvcHRpb25zLmNvbnRyb2xzO1xuXG4gICAgLy8gT3JpZ2luYWwgdGFnIHNldHRpbmdzIHN0b3JlZCBpbiBvcHRpb25zXG4gICAgLy8gbm93IHJlbW92ZSBpbW1lZGlhdGVseSBzbyBuYXRpdmUgY29udHJvbHMgZG9uJ3QgZmxhc2guXG4gICAgLy8gTWF5IGJlIHR1cm5lZCBiYWNrIG9uIGJ5IEhUTUw1IHRlY2ggaWYgbmF0aXZlQ29udHJvbHNGb3JUb3VjaCBpcyB0cnVlXG4gICAgdGFnLmNvbnRyb2xzID0gZmFsc2U7XG5cbiAgICAvKlxuICAgICAqIFN0b3JlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBzY3J1YmJpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyBzY3J1YmJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuXG4gICAgLy8gV2UgYWxzbyB3YW50IHRvIHBhc3MgdGhlIG9yaWdpbmFsIHBsYXllciBvcHRpb25zIHRvIGVhY2ggY29tcG9uZW50IGFuZCBwbHVnaW5cbiAgICAvLyBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0byByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gZG8gYW5vdGhlciBjb3B5IG9mIHRoaXMub3B0aW9uc18gc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGhcbiAgICAvLyBhbiBpbmZpbml0ZSBsb29wLlxuICAgIHZhciBwbGF5ZXJPcHRpb25zQ29weSA9IF91dGlsc01lcmdlT3B0aW9uc0pzMlsnZGVmYXVsdCddKHRoaXMub3B0aW9uc18pO1xuXG4gICAgLy8gTG9hZCBwbHVnaW5zXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7XG5cbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpc1tuYW1lXShwbHVnaW5zW25hbWVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10uZXJyb3IoJ1VuYWJsZSB0byBmaW5kIHBsdWdpbjonLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF90aGlzKTtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zID0gcGxheWVyT3B0aW9uc0NvcHk7XG5cbiAgICB0aGlzLmluaXRDaGlsZHJlbigpO1xuXG4gICAgLy8gU2V0IGlzQXVkaW8gYmFzZWQgb24gd2hldGhlciBvciBub3QgYW4gYXVkaW8gdGFnIHdhcyB1c2VkXG4gICAgdGhpcy5pc0F1ZGlvKHRhZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8nKTtcblxuICAgIC8vIFVwZGF0ZSBjb250cm9scyBjbGFzc05hbWUuIENhbid0IGRvIHRoaXMgd2hlbiB0aGUgY29udHJvbHMgYXJlIGluaXRpYWxseVxuICAgIC8vIHNldCBiZWNhdXNlIHRoZSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIC8vIFNldCBBUklBIGxhYmVsIGFuZCByZWdpb24gcm9sZSBkZXBlbmRpbmcgb24gcGxheWVyIHR5cGVcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncmVnaW9uJyk7XG4gICAgaWYgKHRoaXMuaXNBdWRpbygpKSB7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnYXVkaW8gcGxheWVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICd2aWRlbyBwbGF5ZXInKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0F1ZGlvKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1hdWRpbycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZsZXhOb3RTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1uby1mbGV4Jyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIHNtYXJ0ZXIuIFRvZ2dsZSB1c2VyIHN0YXRlIGJldHdlZW4gdG91Y2hpbmcvbW91c2luZ1xuICAgIC8vIHVzaW5nIGV2ZW50cywgc2luY2UgZGV2aWNlcyBjYW4gaGF2ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHMuXG4gICAgLy8gaWYgKGJyb3dzZXIuVE9VQ0hfRU5BQkxFRCkge1xuICAgIC8vICAgdGhpcy5hZGRDbGFzcygndmpzLXRvdWNoLWVuYWJsZWQnKTtcbiAgICAvLyB9XG5cbiAgICAvLyBpT1MgU2FmYXJpIGhhcyBicm9rZW4gaG92ZXIgaGFuZGxpbmdcbiAgICBpZiAoIWJyb3dzZXIuSVNfSU9TKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtd29ya2luZ2hvdmVyJyk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZWFzaWx5IGZpbmRhYmxlIGJ5IElEXG4gICAgUGxheWVyLnBsYXllcnNbdGhpcy5pZF9dID0gdGhpcztcblxuICAgIC8vIFdoZW4gdGhlIHBsYXllciBpcyBmaXJzdCBpbml0aWFsaXplZCwgdHJpZ2dlciBhY3Rpdml0eSBzbyBjb21wb25lbnRzXG4gICAgLy8gbGlrZSB0aGUgY29udHJvbCBiYXIgc2hvdyB0aGVtc2VsdmVzIGlmIG5lZWRlZFxuICAgIHRoaXMudXNlckFjdGl2ZSh0cnVlKTtcbiAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIHRoaXMubGlzdGVuRm9yVXNlckFjdGl2aXR5XygpO1xuXG4gICAgdGhpcy5vbignZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8pO1xuICAgIHRoaXMub24oJ3N0YWdlY2xpY2snLCB0aGlzLmhhbmRsZVN0YWdlQ2xpY2tfKTtcbiAgfVxuXG4gIC8qXG4gICAqIEdsb2JhbCBwbGF5ZXIgbGlzdFxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHZpZGVvIHBsYXllciBhbmQgZG9lcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXBcbiAgICogYGBganNcbiAgICogICAgIG15UGxheWVyLmRpc3Bvc2UoKTtcbiAgICogYGBgXG4gICAqIFRoaXMgaXMgZXNwZWNpYWxseSBoZWxwZnVsIGlmIHlvdSBhcmUgZHluYW1pY2FsbHkgYWRkaW5nIGFuZCByZW1vdmluZyB2aWRlb3NcbiAgICogdG8vZnJvbSB0aGUgRE9NLlxuICAgKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcbiAgICAvLyBwcmV2ZW50IGRpc3Bvc2UgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICB0aGlzLm9mZignZGlzcG9zZScpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGVFbF8gJiYgdGhpcy5zdHlsZUVsXy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdHlsZUVsXyk7XG4gICAgfVxuXG4gICAgLy8gS2lsbCByZWZlcmVuY2UgdG8gdGhpcyBwbGF5ZXJcbiAgICBQbGF5ZXIucGxheWVyc1t0aGlzLmlkX10gPSBudWxsO1xuICAgIGlmICh0aGlzLnRhZyAmJiB0aGlzLnRhZy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsXyA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicpO1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZztcblxuICAgIC8vIFJlbW92ZSB3aWR0aC9oZWlnaHQgYXR0cnMgZnJvbSB0YWcgc28gQ1NTIGNhbiBtYWtlIGl0IDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gRG9tLmdldEVsQXR0cmlidXRlcyh0YWcpO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgc28gd2UgZG9uJ3QgdG90YWxseSBicmVhayBJRTdcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cnNbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRhZyBpZC9jbGFzcyBmb3IgdXNlIGFzIEhUTUw1IHBsYXliYWNrIHRlY2hcbiAgICAvLyBNaWdodCB0aGluayB3ZSBzaG91bGQgZG8gdGhpcyBhZnRlciBlbWJlZGRpbmcgaW4gY29udGFpbmVyIHNvIC52anMtdGVjaCBjbGFzc1xuICAgIC8vIGRvZXNuJ3QgZmxhc2ggMTAwJSB3aWR0aC9oZWlnaHQsIGJ1dCBjbGFzcyBvbmx5IGFwcGxpZXMgd2l0aCAudmlkZW8tanMgcGFyZW50XG4gICAgdGFnLnBsYXllcklkID0gdGFnLmlkO1xuICAgIHRhZy5pZCArPSAnX2h0bWw1X2FwaSc7XG4gICAgdGFnLmNsYXNzTmFtZSA9ICd2anMtdGVjaCc7XG5cbiAgICAvLyBNYWtlIHBsYXllciBmaW5kYWJsZSBvbiBlbGVtZW50c1xuICAgIHRhZy5wbGF5ZXIgPSBlbC5wbGF5ZXIgPSB0aGlzO1xuICAgIC8vIERlZmF1bHQgc3RhdGUgb2YgdmlkZW8gaXMgcGF1c2VkXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuXG4gICAgLy8gQWRkIGEgc3R5bGUgZWxlbWVudCBpbiB0aGUgcGxheWVyIHRoYXQgd2UnbGwgdXNlIHRvIHNldCB0aGUgd2lkdGgvaGVpZ2h0XG4gICAgLy8gb2YgdGhlIHBsYXllciBpbiBhIHdheSB0aGF0J3Mgc3RpbGwgb3ZlcnJpZGVhYmxlIGJ5IENTUywganVzdCBsaWtlIHRoZVxuICAgIC8vIHZpZGVvIGVsZW1lbnRcbiAgICBpZiAoX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBzdHlsZXNoZWV0LmNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZGVmYXVsdHNTdHlsZUVsID0gRG9tLiQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgICB2YXIgaGVhZCA9IERvbS4kKCdoZWFkJyk7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZSh0aGlzLnN0eWxlRWxfLCBkZWZhdWx0c1N0eWxlRWwgPyBkZWZhdWx0c1N0eWxlRWwubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIC8vIFBhc3MgaW4gdGhlIHdpZHRoL2hlaWdodC9hc3BlY3RSYXRpbyBvcHRpb25zIHdoaWNoIHdpbGwgdXBkYXRlIHRoZSBzdHlsZSBlbFxuICAgIHRoaXMud2lkdGgodGhpcy5vcHRpb25zXy53aWR0aCk7XG4gICAgdGhpcy5oZWlnaHQodGhpcy5vcHRpb25zXy5oZWlnaHQpO1xuICAgIHRoaXMuZmx1aWQodGhpcy5vcHRpb25zXy5mbHVpZCk7XG4gICAgdGhpcy5hc3BlY3RSYXRpbyh0aGlzLm9wdGlvbnNfLmFzcGVjdFJhdGlvKTtcblxuICAgIC8vIEhpZGUgYW55IGxpbmtzIHdpdGhpbiB0aGUgdmlkZW8vYXVkaW8gdGFnLCBiZWNhdXNlIElFIGRvZXNuJ3QgaGlkZSB0aGVtIGNvbXBsZXRlbHkuXG4gICAgdmFyIGxpbmtzID0gdGFnLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmtFbCA9IGxpbmtzLml0ZW0oaSk7XG4gICAgICBEb20uYWRkRWxDbGFzcyhsaW5rRWwsICd2anMtaGlkZGVuJyk7XG4gICAgICBsaW5rRWwuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0RWxGaXJzdCBzZWVtcyB0byBjYXVzZSB0aGUgbmV0d29ya1N0YXRlIHRvIGZsaWNrZXIgZnJvbSAzIHRvIDIsIHNvXG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgb3JpZ2luYWwgZm9yIGxhdGVyIHNvIHdlIGNhbiBrbm93IGlmIHRoZSBzb3VyY2Ugb3JpZ2luYWxseSBmYWlsZWRcbiAgICB0YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPSB0YWcubmV0d29ya1N0YXRlO1xuXG4gICAgLy8gV3JhcCB2aWRlbyB0YWcgaW4gZGl2IChlbC9ib3gpIGNvbnRhaW5lclxuICAgIGlmICh0YWcucGFyZW50Tm9kZSkge1xuICAgICAgdGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YWcpO1xuICAgIH1cblxuICAgIC8vIGluc2VydCB0aGUgdGFnIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCBpdCB0byB0aGUgY2hpbGRyZW4gYXJyYXkgc28gdGhhdCB0aGlzLmFkZENoaWxkXG4gICAgLy8gd2lsbCB3b3JrIHByb3Blcmx5IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgRG9tLmluc2VydEVsRmlyc3QodGFnLCBlbCk7IC8vIEJyZWFrcyBpUGhvbmUsIGZpeGVkIGluIEhUTUw1IHNldHVwLlxuICAgIHRoaXMuY2hpbGRyZW5fLnVuc2hpZnQodGFnKTtcblxuICAgIHRoaXMuZWxfID0gZWw7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgcGxheWVyIHdpZHRoXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gdmFsdWUgVmFsdWUgZm9yIHdpZHRoXG4gICAqIEByZXR1cm4ge051bWJlcn0gV2lkdGggd2hlbiBnZXR0aW5nXG4gICAqIEBtZXRob2Qgd2lkdGhcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCd3aWR0aCcsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCBwbGF5ZXIgaGVpZ2h0XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gdmFsdWUgVmFsdWUgZm9yIGhlaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEhlaWdodCB3aGVuIGdldHRpbmdcbiAgICogQG1ldGhvZCBoZWlnaHRcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiBoZWlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ2hlaWdodCcsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCBkaW1lbnNpb24gZm9yIHBsYXllclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGltZW5zaW9uIEVpdGhlciB3aWR0aCBvciBoZWlnaHRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSB2YWx1ZSBWYWx1ZSBmb3IgZGltZW5zaW9uXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQG1ldGhvZCBkaW1lbnNpb25cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiBkaW1lbnNpb24oX2RpbWVuc2lvbiwgdmFsdWUpIHtcbiAgICB2YXIgcHJpdkRpbWVuc2lvbiA9IF9kaW1lbnNpb24gKyAnXyc7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJpdkRpbWVuc2lvbl0gfHwgMDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAvLyBJZiBhbiBlbXB0eSBzdHJpbmcgaXMgZ2l2ZW4sIHJlc2V0IHRoZSBkaW1lbnNpb24gdG8gYmUgYXV0b21hdGljXG4gICAgICB0aGlzW3ByaXZEaW1lbnNpb25dID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VkVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc05hTihwYXJzZWRWYWwpKSB7XG4gICAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLmVycm9yKCdJbXByb3BlciB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBzdXBwbGllZCBmb3IgZm9yICcgKyBfZGltZW5zaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbcHJpdkRpbWVuc2lvbl0gPSBwYXJzZWRWYWw7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQvcmVtb3ZlIHRoZSB2anMtZmx1aWQgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBib29sIFZhbHVlIG9mIHRydWUgYWRkcyB0aGUgY2xhc3MsIHZhbHVlIG9mIGZhbHNlIHJlbW92ZXMgdGhlIGNsYXNzXG4gICAqIEBtZXRob2QgZmx1aWRcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5mbHVpZCA9IGZ1bmN0aW9uIGZsdWlkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmZsdWlkXztcbiAgICB9XG5cbiAgICB0aGlzLmZsdWlkXyA9ICEhYm9vbDtcblxuICAgIGlmIChib29sKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtZmx1aWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvU2V0IHRoZSBhc3BlY3QgcmF0aW9cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSByYXRpbyBBc3BlY3QgcmF0aW8gZm9yIHBsYXllclxuICAgKiBAcmV0dXJuIGFzcGVjdFJhdGlvXG4gICAqIEBtZXRob2QgYXNwZWN0UmF0aW9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igd2lkdGg6aGVpZ2h0IGZvcm1hdFxuICAgIGlmICghL15cXGQrXFw6XFxkKyQvLnRlc3QocmF0aW8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcHJvcGVyIHZhbHVlIHN1cHBsaWVkIGZvciBhc3BlY3QgcmF0aW8uIFRoZSBmb3JtYXQgc2hvdWxkIGJlIHdpZHRoOmhlaWdodCwgZm9yIGV4YW1wbGUgMTY6OS4nKTtcbiAgICB9XG4gICAgdGhpcy5hc3BlY3RSYXRpb18gPSByYXRpbztcblxuICAgIC8vIFdlJ3JlIGFzc3VtaW5nIGlmIHlvdSBzZXQgYW4gYXNwZWN0IHJhdGlvIHlvdSB3YW50IGZsdWlkIG1vZGUsXG4gICAgLy8gYmVjYXVzZSBpbiBmaXhlZCBtb2RlIHlvdSBjb3VsZCBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCB5b3Vyc2VsZi5cbiAgICB0aGlzLmZsdWlkKHRydWUpO1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3R5bGVzIG9mIHRoZSBwbGF5ZXIgZWxlbWVudCAoaGVpZ2h0LCB3aWR0aCBhbmQgYXNwZWN0IHJhdGlvKVxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVN0eWxlRWxfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUudXBkYXRlU3R5bGVFbF8gPSBmdW5jdGlvbiB1cGRhdGVTdHlsZUVsXygpIHtcbiAgICBpZiAoX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgPT09IHRydWUpIHtcbiAgICAgIHZhciBfd2lkdGggPSB0eXBlb2YgdGhpcy53aWR0aF8gPT09ICdudW1iZXInID8gdGhpcy53aWR0aF8gOiB0aGlzLm9wdGlvbnNfLndpZHRoO1xuICAgICAgdmFyIF9oZWlnaHQgPSB0eXBlb2YgdGhpcy5oZWlnaHRfID09PSAnbnVtYmVyJyA/IHRoaXMuaGVpZ2h0XyA6IHRoaXMub3B0aW9uc18uaGVpZ2h0O1xuICAgICAgdmFyIHRlY2hFbCA9IHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5lbCgpO1xuXG4gICAgICBpZiAodGVjaEVsKSB7XG4gICAgICAgIGlmIChfd2lkdGggPj0gMCkge1xuICAgICAgICAgIHRlY2hFbC53aWR0aCA9IF93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2hlaWdodCA+PSAwKSB7XG4gICAgICAgICAgdGVjaEVsLmhlaWdodCA9IF9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgaWRDbGFzcyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIFRoZSBhc3BlY3QgcmF0aW8gaXMgZWl0aGVyIHVzZWQgZGlyZWN0bHkgb3IgdG8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgaWYgKHRoaXMuYXNwZWN0UmF0aW9fICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hc3BlY3RSYXRpb18gIT09ICdhdXRvJykge1xuICAgICAgLy8gVXNlIGFueSBhc3BlY3RSYXRpbyB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICBhc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW9fO1xuICAgIH0gZWxzZSBpZiAodGhpcy52aWRlb1dpZHRoKCkpIHtcbiAgICAgIC8vIE90aGVyd2lzZSB0cnkgdG8gZ2V0IHRoZSBhc3BlY3QgcmF0aW8gZnJvbSB0aGUgdmlkZW8gbWV0YWRhdGFcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1dpZHRoKCkgKyAnOicgKyB0aGlzLnZpZGVvSGVpZ2h0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSBhIGRlZmF1bHQuIFRoZSB2aWRlbyBlbGVtZW50J3MgaXMgMjoxLCBidXQgMTY6OSBpcyBtb3JlIGNvbW1vbi5cbiAgICAgIGFzcGVjdFJhdGlvID0gJzE2OjknO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgcmF0aW8gYXMgYSBkZWNpbWFsIHdlIGNhbiB1c2UgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnNcbiAgICB2YXIgcmF0aW9QYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgdmFyIHJhdGlvTXVsdGlwbGllciA9IHJhdGlvUGFydHNbMV0gLyByYXRpb1BhcnRzWzBdO1xuXG4gICAgaWYgKHRoaXMud2lkdGhfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgd2lkdGggdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgd2lkdGggPSB0aGlzLndpZHRoXztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPciBjYWx1bGF0ZSB0aGUgd2lkdGggZnJvbSB0aGUgYXNwZWN0IHJhdGlvIGlmIGEgaGVpZ2h0IGhhcyBiZWVuIHNldFxuICAgICAgd2lkdGggPSB0aGlzLmhlaWdodF8gLyByYXRpb011bHRpcGxpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSB0aGUgdmlkZW8ncyBtZXRhZGF0YSwgb3IgdXNlIHRoZSB2aWRlbyBlbCdzIGRlZmF1bHQgb2YgMzAwXG4gICAgICB3aWR0aCA9IHRoaXMudmlkZW9XaWR0aCgpIHx8IDMwMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgaGVpZ2h0IHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0XztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZyb20gdGhlIHJhdGlvIGFuZCB0aGUgd2lkdGhcbiAgICAgIGhlaWdodCA9IHdpZHRoICogcmF0aW9NdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgQ1NTIGNsYXNzIGlzIHZhbGlkIGJ5IHN0YXJ0aW5nIHdpdGggYW4gYWxwaGEgY2hhcmFjdGVyXG4gICAgaWYgKC9eW15hLXpBLVpdLy50ZXN0KHRoaXMuaWQoKSkpIHtcbiAgICAgIGlkQ2xhc3MgPSAnZGltZW5zaW9ucy0nICsgdGhpcy5pZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZENsYXNzID0gdGhpcy5pZCgpICsgJy1kaW1lbnNpb25zJztcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIHJpZ2h0IGNsYXNzIGlzIHN0aWxsIG9uIHRoZSBwbGF5ZXIgZm9yIHRoZSBzdHlsZSBlbGVtZW50XG4gICAgdGhpcy5hZGRDbGFzcyhpZENsYXNzKTtcblxuICAgIHN0eWxlc2hlZXQuc2V0VGV4dENvbnRlbnQodGhpcy5zdHlsZUVsXywgJ1xcbiAgICAgIC4nICsgaWRDbGFzcyArICcge1xcbiAgICAgICAgd2lkdGg6ICcgKyB3aWR0aCArICdweDtcXG4gICAgICAgIGhlaWdodDogJyArIGhlaWdodCArICdweDtcXG4gICAgICB9XFxuXFxuICAgICAgLicgKyBpZENsYXNzICsgJy52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6ICcgKyByYXRpb011bHRpcGxpZXIgKiAxMDAgKyAnJTtcXG4gICAgICB9XFxuICAgICcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBNZWRpYSBQbGF5YmFjayBUZWNobm9sb2d5ICh0ZWNoKVxuICAgKiBMb2FkL0NyZWF0ZSBhbiBpbnN0YW5jZSBvZiBwbGF5YmFjayB0ZWNobm9sb2d5IGluY2x1ZGluZyBlbGVtZW50IGFuZCBBUEkgbWV0aG9kc1xuICAgKiBBbmQgYXBwZW5kIHBsYXliYWNrIGVsZW1lbnQgaW4gcGxheWVyIGRpdi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlY2hOYW1lIE5hbWUgb2YgdGhlIHBsYXliYWNrIHRlY2hub2xvZ3lcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSBWaWRlbyBzb3VyY2VcbiAgICogQG1ldGhvZCBsb2FkVGVjaF9cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb2FkVGVjaF8gPSBmdW5jdGlvbiBsb2FkVGVjaF8odGVjaE5hbWUsIHNvdXJjZSkge1xuXG4gICAgLy8gUGF1c2UgYW5kIHJlbW92ZSBjdXJyZW50IHBsYXliYWNrIHRlY2hub2xvZ3lcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgdGhpcy51bmxvYWRUZWNoXygpO1xuICAgIH1cblxuICAgIC8vIGdldCByaWQgb2YgdGhlIEhUTUw1IHZpZGVvIHRhZyBhcyBzb29uIGFzIHdlIGFyZSB1c2luZyBhbm90aGVyIHRlY2hcbiAgICBpZiAodGVjaE5hbWUgIT09ICdIdG1sNScgJiYgdGhpcy50YWcpIHtcbiAgICAgIF90ZWNoVGVjaEpzMlsnZGVmYXVsdCddLmdldFRlY2goJ0h0bWw1JykuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLnRhZyk7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGVjaE5hbWVfID0gdGVjaE5hbWU7XG5cbiAgICAvLyBUdXJuIG9mZiBBUEkgYWNjZXNzIGJlY2F1c2Ugd2UncmUgbG9hZGluZyBhIG5ldyB0ZWNoIHRoYXQgbWlnaHQgbG9hZCBhc3luY2hyb25vdXNseVxuICAgIHRoaXMuaXNSZWFkeV8gPSBmYWxzZTtcblxuICAgIC8vIEdyYWIgdGVjaC1zcGVjaWZpYyBvcHRpb25zIGZyb20gcGxheWVyIG9wdGlvbnMgYW5kIGFkZCBzb3VyY2UgYW5kIHBhcmVudCBlbGVtZW50IHRvIHVzZS5cbiAgICB2YXIgdGVjaE9wdGlvbnMgPSBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKHtcbiAgICAgICduYXRpdmVDb250cm9sc0ZvclRvdWNoJzogdGhpcy5vcHRpb25zXy5uYXRpdmVDb250cm9sc0ZvclRvdWNoLFxuICAgICAgJ3NvdXJjZSc6IHNvdXJjZSxcbiAgICAgICdwbGF5ZXJJZCc6IHRoaXMuaWQoKSxcbiAgICAgICd0ZWNoSWQnOiB0aGlzLmlkKCkgKyAnXycgKyB0ZWNoTmFtZSArICdfYXBpJyxcbiAgICAgICd2aWRlb1RyYWNrcyc6IHRoaXMudmlkZW9UcmFja3NfLFxuICAgICAgJ3RleHRUcmFja3MnOiB0aGlzLnRleHRUcmFja3NfLFxuICAgICAgJ2F1ZGlvVHJhY2tzJzogdGhpcy5hdWRpb1RyYWNrc18sXG4gICAgICAnYXV0b3BsYXknOiB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5LFxuICAgICAgJ3ByZWxvYWQnOiB0aGlzLm9wdGlvbnNfLnByZWxvYWQsXG4gICAgICAnbG9vcCc6IHRoaXMub3B0aW9uc18ubG9vcCxcbiAgICAgICdtdXRlZCc6IHRoaXMub3B0aW9uc18ubXV0ZWQsXG4gICAgICAncG9zdGVyJzogdGhpcy5wb3N0ZXIoKSxcbiAgICAgICdsYW5ndWFnZSc6IHRoaXMubGFuZ3VhZ2UoKSxcbiAgICAgICd2dHQuanMnOiB0aGlzLm9wdGlvbnNfWyd2dHQuanMnXVxuICAgIH0sIHRoaXMub3B0aW9uc19bdGVjaE5hbWUudG9Mb3dlckNhc2UoKV0pO1xuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0ZWNoT3B0aW9ucy50YWcgPSB0aGlzLnRhZztcbiAgICB9XG5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUeXBlXyA9IHNvdXJjZS50eXBlO1xuICAgICAgaWYgKHNvdXJjZS5zcmMgPT09IHRoaXMuY2FjaGVfLnNyYyAmJiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgICAgdGVjaE9wdGlvbnMuc3RhcnRUaW1lID0gdGhpcy5jYWNoZV8uY3VycmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FjaGVfLnNyYyA9IHNvdXJjZS5zcmM7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0ZWNoIGluc3RhbmNlXG4gICAgdmFyIHRlY2hDb21wb25lbnQgPSBfdGVjaFRlY2hKczJbJ2RlZmF1bHQnXS5nZXRUZWNoKHRlY2hOYW1lKTtcbiAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXG4gICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgaWYgKCF0ZWNoQ29tcG9uZW50KSB7XG4gICAgICB0ZWNoQ29tcG9uZW50ID0gX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgfVxuICAgIHRoaXMudGVjaF8gPSBuZXcgdGVjaENvbXBvbmVudCh0ZWNoT3B0aW9ucyk7XG5cbiAgICAvLyBwbGF5ZXIudHJpZ2dlclJlYWR5IGlzIGFsd2F5cyBhc3luYywgc28gZG9uJ3QgbmVlZCB0aGlzIHRvIGJlIGFzeW5jXG4gICAgdGhpcy50ZWNoXy5yZWFkeShGbi5iaW5kKHRoaXMsIHRoaXMuaGFuZGxlVGVjaFJlYWR5XyksIHRydWUpO1xuXG4gICAgX3RyYWNrc1RleHRUcmFja0xpc3RDb252ZXJ0ZXJKczJbJ2RlZmF1bHQnXS5qc29uVG9UZXh0VHJhY2tzKHRoaXMudGV4dFRyYWNrc0pzb25fIHx8IFtdLCB0aGlzLnRlY2hfKTtcblxuICAgIC8vIExpc3RlbiB0byBhbGwgSFRNTDUtZGVmaW5lZCBldmVudHMgYW5kIHRyaWdnZXIgdGhlbSBvbiB0aGUgcGxheWVyXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnbG9hZHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoTG9hZFN0YXJ0Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnd2FpdGluZycsIHRoaXMuaGFuZGxlVGVjaFdhaXRpbmdfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdjYW5wbGF5JywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwbGF5aW5nJywgdGhpcy5oYW5kbGVUZWNoUGxheWluZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2VuZGVkJywgdGhpcy5oYW5kbGVUZWNoRW5kZWRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVraW5nJywgdGhpcy5oYW5kbGVUZWNoU2Vla2luZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NlZWtlZCcsIHRoaXMuaGFuZGxlVGVjaFNlZWtlZF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BsYXknLCB0aGlzLmhhbmRsZVRlY2hQbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZmlyc3RwbGF5JywgdGhpcy5oYW5kbGVUZWNoRmlyc3RQbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGF1c2UnLCB0aGlzLmhhbmRsZVRlY2hQYXVzZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3Byb2dyZXNzJywgdGhpcy5oYW5kbGVUZWNoUHJvZ3Jlc3NfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdkdXJhdGlvbmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlcnJvcicsIHRoaXMuaGFuZGxlVGVjaEVycm9yXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnc3VzcGVuZCcsIHRoaXMuaGFuZGxlVGVjaFN1c3BlbmRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdhYm9ydCcsIHRoaXMuaGFuZGxlVGVjaEFib3J0Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZW1wdGllZCcsIHRoaXMuaGFuZGxlVGVjaEVtcHRpZWRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzdGFsbGVkJywgdGhpcy5oYW5kbGVUZWNoU3RhbGxlZF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5oYW5kbGVUZWNoTG9hZGVkTWV0YURhdGFfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2FkZWRkYXRhJywgdGhpcy5oYW5kbGVUZWNoTG9hZGVkRGF0YV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RpbWV1cGRhdGUnLCB0aGlzLmhhbmRsZVRlY2hUaW1lVXBkYXRlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncmF0ZWNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaFJhdGVDaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd2b2x1bWVjaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hWb2x1bWVDaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0ZXh0dHJhY2tjaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hUZXh0VHJhY2tDaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2FkZWRtZXRhZGF0YScsIHRoaXMudXBkYXRlU3R5bGVFbF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3Bvc3RlcmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RleHRkYXRhJywgdGhpcy5oYW5kbGVUZWNoVGV4dERhdGFfKTtcblxuICAgIHRoaXMudXNpbmdOYXRpdmVDb250cm9scyh0aGlzLnRlY2hHZXRfKCdjb250cm9scycpKTtcblxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkgJiYgIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHRlY2ggZWxlbWVudCBpbiB0aGUgRE9NIGlmIGl0IHdhcyBub3QgYWxyZWFkeSB0aGVyZVxuICAgIC8vIE1ha2Ugc3VyZSB0byBub3QgaW5zZXJ0IHRoZSBvcmlnaW5hbCB2aWRlbyBlbGVtZW50IGlmIHVzaW5nIEh0bWw1XG4gICAgaWYgKHRoaXMudGVjaF8uZWwoKS5wYXJlbnROb2RlICE9PSB0aGlzLmVsKCkgJiYgKHRlY2hOYW1lICE9PSAnSHRtbDUnIHx8ICF0aGlzLnRhZykpIHtcbiAgICAgIERvbS5pbnNlcnRFbEZpcnN0KHRoaXMudGVjaF8uZWwoKSwgdGhpcy5lbCgpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcmlkIG9mIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgcmVmZXJlbmNlIGFmdGVyIHRoZSBmaXJzdCB0ZWNoIGlzIGxvYWRlZFxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVubG9hZCBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAqXG4gICAqIEBtZXRob2QgdW5sb2FkVGVjaF9cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS51bmxvYWRUZWNoXyA9IGZ1bmN0aW9uIHVubG9hZFRlY2hfKCkge1xuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgdGV4dCB0cmFja3Mgc28gdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGV4dCB0cmFja3Mgd2l0aCB0aGUgbmV4dCB0ZWNoXG4gICAgdGhpcy52aWRlb1RyYWNrc18gPSB0aGlzLnZpZGVvVHJhY2tzKCk7XG4gICAgdGhpcy50ZXh0VHJhY2tzXyA9IHRoaXMudGV4dFRyYWNrcygpO1xuICAgIHRoaXMuYXVkaW9UcmFja3NfID0gdGhpcy5hdWRpb1RyYWNrcygpO1xuICAgIHRoaXMudGV4dFRyYWNrc0pzb25fID0gX3RyYWNrc1RleHRUcmFja0xpc3RDb252ZXJ0ZXJKczJbJ2RlZmF1bHQnXS50ZXh0VHJhY2tzVG9Kc29uKHRoaXMudGVjaF8pO1xuXG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XG5cbiAgICB0aGlzLnRlY2hfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB0ZWNoLlxuICAgKiBJdCB3aWxsIG9ubHkgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIGlmIGdpdmVuIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgKiBgSVdpbGxOb3RVc2VUaGlzSW5QbHVnaW5zYCBwcm9wZXJ0eSBvbiBpdC4gVGhpcyBpcyB0cnkgYW5kIHByZXZlbnQgbWlzdXNlXG4gICAqIG9mIHRlY2hzIGJ5IHBsdWdpbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBUZWNoXG4gICAqIEBtZXRob2QgdGVjaFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2ggPSBmdW5jdGlvbiB0ZWNoKHNhZmV0eSkge1xuICAgIGlmIChzYWZldHkgJiYgc2FmZXR5LklXaWxsTm90VXNlVGhpc0luUGx1Z2lucykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF87XG4gICAgfVxuICAgIHZhciBlcnJvclRleHQgPSAnXFxuICAgICAgUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdSBhcmUgbm90IHVzaW5nIHRoaXMgaW5zaWRlIG9mIGEgcGx1Z2luLlxcbiAgICAgIFRvIGRpc2FibGUgdGhpcyBhbGVydCBhbmQgZXJyb3IsIHBsZWFzZSBwYXNzIGluIGFuIG9iamVjdCB3aXRoXFxuICAgICAgYElXaWxsTm90VXNlVGhpc0luUGx1Z2luc2AgdG8gdGhlIGB0ZWNoYCBtZXRob2QuIFNlZVxcbiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICc7XG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5hbGVydChlcnJvclRleHQpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvclRleHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgY2xpY2sgYW5kIHRvdWNoIGxpc3RlbmVycyBmb3IgdGhlIHBsYXliYWNrIGVsZW1lbnRcbiAgICpcbiAgICogT24gZGVza3RvcHMsIGEgY2xpY2sgb24gdGhlIHZpZGVvIGl0c2VsZiB3aWxsIHRvZ2dsZSBwbGF5YmFjayxcbiAgICogb24gYSBtb2JpbGUgZGV2aWNlIGEgY2xpY2sgb24gdGhlIHZpZGVvIHRvZ2dsZXMgY29udHJvbHMuXG4gICAqICh0b2dnbGluZyBjb250cm9scyBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxuICAgKiBpbmFjdGl2ZSlcbiAgICogQSB0YXAgY2FuIHNpZ25hbCB0aGF0IGEgdXNlciBoYXMgYmVjb21lIGFjdGl2ZSwgb3IgaGFzIGJlY29tZSBpbmFjdGl2ZVxuICAgKiBlLmcuIGEgcXVpY2sgdGFwIG9uIGFuIGlQaG9uZSBtb3ZpZSBzaG91bGQgcmV2ZWFsIHRoZSBjb250cm9scy4gQW5vdGhlclxuICAgKiBxdWljayB0YXAgc2hvdWxkIGhpZGUgdGhlbSBhZ2FpbiAoc2lnbmFsaW5nIHRoZSB1c2VyIGlzIGluIGFuIGluYWN0aXZlXG4gICAqIHZpZXdpbmcgc3RhdGUpXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoaXMsIHdlIHN0aWxsIHdhbnQgdGhlIHVzZXIgdG8gYmUgY29uc2lkZXJlZCBpbmFjdGl2ZSBhZnRlclxuICAgKiBhIGZldyBzZWNvbmRzIG9mIGluYWN0aXZpdHkuXG4gICAqIE5vdGU6IHRoZSBvbmx5IHBhcnQgb2YgaU9TIGludGVyYWN0aW9uIHdlIGNhbid0IG1pbWljIHdpdGggdGhpcyBzZXR1cFxuICAgKiBpcyBhIHRvdWNoIGFuZCBob2xkIG9uIHRoZSB2aWRlbyBlbGVtZW50IGNvdW50aW5nIGFzIGFjdGl2aXR5IGluIG9yZGVyIHRvXG4gICAqIGtlZXAgdGhlIGNvbnRyb2xzIHNob3dpbmcsIGJ1dCB0aGF0IHNob3VsZG4ndCBiZSBhbiBpc3N1ZS4gQSB0b3VjaCBhbmQgaG9sZFxuICAgKiBvbiBhbnkgY29udHJvbHMgd2lsbCBzdGlsbCBrZWVwIHRoZSB1c2VyIGFjdGl2ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGFkZFRlY2hDb250cm9sc0xpc3RlbmVyc19cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBNYWtlIHN1cmUgdG8gcmVtb3ZlIGFsbCB0aGUgcHJldmlvdXMgbGlzdGVuZXJzIGluIGNhc2Ugd2UgYXJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcblxuICAgIC8vIFNvbWUgYnJvd3NlcnMgKENocm9tZSAmIElFKSBkb24ndCB0cmlnZ2VyIGEgY2xpY2sgb24gYSBmbGFzaCBzd2YsIGJ1dCBkb1xuICAgIC8vIHRyaWdnZXIgbW91c2Vkb3duL3VwLlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDU2Mi9qYXZhc2NyaXB0LW9uY2xpY2stZXZlbnQtb3Zlci1mbGFzaC1vYmplY3RcbiAgICAvLyBBbnkgdG91Y2ggZXZlbnRzIGFyZSBzZXQgdG8gYmxvY2sgdGhlIG1vdXNlZG93biBldmVudCBmcm9tIGhhcHBlbmluZ1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG5cbiAgICAvLyBJZiB0aGUgY29udHJvbHMgd2VyZSBoaWRkZW4gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNoYW5nZSB3aXRob3V0IGEgdGFwIGV2ZW50XG4gICAgLy8gc28gd2UnbGwgY2hlY2sgaWYgdGhlIGNvbnRyb2xzIHdlcmUgYWxyZWFkeSBzaG93aW5nIGJlZm9yZSByZXBvcnRpbmcgdXNlclxuICAgIC8vIGFjdGl2aXR5XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XG5cbiAgICAvLyBUaGUgdGFwIGxpc3RlbmVyIG5lZWRzIHRvIGNvbWUgYWZ0ZXIgdGhlIHRvdWNoZW5kIGxpc3RlbmVyIGJlY2F1c2UgdGhlIHRhcFxuICAgIC8vIGxpc3RlbmVyIGNhbmNlbHMgb3V0IGFueSByZXBvcnRlZFVzZXJBY3Rpdml0eSB3aGVuIHNldHRpbmcgdXNlckFjdGl2ZShmYWxzZSlcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdXNlZCBmb3IgY2xpY2sgYW5kIHRhcCBjb250cm9scy4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gICAqIHRvZ2dsaW5nIHRvIGNvbnRyb2xzIGRpc2FibGVkLCB3aGVyZSBhIHRhcC90b3VjaCBzaG91bGQgZG8gbm90aGluZy5cbiAgICpcbiAgICogQG1ldGhvZCByZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXyA9IGZ1bmN0aW9uIHJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBqdXN0IHVzZSBgdGhpcy5vZmYoKWAgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBvdGhlciBuZWVkZWRcbiAgICAvLyBsaXN0ZW5lcnMgYWRkZWQgYnkgdGVjaHMgdGhhdCBleHRlbmQgdGhpcy5cbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaFN0YXJ0Xyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVGVjaFRvdWNoTW92ZV8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBsYXllciB3YWl0cyBmb3IgdGhlIHRlY2ggdG8gYmUgcmVhZHlcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoUmVhZHlfXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFJlYWR5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hSZWFkeV8oKSB7XG4gICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcblxuICAgIC8vIEtlZXAgdGhlIHNhbWUgdm9sdW1lIGFzIGJlZm9yZVxuICAgIGlmICh0aGlzLmNhY2hlXy52b2x1bWUpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRWb2x1bWUnLCB0aGlzLmNhY2hlXy52b2x1bWUpO1xuICAgIH1cblxuICAgIC8vIExvb2sgaWYgdGhlIHRlY2ggZm91bmQgYSBoaWdoZXIgcmVzb2x1dGlvbiBwb3N0ZXIgd2hpbGUgbG9hZGluZ1xuICAgIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgZHVyYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCk7XG5cbiAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGhhdmUgaXNzdWVzIHdpdGggYXV0b3BsYXkuXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXG4gICAgLy8gSW4gQ2hyb21lICgxNSksIGlmIHlvdSBoYXZlIGF1dG9wbGF5ICsgYSBwb3N0ZXIgKyBubyBjb250cm9scywgdGhlIHZpZGVvIGdldHMgaGlkZGVuIChidXQgYXVkaW8gcGxheXMpXG4gICAgLy8gVGhpcyBmaXhlcyBib3RoIGlzc3Vlcy4gTmVlZCB0byB3YWl0IGZvciBBUEksIHNvIGl0IHVwZGF0ZXMgZGlzcGxheXMgY29ycmVjdGx5XG4gICAgaWYgKCh0aGlzLnNyYygpIHx8IHRoaXMuY3VycmVudFNyYygpKSAmJiB0aGlzLnRhZyAmJiB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ICYmIHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhZy5wb3N0ZXI7IC8vIENocm9tZSBGaXguIEZpeGVkIGluIENocm9tZSB2MTYuXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddKCdkZWxldGluZyB0YWcucG9zdGVyIHRocm93cyBpbiBzb21lIGJyb3dzZXJzJywgZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgYWdlbnQgYmVnaW5zIGxvb2tpbmcgZm9yIG1lZGlhIGRhdGFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoTG9hZFN0YXJ0X1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hMb2FkU3RhcnRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaExvYWRTdGFydF8oKSB7XG4gICAgLy8gVE9ETzogVXBkYXRlIHRvIHVzZSBgZW1wdGllZGAgZXZlbnQgaW5zdGVhZC4gU2VlICMxMjc3LlxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG5cbiAgICAvLyByZXNldCB0aGUgZXJyb3Igc3RhdGVcbiAgICB0aGlzLmVycm9yKG51bGwpO1xuXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IHBsYXlpbmcgd2Ugd2FudCB0byB0cmlnZ2VyIGEgZmlyc3RwbGF5IGV2ZW50IG5vdy5cbiAgICAvLyBUaGUgZmlyc3RwbGF5IGV2ZW50IHJlbGllcyBvbiBib3RoIHRoZSBwbGF5IGFuZCBsb2Fkc3RhcnQgZXZlbnRzXG4gICAgLy8gd2hpY2ggY2FuIGhhcHBlbiBpbiBhbnkgb3JkZXIgZm9yIGEgbmV3IHNvdXJjZVxuICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBoYXNTdGFydGVkIHN0YXRlXG4gICAgICB0aGlzLmhhc1N0YXJ0ZWQoZmFsc2UpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZC9yZW1vdmUgdGhlIHZqcy1oYXMtc3RhcnRlZCBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc1N0YXJ0ZWQgVGhlIHZhbHVlIG9mIHRydWUgYWRkcyB0aGUgY2xhc3MgdGhlIHZhbHVlIG9mIGZhbHNlIHJlbW92ZSB0aGUgY2xhc3NcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBpZiBoYXMgc3RhcnRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhc1N0YXJ0ZWRcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gaGFzU3RhcnRlZChfaGFzU3RhcnRlZCkge1xuICAgIGlmIChfaGFzU3RhcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSBpZiB0aGlzIGlzIGEgbmV3IHZhbHVlXG4gICAgICBpZiAodGhpcy5oYXNTdGFydGVkXyAhPT0gX2hhc1N0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IF9oYXNTdGFydGVkO1xuICAgICAgICBpZiAoX2hhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdHBsYXkgZXZlbnQgaWYgdGhpcyBuZXdseSBoYXMgcGxheWVkXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuaGFzU3RhcnRlZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBiZWdpbnMgb3IgcmVzdW1lcyBwbGF5YmFja1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hQbGF5X1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5XygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcblxuICAgIC8vIGhpZGUgdGhlIHBvc3RlciB3aGVuIHRoZSB1c2VyIGhpdHMgcGxheVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheVxuICAgIHRoaXMuaGFzU3RhcnRlZCh0cnVlKTtcblxuICAgIHRoaXMudHJpZ2dlcigncGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgYmVnaW5zIHdhaXRpbmdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoV2FpdGluZ19cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoV2FpdGluZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoV2FpdGluZ18oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIHRoaXMudHJpZ2dlcignd2FpdGluZycpO1xuICAgIHRoaXMub25lKCd0aW1ldXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoQ2FuUGxheV9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2FuUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBoYW5kbGVyIGZvciBldmVudHMgdGhhdCBzaWduYWwgdGhhdCB3YWl0aW5nIGhhcyBlbmRlZFxuICAgKiB3aGljaCBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgaGFuZGxlciBmb3IgZXZlbnRzIHRoYXQgc2lnbmFsIHRoYXQgd2FpdGluZyBoYXMgZW5kZWRcbiAgICogd2hpY2ggaXMgbm90IGNvbnNpc3RlbnQgYmV0d2VlbiBicm93c2Vycy4gU2VlICMxMzUxXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaFBsYXlpbmdfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBsYXlpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBsYXlpbmdfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBwbGF5ZXIgaXMganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaFNlZWtpbmdfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFNlZWtpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFNlZWtpbmdfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdzZWVraW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZmluaXNoZWQganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaFNlZWtlZF9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVrZWRfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdzZWVrZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgdGhlIGZpcnN0IHRpbWUgYSB2aWRlbyBpcyBwbGF5ZWRcbiAgICogTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgd2UncmUgbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdFxuICAgKiBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGEgcmVhc29uIHRvXG4gICAqIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hGaXJzdFBsYXlfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEZpcnN0UGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRmlyc3RQbGF5XygpIHtcbiAgICAvL0lmIHRoZSBmaXJzdCBzdGFydHRpbWUgYXR0cmlidXRlIGlzIHNwZWNpZmllZFxuICAgIC8vdGhlbiB3ZSB3aWxsIHN0YXJ0IGF0IHRoZSBnaXZlbiBvZmZzZXQgaW4gc2Vjb25kc1xuICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIG1lZGlhIGhhcyBiZWVuIHBhdXNlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hQYXVzZV9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGF1c2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBhdXNlXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ3BhdXNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoaWxlIHRoZSB1c2VyIGFnZW50IGlzIGRvd25sb2FkaW5nIG1lZGlhIGRhdGFcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoUHJvZ3Jlc3NfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFByb2dyZXNzXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQcm9ncmVzc18oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hFbmRlZF9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRW5kZWRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEVuZGVkXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZW5kZWQnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zXy5sb29wKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lKDApO1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignZW5kZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIGZpcnN0IGtub3duIG9yIGNoYW5nZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKSB7XG4gICAgdGhpcy5kdXJhdGlvbih0aGlzLnRlY2hHZXRfKCdkdXJhdGlvbicpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgY2xpY2sgb24gdGhlIG1lZGlhIGVsZW1lbnQgdG8gcGxheS9wYXVzZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hDbGlja19cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENsaWNrXyhldmVudCkge1xuICAgIC8vIFdlJ3JlIHVzaW5nIG1vdXNlZG93biB0byBkZXRlY3QgY2xpY2tzIHRoYW5rcyB0byBGbGFzaCwgYnV0IG1vdXNlZG93blxuICAgIC8vIHdpbGwgYWxzbyBiZSB0cmlnZ2VyZWQgd2l0aCByaWdodC1jbGlja3MsIHNvIHdlIG5lZWQgdG8gcHJldmVudCB0aGF0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gV2hlbiBjb250cm9scyBhcmUgZGlzYWJsZWQgYSBjbGljayBzaG91bGQgbm90IHRvZ2dsZSBwbGF5YmFjayBiZWNhdXNlXG4gICAgLy8gdGhlIGNsaWNrIGlzIGNvbnNpZGVyZWQgYSBjb250cm9sXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSkge1xuICAgICAgaWYgKHRoaXMucGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHdpbGwgdG9nZ2xlIHRoZSB1c2VyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hUYXBfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRhcF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVGFwXygpIHtcbiAgICB0aGlzLnVzZXJBY3RpdmUoIXRoaXMudXNlckFjdGl2ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIHN0YXJ0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaFRvdWNoU3RhcnRfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoU3RhcnRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoU3RhcnRfKCkge1xuICAgIHRoaXMudXNlcldhc0FjdGl2ZSA9IHRoaXMudXNlckFjdGl2ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gbW92ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hUb3VjaE1vdmVfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hNb3ZlXygpIHtcbiAgICBpZiAodGhpcy51c2VyV2FzQWN0aXZlKSB7XG4gICAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIGVuZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hUb3VjaEVuZF9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hFbmRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoRW5kXyhldmVudCkge1xuICAgIC8vIFN0b3AgdGhlIG1vdXNlIGV2ZW50cyBmcm9tIGFsc28gaGFwcGVuaW5nXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIHN3aXRjaGVzIGluIG9yIG91dCBvZiBmdWxsc2NyZWVuIG1vZGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBuYXRpdmUgY2xpY2sgZXZlbnRzIG9uIHRoZSBTV0YgYXJlbid0IHRyaWdnZXJlZCBvbiBJRTExLCBXaW44LjFSVFxuICAgKiB1c2Ugc3RhZ2VjbGljayBldmVudHMgdHJpZ2dlcmVkIGZyb20gaW5zaWRlIHRoZSBTV0YgaW5zdGVhZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVN0YWdlQ2xpY2tfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlU3RhZ2VDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVTdGFnZUNsaWNrXygpIHtcbiAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgVGVjaCBGdWxsc2NyZWVuIENoYW5nZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyhldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbihkYXRhLmlzRnVsbHNjcmVlbik7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlb1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hFcnJvcl9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRXJyb3JfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEVycm9yXygpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnRlY2hfLmVycm9yKCk7XG4gICAgdGhpcy5lcnJvcihlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaFN1c3BlbmRfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFN1c3BlbmRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFN1c3BlbmRfKCkge1xuICAgIHRoaXMudHJpZ2dlcignc3VzcGVuZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoQWJvcnRfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEFib3J0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hBYm9ydF8oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdhYm9ydCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXlsaXN0IGlzIGVtcHR5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaEVtcHRpZWRfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVtcHRpZWRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEVtcHRpZWRfKCkge1xuICAgIHRoaXMudHJpZ2dlcignZW1wdGllZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGlzIHRyeWluZyB0byBnZXQgbWVkaWEgZGF0YSwgYnV0IGRhdGEgaXMgbm90IGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hTdGFsbGVkX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTdGFsbGVkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTdGFsbGVkXygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N0YWxsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBoYXMgbG9hZGVkIG1ldGEgZGF0YSBmb3IgdGhlIGF1ZGlvL3ZpZGVvXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaExvYWRlZE1ldGFEYXRhX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hMb2FkZWRNZXRhRGF0YV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoTG9hZGVkTWV0YURhdGFfKCkge1xuICAgIHRoaXMudHJpZ2dlcignbG9hZGVkbWV0YWRhdGEnKTtcbiAgfTtcblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUZXh0RGF0YV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVGV4dERhdGFfKCkge1xuICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcigndGV4dGRhdGEnLCBkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBoYXMgbG9hZGVkIHRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBhdWRpby92aWRlb1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hMb2FkZWREYXRhX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hMb2FkZWREYXRhXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hMb2FkZWREYXRhXygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZGRhdGEnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hUaW1lVXBkYXRlX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUaW1lVXBkYXRlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUaW1lVXBkYXRlXygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3RpbWV1cGRhdGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgcGxheWluZyBzcGVlZCBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGhhbmRsZVRlY2hSYXRlQ2hhbmdlX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hSYXRlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hSYXRlQ2hhbmdlXygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3JhdGVjaGFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgdm9sdW1lIGhhcyBiZWVuIGNoYW5nZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoVm9sdW1lQ2hhbmdlX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hWb2x1bWVDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFZvbHVtZUNoYW5nZV8oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCd2b2x1bWVjaGFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgdGV4dCB0cmFjayBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaGFuZGxlVGVjaFRleHRUcmFja0NoYW5nZV9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGV4dFRyYWNrQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUZXh0VHJhY2tDaGFuZ2VfKCkge1xuICAgIHRoaXMudHJpZ2dlcigndGV4dHRyYWNrY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvYmplY3QgZm9yIGNhY2hlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQG1ldGhvZCBnZXRDYWNoZVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmdldENhY2hlID0gZnVuY3Rpb24gZ2V0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXNzIHZhbHVlcyB0byB0aGUgcGxheWJhY2sgdGVjaFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IG1ldGhvZCBNZXRob2RcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBhcmcgQXJndW1lbnRcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCB0ZWNoQ2FsbF9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoQ2FsbF8gPSBmdW5jdGlvbiB0ZWNoQ2FsbF8obWV0aG9kLCBhcmcpIHtcbiAgICAvLyBJZiBpdCdzIG5vdCByZWFkeSB5ZXQsIGNhbGwgbWV0aG9kIHdoZW4gaXQgaXNcbiAgICBpZiAodGhpcy50ZWNoXyAmJiAhdGhpcy50ZWNoXy5pc1JlYWR5Xykge1xuICAgICAgdGhpcy50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNbbWV0aG9kXShhcmcpO1xuICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgIC8vIE90aGVyd2lzZSBjYWxsIG1ldGhvZCBub3dcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoX1ttZXRob2RdKGFyZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXShlKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjYWxscyBjYW4ndCB3YWl0IGZvciB0aGUgdGVjaCwgYW5kIHNvbWV0aW1lcyBkb24ndCBuZWVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFRlY2ggbWV0aG9kXG4gICAqIEByZXR1cm4ge01ldGhvZH1cbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCB0ZWNoR2V0X1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2hHZXRfID0gZnVuY3Rpb24gdGVjaEdldF8obWV0aG9kKSB7XG4gICAgaWYgKHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5pc1JlYWR5Xykge1xuXG4gICAgICAvLyBGbGFzaCBsaWtlcyB0byBkaWUgYW5kIHJlbG9hZCB3aGVuIHlvdSBoaWRlIG9yIHJlcG9zaXRpb24gaXQuXG4gICAgICAvLyBJbiB0aGVzZSBjYXNlcyB0aGUgb2JqZWN0IG1ldGhvZHMgZ28gYXdheSBhbmQgd2UgZ2V0IGVycm9ycy5cbiAgICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZWNoX1ttZXRob2RdKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLnRlY2hfW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgbWV0aG9kIG5vdCBkZWZpbmVkIGZvciAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kuJywgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10oJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyB1bmF2YWlsYWJsZSBvbiAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kgZWxlbWVudC4nLCBlKTtcbiAgICAgICAgICAgIHRoaXMudGVjaF8uaXNSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10oZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzdGFydCBtZWRpYSBwbGF5YmFja1xuICAgKiBgYGBqc1xuICAgKiAgICAgbXlQbGF5ZXIucGxheSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmXG4gICAqIEBtZXRob2QgcGxheVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgIC8vIE9ubHkgY2FsbHMgdGhlIHRlY2gncyBwbGF5IGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNyYyBsb2FkZWRcbiAgICBpZiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3BsYXknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZWNoXy5vbmUoJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUGF1c2UgdGhlIHZpZGVvIHBsYXliYWNrXG4gICAqIGBgYGpzXG4gICAqICAgICBteVBsYXllci5wYXVzZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmXG4gICAqIEBtZXRob2QgcGF1c2VcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdwYXVzZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZFxuICAgKiBgYGBqc1xuICAgKiAgICAgdmFyIGlzUGF1c2VkID0gbXlQbGF5ZXIucGF1c2VkKCk7XG4gICAqICAgICB2YXIgaXNQbGF5aW5nID0gIW15UGxheWVyLnBhdXNlZCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgaWYgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nLCBvciB0cnVlIG90aGVyd2lzZVxuICAgKiBAbWV0aG9kIHBhdXNlZFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCgpIHtcbiAgICAvLyBUaGUgaW5pdGlhbCBzdGF0ZSBvZiBwYXVzZWQgc2hvdWxkIGJlIHRydWUgKGluIFNhZmFyaSBpdCdzIGFjdHVhbGx5IGZhbHNlKVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwYXVzZWQnKSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgXCJzY3J1YmJpbmdcIi4gU2NydWJiaW5nIGlzIHdoZW4gdGhlIHVzZXJcbiAgICogaGFzIGNsaWNrZWQgdGhlIHByb2dyZXNzIGJhciBoYW5kbGUgYW5kIGlzIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzU2NydWJiaW5nICAgVHJ1ZS9mYWxzZSB0aGUgdXNlciBpcyBzY3J1YmJpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICBUaGUgc2NydWJiaW5nIHN0YXR1cyB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKiBAbWV0aG9kIHNjcnViYmluZ1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnNjcnViYmluZyA9IGZ1bmN0aW9uIHNjcnViYmluZyhpc1NjcnViYmluZykge1xuICAgIGlmIChpc1NjcnViYmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNjcnViYmluZ18gPSAhIWlzU2NydWJiaW5nO1xuXG4gICAgICBpZiAoaXNTY3J1YmJpbmcpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zY3J1YmJpbmdfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHRpbWUgKGluIHNlY29uZHMpXG4gICAqIGBgYGpzXG4gICAqICAgICAvLyBnZXRcbiAgICogICAgIHZhciB3aGVyZVlvdUF0ID0gbXlQbGF5ZXIuY3VycmVudFRpbWUoKTtcbiAgICogICAgIC8vIHNldFxuICAgKiAgICAgbXlQbGF5ZXIuY3VycmVudFRpbWUoMTIwKTsgLy8gMiBtaW51dGVzIGludG8gdGhlIHZpZGVvXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nPX0gc2Vjb25kcyBUaGUgdGltZSB0byBzZWVrIHRvXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgIFRoZSB0aW1lIGluIHNlY29uZHMsIHdoZW4gbm90IHNldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICBzZWxmLCB3aGVuIHRoZSBjdXJyZW50IHRpbWUgaXMgc2V0XG4gICAqIEBtZXRob2QgY3VycmVudFRpbWVcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uIGN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDdXJyZW50VGltZScsIHNlY29uZHMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBjYWNoZSBsYXN0IGN1cnJlbnRUaW1lIGFuZCByZXR1cm4uIGRlZmF1bHQgdG8gMCBzZWNvbmRzXG4gICAgLy9cbiAgICAvLyBDYWNoaW5nIHRoZSBjdXJyZW50VGltZSBpcyBtZWFudCB0byBwcmV2ZW50IGEgbWFzc2l2ZSBhbW91bnQgb2YgcmVhZHMgb24gdGhlIHRlY2gnc1xuICAgIC8vIGN1cnJlbnRUaW1lIHdoZW4gc2NydWJiaW5nLCBidXQgbWF5IG5vdCBwcm92aWRlIG11Y2ggcGVyZm9ybWFuY2UgYmVuZWZpdCBhZnRlcmFsbC5cbiAgICAvLyBTaG91bGQgYmUgdGVzdGVkLiBBbHNvIHNvbWV0aGluZyBoYXMgdG8gcmVhZCB0aGUgYWN0dWFsIGN1cnJlbnQgdGltZSBvciB0aGUgY2FjaGUgd2lsbFxuICAgIC8vIG5ldmVyIGdldCB1cGRhdGVkLlxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA9IHRoaXMudGVjaEdldF8oJ2N1cnJlbnRUaW1lJykgfHwgMDtcbiAgfTtcblxuICAvKipcbiAgICogTm9ybWFsbHkgZ2V0cyB0aGUgbGVuZ3RoIGluIHRpbWUgb2YgdGhlIHZpZGVvIGluIHNlY29uZHM7XG4gICAqIGluIGFsbCBidXQgdGhlIHJhcmVzdCB1c2UgY2FzZXMgYW4gYXJndW1lbnQgd2lsbCBOT1QgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICogYGBganNcbiAgICogICAgIHZhciBsZW5ndGhPZlZpZGVvID0gbXlQbGF5ZXIuZHVyYXRpb24oKTtcbiAgICogYGBgXG4gICAqICoqTk9URSoqOiBUaGUgdmlkZW8gbXVzdCBoYXZlIHN0YXJ0ZWQgbG9hZGluZyBiZWZvcmUgdGhlIGR1cmF0aW9uIGNhbiBiZVxuICAgKiBrbm93biwgYW5kIGluIHRoZSBjYXNlIG9mIEZsYXNoLCBtYXkgbm90IGJlIGtub3duIHVudGlsIHRoZSB2aWRlbyBzdGFydHNcbiAgICogcGxheWluZy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgRHVyYXRpb24gd2hlbiBzZXR0aW5nXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyBpbiBzZWNvbmRzIHdoZW4gZ2V0dGluZ1xuICAgKiBAbWV0aG9kIGR1cmF0aW9uXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbihzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLmR1cmF0aW9uIHx8IDA7XG4gICAgfVxuXG4gICAgc2Vjb25kcyA9IHBhcnNlRmxvYXQoc2Vjb25kcykgfHwgMDtcblxuICAgIC8vIFN0YW5kYXJkaXplIG9uIEluaWZpdHkgZm9yIHNpZ25hbGluZyB2aWRlbyBpcyBsaXZlXG4gICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICBzZWNvbmRzID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZHMgIT09IHRoaXMuY2FjaGVfLmR1cmF0aW9uKSB7XG4gICAgICAvLyBDYWNoZSB0aGUgbGFzdCBzZXQgdmFsdWUgZm9yIG9wdGltaXplZCBzY3J1YmJpbmcgKGVzcC4gRmxhc2gpXG4gICAgICB0aGlzLmNhY2hlXy5kdXJhdGlvbiA9IHNlY29uZHM7XG5cbiAgICAgIGlmIChzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdkdXJhdGlvbmNoYW5nZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGhvdyBtdWNoIHRpbWUgaXMgbGVmdC5cbiAgICogYGBganNcbiAgICogICAgIHZhciB0aW1lTGVmdCA9IG15UGxheWVyLnJlbWFpbmluZ1RpbWUoKTtcbiAgICogYGBgXG4gICAqIE5vdCBhIG5hdGl2ZSB2aWRlbyBlbGVtZW50IGZ1bmN0aW9uLCBidXQgdXNlZnVsXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRpbWUgcmVtYWluaW5nIGluIHNlY29uZHNcbiAgICogQG1ldGhvZCByZW1haW5pbmdUaW1lXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucmVtYWluaW5nVGltZSA9IGZ1bmN0aW9uIHJlbWFpbmluZ1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24oKSAtIHRoaXMuY3VycmVudFRpbWUoKTtcbiAgfTtcblxuICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL3ZpZGVvLmh0bWwjZG9tLW1lZGlhLWJ1ZmZlcmVkXG4gIC8vIEJ1ZmZlcmVkIHJldHVybnMgYSB0aW1lcmFuZ2Ugb2JqZWN0LlxuICAvLyBLaW5kIG9mIGxpa2UgYW4gYXJyYXkgb2YgcG9ydGlvbnMgb2YgdGhlIHZpZGVvIHRoYXQgaGF2ZSBiZWVuIGRvd25sb2FkZWQuXG5cbiAgLyoqXG4gICAqIEdldCBhIFRpbWVSYW5nZSBvYmplY3Qgd2l0aCB0aGUgdGltZXMgb2YgdGhlIHZpZGVvIHRoYXQgaGF2ZSBiZWVuIGRvd25sb2FkZWRcbiAgICogSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGUgdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZCxcbiAgICogdXNlIGJ1ZmZlcmVkUGVyY2VudC5cbiAgICogYGBganNcbiAgICogICAgIC8vIE51bWJlciBvZiBkaWZmZXJlbnQgcmFuZ2VzIG9mIHRpbWUgaGF2ZSBiZWVuIGJ1ZmZlcmVkLiBVc3VhbGx5IDEuXG4gICAqICAgICBudW1iZXJPZlJhbmdlcyA9IGJ1ZmZlcmVkVGltZVJhbmdlLmxlbmd0aCxcbiAgICogICAgIC8vIFRpbWUgaW4gc2Vjb25kcyB3aGVuIHRoZSBmaXJzdCByYW5nZSBzdGFydHMuIFVzdWFsbHkgMC5cbiAgICogICAgIGZpcnN0UmFuZ2VTdGFydCA9IGJ1ZmZlcmVkVGltZVJhbmdlLnN0YXJ0KDApLFxuICAgKiAgICAgLy8gVGltZSBpbiBzZWNvbmRzIHdoZW4gdGhlIGZpcnN0IHJhbmdlIGVuZHNcbiAgICogICAgIGZpcnN0UmFuZ2VFbmQgPSBidWZmZXJlZFRpbWVSYW5nZS5lbmQoMCksXG4gICAqICAgICAvLyBMZW5ndGggaW4gc2Vjb25kcyBvZiB0aGUgZmlyc3QgdGltZSByYW5nZVxuICAgKiAgICAgZmlyc3RSYW5nZUxlbmd0aCA9IGZpcnN0UmFuZ2VFbmQgLSBmaXJzdFJhbmdlU3RhcnQ7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKiBAbWV0aG9kIGJ1ZmZlcmVkXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hHZXRfKCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IF91dGlsc1RpbWVSYW5nZXNKcy5jcmVhdGVUaW1lUmFuZ2UoMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWRcbiAgICogYGBganNcbiAgICogICAgIHZhciBob3dNdWNoSXNEb3dubG9hZGVkID0gbXlQbGF5ZXIuYnVmZmVyZWRQZXJjZW50KCk7XG4gICAqIGBgYFxuICAgKiAwIG1lYW5zIG5vbmUsIDEgbWVhbnMgYWxsLlxuICAgKiAoVGhpcyBtZXRob2QgaXNuJ3QgaW4gdGhlIEhUTUw1IHNwZWMsIGJ1dCBpdCdzIHZlcnkgY29udmVuaWVudClcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudFxuICAgKiBAbWV0aG9kIGJ1ZmZlcmVkUGVyY2VudFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkUGVyY2VudCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudCgpIHtcbiAgICByZXR1cm4gX3V0aWxzQnVmZmVySnMuYnVmZmVyZWRQZXJjZW50KHRoaXMuYnVmZmVyZWQoKSwgdGhpcy5kdXJhdGlvbigpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbmRpbmcgdGltZSBvZiB0aGUgbGFzdCBidWZmZXJlZCB0aW1lIHJhbmdlXG4gICAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgcHJvZ3Jlc3MgYmFyIHRvIGVuY2Fwc3VsYXRlIGFsbCB0aW1lIHJhbmdlcy5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICogQG1ldGhvZCBidWZmZXJlZEVuZFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpLFxuICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSxcbiAgICAgICAgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICogYGBganNcbiAgICogICAgIC8vIGdldFxuICAgKiAgICAgdmFyIGhvd0xvdWRJc0l0ID0gbXlQbGF5ZXIudm9sdW1lKCk7XG4gICAqICAgICAvLyBzZXRcbiAgICogICAgIG15UGxheWVyLnZvbHVtZSgwLjUpOyAvLyBTZXQgdm9sdW1lIHRvIGhhbGZcbiAgICogYGBgXG4gICAqIDAgaXMgb2ZmIChtdXRlZCksIDEuMCBpcyBhbGwgdGhlIHdheSB1cCwgMC41IGlzIGhhbGYgd2F5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBlcmNlbnRBc0RlY2ltYWwgVGhlIG5ldyB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnRcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgVGhlIGN1cnJlbnQgdm9sdW1lIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgICAgICAgICBzZWxmIHdoZW4gc2V0dGluZ1xuICAgKiBAbWV0aG9kIHZvbHVtZVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uIHZvbHVtZShwZXJjZW50QXNEZWNpbWFsKSB7XG4gICAgdmFyIHZvbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHBhcnNlRmxvYXQocGVyY2VudEFzRGVjaW1hbCkpKTsgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdm9sKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byAxIHdoZW4gcmV0dXJuaW5nIGN1cnJlbnQgdm9sdW1lLlxuICAgIHZvbCA9IHBhcnNlRmxvYXQodGhpcy50ZWNoR2V0Xygndm9sdW1lJykpO1xuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqIGBgYGpzXG4gICAqICAgICAvLyBnZXRcbiAgICogICAgIHZhciBpc1ZvbHVtZU11dGVkID0gbXlQbGF5ZXIubXV0ZWQoKTtcbiAgICogICAgIC8vIHNldFxuICAgKiAgICAgbXlQbGF5ZXIubXV0ZWQodHJ1ZSk7IC8vIG11dGUgdGhlIHZvbHVtZVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IG11dGVkIFRydWUgdG8gbXV0ZSwgZmFsc2UgdG8gdW5tdXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgbXV0ZSBpcyBvbiwgZmFsc2UgaWYgbm90IHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IHNlbGYgd2hlbiBzZXR0aW5nIG11dGVcbiAgICogQG1ldGhvZCBtdXRlZFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLm11dGVkID0gZnVuY3Rpb24gbXV0ZWQoX211dGVkKSB7XG4gICAgaWYgKF9tdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TXV0ZWQnLCBfbXV0ZWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdtdXRlZCcpIHx8IGZhbHNlOyAvLyBEZWZhdWx0IHRvIGZhbHNlXG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gIC8vIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBtZXRob2Qgc3VwcG9ydHNGdWxsU2NyZWVuXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICogYGBganNcbiAgICogICAgIC8vIGdldFxuICAgKiAgICAgdmFyIGZ1bGxzY3JlZW5Pck5vdCA9IG15UGxheWVyLmlzRnVsbHNjcmVlbigpO1xuICAgKiAgICAgLy8gc2V0XG4gICAqICAgICBteVBsYXllci5pc0Z1bGxzY3JlZW4odHJ1ZSk7IC8vIHRlbGwgdGhlIHBsYXllciBpdCdzIGluIGZ1bGxzY3JlZW5cbiAgICogYGBgXG4gICAqIE5PVEU6IEFzIG9mIHRoZSBsYXRlc3QgSFRNTDUgc3BlYywgaXNGdWxsc2NyZWVuIGlzIG5vIGxvbmdlciBhbiBvZmZpY2lhbFxuICAgKiBwcm9wZXJ0eSBhbmQgaW5zdGVhZCBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCBpcyB1c2VkLiBCdXQgaXNGdWxsc2NyZWVuIGlzXG4gICAqIHN0aWxsIGEgdmFsdWFibGUgcHJvcGVydHkgZm9yIGludGVybmFsIHBsYXllciB3b3JraW5ncy5cbiAgICpcbiAgICogQHBhcmFtICB7Qm9vbGVhbj19IGlzRlMgVXBkYXRlIHRoZSBwbGF5ZXIncyBmdWxsc2NyZWVuIHN0YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZnVsbHNjcmVlbiBmYWxzZSBpZiBub3Qgd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZiB3aGVuIHNldHRpbmdcbiAgICogQG1ldGhvZCBpc0Z1bGxzY3JlZW5cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5pc0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiBpc0Z1bGxzY3JlZW4oaXNGUykge1xuICAgIGlmIChpc0ZTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuXyA9ICEhaXNGUztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmlzRnVsbHNjcmVlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSB2aWRlbyB0byBmdWxsIHNjcmVlblxuICAgKiBgYGBqc1xuICAgKiAgICAgbXlQbGF5ZXIucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICogYGBgXG4gICAqIEluIHNvbWUgYnJvd3NlcnMsIGZ1bGwgc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHksIHNvIGl0IGVudGVyc1xuICAgKiBcImZ1bGwgd2luZG93IG1vZGVcIiwgd2hlcmUgdGhlIHZpZGVvIGZpbGxzIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICogSW4gYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBzdXBwb3J0IG5hdGl2ZSBmdWxsIHNjcmVlbiwgc29tZXRpbWVzIHRoZVxuICAgKiBicm93c2VyJ3MgZGVmYXVsdCBjb250cm9scyB3aWxsIGJlIHNob3duLCBhbmQgbm90IHRoZSBWaWRlby5qcyBjdXN0b20gc2tpbi5cbiAgICogVGhpcyBpbmNsdWRlcyBtb3N0IG1vYmlsZSBkZXZpY2VzIChpT1MsIEFuZHJvaWQpIGFuZCBvbGRlciB2ZXJzaW9ucyBvZlxuICAgKiBTYWZhcmkuXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZlxuICAgKiBAbWV0aG9kIHJlcXVlc3RGdWxsc2NyZWVuXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucmVxdWVzdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbiByZXF1ZXN0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBfZnVsbHNjcmVlbkFwaUpzMlsnZGVmYXVsdCddO1xuXG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4odHJ1ZSk7XG5cbiAgICBpZiAoZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgIC8vIHRoZSBicm93c2VyIHN1cHBvcnRzIGdvaW5nIGZ1bGxzY3JlZW4gYXQgdGhlIGVsZW1lbnQgbGV2ZWwgc28gd2UgY2FuXG4gICAgICAvLyB0YWtlIHRoZSBjb250cm9scyBmdWxsc2NyZWVuIGFzIHdlbGwgYXMgdGhlIHZpZGVvXG5cbiAgICAgIC8vIFRyaWdnZXIgZnVsbHNjcmVlbmNoYW5nZSBldmVudCBhZnRlciBjaGFuZ2VcbiAgICAgIC8vIFdlIGhhdmUgdG8gc3BlY2lmaWNhbGx5IGFkZCB0aGlzIGVhY2ggdGltZSwgYW5kIHJlbW92ZVxuICAgICAgLy8gd2hlbiBjYW5jZWxpbmcgZnVsbHNjcmVlbi4gT3RoZXJ3aXNlIGlmIHRoZXJlJ3MgbXVsdGlwbGVcbiAgICAgIC8vIHBsYXllcnMgb24gYSBwYWdlLCB0aGV5IHdvdWxkIGFsbCBiZSByZWFjdGluZyB0byB0aGUgc2FtZSBmdWxsc2NyZWVuXG4gICAgICAvLyBldmVudHNcbiAgICAgIEV2ZW50cy5vbihfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10sIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIEZuLmJpbmQodGhpcywgZnVuY3Rpb24gZG9jdW1lbnRGdWxsc2NyZWVuQ2hhbmdlKGUpIHtcbiAgICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4oX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddW2ZzQXBpLmZ1bGxzY3JlZW5FbGVtZW50XSk7XG5cbiAgICAgICAgLy8gSWYgY2FuY2VsbGluZyBmdWxsc2NyZWVuLCByZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpID09PSBmYWxzZSkge1xuICAgICAgICAgIEV2ZW50cy5vZmYoX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLCBmc0FwaS5mdWxsc2NyZWVuY2hhbmdlLCBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgICB9KSk7XG5cbiAgICAgIHRoaXMuZWxfW2ZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuXSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZWNoXy5zdXBwb3J0c0Z1bGxTY3JlZW4oKSkge1xuICAgICAgLy8gd2UgY2FuJ3QgdGFrZSB0aGUgdmlkZW8uanMgY29udHJvbHMgZnVsbHNjcmVlbiBidXQgd2UgY2FuIGdvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIHdpdGggbmF0aXZlIGNvbnRyb2xzXG4gICAgICB0aGlzLnRlY2hDYWxsXygnZW50ZXJGdWxsU2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZ1bGxzY3JlZW4gaXNuJ3Qgc3VwcG9ydGVkIHNvIHdlJ2xsIGp1c3Qgc3RyZXRjaCB0aGUgdmlkZW8gZWxlbWVudCB0b1xuICAgICAgLy8gZmlsbCB0aGUgdmlld3BvcnRcbiAgICAgIHRoaXMuZW50ZXJGdWxsV2luZG93KCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKiBgYGBqc1xuICAgKiAgICAgbXlQbGF5ZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn0gc2VsZlxuICAgKiBAbWV0aG9kIGV4aXRGdWxsc2NyZWVuXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuZXhpdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBfZnVsbHNjcmVlbkFwaUpzMlsnZGVmYXVsdCddO1xuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J11bZnNBcGkuZXhpdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2hfLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnZXhpdEZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgd2UgY2FuIHN0cmV0Y2ggdGhlIHZpZGVvIGNvbnRhaW5lciB0byBhcyB3aWRlIGFzIHRoZSBicm93c2VyIHdpbGwgbGV0IHVzLlxuICAgKlxuICAgKiBAbWV0aG9kIGVudGVyRnVsbFdpbmRvd1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmVudGVyRnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGVudGVyRnVsbFdpbmRvdygpIHtcbiAgICB0aGlzLmlzRnVsbFdpbmRvdyA9IHRydWU7XG5cbiAgICAvLyBTdG9yaW5nIG9yaWdpbmFsIGRvYyBvdmVyZmxvdyB2YWx1ZSB0byByZXR1cm4gdG8gd2hlbiBmdWxsc2NyZWVuIGlzIG9mZlxuICAgIHRoaXMuZG9jT3JpZ092ZXJmbG93ID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcblxuICAgIC8vIEFkZCBsaXN0ZW5lciBmb3IgZXNjIGtleSB0byBleGl0IGZ1bGxzY3JlZW5cbiAgICBFdmVudHMub24oX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLCAna2V5ZG93bicsIEZuLmJpbmQodGhpcywgdGhpcy5mdWxsV2luZG93T25Fc2NLZXkpKTtcblxuICAgIC8vIEhpZGUgYW55IHNjcm9sbCBiYXJzXG4gICAgX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgLy8gQXBwbHkgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICBEb20uYWRkRWxDbGFzcyhfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNhbGwgdG8gZWl0aGVyIGV4aXQgZnVsbCB3aW5kb3cgb3IgZnVsbCBzY3JlZW4gb24gRVNDIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRXZlbnQgdG8gY2hlY2sgZm9yIGtleSBwcmVzc1xuICAgKiBAbWV0aG9kIGZ1bGxXaW5kb3dPbkVzY0tleVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmZ1bGxXaW5kb3dPbkVzY0tleSA9IGZ1bmN0aW9uIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xuICAgKlxuICAgKiBAbWV0aG9kIGV4aXRGdWxsV2luZG93XG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuZXhpdEZ1bGxXaW5kb3cgPSBmdW5jdGlvbiBleGl0RnVsbFdpbmRvdygpIHtcbiAgICB0aGlzLmlzRnVsbFdpbmRvdyA9IGZhbHNlO1xuICAgIEV2ZW50cy5vZmYoX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gdGhpcy5kb2NPcmlnT3ZlcmZsb3c7XG5cbiAgICAvLyBSZW1vdmUgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICBEb20ucmVtb3ZlRWxDbGFzcyhfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLy8gUmVzaXplIHRoZSBib3gsIGNvbnRyb2xsZXIsIGFuZCBwb3N0ZXIgdG8gb3JpZ2luYWwgc2l6ZXNcbiAgICAvLyB0aGlzLnBvc2l0aW9uQWxsKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHBsYXkgYSBnaXZlbiBtaW1ldHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7U3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKiBAbWV0aG9kIGNhblBsYXlUeXBlXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGNhbiA9IHVuZGVmaW5lZDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlY2hOYW1lID0gX3V0aWxzVG9UaXRsZUNhc2VKczJbJ2RlZmF1bHQnXShqW2ldKTtcbiAgICAgIHZhciB0ZWNoID0gX3RlY2hUZWNoSnMyWydkZWZhdWx0J10uZ2V0VGVjaCh0ZWNoTmFtZSk7XG5cbiAgICAgIC8vIFN1cHBvcnQgb2xkIGJlaGF2aW9yIG9mIHRlY2hzIGJlaW5nIHJlZ2lzdGVyZWQgYXMgY29tcG9uZW50cy5cbiAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxuICAgICAgaWYgKCF0ZWNoKSB7XG4gICAgICAgIHRlY2ggPSBfY29tcG9uZW50SnMyWydkZWZhdWx0J10uZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdGVjaCBpcyBkZWZpbmVkIGJlZm9yZSBjb250aW51aW5nXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10uZXJyb3IoJ1RoZSBcIicgKyB0ZWNoTmFtZSArICdcIiB0ZWNoIGlzIHVuZGVmaW5lZC4gU2tpcHBlZCBicm93c2VyIHN1cHBvcnQgY2hlY2sgZm9yIHRoYXQgdGVjaC4nKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgaWYgKHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBjYW4gPSB0ZWNoLmNhblBsYXlUeXBlKHR5cGUpO1xuXG4gICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3Qgc291cmNlIGJhc2VkIG9uIHRlY2gtb3JkZXIgb3Igc291cmNlLW9yZGVyXG4gICAqIFVzZXMgc291cmNlLW9yZGVyIHNlbGVjdGlvbiBpZiBgb3B0aW9ucy5zb3VyY2VPcmRlcmAgaXMgdHJ1dGh5LiBPdGhlcndpc2UsXG4gICAqIGRlZmF1bHRzIHRvIHRlY2gtb3JkZXIgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZXMgVGhlIHNvdXJjZXMgZm9yIGEgbWVkaWEgYXNzZXRcbiAgICogQHJldHVybiB7T2JqZWN0fEJvb2xlYW59IE9iamVjdCBvZiBzb3VyY2UgYW5kIHRlY2ggb3JkZXIsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAbWV0aG9kIHNlbGVjdFNvdXJjZVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnNlbGVjdFNvdXJjZSA9IGZ1bmN0aW9uIHNlbGVjdFNvdXJjZShzb3VyY2VzKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvLyBHZXQgb25seSB0aGUgdGVjaHMgc3BlY2lmaWVkIGluIGB0ZWNoT3JkZXJgIHRoYXQgZXhpc3QgYW5kIGFyZSBzdXBwb3J0ZWQgYnkgdGhlXG4gICAgLy8gY3VycmVudCBwbGF0Zm9ybVxuICAgIHZhciB0ZWNocyA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyLm1hcChfdXRpbHNUb1RpdGxlQ2FzZUpzMlsnZGVmYXVsdCddKS5tYXAoZnVuY3Rpb24gKHRlY2hOYW1lKSB7XG4gICAgICAvLyBgQ29tcG9uZW50LmdldENvbXBvbmVudCguLi4pYCBpcyBmb3Igc3VwcG9ydCBvZiBvbGQgYmVoYXZpb3Igb2YgdGVjaHNcbiAgICAgIC8vIGJlaW5nIHJlZ2lzdGVyZWQgYXMgY29tcG9uZW50cy5cbiAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxuICAgICAgcmV0dXJuIFt0ZWNoTmFtZSwgX3RlY2hUZWNoSnMyWydkZWZhdWx0J10uZ2V0VGVjaCh0ZWNoTmFtZSkgfHwgX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLmdldENvbXBvbmVudCh0ZWNoTmFtZSldO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHRlY2hOYW1lID0gX3JlZlswXTtcbiAgICAgIHZhciB0ZWNoID0gX3JlZlsxXTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdGVjaCBpcyBkZWZpbmVkIGJlZm9yZSBjb250aW51aW5nXG4gICAgICBpZiAodGVjaCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgICAgcmV0dXJuIHRlY2guaXNTdXBwb3J0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10uZXJyb3IoJ1RoZSBcIicgKyB0ZWNoTmFtZSArICdcIiB0ZWNoIGlzIHVuZGVmaW5lZC4gU2tpcHBlZCBicm93c2VyIHN1cHBvcnQgY2hlY2sgZm9yIHRoYXQgdGVjaC4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGBpbm5lckFycmF5YCBlbGVtZW50IG9uY2UgcGVyIGBvdXRlckFycmF5YCBlbGVtZW50IGFuZCBleGVjdXRlXG4gICAgLy8gYHRlc3RlcmAgd2l0aCBib3RoLiBJZiBgdGVzdGVyYCByZXR1cm5zIGEgbm9uLWZhbHN5IHZhbHVlLCBleGl0IGVhcmx5IGFuZCByZXR1cm5cbiAgICAvLyB0aGF0IHZhbHVlLlxuICAgIHZhciBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIgPSBmdW5jdGlvbiBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIob3V0ZXJBcnJheSwgaW5uZXJBcnJheSwgdGVzdGVyKSB7XG4gICAgICB2YXIgZm91bmQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIG91dGVyQXJyYXkuc29tZShmdW5jdGlvbiAob3V0ZXJDaG9pY2UpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyQXJyYXkuc29tZShmdW5jdGlvbiAoaW5uZXJDaG9pY2UpIHtcbiAgICAgICAgICBmb3VuZCA9IHRlc3RlcihvdXRlckNob2ljZSwgaW5uZXJDaG9pY2UpO1xuXG4gICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xuXG4gICAgdmFyIGZvdW5kU291cmNlQW5kVGVjaCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZmxpcCA9IGZ1bmN0aW9uIGZsaXAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZm4oYiwgYSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGZpbmRlciA9IGZ1bmN0aW9uIGZpbmRlcihfcmVmMiwgc291cmNlKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBfcmVmMlswXTtcbiAgICAgIHZhciB0ZWNoID0gX3JlZjJbMV07XG5cbiAgICAgIGlmICh0ZWNoLmNhblBsYXlTb3VyY2Uoc291cmNlLCBfdGhpczMub3B0aW9uc19bdGVjaE5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgICAgIHJldHVybiB7IHNvdXJjZTogc291cmNlLCB0ZWNoOiB0ZWNoTmFtZSB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHRydXRoaW5lc3Mgb2YgYG9wdGlvbnMuc291cmNlT3JkZXJgLCB3ZSBzd2FwIHRoZSBvcmRlciBvZiB0ZWNocyBhbmQgc291cmNlc1xuICAgIC8vIHRvIHNlbGVjdCBmcm9tIHRoZW0gYmFzZWQgb24gdGhlaXIgcHJpb3JpdHkuXG4gICAgaWYgKHRoaXMub3B0aW9uc18uc291cmNlT3JkZXIpIHtcbiAgICAgIC8vIFNvdXJjZS1maXJzdCBvcmRlcmluZ1xuICAgICAgZm91bmRTb3VyY2VBbmRUZWNoID0gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKHNvdXJjZXMsIHRlY2hzLCBmbGlwKGZpbmRlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUZWNoLWZpcnN0IG9yZGVyaW5nXG4gICAgICBmb3VuZFNvdXJjZUFuZFRlY2ggPSBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIodGVjaHMsIHNvdXJjZXMsIGZpbmRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kU291cmNlQW5kVGVjaCB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHNvdXJjZSBmdW5jdGlvbiB1cGRhdGVzIHRoZSB2aWRlbyBzb3VyY2VcbiAgICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHZhcmlhYmxlcyB5b3UgY2FuIHBhc3MgYXMgdGhlIGFyZ3VtZW50LlxuICAgKiAqKlVSTCBTdHJpbmcqKjogQSBVUkwgdG8gdGhlIHRoZSB2aWRlbyBmaWxlLiBVc2UgdGhpcyBtZXRob2QgaWYgeW91IGFyZSBzdXJlXG4gICAqIHRoZSBjdXJyZW50IHBsYXliYWNrIHRlY2hub2xvZ3kgKEhUTUw1L0ZsYXNoKSBjYW4gc3VwcG9ydCB0aGUgc291cmNlIHlvdVxuICAgKiBwcm92aWRlLiBDdXJyZW50bHkgb25seSBNUDQgZmlsZXMgY2FuIGJlIHVzZWQgaW4gYm90aCBIVE1MNSBhbmQgRmxhc2guXG4gICAqIGBgYGpzXG4gICAqICAgICBteVBsYXllci5zcmMoXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIpO1xuICAgKiBgYGBcbiAgICogKipTb3VyY2UgT2JqZWN0IChvciBlbGVtZW50KToqICogQSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uXG4gICAqIGFib3V0IHRoZSBzb3VyY2UgZmlsZS4gVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRoZSBwbGF5ZXIgdG8gZGV0ZXJtaW5lIGlmXG4gICAqIGl0IGNhbiBzdXBwb3J0IHRoZSBmaWxlIHVzaW5nIHRoZSB0eXBlIGluZm9ybWF0aW9uLlxuICAgKiBgYGBqc1xuICAgKiAgICAgbXlQbGF5ZXIuc3JjKHsgdHlwZTogXCJ2aWRlby9tcDRcIiwgc3JjOiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vcGF0aC90by92aWRlby5tcDRcIiB9KTtcbiAgICogYGBgXG4gICAqICoqQXJyYXkgb2YgU291cmNlIE9iamVjdHM6KiAqIFRvIHByb3ZpZGUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIHNvdXJjZSBzb1xuICAgKiB0aGF0IGl0IGNhbiBiZSBwbGF5ZWQgdXNpbmcgSFRNTDUgYWNyb3NzIGJyb3dzZXJzIHlvdSBjYW4gdXNlIGFuIGFycmF5IG9mXG4gICAqIHNvdXJjZSBvYmplY3RzLiBWaWRlby5qcyB3aWxsIGRldGVjdCB3aGljaCB2ZXJzaW9uIGlzIHN1cHBvcnRlZCBhbmQgbG9hZCB0aGF0XG4gICAqIGZpbGUuXG4gICAqIGBgYGpzXG4gICAqICAgICBteVBsYXllci5zcmMoW1xuICAgKiAgICAgICB7IHR5cGU6IFwidmlkZW8vbXA0XCIsIHNyYzogXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIgfSxcbiAgICogICAgICAgeyB0eXBlOiBcInZpZGVvL3dlYm1cIiwgc3JjOiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vcGF0aC90by92aWRlby53ZWJtXCIgfSxcbiAgICogICAgICAgeyB0eXBlOiBcInZpZGVvL29nZ1wiLCBzcmM6IFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm9ndlwiIH1cbiAgICogICAgIF0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdHxBcnJheT19IHNvdXJjZSBUaGUgc291cmNlIFVSTCwgb2JqZWN0LCBvciBhcnJheSBvZiBzb3VyY2VzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGN1cnJlbnQgdmlkZW8gc291cmNlIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqIEBtZXRob2Qgc3JjXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3NyYycpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VGVjaCA9IF90ZWNoVGVjaEpzMlsnZGVmYXVsdCddLmdldFRlY2godGhpcy50ZWNoTmFtZV8pO1xuICAgIC8vIFN1cHBvcnQgb2xkIGJlaGF2aW9yIG9mIHRlY2hzIGJlaW5nIHJlZ2lzdGVyZWQgYXMgY29tcG9uZW50cy5cbiAgICAvLyBSZW1vdmUgb25jZSB0aGF0IGRlcHJlY2F0ZWQgYmVoYXZpb3IgaXMgcmVtb3ZlZC5cbiAgICBpZiAoIWN1cnJlbnRUZWNoKSB7XG4gICAgICBjdXJyZW50VGVjaCA9IF9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5nZXRDb21wb25lbnQodGhpcy50ZWNoTmFtZV8pO1xuICAgIH1cblxuICAgIC8vIGNhc2U6IEFycmF5IG9mIHNvdXJjZSBvYmplY3RzIHRvIGNob29zZSBmcm9tIGFuZCBwaWNrIHRoZSBiZXN0IHRvIHBsYXlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnNvdXJjZUxpc3RfKHNvdXJjZSk7XG5cbiAgICAgIC8vIGNhc2U6IFVSTCBTdHJpbmcgKGh0dHA6Ly9teXZpZGVvLi4uKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgc291cmNlIG9iamVjdCBmcm9tIHRoZSBzdHJpbmdcbiAgICAgICAgdGhpcy5zcmMoeyBzcmM6IHNvdXJjZSB9KTtcblxuICAgICAgICAvLyBjYXNlOiBTb3VyY2Ugb2JqZWN0IHsgc3JjOiAnJywgdHlwZTogJycgLi4uIH1cbiAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNvdXJjZSBoYXMgYSB0eXBlIGFuZCB0aGUgbG9hZGVkIHRlY2ggY2Fubm90IHBsYXkgdGhlIHNvdXJjZVxuICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gdHlwZSB3ZSdsbCBqdXN0IHRyeSB0aGUgY3VycmVudCB0ZWNoXG4gICAgICAgICAgaWYgKHNvdXJjZS50eXBlICYmICFjdXJyZW50VGVjaC5jYW5QbGF5U291cmNlKHNvdXJjZSwgdGhpcy5vcHRpb25zX1t0aGlzLnRlY2hOYW1lXy50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHNvdXJjZSBsaXN0IHdpdGggdGhlIGN1cnJlbnQgc291cmNlIGFuZCBzZW5kIHRocm91Z2hcbiAgICAgICAgICAgIC8vIHRoZSB0ZWNoIGxvb3AgdG8gY2hlY2sgZm9yIGEgY29tcGF0aWJsZSB0ZWNobm9sb2d5XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUxpc3RfKFtzb3VyY2VdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWNoZV8uc3JjID0gc291cmNlLnNyYztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFR5cGVfID0gc291cmNlLnR5cGUgfHwgJyc7XG5cbiAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICAgICAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgIC8vIFRoZSBzZXRTb3VyY2UgdGVjaCBtZXRob2Qgd2FzIGFkZGVkIHdpdGggc291cmNlIGhhbmRsZXJzXG4gICAgICAgICAgICAgIC8vIHNvIG9sZGVyIHRlY2hzIHdvbid0IHN1cHBvcnQgaXRcbiAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGUgZGlyZWN0IHByb3RvdHlwZSBmb3IgdGhlIGNhc2Ugd2hlcmUgc3ViY2xhc3Nlc1xuICAgICAgICAgICAgICAvLyBvZiB0aGUgdGVjaCBkbyBub3Qgc3VwcG9ydCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUZWNoLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc2V0U291cmNlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlY2hDYWxsXygnc2V0U291cmNlJywgc291cmNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlY2hDYWxsXygnc3JjJywgc291cmNlLnNyYyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5wcmVsb2FkID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmF1dG9wbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBTZXQgdGhlIHNvdXJjZSBzeW5jaHJvbm91c2x5IGlmIHBvc3NpYmxlICgjMjMyNilcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0c1xuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheX0gc291cmNlcyBBcnJheSBvZiBzb3VyY2Ugb2JqZWN0c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIHNvdXJjZUxpc3RfXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuc291cmNlTGlzdF8gPSBmdW5jdGlvbiBzb3VyY2VMaXN0Xyhzb3VyY2VzKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShzb3VyY2VzKTtcblxuICAgIGlmIChzb3VyY2VUZWNoKSB7XG4gICAgICBpZiAoc291cmNlVGVjaC50ZWNoID09PSB0aGlzLnRlY2hOYW1lXykge1xuICAgICAgICAvLyBpZiB0aGlzIHRlY2hub2xvZ3kgaXMgYWxyZWFkeSBsb2FkZWQsIHNldCB0aGUgc291cmNlXG4gICAgICAgIHRoaXMuc3JjKHNvdXJjZVRlY2guc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxvYWQgdGhpcyB0ZWNobm9sb2d5IHdpdGggdGhlIGNob3NlbiBzb3VyY2VcbiAgICAgICAgdGhpcy5sb2FkVGVjaF8oc291cmNlVGVjaC50ZWNoLCBzb3VyY2VUZWNoLnNvdXJjZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGEgdGltZW91dCB0byBnaXZlIGZvbGtzIGEgY2hhbmNlIHRvIGFkZCBlcnJvciBldmVudCBoYW5kbGVyc1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5ub3RTdXBwb3J0ZWRNZXNzYWdlKSB9KTtcbiAgICAgIH0sIDApO1xuXG4gICAgICAvLyB3ZSBjb3VsZCBub3QgZmluZCBhbiBhcHByb3ByaWF0ZSB0ZWNoLCBidXQgbGV0J3Mgc3RpbGwgbm90aWZ5IHRoZSBkZWxlZ2F0ZSB0aGF0IHRoaXMgaXMgaXRcbiAgICAgIC8vIHRoaXMgbmVlZHMgYSBiZXR0ZXIgY29tbWVudCBhYm91dCB3aHkgdGhpcyBpcyBuZWVkZWRcbiAgICAgIHRoaXMudHJpZ2dlclJlYWR5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCZWdpbiBsb2FkaW5nIHRoZSBzcmMgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfSBSZXR1cm5zIHRoZSBwbGF5ZXJcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ2xvYWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHBsYXllci4gTG9hZHMgdGhlIGZpcnN0IHRlY2ggaW4gdGhlIHRlY2hPcmRlcixcbiAgICogYW5kIGNhbGxzIGByZXNldGAgb24gdGhlIHRlY2hgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IFJldHVybnMgdGhlIHBsYXllclxuICAgKiBAbWV0aG9kIHJlc2V0XG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmxvYWRUZWNoXyhfdXRpbHNUb1RpdGxlQ2FzZUpzMlsnZGVmYXVsdCddKHRoaXMub3B0aW9uc18udGVjaE9yZGVyWzBdKSwgbnVsbCk7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3Jlc2V0Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgc291cmNlIHZhbHVlIGUuZy4gaHR0cDovL215c2l0ZS5jb20vdmlkZW8ubXA0XG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBgY3VycmVudFR5cGVgIHRvIGFzc2lzdCBpbiByZWJ1aWxkaW5nIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGN1cnJlbnQgc291cmNlXG4gICAqIEBtZXRob2QgY3VycmVudFNyY1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdjdXJyZW50U3JjJykgfHwgdGhpcy5jYWNoZV8uc3JjIHx8ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlIHR5cGUgZS5nLiB2aWRlby9tcDRcbiAgICogVGhpcyBjYW4gYWxsb3cgeW91IHJlYnVpbGQgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdCBzbyB0aGF0IHlvdSBjb3VsZCBsb2FkIHRoZSBzYW1lXG4gICAqIHNvdXJjZSBhbmQgdGVjaCBsYXRlclxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzb3VyY2UgTUlNRSB0eXBlXG4gICAqIEBtZXRob2QgY3VycmVudFR5cGVcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VHlwZSA9IGZ1bmN0aW9uIGN1cnJlbnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRUeXBlXyB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcHJlbG9hZCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBCb29sZWFuIHRvIGRldGVybWluZSBpZiBwcmVsb2FkIHNob3VsZCBiZSB1c2VkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByZWxvYWQgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IFJldHVybnMgdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICogQG1ldGhvZCBwcmVsb2FkXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIHByZWxvYWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFByZWxvYWQnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnByZWxvYWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncHJlbG9hZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgQm9vbGVhbiB0byBkZXRlcm1pbmUgaWYgdmlkZW8gc2hvdWxkIGF1dG9wbGF5XG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSB2YWx1ZSB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBSZXR1cm5zIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqIEBtZXRob2QgYXV0b3BsYXlcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hdXRvcGxheSA9IGZ1bmN0aW9uIGF1dG9wbGF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRBdXRvcGxheScsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnYXV0b3BsYXknLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvb3AgYXR0cmlidXRlIG9uIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIEJvb2xlYW4gdG8gZGV0ZXJtaW5lIGlmIHZpZGVvIHNob3VsZCBsb29wXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxvb3AgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IFJldHVybnMgdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICogQG1ldGhvZCBsb29wXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uIGxvb3AodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldExvb3AnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfWydsb29wJ10gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbG9vcCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiAjIyMjIyBFWEFNUExFOlxuICAgKiBgYGBqc1xuICAgKiAgICAgLy8gZ2V0XG4gICAqICAgICB2YXIgY3VycmVudFBvc3RlciA9IG15UGxheWVyLnBvc3RlcigpO1xuICAgKiAgICAgLy8gc2V0XG4gICAqICAgICBteVBsYXllci5wb3N0ZXIoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teUltYWdlLmpwZycpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nPX0gc3JjIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqIEByZXR1cm4ge1N0cmluZ30gcG9zdGVyIFVSTCB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSBzZWxmIHdoZW4gc2V0dGluZ1xuICAgKiBAbWV0aG9kIHBvc3RlclxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnBvc3RlciA9IGZ1bmN0aW9uIHBvc3RlcihzcmMpIHtcbiAgICBpZiAoc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc3Rlcl87XG4gICAgfVxuXG4gICAgLy8gVGhlIGNvcnJlY3Qgd2F5IHRvIHJlbW92ZSBhIHBvc3RlciBpcyB0byBzZXQgYXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgLy8gb3RoZXIgZmFsc2V5IHZhbHVlcyB3aWxsIHRocm93IGVycm9yc1xuICAgIGlmICghc3JjKSB7XG4gICAgICBzcmMgPSAnJztcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGludGVybmFsIHBvc3RlciB2YXJpYWJsZVxuICAgIHRoaXMucG9zdGVyXyA9IHNyYztcblxuICAgIC8vIHVwZGF0ZSB0aGUgdGVjaCdzIHBvc3RlclxuICAgIHRoaXMudGVjaENhbGxfKCdzZXRQb3N0ZXInLCBzcmMpO1xuXG4gICAgLy8gYWxlcnQgY29tcG9uZW50cyB0aGF0IHRoZSBwb3N0ZXIgaGFzIGJlZW4gc2V0XG4gICAgdGhpcy50cmlnZ2VyKCdwb3N0ZXJjaGFuZ2UnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb21lIHRlY2hzIChlLmcuIFlvdVR1YmUpIGNhbiBwcm92aWRlIGEgcG9zdGVyIHNvdXJjZSBpbiBhblxuICAgKiBhc3luY2hyb25vdXMgd2F5LiBXZSB3YW50IHRoZSBwb3N0ZXIgY29tcG9uZW50IHRvIHVzZSB0aGlzXG4gICAqIHBvc3RlciBzb3VyY2Ugc28gdGhhdCBpdCBjb3ZlcnMgdXAgdGhlIHRlY2gncyBjb250cm9scy5cbiAgICogKFlvdVR1YmUncyBwbGF5IGJ1dHRvbikuIEhvd2V2ZXIgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzXG4gICAqIHNvcnVjZSBpZiB0aGUgcGxheWVyIHVzZXIgaGFzbid0IHNldCBhIHBvc3RlciB0aHJvdWdoXG4gICAqIHRoZSBub3JtYWwgQVBJcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBoYW5kbGVUZWNoUG9zdGVyQ2hhbmdlX1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKSB7XG4gICAgaWYgKCF0aGlzLnBvc3Rlcl8gJiYgdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnBvc3Rlcikge1xuICAgICAgdGhpcy5wb3N0ZXJfID0gdGhpcy50ZWNoXy5wb3N0ZXIoKSB8fCAnJztcblxuICAgICAgLy8gTGV0IGNvbXBvbmVudHMga25vdyB0aGUgcG9zdGVyIGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbHMgYXJlIHNob3dpbmcuXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGJvb2wgU2V0IGNvbnRyb2xzIHRvIHNob3dpbmcgb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIENvbnRyb2xzIGFyZSBzaG93aW5nXG4gICAqIEBtZXRob2QgY29udHJvbHNcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sOyAvLyBmb3JjZSBib29sZWFuXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5jb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy5jb250cm9sc18gPSBib29sO1xuXG4gICAgICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDb250cm9scycsIGJvb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZGlzYWJsZWQnKTtcblxuICAgICAgICAgIGlmICghdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuY29udHJvbHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgbmF0aXZlIGNvbnRyb2xzIG9uL29mZi4gTmF0aXZlIGNvbnRyb2xzIGFyZSB0aGUgY29udHJvbHMgYnVpbHQgaW50b1xuICAgKiBkZXZpY2VzIChlLmcuIGRlZmF1bHQgaVBob25lIGNvbnRyb2xzKSwgRmxhc2gsIG9yIG90aGVyIHRlY2hzXG4gICAqIChlLmcuIFZpbWVvIENvbnRyb2xzKVxuICAgKiAqKlRoaXMgc2hvdWxkIG9ubHkgYmUgc2V0IGJ5IHRoZSBjdXJyZW50IHRlY2gsIGJlY2F1c2Ugb25seSB0aGUgdGVjaCBrbm93c1xuICAgKiBpZiBpdCBjYW4gc3VwcG9ydCBuYXRpdmUgY29udHJvbHMqKlxuICAgKlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBib29sICAgIFRydWUgc2lnbmFscyB0aGF0IG5hdGl2ZSBjb250cm9scyBhcmUgb25cbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgIFJldHVybnMgdGhlIHBsYXllclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIHVzaW5nTmF0aXZlQ29udHJvbHNcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2luZ05hdGl2ZUNvbnRyb2xzID0gZnVuY3Rpb24gdXNpbmdOYXRpdmVDb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDsgLy8gZm9yY2UgYm9vbGVhblxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9IGJvb2w7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIHBsYXllciBpcyB1c2luZyB0aGUgbmF0aXZlIGRldmljZSBjb250cm9sc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICAqIEBldmVudCB1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBQbGF5ZXJcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNpbmduYXRpdmVjb250cm9scycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIGN1c3RvbSBIVE1MIGNvbnRyb2xzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgICogQGV2ZW50IHVzaW5nY3VzdG9tY29udHJvbHNcbiAgICAgICAgICAgICogQG1lbWJlcm9mIFBsYXllclxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ2N1c3RvbWNvbnRyb2xzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgb3IgZ2V0IHRoZSBjdXJyZW50IE1lZGlhRXJyb3JcbiAgICpcbiAgICogQHBhcmFtICB7Kn0gZXJyIEEgTWVkaWFFcnJvciBvciBhIFN0cmluZy9OdW1iZXIgdG8gYmUgdHVybmVkIGludG8gYSBNZWRpYUVycm9yXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH0gICAgIHdoZW4gZ2V0dGluZ1xuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9ICAgICAgICAgICAgICB3aGVuIHNldHRpbmdcbiAgICogQG1ldGhvZCBlcnJvclxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl8gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JpbmcgdG8gZGVmYXVsdFxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVycm9yJyk7XG4gICAgICBpZiAodGhpcy5lcnJvckRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5lcnJvckRpc3BsYXkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3JfID0gbmV3IF9tZWRpYUVycm9ySnMyWydkZWZhdWx0J10oZXJyKTtcblxuICAgIC8vIGFkZCB0aGUgdmpzLWVycm9yIGNsYXNzbmFtZSB0byB0aGUgcGxheWVyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVycm9yJyk7XG5cbiAgICAvLyBsb2cgdGhlIG5hbWUgb2YgdGhlIGVycm9yIHR5cGUgYW5kIGFueSBtZXNzYWdlXG4gICAgLy8gaWU4IGp1c3QgbG9ncyBcIltvYmplY3Qgb2JqZWN0XVwiIGlmIHlvdSBqdXN0IGxvZyB0aGUgZXJyb3Igb2JqZWN0XG4gICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10uZXJyb3IoJyhDT0RFOicgKyB0aGlzLmVycm9yXy5jb2RlICsgJyAnICsgX21lZGlhRXJyb3JKczJbJ2RlZmF1bHQnXS5lcnJvclR5cGVzW3RoaXMuZXJyb3JfLmNvZGVdICsgJyknLCB0aGlzLmVycm9yXy5tZXNzYWdlLCB0aGlzLmVycm9yXyk7XG5cbiAgICAvLyBmaXJlIGFuIGVycm9yIGV2ZW50IG9uIHRoZSBwbGF5ZXJcbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgZW5kZWQgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAgICogQG1ldGhvZCBlbmRlZFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmVuZGVkID0gZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2VuZGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsYXllciBpcyBpbiB0aGUgXCJzZWVraW5nXCIgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgc2Vla2luZyBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICAgKiBAbWV0aG9kIHNlZWtpbmdcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zZWVraW5nID0gZnVuY3Rpb24gc2Vla2luZygpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0Xygnc2Vla2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBUaW1lUmFuZ2VzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlXG4gICAqIGZvciBzZWVraW5nIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2VzfSB0aGUgc2Vla2FibGUgaW50ZXJ2YWxzIG9mIHRoZSBtZWRpYSB0aW1lbGluZVxuICAgKiBAbWV0aG9kIHNlZWthYmxlXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUuc2Vla2FibGUgPSBmdW5jdGlvbiBzZWVrYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0Xygnc2Vla2FibGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVwb3J0IHVzZXIgYWN0aXZpdHlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKiBAbWV0aG9kIHJlcG9ydFVzZXJBY3Rpdml0eVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcG9ydFVzZXJBY3Rpdml0eSA9IGZ1bmN0aW9uIHJlcG9ydFVzZXJBY3Rpdml0eShldmVudCkge1xuICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgaWYgdXNlciBpcyBhY3RpdmVcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBib29sIFZhbHVlIHdoZW4gc2V0dGluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSBWYWx1ZSBpZiB1c2VyIGlzIGFjdGl2ZSB1c2VyIHdoZW4gZ2V0dGluZ1xuICAgKiBAbWV0aG9kIHVzZXJBY3RpdmVcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2VyQWN0aXZlID0gZnVuY3Rpb24gdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDtcbiAgICAgIGlmIChib29sICE9PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICAgIHRoaXMudXNlckFjdGl2ZV8gPSBib29sO1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhcyBpbmFjdGl2ZSBhbmQgaXMgbm93IGFjdGl2ZSB3ZSB3YW50IHRvIHJlc2V0IHRoZVxuICAgICAgICAgIC8vIGluYWN0aXZpdHkgdGltZXJcbiAgICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2VyYWN0aXZlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UncmUgc3dpdGNoaW5nIHRoZSBzdGF0ZSB0byBpbmFjdGl2ZSBtYW51YWxseSwgc28gZXJhc2UgYW55IG90aGVyXG4gICAgICAgICAgLy8gYWN0aXZpdHlcbiAgICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgICAgIC8vIENocm9tZS9TYWZhcmkvSUUgaGF2ZSBidWdzIHdoZXJlIHdoZW4geW91IGNoYW5nZSB0aGUgY3Vyc29yIGl0IGNhblxuICAgICAgICAgIC8vIHRyaWdnZXIgYSBtb3VzZW1vdmUgZXZlbnQuIFRoaXMgY2F1c2VzIGFuIGlzc3VlIHdoZW4geW91J3JlIGhpZGluZ1xuICAgICAgICAgIC8vIHRoZSBjdXJzb3Igd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgYW5kIGEgbW91c2Vtb3ZlIHNpZ25hbHMgdXNlclxuICAgICAgICAgIC8vIGFjdGl2aXR5LiBNYWtpbmcgaXQgaW1wb3NzaWJsZSB0byBnbyBpbnRvIGluYWN0aXZlIG1vZGUuIFNwZWNpZmljYWxseVxuICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBpbiBmdWxsc2NyZWVuIHdoZW4gd2UgcmVhbGx5IG5lZWQgdG8gaGlkZSB0aGUgY3Vyc29yLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2hlbiB0aGlzIGdldHMgcmVzb2x2ZWQgaW4gQUxMIGJyb3dzZXJzIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMzA0MVxuICAgICAgICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICAgICAgICB0aGlzLnRlY2hfLm9uZSgnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VzZXJpbmFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXNlckFjdGl2ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgdXNlciBhY3Rpdml0eSBiYXNlZCBvbiB0aW1lb3V0IHZhbHVlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgbGlzdGVuRm9yVXNlckFjdGl2aXR5X1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8gPSBmdW5jdGlvbiBsaXN0ZW5Gb3JVc2VyQWN0aXZpdHlfKCkge1xuICAgIHZhciBtb3VzZUluUHJvZ3Jlc3MgPSB1bmRlZmluZWQsXG4gICAgICAgIGxhc3RNb3ZlWCA9IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdE1vdmVZID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGhhbmRsZUFjdGl2aXR5ID0gRm4uYmluZCh0aGlzLCB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGUpIHtcbiAgICAgIC8vICMxMDY4IC0gUHJldmVudCBtb3VzZW1vdmUgc3BhbW1pbmdcbiAgICAgIC8vIENocm9tZSBCdWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNjY5NzBcbiAgICAgIGlmIChlLnNjcmVlblggIT09IGxhc3RNb3ZlWCB8fCBlLnNjcmVlblkgIT09IGxhc3RNb3ZlWSkge1xuICAgICAgICBsYXN0TW92ZVggPSBlLnNjcmVlblg7XG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcbiAgICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bigpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBTZXR0aW5nIHVzZXJBY3Rpdml0eT10cnVlIG5vdyBhbmQgc2V0dGluZyB0aGUgaW50ZXJ2YWwgdG8gdGhlIHNhbWUgdGltZVxuICAgICAgLy8gYXMgdGhlIGFjdGl2aXR5Q2hlY2sgaW50ZXJ2YWwgKDI1MCkgc2hvdWxkIGVuc3VyZSB3ZSBuZXZlciBtaXNzIHRoZVxuICAgICAgLy8gbmV4dCBhY3Rpdml0eUNoZWNrXG4gICAgICBtb3VzZUluUHJvZ3Jlc3MgPSB0aGlzLnNldEludGVydmFsKGhhbmRsZUFjdGl2aXR5LCAyNTApO1xuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBTdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgbW91c2UvdG91Y2ggaXMgZG93blxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIC8vIEFueSBtb3VzZSBtb3ZlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdXNlciBhY3Rpdml0eVxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAvLyBTaG91bGRuJ3QgbmVlZCB0byB1c2UgaW5Qcm9ncmVzcyBpbnRlcnZhbCBiZWNhdXNlIG9mIGtleSByZXBlYXRcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgaGFuZGxlQWN0aXZpdHkpO1xuXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cbiAgICAvLyB0aGUgbW91c2Vtb3ZlL3RvdWNobW92ZSBmdW5jdGlvbiBpdHNlbGYsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gICAgLy8gYHRoaXMucmVwb3J0VXNlckFjdGl2aXR5YCBzaW1wbHkgc2V0cyB0aGlzLnVzZXJBY3Rpdml0eV8gdG8gdHJ1ZSwgd2hpY2hcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9sZWFybmluZy1mcm9tLXR3aXR0ZXIvXG4gICAgdmFyIGluYWN0aXZpdHlUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIHZhciBhY3Rpdml0eUNoZWNrID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgbW91c2UvdG91Y2ggYWN0aXZpdHkgaGFzIGhhcHBlbmVkXG4gICAgICBpZiAodGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhY3Rpdml0eSB0cmFja2VyXG4gICAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHN0YXRlIHdhcyBpbmFjdGl2ZSwgc2V0IHRoZSBzdGF0ZSB0byBhY3RpdmVcbiAgICAgICAgdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbmFjdGl2aXR5IHRpbWVvdXQgdG8gc3RhcnQgdGhlIHRpbWVyIG92ZXJcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoaW5hY3Rpdml0eVRpbWVvdXQpO1xuXG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5vcHRpb25zX1snaW5hY3Rpdml0eVRpbWVvdXQnXTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgLy8gSW4gPHRpbWVvdXQ+IG1pbGxpc2Vjb25kcywgaWYgbm8gbW9yZSBhY3Rpdml0eSBoYXMgb2NjdXJyZWQgdGhlXG4gICAgICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgICAgICBpbmFjdGl2aXR5VGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgdGhlIGluYWN0aXZpdHlUaW1lb3V0IGNhbiB0cmlnZ2VyIGp1c3RcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHlDaGVjayBsb29wXG4gICAgICAgICAgICAvLyBjYXVzaW5nIGEgZmxpY2tlclxuICAgICAgICAgICAgaWYgKCF0aGlzLnVzZXJBY3Rpdml0eV8pIHtcbiAgICAgICAgICAgICAgdGhpcy51c2VyQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLiAgQSBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWRcbiAgICogcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJhdGUgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgUmV0dXJucyB0aGUgbmV3IHBsYXliYWNrIHJhdGUgd2hlbiBzZXR0aW5nXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nXG4gICAqIEBtZXRob2QgcGxheWJhY2tSYXRlXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucGxheWJhY2tSYXRlID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfWydmZWF0dXJlc1BsYXliYWNrUmF0ZSddKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGxheWJhY2tSYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxLjA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGF1ZGlvIGZsYWdcbiAgICpcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gYm9vbCAgICBUcnVlIHNpZ25hbHMgdGhhdCB0aGlzIGlzIGFuIGF1ZGlvIHBsYXllci5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICBSZXR1cm5zIHRydWUgaWYgcGxheWVyIGlzIGF1ZGlvLCBmYWxzZSBpZiBub3Qgd2hlbiBnZXR0aW5nXG4gICAqIEByZXR1cm4ge1BsYXllcn0gICAgICBSZXR1cm5zIHRoZSBwbGF5ZXIgaWYgc2V0dGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGlzQXVkaW9cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5pc0F1ZGlvID0gZnVuY3Rpb24gaXNBdWRpbyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0F1ZGlvXyA9ICEhYm9vbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiAhIXRoaXMuaXNBdWRpb187XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgbmV0d29yayBhY3Rpdml0eSBmb3IgdGhlIGVsZW1lbnQsIGZyb21cbiAgICogdGhlIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICAgKiAtIE5FVFdPUktfRU1QVFkgKG51bWVyaWMgdmFsdWUgMClcbiAgICogICBUaGUgZWxlbWVudCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpc2VkLiBBbGwgYXR0cmlidXRlcyBhcmUgaW5cbiAgICogICB0aGVpciBpbml0aWFsIHN0YXRlcy5cbiAgICogLSBORVRXT1JLX0lETEUgKG51bWVyaWMgdmFsdWUgMSlcbiAgICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlIGFuZCBoYXNcbiAgICogICBzZWxlY3RlZCBhIHJlc291cmNlLCBidXQgaXQgaXMgbm90IGFjdHVhbGx5IHVzaW5nIHRoZSBuZXR3b3JrIGF0XG4gICAqICAgdGhpcyB0aW1lLlxuICAgKiAtIE5FVFdPUktfTE9BRElORyAobnVtZXJpYyB2YWx1ZSAyKVxuICAgKiAgIFRoZSB1c2VyIGFnZW50IGlzIGFjdGl2ZWx5IHRyeWluZyB0byBkb3dubG9hZCBkYXRhLlxuICAgKiAtIE5FVFdPUktfTk9fU09VUkNFIChudW1lcmljIHZhbHVlIDMpXG4gICAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSwgYnV0IGl0IGhhc1xuICAgKiAgIG5vdCB5ZXQgZm91bmQgYSByZXNvdXJjZSB0byB1c2UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI25ldHdvcmstc3RhdGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGN1cnJlbnQgbmV0d29yayBhY3Rpdml0eSBzdGF0ZVxuICAgKiBAbWV0aG9kIG5ldHdvcmtTdGF0ZVxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLm5ldHdvcmtTdGF0ZSA9IGZ1bmN0aW9uIG5ldHdvcmtTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbmV0d29ya1N0YXRlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGV4cHJlc3NlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICAgKiB3aXRoIHJlc3BlY3QgdG8gcmVuZGVyaW5nIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uLCBmcm9tIHRoZVxuICAgKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAgICogLSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMClcbiAgICogICBObyBpbmZvcm1hdGlvbiByZWdhcmRpbmcgdGhlIG1lZGlhIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAgICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXG4gICAqICAgRW5vdWdoIG9mIHRoZSByZXNvdXJjZSBoYXMgYmVlbiBvYnRhaW5lZCB0aGF0IHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAgICogICByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gICAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcbiAgICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLlxuICAgKiAtIEhBVkVfRlVUVVJFX0RBVEEgKG51bWVyaWMgdmFsdWUgMylcbiAgICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xuICAgKiAgIHdlbGwgYXMgZW5vdWdoIGRhdGEgZm9yIHRoZSB1c2VyIGFnZW50IHRvIGFkdmFuY2UgdGhlIGN1cnJlbnRcbiAgICogICBwbGF5YmFjayBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIG9mIHBsYXliYWNrLlxuICAgKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAgICogICBUaGUgdXNlciBhZ2VudCBlc3RpbWF0ZXMgdGhhdCBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgZm9yXG4gICAqICAgcGxheWJhY2sgdG8gcHJvY2VlZCB1bmludGVycnVwdGVkLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcmVhZHlzdGF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50IHBsYXliYWNrIHJlbmRlcmluZyBzdGF0ZVxuICAgKiBAbWV0aG9kIHJlYWR5U3RhdGVcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZWFkeVN0YXRlID0gZnVuY3Rpb24gcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncmVhZHlTdGF0ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSB2aWRlbyB0cmFjayBsaXN0XG4gICAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdFxuICAgKlxuICAgKiBAcmV0dXJuIHtWaWRlb1RyYWNrTGlzdH0gdGhlcyBjdXJyZW50IHZpZGVvIHRyYWNrIGxpc3RcbiAgICogQG1ldGhvZCB2aWRlb1RyYWNrc1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvVHJhY2tzID0gZnVuY3Rpb24gdmlkZW9UcmFja3MoKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRUZWNoXywgd2UgY3JlYXRlIHZpZGVvVHJhY2tzX1xuICAgIC8vIHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0ZWNoIGR1cmluZyBsb2FkaW5nXG4gICAgaWYgKCF0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnZpZGVvVHJhY2tzXyA9IHRoaXMudmlkZW9UcmFja3NfIHx8IG5ldyBfdHJhY2tzVmlkZW9UcmFja0xpc3RKczJbJ2RlZmF1bHQnXSgpO1xuICAgICAgcmV0dXJuIHRoaXMudmlkZW9UcmFja3NfO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlY2hfLnZpZGVvVHJhY2tzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhdWRpbyB0cmFjayBsaXN0XG4gICAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdFxuICAgKlxuICAgKiBAcmV0dXJuIHtBdWRpb1RyYWNrTGlzdH0gdGhlcyBjdXJyZW50IGF1ZGlvIHRyYWNrIGxpc3RcbiAgICogQG1ldGhvZCBhdWRpb1RyYWNrc1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmF1ZGlvVHJhY2tzID0gZnVuY3Rpb24gYXVkaW9UcmFja3MoKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRUZWNoXywgd2UgY3JlYXRlIHZpZGVvVHJhY2tzX1xuICAgIC8vIHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0ZWNoIGR1cmluZyBsb2FkaW5nXG4gICAgaWYgKCF0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tzXyA9IHRoaXMuYXVkaW9UcmFja3NfIHx8IG5ldyBfdHJhY2tzQXVkaW9UcmFja0xpc3RKczJbJ2RlZmF1bHQnXSgpO1xuICAgICAgcmV0dXJuIHRoaXMuYXVkaW9UcmFja3NfO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlY2hfLmF1ZGlvVHJhY2tzKCk7XG4gIH07XG5cbiAgLypcbiAgICAqIFRleHQgdHJhY2tzIGFyZSB0cmFja3Mgb2YgdGltZWQgdGV4dCBldmVudHMuXG4gICAgKiBDYXB0aW9ucyAtIHRleHQgZGlzcGxheWVkIG92ZXIgdGhlIHZpZGVvIGZvciB0aGUgaGVhcmluZyBpbXBhaXJlZFxuICAgICogU3VidGl0bGVzIC0gdGV4dCBkaXNwbGF5ZWQgb3ZlciB0aGUgdmlkZW8gZm9yIHRob3NlIHdobyBkb24ndCB1bmRlcnN0YW5kIGxhbmd1YWdlIGluIHRoZSB2aWRlb1xuICAgICogQ2hhcHRlcnMgLSB0ZXh0IGRpc3BsYXllZCBpbiBhIG1lbnUgYWxsb3dpbmcgdGhlIHVzZXIgdG8ganVtcCB0byBwYXJ0aWN1bGFyIHBvaW50cyAoY2hhcHRlcnMpIGluIHRoZSB2aWRlb1xuICAgICogRGVzY3JpcHRpb25zIChub3Qgc3VwcG9ydGVkIHlldCkgLSBhdWRpbyBkZXNjcmlwdGlvbnMgdGhhdCBhcmUgcmVhZCBiYWNrIHRvIHRoZSB1c2VyIGJ5IGEgc2NyZWVuIHJlYWRpbmcgZGV2aWNlXG4gICAgKi9cblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3MuIGNhcHRpb25zLCBzdWJ0aXRsZXMsIGNoYXB0ZXJzLCBkZXNjcmlwdGlvbnNcbiAgICogaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXRleHR0cmFja3NcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICBBcnJheSBvZiB0cmFjayBvYmplY3RzXG4gICAqIEBtZXRob2QgdGV4dFRyYWNrc1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnRleHRUcmFja3MgPSBmdW5jdGlvbiB0ZXh0VHJhY2tzKCkge1xuICAgIC8vIGNhbm5vdCB1c2UgdGVjaEdldF8gZGlyZWN0bHkgYmVjYXVzZSBpdCBjaGVja3MgdG8gc2VlIHdoZXRoZXIgdGhlIHRlY2ggaXMgcmVhZHkuXG4gICAgLy8gRmxhc2ggaXMgdW5saWtlbHkgdG8gYmUgcmVhZHkgaW4gdGltZSBidXQgdGV4dFRyYWNrcyBzaG91bGQgc3RpbGwgd29yay5cbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfWyd0ZXh0VHJhY2tzJ10oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIHJlbW90ZSB0ZXh0IHRyYWNrc1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQG1ldGhvZCByZW1vdGVUZXh0VHJhY2tzXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIHJlbW90ZVRleHRUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoX1sncmVtb3RlVGV4dFRyYWNrcyddKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiByZW1vdGUgaHRtbCB0cmFjayBlbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50W119XG4gICAqIEBtZXRob2QgcmVtb3RlVGV4dFRyYWNrRWxzXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrRWxzID0gZnVuY3Rpb24gcmVtb3RlVGV4dFRyYWNrRWxzKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF9bJ3JlbW90ZVRleHRUcmFja0VscyddKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRleHQgdHJhY2tcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIFczQyBzZXR0aW5ncyB3ZSBhbGxvdyBhZGRpbmcgYWRkaXRpb25hbCBpbmZvIHRocm91Z2ggb3B0aW9ucy5cbiAgICogaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWFkZHRleHR0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gIGtpbmQgICAgICAgIENhcHRpb25zLCBzdWJ0aXRsZXMsIGNoYXB0ZXJzLCBkZXNjcmlwdGlvbnMsIG9yIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbGFiZWwgICAgICAgT3B0aW9uYWwgbGFiZWxcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBsYW5ndWFnZSAgICBPcHRpb25hbCBsYW5ndWFnZVxuICAgKiBAbWV0aG9kIGFkZFRleHRUcmFja1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfWydhZGRUZXh0VHJhY2snXShraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSByZW1vdGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICBPcHRpb25zIGZvciByZW1vdGUgdGV4dCB0cmFja1xuICAgKiBAbWV0aG9kIGFkZFJlbW90ZVRleHRUcmFja1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoX1snYWRkUmVtb3RlVGV4dFRyYWNrJ10ob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlbW90ZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFjayAgICBSZW1vdGUgdGV4dCB0cmFjayB0byByZW1vdmVcbiAgICogQG1ldGhvZCByZW1vdmVSZW1vdGVUZXh0VHJhY2tcbiAgICovXG4gIC8vIGRlc3RydWN0dXJlIHRoZSBpbnB1dCBpbnRvIGFuIG9iamVjdCB3aXRoIGEgdHJhY2sgYXJndW1lbnQsIGRlZmF1bHRpbmcgdG8gYXJndW1lbnRzWzBdXG4gIC8vIGRlZmF1bHQgdGhlIHdob2xlIGFyZ3VtZW50IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBub3RoaW5nIHdhcyBwYXNzZWQgaW5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBfcmVmMyR0cmFjayA9IF9yZWYzLnRyYWNrO1xuICAgIHZhciB0cmFjayA9IF9yZWYzJHRyYWNrID09PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfcmVmMyR0cmFjaztcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF9bJ3JlbW92ZVJlbW90ZVRleHRUcmFjayddKHRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHZpZGVvIHdpZHRoXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVmlkZW8gd2lkdGhcbiAgICogQG1ldGhvZCB2aWRlb1dpZHRoXG4gICAqL1xuXG4gIFBsYXllci5wcm90b3R5cGUudmlkZW9XaWR0aCA9IGZ1bmN0aW9uIHZpZGVvV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy52aWRlb1dpZHRoICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCgpIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2aWRlbyBoZWlnaHRcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBWaWRlbyBoZWlnaHRcbiAgICogQG1ldGhvZCB2aWRlb0hlaWdodFxuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvSGVpZ2h0ID0gZnVuY3Rpb24gdmlkZW9IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy52aWRlb0hlaWdodCAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0KCkgfHwgMDtcbiAgfTtcblxuICAvLyBNZXRob2RzIHRvIGFkZCBzdXBwb3J0IGZvclxuICAvLyBpbml0aWFsVGltZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGxfKCdpbml0aWFsVGltZScpOyB9LFxuICAvLyBzdGFydE9mZnNldFRpbWU6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnRlY2hDYWxsXygnc3RhcnRPZmZzZXRUaW1lJyk7IH0sXG4gIC8vIHBsYXllZDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGxfKCdwbGF5ZWQnKTsgfSxcbiAgLy8gZGVmYXVsdFBsYXliYWNrUmF0ZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGxfKCdkZWZhdWx0UGxheWJhY2tSYXRlJyk7IH0sXG4gIC8vIGRlZmF1bHRNdXRlZDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMudGVjaENhbGxfKCdkZWZhdWx0TXV0ZWQnKTsgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyJ3MgbGFuZ3VhZ2UgY29kZVxuICAgKiBOT1RFOiBUaGUgbGFuZ3VhZ2Ugc2hvdWxkIGJlIHNldCBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaWYgeW91IHdhbnQgdGhlXG4gICAqIHRoZSBjb250cm9scyB0byBiZSBidWlsdCB3aXRoIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuIENoYW5naW5nIHRoZSBsYW51Z2FnZVxuICAgKiBsYXRlciB3aWxsIG5vdCB1cGRhdGUgY29udHJvbHMgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgIFRoZSBsb2NhbGUgc3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICBUaGUgbG9jYWxlIHN0cmluZyB3aGVuIGdldHRpbmdcbiAgICogQHJldHVybiB7UGxheWVyfSAgICAgIHNlbGYgd2hlbiBzZXR0aW5nXG4gICAqIEBtZXRob2QgbGFuZ3VhZ2VcbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZSA9IGZ1bmN0aW9uIGxhbmd1YWdlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZV87XG4gICAgfVxuXG4gICAgdGhpcy5sYW5ndWFnZV8gPSAoJycgKyBjb2RlKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBsYXllcidzIGxhbmd1YWdlIGRpY3Rpb25hcnlcbiAgICogTWVyZ2UgZXZlcnkgdGltZSwgYmVjYXVzZSBhIG5ld2x5IGFkZGVkIHBsdWdpbiBtaWdodCBjYWxsIHZpZGVvanMuYWRkTGFuZ3VhZ2UoKSBhdCBhbnkgdGltZVxuICAgKiBMYW5ndWFnZXMgc3BlY2lmaWVkIGRpcmVjdGx5IGluIHRoZSBwbGF5ZXIgb3B0aW9ucyBoYXZlIHByZWNlZGVuY2VcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGxhbmd1YWdlc1xuICAgKiBAbWV0aG9kIGxhbmd1YWdlc1xuICAgKi9cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhbmd1YWdlcyA9IGZ1bmN0aW9uIGxhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gX3V0aWxzTWVyZ2VPcHRpb25zSnMyWydkZWZhdWx0J10oUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXy5sYW5ndWFnZXMsIHRoaXMubGFuZ3VhZ2VzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRyYWNrIGluZm8gdG8gSlNPTlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gb2JqZWN0IG9mIG9wdGlvbnNcbiAgICogQG1ldGhvZCB0b0pTT05cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfdXRpbHNNZXJnZU9wdGlvbnNKczJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnNfKTtcbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gZGVlcCBtZXJnZSB0cmFja3MgYW5kIG51bGwgb3V0IHBsYXllciBzbyBubyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICB0cmFjayA9IF91dGlsc01lcmdlT3B0aW9uc0pzMlsnZGVmYXVsdCddKHRyYWNrKTtcbiAgICAgIHRyYWNrLnBsYXllciA9IHVuZGVmaW5lZDtcbiAgICAgIG9wdGlvbnMudHJhY2tzW2ldID0gdHJhY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW1wbGUgbW9kYWwgZGlhbG9nIChhbiBpbnN0YW5jZSBvZiB0aGUgYE1vZGFsRGlhbG9nYFxuICAgKiBjb21wb25lbnQpIHRoYXQgaW1tZWRpYXRlbHkgb3ZlcmxheXMgdGhlIHBsYXllciB3aXRoIGFyYml0cmFyeVxuICAgKiBjb250ZW50IGFuZCByZW1vdmVzIGl0c2VsZiB3aGVuIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258RWxlbWVudHxBcnJheXxOdWxsfSBjb250ZW50XG4gICAqICAgICAgICBTYW1lIGFzIGBNb2RhbERpYWxvZyNjb250ZW50YCdzIHBhcmFtIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAqXG4gICAqICAgICAgICBUaGUgbW9zdCBzdHJhaWdodC1mb3J3YXJkIHVzYWdlIGlzIHRvIHByb3ZpZGUgYSBzdHJpbmcgb3IgRE9NXG4gICAqICAgICAgICBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBFeHRyYSBvcHRpb25zIHdoaWNoIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBgTW9kYWxEaWFsb2dgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNb2RhbERpYWxvZ31cbiAgICovXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVNb2RhbCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGFsKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGxheWVyID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY29udGVudCA9IGNvbnRlbnQgfHwgJyc7XG5cbiAgICB2YXIgbW9kYWwgPSBuZXcgX21vZGFsRGlhbG9nMlsnZGVmYXVsdCddKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICBwbGF5ZXIuYWRkQ2hpbGQobW9kYWwpO1xuICAgIG1vZGFsLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcGxheWVyLnJlbW92ZUNoaWxkKG1vZGFsKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtb2RhbC5vcGVuKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGFnIHNldHRpbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnIFRoZSBwbGF5ZXIgdGFnXG4gICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBzb3VyY2VzIGFuZCB0cmFjayBvYmplY3RzXG4gICAqIEBzdGF0aWNcbiAgICogQG1ldGhvZCBnZXRUYWdTZXR0aW5nc1xuICAgKi9cblxuICBQbGF5ZXIuZ2V0VGFnU2V0dGluZ3MgPSBmdW5jdGlvbiBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcbiAgICB2YXIgYmFzZU9wdGlvbnMgPSB7XG4gICAgICAnc291cmNlcyc6IFtdLFxuICAgICAgJ3RyYWNrcyc6IFtdXG4gICAgfTtcblxuICAgIHZhciB0YWdPcHRpb25zID0gRG9tLmdldEVsQXR0cmlidXRlcyh0YWcpO1xuICAgIHZhciBkYXRhU2V0dXAgPSB0YWdPcHRpb25zWydkYXRhLXNldHVwJ107XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgIGlmIChkYXRhU2V0dXAgIT09IG51bGwpIHtcbiAgICAgIC8vIFBhcnNlIG9wdGlvbnMgSlNPTlxuXG4gICAgICB2YXIgX3NhZmVQYXJzZVR1cGxlID0gX3NhZmVKc29uUGFyc2VUdXBsZTJbJ2RlZmF1bHQnXShkYXRhU2V0dXAgfHwgJ3t9Jyk7XG5cbiAgICAgIHZhciBlcnIgPSBfc2FmZVBhcnNlVHVwbGVbMF07XG4gICAgICB2YXIgZGF0YSA9IF9zYWZlUGFyc2VUdXBsZVsxXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSh0YWdPcHRpb25zLCBkYXRhKTtcbiAgICB9XG5cbiAgICBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKGJhc2VPcHRpb25zLCB0YWdPcHRpb25zKTtcblxuICAgIC8vIEdldCB0YWcgY2hpbGRyZW4gc2V0dGluZ3NcbiAgICBpZiAodGFnLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGFnLmNoaWxkTm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBDaGFuZ2UgY2FzZSBuZWVkZWQ6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ub2RlbmFtZS1jYXNlLXNlbnNpdGl2aXR5L1xuICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICBiYXNlT3B0aW9ucy5zb3VyY2VzLnB1c2goRG9tLmdldEVsQXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnRyYWNrcy5wdXNoKERvbS5nZXRFbEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfTtcblxuICByZXR1cm4gUGxheWVyO1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuUGxheWVyLnBsYXllcnMgPSB7fTtcblxudmFyIG5hdmlnYXRvciA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ubmF2aWdhdG9yO1xuLypcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogTWFrZSBjaGFuZ2VzIGluIG9wdGlvbnMsIG5vdCBoZXJlLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICAvLyBEZWZhdWx0IG9yZGVyIG9mIGZhbGxiYWNrIHRlY2hub2xvZ3lcbiAgdGVjaE9yZGVyOiBbJ2h0bWw1JywgJ2ZsYXNoJ10sXG4gIC8vIHRlY2hPcmRlcjogWydmbGFzaCcsJ2h0bWw1J10sXG5cbiAgaHRtbDU6IHt9LFxuICBmbGFzaDoge30sXG5cbiAgLy8gZGVmYXVsdFZvbHVtZTogMC44NSxcbiAgZGVmYXVsdFZvbHVtZTogMC4wMCwgLy8gVGhlIGZyZWFraW4gc2VhZ3VscyBhcmUgZHJpdmluZyBtZSBjcmF6eSFcblxuICAvLyBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dFxuICBpbmFjdGl2aXR5VGltZW91dDogMjAwMCxcblxuICAvLyBkZWZhdWx0IHBsYXliYWNrIHJhdGVzXG4gIHBsYXliYWNrUmF0ZXM6IFtdLFxuICAvLyBBZGQgcGxheWJhY2sgcmF0ZSBzZWxlY3Rpb24gYnkgYWRkaW5nIHJhdGVzXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcblxuICAvLyBJbmNsdWRlZCBjb250cm9sIHNldHNcbiAgY2hpbGRyZW46IFsnbWVkaWFMb2FkZXInLCAncG9zdGVySW1hZ2UnLCAndGV4dFRyYWNrRGlzcGxheScsICdsb2FkaW5nU3Bpbm5lcicsICdiaWdQbGF5QnV0dG9uJywgJ2NvbnRyb2xCYXInLCAnZXJyb3JEaXNwbGF5JywgJ3RleHRUcmFja1NldHRpbmdzJ10sXG5cbiAgbGFuZ3VhZ2U6IG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8IG5hdmlnYXRvci5sYW5ndWFnZSB8fCAnZW4nLFxuXG4gIC8vIGxvY2FsZXMgYW5kIHRoZWlyIGxhbmd1YWdlIHRyYW5zbGF0aW9uc1xuICBsYW5ndWFnZXM6IHt9LFxuXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxuICBub3RTdXBwb3J0ZWRNZXNzYWdlOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIG1lZGlhLidcbn07XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YVxuICpcbiAqIEBldmVudCBsb2Fkc3RhcnRcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoTG9hZFN0YXJ0XztcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGluaXRpYWwgZHVyYXRpb24gYW5kIGRpbWVuc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEBldmVudCBsb2FkZWRtZXRhZGF0YVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUxvYWRlZE1ldGFEYXRhXztcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgcmVjZWl2ZXMgdGV4dCBkYXRhXG4gKlxuICogQGV2ZW50IHRleHRkYXRhXG4gKi9cblBsYXllci5wcm90b3R5cGUuaGFuZGxlVGV4dERhdGFfO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKlxuICogQGV2ZW50IGxvYWRlZGRhdGFcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVMb2FkZWREYXRhXztcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGlzIGFjdGl2ZSwgZS5nLiBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgcGxheWVyXG4gKlxuICogQGV2ZW50IHVzZXJhY3RpdmVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVVc2VyQWN0aXZlXztcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGlzIGluYWN0aXZlLCBlLmcuIGEgc2hvcnQgZGVsYXkgYWZ0ZXIgdGhlIGxhc3QgbW91c2UgbW92ZSBvciBjb250cm9sIGludGVyYWN0aW9uXG4gKlxuICogQGV2ZW50IHVzZXJpbmFjdGl2ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVVzZXJJbmFjdGl2ZV87XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZCAqXG4gKiBEdXJpbmcgcGxheWJhY2sgdGhpcyBpcyBmaXJlZCBldmVyeSAxNS0yNTAgbWlsbGlzZWNvbmRzLCBkZXBlbmRpbmcgb24gdGhlXG4gKiBwbGF5YmFjayB0ZWNobm9sb2d5IGluIHVzZS5cbiAqXG4gKiBAZXZlbnQgdGltZXVwZGF0ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRpbWVVcGRhdGVfO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdmlkZW8gcGxheWJhY2sgZW5kc1xuICpcbiAqIEBldmVudCBlbmRlZFxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hFbmRlZF87XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqXG4gKiBAZXZlbnQgdm9sdW1lY2hhbmdlXG4gKi9cblBsYXllci5wcm90b3R5cGUuaGFuZGxlVm9sdW1lQ2hhbmdlXztcblxuLyoqXG4gKiBGaXJlZCB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICpcbiAqIEBldmVudCBlcnJvclxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhbmRsZUVycm9yXztcblxuUGxheWVyLnByb3RvdHlwZS5mbGV4Tm90U3VwcG9ydGVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZW0gPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnaScpO1xuXG4gIC8vIE5vdGU6IFdlIGRvbid0IGFjdHVhbGx5IHVzZSBmbGV4QmFzaXMgKG9yIGZsZXhPcmRlciksIGJ1dCBpdCdzIG9uZSBvZiB0aGUgbW9yZVxuICAvLyBjb21tb24gZmxleCBmZWF0dXJlcyB0aGF0IHdlIGNhbiByZWx5IG9uIHdoZW4gY2hlY2tpbmcgZm9yIGZsZXggc3VwcG9ydC5cbiAgcmV0dXJuICEoJ2ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnd2Via2l0RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtb3pGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ21zRmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtc0ZsZXhPcmRlcicgaW4gZWxlbS5zdHlsZSkgLyogSUUxMC1zcGVjaWZpYyAoMjAxMiBmbGV4IHNwZWMpICAqLztcbn07XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnUGxheWVyJywgUGxheWVyKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBsYXllcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8gSWYgZW1wdHkgc3RyaW5nLCBtYWtlIGl0IGEgcGFyc2FibGUganNvbiBvYmplY3QuXG5cbn0se1wiLi9iaWctcGxheS1idXR0b24uanNcIjo2MyxcIi4vY29tcG9uZW50LmpzXCI6NjcsXCIuL2NvbnRyb2wtYmFyL2NvbnRyb2wtYmFyLmpzXCI6NzAsXCIuL2Vycm9yLWRpc3BsYXkuanNcIjoxMDMsXCIuL2Z1bGxzY3JlZW4tYXBpLmpzXCI6MTA2LFwiLi9sb2FkaW5nLXNwaW5uZXIuanNcIjoxMDcsXCIuL21lZGlhLWVycm9yLmpzXCI6MTA4LFwiLi9tb2RhbC1kaWFsb2dcIjoxMTIsXCIuL3Bvc3Rlci1pbWFnZS5qc1wiOjExNyxcIi4vdGVjaC9odG1sNS5qc1wiOjEyMixcIi4vdGVjaC9sb2FkZXIuanNcIjoxMjMsXCIuL3RlY2gvdGVjaC5qc1wiOjEyNCxcIi4vdHJhY2tzL2F1ZGlvLXRyYWNrLWxpc3QuanNcIjoxMjUsXCIuL3RyYWNrcy90ZXh0LXRyYWNrLWRpc3BsYXkuanNcIjoxMzAsXCIuL3RyYWNrcy90ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyLmpzXCI6MTMxLFwiLi90cmFja3MvdGV4dC10cmFjay1zZXR0aW5ncy5qc1wiOjEzMyxcIi4vdHJhY2tzL3ZpZGVvLXRyYWNrLWxpc3QuanNcIjoxMzgsXCIuL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuL3V0aWxzL2J1ZmZlci5qc1wiOjE0MSxcIi4vdXRpbHMvZG9tLmpzXCI6MTQyLFwiLi91dGlscy9ldmVudHMuanNcIjoxNDMsXCIuL3V0aWxzL2ZuLmpzXCI6MTQ0LFwiLi91dGlscy9ndWlkLmpzXCI6MTQ2LFwiLi91dGlscy9sb2cuanNcIjoxNDcsXCIuL3V0aWxzL21lcmdlLW9wdGlvbnMuanNcIjoxNDgsXCIuL3V0aWxzL3N0eWxlc2hlZXQuanNcIjoxNDksXCIuL3V0aWxzL3RpbWUtcmFuZ2VzLmpzXCI6MTUwLFwiLi91dGlscy90by10aXRsZS1jYXNlLmpzXCI6MTUxLFwiZ2xvYmFsL2RvY3VtZW50XCI6MSxcImdsb2JhbC93aW5kb3dcIjoyLFwib2JqZWN0LmFzc2lnblwiOjQ1LFwic2FmZS1qc29uLXBhcnNlL3R1cGxlXCI6NTR9XSwxMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBwbHVnaW5zLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3BsYXllckpzID0gX2RlcmVxXygnLi9wbGF5ZXIuanMnKTtcblxudmFyIF9wbGF5ZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5ZXJKcyk7XG5cbi8qKlxuICogVGhlIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgYSB2aWRlby5qcyBwbHVnaW5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBsdWdpblxuICogQHBhcmFtICB7RnVuY3Rpb259IGluaXQgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIHdoZW4gdGhlIHBsYXllciBpbml0c1xuICogQG1ldGhvZCBwbHVnaW5cbiAqL1xudmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihuYW1lLCBpbml0KSB7XG4gIF9wbGF5ZXJKczJbJ2RlZmF1bHQnXS5wcm90b3R5cGVbbmFtZV0gPSBpbml0O1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gcGx1Z2luO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi9wbGF5ZXIuanNcIjoxMTN9XSwxMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBwb3B1cC1idXR0b24uanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NsaWNrYWJsZUNvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vY2xpY2thYmxlLWNvbXBvbmVudC5qcycpO1xuXG52YXIgX2NsaWNrYWJsZUNvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsaWNrYWJsZUNvbXBvbmVudEpzKTtcblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF9wb3B1cEpzID0gX2RlcmVxXygnLi9wb3B1cC5qcycpO1xuXG52YXIgX3BvcHVwSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9wdXBKcyk7XG5cbnZhciBfdXRpbHNEb21KcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2RvbS5qcycpO1xuXG52YXIgRG9tID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRG9tSnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG52YXIgX3V0aWxzVG9UaXRsZUNhc2VKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL3RvLXRpdGxlLWNhc2UuanMnKTtcblxudmFyIF91dGlsc1RvVGl0bGVDYXNlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNUb1RpdGxlQ2FzZUpzKTtcblxuLyoqXG4gKiBBIGJ1dHRvbiBjbGFzcyB3aXRoIGEgcG9wdXAgY29udHJvbFxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICogQGNsYXNzIFBvcHVwQnV0dG9uXG4gKi9cblxudmFyIFBvcHVwQnV0dG9uID0gKGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQb3B1cEJ1dHRvbiwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9wdXBCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cEJ1dHRvbik7XG5cbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHBvcHVwXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqL1xuXG4gIFBvcHVwQnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHBvcHVwID0gdGhpcy5jcmVhdGVQb3B1cCgpO1xuXG4gICAgaWYgKHRoaXMucG9wdXApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cCk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3B1cCA9IHBvcHVwO1xuICAgIHRoaXMuYWRkQ2hpbGQocG9wdXApO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHBvcHVwIC0gT3ZlcnJpZGUgd2l0aCBzcGVjaWZpYyBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7UG9wdXB9IFRoZSBjb25zdHJ1Y3RlZCBwb3B1cFxuICAgKiBAbWV0aG9kIGNyZWF0ZVBvcHVwXG4gICAqL1xuXG4gIFBvcHVwQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVQb3B1cCA9IGZ1bmN0aW9uIGNyZWF0ZVBvcHVwKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBQb3B1cEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvdyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXNcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgY2xhc3MgbmFtZVxuICAgKiBAbWV0aG9kIGJ1aWxkQ1NTQ2xhc3NcbiAgICovXG5cbiAgUG9wdXBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHZhciBtZW51QnV0dG9uQ2xhc3MgPSAndmpzLW1lbnUtYnV0dG9uJztcblxuICAgIC8vIElmIHRoZSBpbmxpbmUgb3B0aW9uIGlzIHBhc3NlZCwgd2Ugd2FudCB0byB1c2UgZGlmZmVyZW50IHN0eWxlcyBhbHRvZ2V0aGVyLlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLmlubGluZSA9PT0gdHJ1ZSkge1xuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctaW5saW5lJztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctcG9wdXAnO1xuICAgIH1cblxuICAgIHJldHVybiAndmpzLW1lbnUtYnV0dG9uICcgKyBtZW51QnV0dG9uQ2xhc3MgKyAnICcgKyBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFBvcHVwQnV0dG9uO1xufSkoX2NsaWNrYWJsZUNvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdQb3B1cEJ1dHRvbicsIFBvcHVwQnV0dG9uKTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBvcHVwQnV0dG9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY2xpY2thYmxlLWNvbXBvbmVudC5qc1wiOjY1LFwiLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi91dGlscy9kb20uanNcIjoxNDIsXCIuLi91dGlscy9mbi5qc1wiOjE0NCxcIi4uL3V0aWxzL3RvLXRpdGxlLWNhc2UuanNcIjoxNTEsXCIuL3BvcHVwLmpzXCI6MTE2fV0sMTE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgcG9wdXAuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi4vY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50SnMpO1xuXG52YXIgX3V0aWxzRG9tSnMgPSBfZGVyZXFfKCcuLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi4vdXRpbHMvZXZlbnRzLmpzJyk7XG5cbnZhciBFdmVudHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNFdmVudHNKcyk7XG5cbi8qKlxuICogVGhlIFBvcHVwIGNvbXBvbmVudCBpcyB1c2VkIHRvIGJ1aWxkIHBvcCB1cCBjb250cm9scy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBQb3B1cFxuICovXG5cbnZhciBQb3B1cCA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUG9wdXAsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvcHVwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cCk7XG5cbiAgICBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcG9wdXAgaXRlbSB0byB0aGUgcG9wdXBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb21wb25lbnQgQ29tcG9uZW50IG9yIGNvbXBvbmVudCB0eXBlIHRvIGFkZFxuICAgKiBAbWV0aG9kIGFkZEl0ZW1cbiAgICovXG5cbiAgUG9wdXAucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbiBhZGRJdGVtKGNvbXBvbmVudCkge1xuICAgIHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQub24oJ2NsaWNrJywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnVubG9ja1Nob3dpbmcoKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBQb3B1cC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgY29udGVudEVsVHlwZSA9IHRoaXMub3B0aW9uc18uY29udGVudEVsVHlwZSB8fCAndWwnO1xuICAgIHRoaXMuY29udGVudEVsXyA9IERvbS5jcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1jb250ZW50J1xuICAgIH0pO1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGFwcGVuZDogdGhpcy5jb250ZW50RWxfLFxuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUnXG4gICAgfSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAuIE5lZWRlZCBmb3IgUG9wdXAgQnV0dG9ucyxcbiAgICAvLyB3aGVyZSBhIGNsaWNrIG9uIHRoZSBwYXJlbnQgaXMgc2lnbmlmaWNhbnRcbiAgICBFdmVudHMub24oZWwsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIHJldHVybiBQb3B1cDtcbn0pKF9jb21wb25lbnRKczJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnUG9wdXAnLCBQb3B1cCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBQb3B1cDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vdXRpbHMvZG9tLmpzXCI6MTQyLFwiLi4vdXRpbHMvZXZlbnRzLmpzXCI6MTQzLFwiLi4vdXRpbHMvZm4uanNcIjoxNDR9XSwxMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBwb3N0ZXItaW1hZ2UuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NsaWNrYWJsZUNvbXBvbmVudEpzID0gX2RlcmVxXygnLi9jbGlja2FibGUtY29tcG9uZW50LmpzJyk7XG5cbnZhciBfY2xpY2thYmxlQ29tcG9uZW50SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xpY2thYmxlQ29tcG9uZW50SnMpO1xuXG52YXIgX2NvbXBvbmVudEpzID0gX2RlcmVxXygnLi9jb21wb25lbnQuanMnKTtcblxudmFyIF9jb21wb25lbnRKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnRKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4vdXRpbHMvYnJvd3Nlci5qcycpO1xuXG52YXIgYnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0Jyb3dzZXJKcyk7XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCB0aGF0IGhhbmRsZXMgc2hvd2luZyB0aGUgcG9zdGVyIGltYWdlLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfE9iamVjdH0gcGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEBleHRlbmRzIEJ1dHRvblxuICogQGNsYXNzIFBvc3RlckltYWdlXG4gKi9cblxudmFyIFBvc3RlckltYWdlID0gKGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQb3N0ZXJJbWFnZSwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9zdGVySW1hZ2UocGxheWVyLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc3RlckltYWdlKTtcblxuICAgIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0aGUgcG9zdGVyIGltYWdlXG4gICAqXG4gICAqIEBtZXRob2QgZGlzcG9zZVxuICAgKi9cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgcG9zdGVyJ3MgaW1hZ2UgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IERvbS5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBvc3RlcicsXG5cbiAgICAgIC8vIERvbid0IHdhbnQgcG9zdGVyIHRvIGJlIHRhYmJhYmxlLlxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSk7XG5cbiAgICAvLyBUbyBlbnN1cmUgdGhlIHBvc3RlciBpbWFnZSByZXNpemVzIHdoaWxlIG1haW50YWluaW5nIGl0cyBvcmlnaW5hbCBhc3BlY3RcbiAgICAvLyByYXRpbywgdXNlIGEgZGl2IHdpdGggYGJhY2tncm91bmQtc2l6ZWAgd2hlbiBhdmFpbGFibGUuIEZvciBicm93c2VycyB0aGF0XG4gICAgLy8gZG8gbm90IHN1cHBvcnQgYGJhY2tncm91bmQtc2l6ZWAgKGUuZy4gSUU4KSwgZmFsbCBiYWNrIG9uIHVzaW5nIGEgcmVndWxhclxuICAgIC8vIGltZyBlbGVtZW50LlxuICAgIGlmICghYnJvd3Nlci5CQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrSW1nXyA9IERvbS5jcmVhdGVFbCgnaW1nJyk7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmZhbGxiYWNrSW1nXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB1cGRhdGVzIHRvIHRoZSBwbGF5ZXIncyBwb3N0ZXIgc291cmNlXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqL1xuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBwb3N0ZXIgc291cmNlIGRlcGVuZGluZyBvbiB0aGUgZGlzcGxheSBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRoZSBwb3N0ZXIgc291cmNlXG4gICAqIEBtZXRob2Qgc2V0U3JjXG4gICAqL1xuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbiBzZXRTcmModXJsKSB7XG4gICAgaWYgKHRoaXMuZmFsbGJhY2tJbWdfKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrSW1nXy5zcmMgPSB1cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSAnJztcbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXh0cmEgZXJyb3JcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbF8uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2xpY2tzIG9uIHRoZSBwb3N0ZXIgaW1hZ2VcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IGEgY2xpY2sgdG8gdHJpZ2dlciBwbGF5YmFjayB3aGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZFxuICAgIC8vIGJ1dCBDU1Mgc2hvdWxkIGJlIGhpZGluZyB0aGUgcG9zdGVyIHRvIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZ1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9zdGVySW1hZ2U7XG59KShfY2xpY2thYmxlQ29tcG9uZW50SnMyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50SnMyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ1Bvc3RlckltYWdlJywgUG9zdGVySW1hZ2UpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gUG9zdGVySW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL2NsaWNrYWJsZS1jb21wb25lbnQuanNcIjo2NSxcIi4vY29tcG9uZW50LmpzXCI6NjcsXCIuL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4vdXRpbHMvZm4uanNcIjoxNDR9XSwxMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBzZXR1cC5qc1xuICpcbiAqIEZ1bmN0aW9ucyBmb3IgYXV0b21hdGljYWxseSBzZXR0aW5nIHVwIGEgcGxheWVyXG4gKiBiYXNlZCBvbiB0aGUgZGF0YS1zZXR1cCBhdHRyaWJ1dGUgb2YgdGhlIHZpZGVvIHRhZ1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi91dGlscy9ldmVudHMuanMnKTtcblxudmFyIEV2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0V2ZW50c0pzKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfd2luZG93TG9hZGVkID0gZmFsc2U7XG52YXIgdmlkZW9qcyA9IHVuZGVmaW5lZDtcblxuLy8gQXV0b21hdGljYWxseSBzZXQgdXAgYW55IHRhZ3MgdGhhdCBoYXZlIGEgZGF0YS1zZXR1cCBhdHRyaWJ1dGVcbnZhciBhdXRvU2V0dXAgPSBmdW5jdGlvbiBhdXRvU2V0dXAoKSB7XG4gIC8vIE9uZSBkYXksIHdoZW4gd2Ugc3RvcCBzdXBwb3J0aW5nIElFOCwgZ28gYmFjayB0byB0aGlzLCBidXQgaW4gdGhlIG1lYW50aW1lLi4uKmhhY2sgaGFjayBoYWNrKlxuICAvLyB2YXIgdmlkcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlbycpKTtcbiAgLy8gdmFyIGF1ZGlvcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpKTtcbiAgLy8gdmFyIG1lZGlhRWxzID0gdmlkcy5jb25jYXQoYXVkaW9zKTtcblxuICAvLyBCZWNhdXNlIElFOCBkb2Vzbid0IHN1cHBvcnQgY2FsbGluZyBzbGljZSBvbiBhIG5vZGUgbGlzdCwgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggZWFjaCBsaXN0IG9mIGVsZW1lbnRzXG4gIC8vIHRvIGJ1aWxkIHVwIGEgbmV3LCBjb21iaW5lZCBsaXN0IG9mIGVsZW1lbnRzLlxuICB2YXIgdmlkcyA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcbiAgdmFyIGF1ZGlvcyA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKTtcbiAgdmFyIG1lZGlhRWxzID0gW107XG4gIGlmICh2aWRzICYmIHZpZHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gdmlkcy5sZW5ndGg7IGkgPCBlOyBpKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2godmlkc1tpXSk7XG4gICAgfVxuICB9XG4gIGlmIChhdWRpb3MgJiYgYXVkaW9zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IGF1ZGlvcy5sZW5ndGg7IGkgPCBlOyBpKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2goYXVkaW9zW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgbWVkaWEgZWxlbWVudHMgZXhpc3RcbiAgaWYgKG1lZGlhRWxzICYmIG1lZGlhRWxzLmxlbmd0aCA+IDApIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBlID0gbWVkaWFFbHMubGVuZ3RoOyBpIDwgZTsgaSsrKSB7XG4gICAgICB2YXIgbWVkaWFFbCA9IG1lZGlhRWxzW2ldO1xuXG4gICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGV4aXN0cywgaGFzIGdldEF0dHJpYnV0ZSBmdW5jLlxuICAgICAgLy8gSUUgc2VlbXMgdG8gY29uc2lkZXIgdHlwZW9mIGVsLmdldEF0dHJpYnV0ZSA9PSAnb2JqZWN0JyBpbnN0ZWFkIG9mICdmdW5jdGlvbicgbGlrZSBleHBlY3RlZCwgYXQgbGVhc3Qgd2hlbiBsb2FkaW5nIHRoZSBwbGF5ZXIgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAobWVkaWFFbCAmJiBtZWRpYUVsLmdldEF0dHJpYnV0ZSkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cbiAgICAgICAgaWYgKG1lZGlhRWxbJ3BsYXllciddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IG1lZGlhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHVwJyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgYXV0by1zZXR1cCBpZiB0aGV5J3ZlIGFkZGVkIHRoZSBkYXRhLXNldHVwIGF0dHIuXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdmlkZW8uanMgaW5zdGFuY2UuXG4gICAgICAgICAgICB2YXIgcGxheWVyID0gdmlkZW9qcyhtZWRpYUVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBnZXRBdHRyaWJ1dGUgaXNuJ3QgZGVmaW5lZCwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgRE9NLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmlkZW9zIHdlcmUgZm91bmQsIHNvIGtlZXAgbG9vcGluZyB1bmxlc3MgcGFnZSBpcyBmaW5pc2hlZCBsb2FkaW5nLlxuICB9IGVsc2UgaWYgKCFfd2luZG93TG9hZGVkKSB7XG4gICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICAgIH1cbn07XG5cbi8vIFBhdXNlIHRvIGxldCB0aGUgRE9NIGtlZXAgcHJvY2Vzc2luZ1xudmFyIGF1dG9TZXR1cFRpbWVvdXQgPSBmdW5jdGlvbiBhdXRvU2V0dXBUaW1lb3V0KHdhaXQsIHZqcykge1xuICBpZiAodmpzKSB7XG4gICAgdmlkZW9qcyA9IHZqcztcbiAgfVxuXG4gIHNldFRpbWVvdXQoYXV0b1NldHVwLCB3YWl0KTtcbn07XG5cbmlmIChfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10ucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbn0gZWxzZSB7XG4gIEV2ZW50cy5vbmUoX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXSwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG4gIH0pO1xufVxuXG52YXIgaGFzTG9hZGVkID0gZnVuY3Rpb24gaGFzTG9hZGVkKCkge1xuICByZXR1cm4gX3dpbmRvd0xvYWRlZDtcbn07XG5cbmV4cG9ydHMuYXV0b1NldHVwID0gYXV0b1NldHVwO1xuZXhwb3J0cy5hdXRvU2V0dXBUaW1lb3V0ID0gYXV0b1NldHVwVGltZW91dDtcbmV4cG9ydHMuaGFzTG9hZGVkID0gaGFzTG9hZGVkO1xuXG59LHtcIi4vdXRpbHMvZXZlbnRzLmpzXCI6MTQzLFwiZ2xvYmFsL2RvY3VtZW50XCI6MSxcImdsb2JhbC93aW5kb3dcIjoyfV0sMTE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgc2xpZGVyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gX2RlcmVxXygnb2JqZWN0LmFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIHNsaWRlcnMgbGlrZSB0aGUgdm9sdW1lIGJhciBhbmQgc2VlayBiYXJcbiAqXG4gKiBAcGFyYW0ge1BsYXllcnxPYmplY3R9IHBsYXllclxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBTbGlkZXJcbiAqL1xuXG52YXIgU2xpZGVyID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTbGlkZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNsaWRlcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciB0byBtYXRjaCB3aXRoIHRoZSBjaGlsZCBTbGlkZXIgY2xhc3MgaXMgbG9va2luZyBmb3JcbiAgICB0aGlzLmJhciA9IHRoaXMuZ2V0Q2hpbGQodGhpcy5vcHRpb25zXy5iYXJOYW1lKTtcblxuICAgIC8vIFNldCBhIGhvcml6b250YWwgb3IgdmVydGljYWwgY2xhc3Mgb24gdGhlIHNsaWRlciBkZXBlbmRpbmcgb24gdGhlIHNsaWRlciB0eXBlXG4gICAgdGhpcy52ZXJ0aWNhbCghIXRoaXMub3B0aW9uc18udmVydGljYWwpO1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuXG4gICAgdGhpcy5vbihwbGF5ZXIsICdjb250cm9sc3Zpc2libGUnLCB0aGlzLnVwZGF0ZSk7XG4gICAgdGhpcy5vbihwbGF5ZXIsIHRoaXMucGxheWVyRXZlbnQsIHRoaXMudXBkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgZWxlbWVudCB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wcyBMaXN0IG9mIHByb3BlcnRpZXMgaW4gT2JqZWN0IGZvcm1cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSkge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICAvLyBBZGQgdGhlIHNsaWRlciBlbGVtZW50IGNsYXNzIHRvIGFsbCBzdWIgY2xhc3Nlc1xuICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArICcgdmpzLXNsaWRlcic7XG4gICAgcHJvcHMgPSBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKHtcbiAgICAgIHRhYkluZGV4OiAwXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgYXR0cmlidXRlcyA9IF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10oe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogMTAwLFxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHR5cGUsIHByb3BzLCBhdHRyaWJ1dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gc2xpZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBNb3VzZSBkb3duIGV2ZW50IG9iamVjdFxuICAgKiBAbWV0aG9kIGhhbmRsZU1vdXNlRG93blxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgRG9tLmJsb2NrVGV4dFNlbGVjdGlvbigpO1xuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRpbmcnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmFjdGl2ZScpO1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlTW91c2VNb3ZlXG4gICAqL1xuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKCkge307XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBvbiBTbGlkZXJcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVNb3VzZVVwXG4gICAqL1xuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgRG9tLnVuYmxvY2tUZXh0U2VsZWN0aW9uKCk7XG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGluZycpO1xuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyaW5hY3RpdmUnKTtcblxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHNsaWRlclxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAvLyBJbiBWb2x1bWVCYXIgaW5pdCB3ZSBoYXZlIGEgc2V0VGltZW91dCBmb3IgdXBkYXRlIHRoYXQgcG9wcyBhbmQgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gZXhlY3V0aW9uIHN0YWNrLiBUaGUgcGxheWVyIGlzIGRlc3Ryb3llZCBiZWZvcmUgdGhlbiB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxuICAgIGlmICghdGhpcy5lbF8pIHJldHVybjtcblxuICAgIC8vIElmIHNjcnViYmluZywgd2UgY291bGQgdXNlIGEgY2FjaGVkIHZhbHVlIHRvIG1ha2UgdGhlIGhhbmRsZSBrZWVwIHVwIHdpdGggdGhlIHVzZXIncyBtb3VzZS5cbiAgICAvLyBPbiBIVE1MNSBicm93c2VycyBzY3J1YmJpbmcgaXMgcmVhbGx5IHNtb290aCwgYnV0IHNvbWUgZmxhc2ggcGxheWVycyBhcmUgc2xvdywgc28gd2UgbWlnaHQgd2FudCB0byB1dGlsaXplIHRoaXMgbGF0ZXIuXG4gICAgLy8gdmFyIHByb2dyZXNzID0gICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XG4gICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cbiAgICBpZiAoIWJhcikgcmV0dXJuO1xuXG4gICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vIGR1cmF0aW9uIGFuZCBvdGhlciBkaXZpc2lvbiBpc3N1ZXNcbiAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAnbnVtYmVyJyB8fCBwcm9ncmVzcyAhPT0gcHJvZ3Jlc3MgfHwgcHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID09PSBJbmZpbml0eSkge1xuICAgICAgcHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdG8gYSBwZXJjZW50YWdlIGZvciBzZXR0aW5nXG4gICAgdmFyIHBlcmNlbnRhZ2UgPSAocHJvZ3Jlc3MgKiAxMDApLnRvRml4ZWQoMikgKyAnJSc7XG5cbiAgICAvLyBTZXQgdGhlIG5ldyBiYXIgd2lkdGggb3IgaGVpZ2h0XG4gICAgaWYgKHRoaXMudmVydGljYWwoKSkge1xuICAgICAgYmFyLmVsKCkuc3R5bGUuaGVpZ2h0ID0gcGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyLmVsKCkuc3R5bGUud2lkdGggPSBwZXJjZW50YWdlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGRpc3RhbmNlIGZvciBzbGlkZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKiBAbWV0aG9kIGNhbGN1bGF0ZURpc3RhbmNlXG4gICAqL1xuXG4gIFNsaWRlci5wcm90b3R5cGUuY2FsY3VsYXRlRGlzdGFuY2UgPSBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIHZhciBwb3NpdGlvbiA9IERvbS5nZXRQb2ludGVyUG9zaXRpb24odGhpcy5lbF8sIGV2ZW50KTtcbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24ueTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uLng7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvbiBmb2N1cyBmb3Igc2xpZGVyXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlRm9jdXNcbiAgICovXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMub24odGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBrZXkgcHJlc3MgZm9yIHNsaWRlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqIEBtZXRob2QgaGFuZGxlS2V5UHJlc3NcbiAgICovXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwQmFjaygpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvbiBibHVyIGZvciBzbGlkZXJcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVCbHVyXG4gICAqL1xuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgdGhpcy5vZmYodGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbmVyIGZvciBjbGljayBldmVudHMgb24gc2xpZGVyLCB1c2VkIHRvIHByZXZlbnQgY2xpY2tzXG4gICAqICAgZnJvbSBidWJibGluZyB1cCB0byBwYXJlbnQgZWxlbWVudHMgbGlrZSBidXR0b24gbWVudXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3RcbiAgICogQG1ldGhvZCBoYW5kbGVDbGlja1xuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHNsaWRlciBpcyBob3Jpem9udGFsIGZvciB2ZXJ0aWNhbFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2wgVHJ1ZSBpZiBzbGlkZXIgaXMgdmVydGljYWwsIGZhbHNlIGlzIGhvcml6b250YWxcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBzbGlkZXIgaXMgdmVydGljYWwsIGZhbHNlIGlzIGhvcml6b250YWxcbiAgICogQG1ldGhvZCB2ZXJ0aWNhbFxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLnZlcnRpY2FsID0gZnVuY3Rpb24gdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gU2xpZGVyO1xufSkoX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddKTtcblxuX2NvbXBvbmVudEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdTbGlkZXInLCBTbGlkZXIpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gU2xpZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50LmpzXCI6NjcsXCIuLi91dGlscy9kb20uanNcIjoxNDIsXCJvYmplY3QuYXNzaWduXCI6NDV9XSwxMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBmbGFzaC1ydG1wLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIEZsYXNoUnRtcERlY29yYXRvcihGbGFzaCkge1xuICBGbGFzaC5zdHJlYW1pbmdGb3JtYXRzID0ge1xuICAgICdydG1wL21wNCc6ICdNUDQnLFxuICAgICdydG1wL2Zsdic6ICdGTFYnXG4gIH07XG5cbiAgRmxhc2guc3RyZWFtRnJvbVBhcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHN0cmVhbSkge1xuICAgIHJldHVybiBjb25uZWN0aW9uICsgJyYnICsgc3RyZWFtO1xuICB9O1xuXG4gIEZsYXNoLnN0cmVhbVRvUGFydHMgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgdmFyIHBhcnRzID0ge1xuICAgICAgY29ubmVjdGlvbjogJycsXG4gICAgICBzdHJlYW06ICcnXG4gICAgfTtcblxuICAgIGlmICghc3JjKSByZXR1cm4gcGFydHM7XG5cbiAgICAvLyBMb29rIGZvciB0aGUgbm9ybWFsIFVSTCBzZXBhcmF0b3Igd2UgZXhwZWN0LCAnJicuXG4gICAgLy8gSWYgZm91bmQsIHdlIHNwbGl0IHRoZSBVUkwgaW50byB0d28gcGllY2VzIGFyb3VuZCB0aGVcbiAgICAvLyBmaXJzdCAnJicuXG4gICAgdmFyIGNvbm5FbmQgPSBzcmMuc2VhcmNoKC8mKD8hXFx3Kz0pLyk7XG4gICAgdmFyIHN0cmVhbUJlZ2luID0gdW5kZWZpbmVkO1xuICAgIGlmIChjb25uRW5kICE9PSAtMSkge1xuICAgICAgc3RyZWFtQmVnaW4gPSBjb25uRW5kICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBub3QgYSAnJicsIHdlIHVzZSB0aGUgbGFzdCAnLycgYXMgdGhlIGRlbGltaXRlci5cbiAgICAgIGNvbm5FbmQgPSBzdHJlYW1CZWdpbiA9IHNyYy5sYXN0SW5kZXhPZignLycpICsgMTtcbiAgICAgIGlmIChjb25uRW5kID09PSAwKSB7XG4gICAgICAgIC8vIHJlYWxseSwgdGhlcmUncyBub3QgYSAnLyc/XG4gICAgICAgIGNvbm5FbmQgPSBzdHJlYW1CZWdpbiA9IHNyYy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnRzLmNvbm5lY3Rpb24gPSBzcmMuc3Vic3RyaW5nKDAsIGNvbm5FbmQpO1xuICAgIHBhcnRzLnN0cmVhbSA9IHNyYy5zdWJzdHJpbmcoc3RyZWFtQmVnaW4sIHNyYy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9O1xuXG4gIEZsYXNoLmlzU3RyZWFtaW5nVHlwZSA9IGZ1bmN0aW9uIChzcmNUeXBlKSB7XG4gICAgcmV0dXJuIHNyY1R5cGUgaW4gRmxhc2guc3RyZWFtaW5nRm9ybWF0cztcbiAgfTtcblxuICAvLyBSVE1QIGhhcyBmb3VyIHZhcmlhdGlvbnMsIGFueSBzdHJpbmcgc3RhcnRpbmdcbiAgLy8gd2l0aCBvbmUgb2YgdGhlc2UgcHJvdG9jb2xzIHNob3VsZCBiZSB2YWxpZFxuICBGbGFzaC5SVE1QX1JFID0gL15ydG1wW3NldF0/OlxcL1xcLy9pO1xuXG4gIEZsYXNoLmlzU3RyZWFtaW5nU3JjID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHJldHVybiBGbGFzaC5SVE1QX1JFLnRlc3Qoc3JjKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBzb3VyY2UgaGFuZGxlciBmb3IgUlRNUCB1cmxzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlciA9IHt9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBGbGFzaCBjYW4gcGxheSB0aGUgZ2l2ZW4gdmlkZW90eXBlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKEZsYXNoLmlzU3RyZWFtaW5nVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBGbGFzaCBjYW4gaGFuZGxlIHRoZSBzb3VyY2UgbmF0aXZlbHlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNhbiA9IEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKHNvdXJjZS50eXBlKTtcblxuICAgIGlmIChjYW4pIHtcbiAgICAgIHJldHVybiBjYW47XG4gICAgfVxuXG4gICAgaWYgKEZsYXNoLmlzU3RyZWFtaW5nU3JjKHNvdXJjZS5zcmMpKSB7XG4gICAgICByZXR1cm4gJ21heWJlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgZmxhc2ggb2JqZWN0XG4gICAqIEFkYXB0aXZlIHNvdXJjZSBoYW5kbGVycyB3aWxsIGhhdmUgbW9yZSBjb21wbGljYXRlZCB3b3JrZmxvd3MgYmVmb3JlIHBhc3NpbmdcbiAgICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSAge0ZsYXNofSAgdGVjaCAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlXG4gICAqL1xuICBGbGFzaC5ydG1wU291cmNlSGFuZGxlci5oYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCB0ZWNoLCBvcHRpb25zKSB7XG4gICAgdmFyIHNyY1BhcnRzID0gRmxhc2guc3RyZWFtVG9QYXJ0cyhzb3VyY2Uuc3JjKTtcblxuICAgIHRlY2hbJ3NldFJ0bXBDb25uZWN0aW9uJ10oc3JjUGFydHMuY29ubmVjdGlvbik7XG4gICAgdGVjaFsnc2V0UnRtcFN0cmVhbSddKHNyY1BhcnRzLnN0cmVhbSk7XG4gIH07XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIG5hdGl2ZSBzb3VyY2UgaGFuZGxlclxuICBGbGFzaC5yZWdpc3RlclNvdXJjZUhhbmRsZXIoRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIpO1xuXG4gIHJldHVybiBGbGFzaDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gRmxhc2hSdG1wRGVjb3JhdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se31dLDEyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGZsYXNoLmpzXG4gKiBWaWRlb0pTLVNXRiAtIEN1c3RvbSBGbGFzaCBQbGF5ZXIgd2l0aCBIVE1MNS1pc2ggQVBJXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemVuY29kZXIvdmlkZW8tanMtc3dmXG4gKiBOb3QgdXNpbmcgc2V0dXBUcmlnZ2Vycy4gVXNpbmcgZ2xvYmFsIG9uRXZlbnQgZnVuYyB0byBkaXN0cmlidXRlIGV2ZW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90ZWNoID0gX2RlcmVxXygnLi90ZWNoJyk7XG5cbnZhciBfdGVjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZWNoKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbnZhciBfdXRpbHNVcmxKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL3VybC5qcycpO1xuXG52YXIgVXJsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzVXJsSnMpO1xuXG52YXIgX3V0aWxzVGltZVJhbmdlc0pzID0gX2RlcmVxXygnLi4vdXRpbHMvdGltZS1yYW5nZXMuanMnKTtcblxudmFyIF9mbGFzaFJ0bXAgPSBfZGVyZXFfKCcuL2ZsYXNoLXJ0bXAnKTtcblxudmFyIF9mbGFzaFJ0bXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmxhc2hSdG1wKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb21wb25lbnQnKTtcblxudmFyIF9jb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50KTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfb2JqZWN0QXNzaWduID0gX2RlcmVxXygnb2JqZWN0LmFzc2lnbicpO1xuXG52YXIgX29iamVjdEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RBc3NpZ24pO1xuXG52YXIgbmF2aWdhdG9yID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5uYXZpZ2F0b3I7XG4vKipcbiAqIEZsYXNoIE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBmYWxsYmFjayBTV0YgQVBJXG4gKlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5IFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBUZWNoXG4gKiBAY2xhc3MgRmxhc2hcbiAqL1xuXG52YXIgRmxhc2ggPSAoZnVuY3Rpb24gKF9UZWNoKSB7XG4gIF9pbmhlcml0cyhGbGFzaCwgX1RlY2gpO1xuXG4gIGZ1bmN0aW9uIEZsYXNoKG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsYXNoKTtcblxuICAgIF9UZWNoLmNhbGwodGhpcywgb3B0aW9ucywgcmVhZHkpO1xuXG4gICAgLy8gU2V0IHRoZSBzb3VyY2Ugd2hlbiByZWFkeVxuICAgIGlmIChvcHRpb25zLnNvdXJjZSkge1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKG9wdGlvbnMuc291cmNlKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEhhdmluZyBpc3N1ZXMgd2l0aCBGbGFzaCByZWxvYWRpbmcgb24gY2VydGFpbiBwYWdlIGFjdGlvbnMgKGhpZGUvcmVzaXplL2Z1bGxzY3JlZW4pIGluIGNlcnRhaW4gYnJvd3NlcnNcbiAgICAvLyBUaGlzIGFsbG93cyByZXNldHRpbmcgdGhlIHBsYXloZWFkIHdoZW4gd2UgY2F0Y2ggdGhlIHJlbG9hZFxuICAgIGlmIChvcHRpb25zLnN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZShvcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZ2xvYmFsIHdpbmRvdyBmdW5jdGlvbnMgdGhhdCB0aGUgc3dmIGV4cGVjdHNcbiAgICAvLyBBIDQueCB3b3JrZmxvdyB3ZSB3ZXJlbid0IGFibGUgdG8gc29sdmUgZm9yIGluIDUuMFxuICAgIC8vIGJlY2F1c2Ugb2YgdGhlIG5lZWQgdG8gaGFyZCBjb2RlIHRoZXNlIGZ1bmN0aW9uc1xuICAgIC8vIGludG8gdGhlIHN3ZiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10udmlkZW9qcyA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10udmlkZW9qcyB8fCB7fTtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnZpZGVvanMuRmxhc2ggPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnZpZGVvanMuRmxhc2ggfHwge307XG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS52aWRlb2pzLkZsYXNoLm9uUmVhZHkgPSBGbGFzaC5vblJlYWR5O1xuICAgIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10udmlkZW9qcy5GbGFzaC5vbkV2ZW50ID0gRmxhc2gub25FdmVudDtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnZpZGVvanMuRmxhc2gub25FcnJvciA9IEZsYXNoLm9uRXJyb3I7XG5cbiAgICB0aGlzLm9uKCdzZWVrZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxhc3RTZWVrVGFyZ2V0XyA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciBhdHRyaWJ1dGVzXG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogQG1ldGhvZCBjcmVhdGVFbFxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc187XG5cbiAgICAvLyBJZiB2aWRlby5qcyBpcyBob3N0ZWQgbG9jYWxseSB5b3Ugc2hvdWxkIGFsc28gc2V0IHRoZSBsb2NhdGlvblxuICAgIC8vIGZvciB0aGUgaG9zdGVkIHN3Ziwgd2hpY2ggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBwYWdlIChub3QgdmlkZW8uanMpXG4gICAgLy8gT3RoZXJ3aXNlIHRoaXMgYWRkcyBhIENETiB1cmwuXG4gICAgLy8gVGhlIENETiBhbHNvIGF1dG8tYWRkcyBhIHN3ZiBVUkwgZm9yIHRoYXQgc3BlY2lmaWMgdmVyc2lvbi5cbiAgICBpZiAoIW9wdGlvbnMuc3dmKSB7XG4gICAgICBvcHRpb25zLnN3ZiA9ICcvL3Zqcy56ZW5jZG4ubmV0L3N3Zi81LjEuMC92aWRlby1qcy5zd2YnO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIElEIGZvciBzd2Ygb2JqZWN0XG4gICAgdmFyIG9iaklkID0gb3B0aW9ucy50ZWNoSWQ7XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IGZsYXNodmFycyB3aXRoIG9uZXMgcGFzc2VkIGluIHRvIGluaXRcbiAgICB2YXIgZmxhc2hWYXJzID0gX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSh7XG5cbiAgICAgIC8vIFNXRiBDYWxsYmFjayBGdW5jdGlvbnNcbiAgICAgICdyZWFkeUZ1bmN0aW9uJzogJ3ZpZGVvanMuRmxhc2gub25SZWFkeScsXG4gICAgICAnZXZlbnRQcm94eUZ1bmN0aW9uJzogJ3ZpZGVvanMuRmxhc2gub25FdmVudCcsXG4gICAgICAnZXJyb3JFdmVudFByb3h5RnVuY3Rpb24nOiAndmlkZW9qcy5GbGFzaC5vbkVycm9yJyxcblxuICAgICAgLy8gUGxheWVyIFNldHRpbmdzXG4gICAgICAnYXV0b3BsYXknOiBvcHRpb25zLmF1dG9wbGF5LFxuICAgICAgJ3ByZWxvYWQnOiBvcHRpb25zLnByZWxvYWQsXG4gICAgICAnbG9vcCc6IG9wdGlvbnMubG9vcCxcbiAgICAgICdtdXRlZCc6IG9wdGlvbnMubXV0ZWRcblxuICAgIH0sIG9wdGlvbnMuZmxhc2hWYXJzKTtcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgcGFyYW1lcyB3aXRoIG9uZXMgcGFzc2VkIGluXG4gICAgdmFyIHBhcmFtcyA9IF9vYmplY3RBc3NpZ24yWydkZWZhdWx0J10oe1xuICAgICAgJ3dtb2RlJzogJ29wYXF1ZScsIC8vIE9wYXF1ZSBpcyBuZWVkZWQgdG8gb3ZlcmxheSBjb250cm9scywgYnV0IGNhbiBhZmZlY3QgcGxheWJhY2sgcGVyZm9ybWFuY2VcbiAgICAgICdiZ2NvbG9yJzogJyMwMDAwMDAnIC8vIFVzaW5nIGJnY29sb3IgcHJldmVudHMgYSB3aGl0ZSBmbGFzaCB3aGVuIHRoZSBvYmplY3QgaXMgbG9hZGluZ1xuICAgIH0sIG9wdGlvbnMucGFyYW1zKTtcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgYXR0cmlidXRlcyB3aXRoIG9uZXMgcGFzc2VkIGluXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKHtcbiAgICAgICdpZCc6IG9iaklkLFxuICAgICAgJ25hbWUnOiBvYmpJZCwgLy8gQm90aCBJRCBhbmQgTmFtZSBuZWVkZWQgb3Igc3dmIHRvIGlkZW50aWZ5IGl0c2VsZlxuICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgIH0sIG9wdGlvbnMuYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLmVsXyA9IEZsYXNoLmVtYmVkKG9wdGlvbnMuc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcyk7XG4gICAgdGhpcy5lbF8udGVjaCA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFBsYXkgZm9yIGZsYXNoIHRlY2hcbiAgICpcbiAgICogQG1ldGhvZCBwbGF5XG4gICAqL1xuXG4gIEZsYXNoLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcbiAgICBpZiAodGhpcy5lbmRlZCgpKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRUaW1lKDApO1xuICAgIH1cbiAgICB0aGlzLmVsXy52anNfcGxheSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXVzZSBmb3IgZmxhc2ggdGVjaFxuICAgKlxuICAgKiBAbWV0aG9kIHBhdXNlXG4gICAqL1xuXG4gIEZsYXNoLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMuZWxfLnZqc19wYXVzZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHZpZGVvXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gc3JjIFNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAbWV0aG9kIHNyY1xuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKF9zcmMpIHtcbiAgICBpZiAoX3NyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3JjKCk7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBub3QgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgcmV0dXJuIHRoaXMuc2V0U3JjKF9zcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdmlkZW9cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBzcmMgU291cmNlIG9iamVjdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAbWV0aG9kIHNldFNyY1xuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHNyYykge1xuICAgIC8vIE1ha2Ugc3VyZSBzb3VyY2UgVVJMIGlzIGFic29sdXRlLlxuICAgIHNyYyA9IFVybC5nZXRBYnNvbHV0ZVVSTChzcmMpO1xuICAgIHRoaXMuZWxfLnZqc19zcmMoc3JjKTtcblxuICAgIC8vIEN1cnJlbnRseSB0aGUgU1dGIGRvZXNuJ3QgYXV0b3BsYXkgaWYgeW91IGxvYWQgYSBzb3VyY2UgbGF0ZXIuXG4gICAgLy8gZS5nLiBMb2FkIHBsYXllciB3LyBubyBzb3VyY2UsIHdhaXQgMnMsIHNldCBzcmMuXG4gICAgaWYgKHRoaXMuYXV0b3BsYXkoKSkge1xuICAgICAgdmFyIHRlY2ggPSB0aGlzO1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVjaC5wbGF5KCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVjaCBpcyBjdXJyZW50bHkgc2Vla2luZy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBzZWVraW5nXG4gICAqL1xuXG4gIEZsYXNoLnByb3RvdHlwZS5zZWVraW5nID0gZnVuY3Rpb24gc2Vla2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0U2Vla1RhcmdldF8gIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBDdXJyZW50IHRpbWUgb2YgdmlkZW9cbiAgICogQG1ldGhvZCBzZXRDdXJyZW50VGltZVxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgdmFyIHNlZWthYmxlID0gdGhpcy5zZWVrYWJsZSgpO1xuICAgIGlmIChzZWVrYWJsZS5sZW5ndGgpIHtcbiAgICAgIC8vIGNsYW1wIHRvIHRoZSBjdXJyZW50IHNlZWthYmxlIHJhbmdlXG4gICAgICB0aW1lID0gdGltZSA+IHNlZWthYmxlLnN0YXJ0KDApID8gdGltZSA6IHNlZWthYmxlLnN0YXJ0KDApO1xuICAgICAgdGltZSA9IHRpbWUgPCBzZWVrYWJsZS5lbmQoc2Vla2FibGUubGVuZ3RoIC0gMSkgPyB0aW1lIDogc2Vla2FibGUuZW5kKHNlZWthYmxlLmxlbmd0aCAtIDEpO1xuXG4gICAgICB0aGlzLmxhc3RTZWVrVGFyZ2V0XyA9IHRpbWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3NlZWtpbmcnKTtcbiAgICAgIHRoaXMuZWxfLnZqc19zZXRQcm9wZXJ0eSgnY3VycmVudFRpbWUnLCB0aW1lKTtcbiAgICAgIF9UZWNoLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGltZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcj19IHRpbWUgQ3VycmVudCB0aW1lIG9mIHZpZGVvXG4gICAqIEByZXR1cm4ge051bWJlcn0gQ3VycmVudCB0aW1lXG4gICAqIEBtZXRob2QgY3VycmVudFRpbWVcbiAgICovXG5cbiAgRmxhc2gucHJvdG90eXBlLmN1cnJlbnRUaW1lID0gZnVuY3Rpb24gY3VycmVudFRpbWUodGltZSkge1xuICAgIC8vIHdoZW4gc2Vla2luZyBtYWtlIHRoZSByZXBvcnRlZCB0aW1lIGtlZXAgdXAgd2l0aCB0aGUgcmVxdWVzdGVkIHRpbWVcbiAgICAvLyBieSByZWFkaW5nIHRoZSB0aW1lIHdlJ3JlIHNlZWtpbmcgdG9cbiAgICBpZiAodGhpcy5zZWVraW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RTZWVrVGFyZ2V0XyB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50VGltZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBzb3VyY2VcbiAgICpcbiAgICogQG1ldGhvZCBjdXJyZW50U3JjXG4gICAqL1xuXG4gIEZsYXNoLnByb3RvdHlwZS5jdXJyZW50U3JjID0gZnVuY3Rpb24gY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50U3JjJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgbWVkaWEgZHVyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gTWVkaWEgZHVyYXRpb25cbiAgICovXG5cbiAgRmxhc2gucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSgpID09PSAwKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmVsXy52anNfZ2V0UHJvcGVydHkoJ2R1cmF0aW9uJyk7XG4gICAgICByZXR1cm4gZHVyYXRpb24gPj0gMCA/IGR1cmF0aW9uIDogSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIG1lZGlhIGludG8gcGxheWVyXG4gICAqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgdGhpcy5lbF8udmpzX2xvYWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBvc3RlclxuICAgKlxuICAgKiBAbWV0aG9kIHBvc3RlclxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUucG9zdGVyID0gZnVuY3Rpb24gcG9zdGVyKCkge1xuICAgIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgncG9zdGVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvc3RlciBpbWFnZXMgYXJlIG5vdCBoYW5kbGVkIGJ5IHRoZSBGbGFzaCB0ZWNoIHNvIG1ha2UgdGhpcyBhIG5vLW9wXG4gICAqXG4gICAqIEBtZXRob2Qgc2V0UG9zdGVyXG4gICAqL1xuXG4gIEZsYXNoLnByb3RvdHlwZS5zZXRQb3N0ZXIgPSBmdW5jdGlvbiBzZXRQb3N0ZXIoKSB7fTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGNhbiBzZWVrIGluIG1lZGlhXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZU9iamVjdH1cbiAgICogQG1ldGhvZCBzZWVrYWJsZVxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuc2Vla2FibGUgPSBmdW5jdGlvbiBzZWVrYWJsZSgpIHtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCk7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gX3V0aWxzVGltZVJhbmdlc0pzLmNyZWF0ZVRpbWVSYW5nZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX3V0aWxzVGltZVJhbmdlc0pzLmNyZWF0ZVRpbWVSYW5nZSgwLCBkdXJhdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBidWZmZXJlZCB0aW1lIHJhbmdlXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZU9iamVjdH1cbiAgICogQG1ldGhvZCBidWZmZXJlZFxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdidWZmZXJlZCcpO1xuICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gX3V0aWxzVGltZVJhbmdlc0pzLmNyZWF0ZVRpbWVSYW5nZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX3V0aWxzVGltZVJhbmdlc0pzLmNyZWF0ZVRpbWVSYW5nZShyYW5nZXNbMF1bMF0sIHJhbmdlc1swXVsxXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBmdWxsc2NyZWVuIHN1cHBvcnQgLVxuICAgKiBGbGFzaCBkb2VzIG5vdCBhbGxvdyBmdWxsc2NyZWVuIHRocm91Z2ggamF2YXNjcmlwdFxuICAgKiBzbyBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZVxuICAgKiBAbWV0aG9kIHN1cHBvcnRzRnVsbFNjcmVlblxuICAgKi9cblxuICBGbGFzaC5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gRmxhc2ggZG9lcyBub3QgYWxsb3cgZnVsbHNjcmVlbiB0aHJvdWdoIGphdmFzY3JpcHRcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0byBlbnRlciBmdWxsc2NyZWVuXG4gICAqIEZsYXNoIGRvZXMgbm90IGFsbG93IGZ1bGxzY3JlZW4gdGhyb3VnaCBqYXZhc2NyaXB0XG4gICAqIHNvIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZhbHNlXG4gICAqIEBtZXRob2QgZW50ZXJGdWxsU2NyZWVuXG4gICAqL1xuXG4gIEZsYXNoLnByb3RvdHlwZS5lbnRlckZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBlbnRlckZ1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBGbGFzaDtcbn0pKF90ZWNoMlsnZGVmYXVsdCddKTtcblxudmFyIF9hcGkgPSBGbGFzaC5wcm90b3R5cGU7XG52YXIgX3JlYWRXcml0ZSA9ICdydG1wQ29ubmVjdGlvbixydG1wU3RyZWFtLHByZWxvYWQsZGVmYXVsdFBsYXliYWNrUmF0ZSxwbGF5YmFja1JhdGUsYXV0b3BsYXksbG9vcCxtZWRpYUdyb3VwLGNvbnRyb2xsZXIsY29udHJvbHMsdm9sdW1lLG11dGVkLGRlZmF1bHRNdXRlZCcuc3BsaXQoJywnKTtcbnZhciBfcmVhZE9ubHkgPSAnbmV0d29ya1N0YXRlLHJlYWR5U3RhdGUsaW5pdGlhbFRpbWUsc3RhcnRPZmZzZXRUaW1lLHBhdXNlZCxlbmRlZCx2aWRlb1dpZHRoLHZpZGVvSGVpZ2h0Jy5zcGxpdCgnLCcpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU2V0dGVyKGF0dHIpIHtcbiAgdmFyIGF0dHJVcHBlciA9IGF0dHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBhdHRyLnNsaWNlKDEpO1xuICBfYXBpWydzZXQnICsgYXR0clVwcGVyXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX3NldFByb3BlcnR5KGF0dHIsIHZhbCk7XG4gIH07XG59XG5mdW5jdGlvbiBfY3JlYXRlR2V0dGVyKGF0dHIpIHtcbiAgX2FwaVthdHRyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KGF0dHIpO1xuICB9O1xufVxuXG4vLyBDcmVhdGUgZ2V0dGVyIGFuZCBzZXR0ZXJzIGZvciBhbGwgcmVhZC93cml0ZSBhdHRyaWJ1dGVzXG5mb3IgKHZhciBpID0gMDsgaSA8IF9yZWFkV3JpdGUubGVuZ3RoOyBpKyspIHtcbiAgX2NyZWF0ZUdldHRlcihfcmVhZFdyaXRlW2ldKTtcbiAgX2NyZWF0ZVNldHRlcihfcmVhZFdyaXRlW2ldKTtcbn1cblxuLy8gQ3JlYXRlIGdldHRlcnMgZm9yIHJlYWQtb25seSBhdHRyaWJ1dGVzXG5mb3IgKHZhciBpID0gMDsgaSA8IF9yZWFkT25seS5sZW5ndGg7IGkrKykge1xuICBfY3JlYXRlR2V0dGVyKF9yZWFkT25seVtpXSk7XG59XG5cbi8qIEZsYXNoIFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5GbGFzaC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEZsYXNoLnZlcnNpb24oKVswXSA+PSAxMDtcbiAgLy8gcmV0dXJuIHN3Zm9iamVjdC5oYXNGbGFzaFBsYXllclZlcnNpb24oJzEwJyk7XG59O1xuXG4vLyBBZGQgU291cmNlIEhhbmRsZXIgcGF0dGVybiBmdW5jdGlvbnMgdG8gdGhpcyB0ZWNoXG5fdGVjaDJbJ2RlZmF1bHQnXS53aXRoU291cmNlSGFuZGxlcnMoRmxhc2gpO1xuXG4vKlxuICogVGhlIGRlZmF1bHQgbmF0aXZlIHNvdXJjZSBoYW5kbGVyLlxuICogVGhpcyBzaW1wbHkgcGFzc2VzIHRoZSBzb3VyY2UgdG8gdGhlIHZpZGVvIGVsZW1lbnQuIE5vdGhpbmcgZmFuY3kuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgICBUaGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtICB7Rmxhc2h9IHRlY2ggIFRoZSBpbnN0YW5jZSBvZiB0aGUgRmxhc2ggdGVjaFxuICovXG5GbGFzaC5uYXRpdmVTb3VyY2VIYW5kbGVyID0ge307XG5cbi8qKlxuICogQ2hlY2sgaWYgRmxhc2ggY2FuIHBsYXkgdGhlIGdpdmVuIHZpZGVvdHlwZVxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAodHlwZSBpbiBGbGFzaC5mb3JtYXRzKSB7XG4gICAgcmV0dXJuICdtYXliZSc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKlxuICogQ2hlY2sgRmxhc2ggY2FuIGhhbmRsZSB0aGUgc291cmNlIG5hdGl2ZWx5XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzb3VyY2UgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciB0eXBlO1xuXG4gIGZ1bmN0aW9uIGd1ZXNzTWltZVR5cGUoc3JjKSB7XG4gICAgdmFyIGV4dCA9IFVybC5nZXRGaWxlRXh0ZW5zaW9uKHNyYyk7XG4gICAgaWYgKGV4dCkge1xuICAgICAgcmV0dXJuICd2aWRlby8nICsgZXh0O1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIXNvdXJjZS50eXBlKSB7XG4gICAgdHlwZSA9IGd1ZXNzTWltZVR5cGUoc291cmNlLnNyYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaXAgY29kZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0eXBlIGJlY2F1c2Ugd2UgZG9uJ3QgZ2V0IHRoYXQgc3BlY2lmaWNcbiAgICB0eXBlID0gc291cmNlLnR5cGUucmVwbGFjZSgvOy4qLywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSh0eXBlKTtcbn07XG5cbi8qXG4gKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIGZsYXNoIG9iamVjdFxuICogQWRhcHRpdmUgc291cmNlIGhhbmRsZXJzIHdpbGwgaGF2ZSBtb3JlIGNvbXBsaWNhdGVkIHdvcmtmbG93cyBiZWZvcmUgcGFzc2luZ1xuICogdmlkZW8gZGF0YSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0ZsYXNofSAgdGVjaCAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZVxuICovXG5GbGFzaC5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKlxuICogQ2xlYW4gdXAgdGhlIHNvdXJjZSBoYW5kbGVyIHdoZW4gZGlzcG9zaW5nIHRoZSBwbGF5ZXIgb3Igc3dpdGNoaW5nIHNvdXJjZXMuLlxuICogKG5vIGNsZWFudXAgaXMgbmVlZGVkIHdoZW4gc3VwcG9ydGluZyB0aGUgZm9ybWF0IG5hdGl2ZWx5KVxuICovXG5GbGFzaC5uYXRpdmVTb3VyY2VIYW5kbGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gUmVnaXN0ZXIgdGhlIG5hdGl2ZSBzb3VyY2UgaGFuZGxlclxuRmxhc2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyKEZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpO1xuXG5GbGFzaC5mb3JtYXRzID0ge1xuICAndmlkZW8vZmx2JzogJ0ZMVicsXG4gICd2aWRlby94LWZsdic6ICdGTFYnLFxuICAndmlkZW8vbXA0JzogJ01QNCcsXG4gICd2aWRlby9tNHYnOiAnTVA0J1xufTtcblxuRmxhc2gub25SZWFkeSA9IGZ1bmN0aW9uIChjdXJyU3dmKSB7XG4gIHZhciBlbCA9IERvbS5nZXRFbChjdXJyU3dmKTtcbiAgdmFyIHRlY2ggPSBlbCAmJiBlbC50ZWNoO1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGVsIHRoZW4gdGhlIHRlY2ggaGFzIGJlZW4gZGlzcG9zZWRcbiAgLy8gYW5kIHRoZSB0ZWNoIGVsZW1lbnQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgcGxheWVyIGRpdlxuICBpZiAodGVjaCAmJiB0ZWNoLmVsKCkpIHtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBmbGFzaCBvYmplY3QgaXMgcmVhbGx5IHJlYWR5XG4gICAgRmxhc2guY2hlY2tSZWFkeSh0ZWNoKTtcbiAgfVxufTtcblxuLy8gVGhlIFNXRiBpc24ndCBhbHdheXMgcmVhZHkgd2hlbiBpdCBzYXlzIGl0IGlzLiBTb21ldGltZXMgdGhlIEFQSSBmdW5jdGlvbnMgc3RpbGwgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgb2JqZWN0LlxuLy8gSWYgaXQncyBub3QgcmVhZHksIHdlIHNldCBhIHRpbWVvdXQgdG8gY2hlY2sgYWdhaW4gc2hvcnRseS5cbkZsYXNoLmNoZWNrUmVhZHkgPSBmdW5jdGlvbiAodGVjaCkge1xuICAvLyBzdG9wIHdvcnJ5aW5nIGlmIHRoZSB0ZWNoIGhhcyBiZWVuIGRpc3Bvc2VkXG4gIGlmICghdGVjaC5lbCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgQVBJIHByb3BlcnR5IGV4aXN0c1xuICBpZiAodGVjaC5lbCgpLnZqc19nZXRQcm9wZXJ0eSkge1xuICAgIC8vIHRlbGwgdGVjaCBpdCdzIHJlYWR5XG4gICAgdGVjaC50cmlnZ2VyUmVhZHkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3YWl0IGxvbmdlclxuICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBGbGFzaFsnY2hlY2tSZWFkeSddKHRlY2gpO1xuICAgIH0sIDUwKTtcbiAgfVxufTtcblxuLy8gVHJpZ2dlciBldmVudHMgZnJvbSB0aGUgc3dmIG9uIHRoZSBwbGF5ZXJcbkZsYXNoLm9uRXZlbnQgPSBmdW5jdGlvbiAoc3dmSUQsIGV2ZW50TmFtZSkge1xuICB2YXIgdGVjaCA9IERvbS5nZXRFbChzd2ZJRCkudGVjaDtcbiAgdGVjaC50cmlnZ2VyKGV2ZW50TmFtZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG59O1xuXG4vLyBMb2cgZXJyb3JzIGZyb20gdGhlIHN3ZlxuRmxhc2gub25FcnJvciA9IGZ1bmN0aW9uIChzd2ZJRCwgZXJyKSB7XG4gIHZhciB0ZWNoID0gRG9tLmdldEVsKHN3ZklEKS50ZWNoO1xuXG4gIC8vIHRyaWdnZXIgTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEXG4gIGlmIChlcnIgPT09ICdzcmNub3Rmb3VuZCcpIHtcbiAgICByZXR1cm4gdGVjaC5lcnJvcig0KTtcbiAgfVxuXG4gIC8vIHRyaWdnZXIgYSBjdXN0b20gZXJyb3JcbiAgdGVjaC5lcnJvcignRkxBU0g6ICcgKyBlcnIpO1xufTtcblxuLy8gRmxhc2ggVmVyc2lvbiBDaGVja1xuRmxhc2gudmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlcnNpb24gPSAnMCwwLDAnO1xuXG4gIC8vIElFXG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IG5ldyBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLkFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJykucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV07XG5cbiAgICAvLyBvdGhlciBicm93c2Vyc1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pIHtcbiAgICAgICAgdmVyc2lvbiA9IChuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoIDIuMCddIHx8IG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2gnXSkuZGVzY3JpcHRpb24ucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9XG4gIHJldHVybiB2ZXJzaW9uLnNwbGl0KCcsJyk7XG59O1xuXG4vLyBGbGFzaCBlbWJlZGRpbmcgbWV0aG9kLiBPbmx5IHVzZWQgaW4gbm9uLWlmcmFtZSBtb2RlXG5GbGFzaC5lbWJlZCA9IGZ1bmN0aW9uIChzd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBjb2RlID0gRmxhc2guZ2V0RW1iZWRDb2RlKHN3ZiwgZmxhc2hWYXJzLCBwYXJhbXMsIGF0dHJpYnV0ZXMpO1xuXG4gIC8vIEdldCBlbGVtZW50IGJ5IGVtYmVkZGluZyBjb2RlIGFuZCByZXRyaWV2aW5nIGNyZWF0ZWQgZWxlbWVudFxuICB2YXIgb2JqID0gRG9tLmNyZWF0ZUVsKCdkaXYnLCB7IGlubmVySFRNTDogY29kZSB9KS5jaGlsZE5vZGVzWzBdO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5GbGFzaC5nZXRFbWJlZENvZGUgPSBmdW5jdGlvbiAoc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcykge1xuICB2YXIgb2JqVGFnID0gJzxvYmplY3QgdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIgJztcbiAgdmFyIGZsYXNoVmFyc1N0cmluZyA9ICcnO1xuICB2YXIgcGFyYW1zU3RyaW5nID0gJyc7XG4gIHZhciBhdHRyc1N0cmluZyA9ICcnO1xuXG4gIC8vIENvbnZlcnQgZmxhc2ggdmFycyB0byBzdHJpbmdcbiAgaWYgKGZsYXNoVmFycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZsYXNoVmFycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBmbGFzaFZhcnNTdHJpbmcgKz0ga2V5ICsgJz0nICsgZmxhc2hWYXJzW2tleV0gKyAnJmFtcDsnO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHN3ZiwgZmxhc2hWYXJzLCBhbmQgb3RoZXIgZGVmYXVsdCBwYXJhbXNcbiAgcGFyYW1zID0gX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSh7XG4gICAgJ21vdmllJzogc3dmLFxuICAgICdmbGFzaHZhcnMnOiBmbGFzaFZhcnNTdHJpbmcsXG4gICAgJ2FsbG93U2NyaXB0QWNjZXNzJzogJ2Fsd2F5cycsIC8vIFJlcXVpcmVkIHRvIHRhbGsgdG8gc3dmXG4gICAgJ2FsbG93TmV0d29ya2luZyc6ICdhbGwnIC8vIEFsbCBzaG91bGQgYmUgZGVmYXVsdCwgYnV0IGhhdmluZyBzZWN1cml0eSBpc3N1ZXMuXG4gIH0sIHBhcmFtcyk7XG5cbiAgLy8gQ3JlYXRlIHBhcmFtIHRhZ3Mgc3RyaW5nXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcGFyYW1zU3RyaW5nICs9ICc8cGFyYW0gbmFtZT1cIicgKyBrZXkgKyAnXCIgdmFsdWU9XCInICsgcGFyYW1zW2tleV0gKyAnXCIgLz4nO1xuICB9KTtcblxuICBhdHRyaWJ1dGVzID0gX29iamVjdEFzc2lnbjJbJ2RlZmF1bHQnXSh7XG4gICAgLy8gQWRkIHN3ZiB0byBhdHRyaWJ1dGVzIChuZWVkIGJvdGggZm9yIElFIGFuZCBPdGhlcnMgdG8gd29yaylcbiAgICAnZGF0YSc6IHN3ZixcblxuICAgIC8vIERlZmF1bHQgdG8gMTAwJSB3aWR0aC9oZWlnaHRcbiAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgJ2hlaWdodCc6ICcxMDAlJ1xuXG4gIH0sIGF0dHJpYnV0ZXMpO1xuXG4gIC8vIENyZWF0ZSBBdHRyaWJ1dGVzIHN0cmluZ1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBhdHRyc1N0cmluZyArPSBrZXkgKyAnPVwiJyArIGF0dHJpYnV0ZXNba2V5XSArICdcIiAnO1xuICB9KTtcblxuICByZXR1cm4gJycgKyBvYmpUYWcgKyBhdHRyc1N0cmluZyArICc+JyArIHBhcmFtc1N0cmluZyArICc8L29iamVjdD4nO1xufTtcblxuLy8gUnVuIEZsYXNoIHRocm91Z2ggdGhlIFJUTVAgZGVjb3JhdG9yXG5fZmxhc2hSdG1wMlsnZGVmYXVsdCddKEZsYXNoKTtcblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnRmxhc2gnLCBGbGFzaCk7XG5fdGVjaDJbJ2RlZmF1bHQnXS5yZWdpc3RlclRlY2goJ0ZsYXNoJywgRmxhc2gpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gRmxhc2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi9jb21wb25lbnRcIjo2NyxcIi4uL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4uL3V0aWxzL3RpbWUtcmFuZ2VzLmpzXCI6MTUwLFwiLi4vdXRpbHMvdXJsLmpzXCI6MTUyLFwiLi9mbGFzaC1ydG1wXCI6MTIwLFwiLi90ZWNoXCI6MTI0LFwiZ2xvYmFsL3dpbmRvd1wiOjIsXCJvYmplY3QuYXNzaWduXCI6NDV9XSwxMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBodG1sNS5qc1xuICogSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1RleHQgVHJhY2tzIGFyZSBiZWluZyBsb2FkZWQgZnJvbSBhbm90aGVyIG9yaWdpbiBidXQgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSBpc25cXCd0IHVzZWQuIFxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddLCBbJ1RleHQgVHJhY2tzIGFyZSBiZWluZyBsb2FkZWQgZnJvbSBhbm90aGVyIG9yaWdpbiBidXQgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSBpc25cXCd0IHVzZWQuIFxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykgeyBzdHJpbmdzLnJhdyA9IHJhdzsgcmV0dXJuIHN0cmluZ3M7IH1cblxudmFyIF90ZWNoSnMgPSBfZGVyZXFfKCcuL3RlY2guanMnKTtcblxudmFyIF90ZWNoSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGVjaEpzKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb21wb25lbnQnKTtcblxudmFyIF9jb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50KTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi4vdXRpbHMvZG9tLmpzJyk7XG5cbnZhciBEb20gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNEb21Kcyk7XG5cbnZhciBfdXRpbHNVcmxKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL3VybC5qcycpO1xuXG52YXIgVXJsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzVXJsSnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2ZuLmpzJyk7XG5cbnZhciBGbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0ZuSnMpO1xuXG52YXIgX3V0aWxzTG9nSnMgPSBfZGVyZXFfKCcuLi91dGlscy9sb2cuanMnKTtcblxudmFyIF91dGlsc0xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTG9nSnMpO1xuXG52YXIgX3RzbWwgPSBfZGVyZXFfKCd0c21sJyk7XG5cbnZhciBfdHNtbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90c21sKTtcblxudmFyIF9zcmNKc1RyYWNrc1RleHRUcmFja0pzID0gX2RlcmVxXygnLi4vLi4vLi4vc3JjL2pzL3RyYWNrcy90ZXh0LXRyYWNrLmpzJyk7XG5cbnZhciBfc3JjSnNUcmFja3NUZXh0VHJhY2tKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcmNKc1RyYWNrc1RleHRUcmFja0pzKTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Jyb3dzZXIuanMnKTtcblxudmFyIGJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNCcm93c2VySnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF9vYmplY3RBc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QuYXNzaWduJyk7XG5cbnZhciBfb2JqZWN0QXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEFzc2lnbik7XG5cbnZhciBfdXRpbHNNZXJnZU9wdGlvbnNKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL21lcmdlLW9wdGlvbnMuanMnKTtcblxudmFyIF91dGlsc01lcmdlT3B0aW9uc0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTWVyZ2VPcHRpb25zSnMpO1xuXG52YXIgX3V0aWxzVG9UaXRsZUNhc2VKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL3RvLXRpdGxlLWNhc2UuanMnKTtcblxudmFyIF91dGlsc1RvVGl0bGVDYXNlSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNUb1RpdGxlQ2FzZUpzKTtcblxuLyoqXG4gKiBIVE1MNSBNZWRpYSBDb250cm9sbGVyIC0gV3JhcHBlciBmb3IgSFRNTDUgTWVkaWEgQVBJXG4gKlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5IFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBUZWNoXG4gKiBAY2xhc3MgSHRtbDVcbiAqL1xuXG52YXIgSHRtbDUgPSAoZnVuY3Rpb24gKF9UZWNoKSB7XG4gIF9pbmhlcml0cyhIdG1sNSwgX1RlY2gpO1xuXG4gIGZ1bmN0aW9uIEh0bWw1KG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XG5cbiAgICBfVGVjaC5jYWxsKHRoaXMsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgY3Jvc3NvcmlnaW5UcmFja3MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAodGhpcy5lbF8uY3VycmVudFNyYyAhPT0gc291cmNlLnNyYyB8fCBvcHRpb25zLnRhZyAmJiBvcHRpb25zLnRhZy5pbml0TmV0d29ya1N0YXRlXyA9PT0gMykpIHtcbiAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlTGF0ZUluaXRfKHRoaXMuZWxfKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbF8uaGFzQ2hpbGROb2RlcygpKSB7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICAgICAgICAvLyBFbXB0eSB2aWRlbyB0YWcgdHJhY2tzIHNvIHRoZSBidWlsdC1pbiBwbGF5ZXIgZG9lc24ndCB1c2UgdGhlbSBhbHNvLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbm90IGJlIGZhc3QgZW5vdWdoIHRvIHN0b3AgSFRNTDUgYnJvd3NlcnMgZnJvbSByZWFkaW5nIHRoZSB0YWdzXG4gICAgICAgICAgICAvLyBzbyB3ZSdsbCBuZWVkIHRvIHR1cm4gb2ZmIGFueSBkZWZhdWx0IHRyYWNrcyBpZiB3ZSdyZSBtYW51YWxseSBkb2luZ1xuICAgICAgICAgICAgLy8gY2FwdGlvbnMgYW5kIHN1YnRpdGxlcy4gdmlkZW9FbGVtZW50LnRleHRUcmFja3NcbiAgICAgICAgICAgIHJlbW92ZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayB0byByZW1vdGUgbGlzdFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5hZGRUcmFja0VsZW1lbnRfKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2tfKG5vZGUudHJhY2spO1xuICAgICAgICAgICAgaWYgKCFjcm9zc29yaWdpblRyYWNrcyAmJiAhdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIFVybC5pc0Nyb3NzT3JpZ2luKG5vZGUuc3JjKSkge1xuICAgICAgICAgICAgICBjcm9zc29yaWdpblRyYWNrcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFja1R5cGVzID0gWydhdWRpbycsICd2aWRlbyddO1xuXG4gICAgLy8gUHJveHlOYXRpdmVUZXh0VHJhY2tzXG4gICAgdHJhY2tUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgY2FwaXRhbFR5cGUgPSBfdXRpbHNUb1RpdGxlQ2FzZUpzMlsnZGVmYXVsdCddKHR5cGUpO1xuXG4gICAgICBpZiAoIV90aGlzWydmZWF0dXJlc05hdGl2ZScgKyBjYXBpdGFsVHlwZSArICdUcmFja3MnXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGwgPSBfdGhpcy5lbCgpW3R5cGUgKyAnVHJhY2tzJ107XG5cbiAgICAgIGlmICh0bCAmJiB0bC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHRsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIEZuLmJpbmQoX3RoaXMsIF90aGlzWydoYW5kbGUnICsgY2FwaXRhbFR5cGUgKyAnVHJhY2tDaGFuZ2VfJ10pKTtcbiAgICAgICAgdGwuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCBGbi5iaW5kKF90aGlzLCBfdGhpc1snaGFuZGxlJyArIGNhcGl0YWxUeXBlICsgJ1RyYWNrQWRkXyddKSk7XG4gICAgICAgIHRsLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgRm4uYmluZChfdGhpcywgX3RoaXNbJ2hhbmRsZScgKyBjYXBpdGFsVHlwZSArICdUcmFja1JlbW92ZV8nXSkpO1xuXG4gICAgICAgIC8vIFJlbW92ZSAobmF0aXZlKSB0cmFja3RzIHRoYXQgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgICAgX3RoaXMub24oJ2xvYWRzdGFydCcsIF90aGlzWydyZW1vdmVPbGQnICsgY2FwaXRhbFR5cGUgKyAnVHJhY2tzXyddKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgaWYgKGNyb3Nzb3JpZ2luVHJhY2tzKSB7XG4gICAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLndhcm4oX3RzbWwyWydkZWZhdWx0J10oX3RlbXBsYXRlT2JqZWN0KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFuZGxlVGV4dFRyYWNrQ2hhbmdlXyA9IEZuLmJpbmQodGhpcywgdGhpcy5oYW5kbGVUZXh0VHJhY2tDaGFuZ2UpO1xuICAgICAgdGhpcy5oYW5kbGVUZXh0VHJhY2tBZGRfID0gRm4uYmluZCh0aGlzLCB0aGlzLmhhbmRsZVRleHRUcmFja0FkZCk7XG4gICAgICB0aGlzLmhhbmRsZVRleHRUcmFja1JlbW92ZV8gPSBGbi5iaW5kKHRoaXMsIHRoaXMuaGFuZGxlVGV4dFRyYWNrUmVtb3ZlKTtcbiAgICAgIHRoaXMucHJveHlOYXRpdmVUZXh0VHJhY2tzXygpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBPdXIgZ29hbCBzaG91bGQgYmUgdG8gZ2V0IHRoZSBjdXN0b20gY29udHJvbHMgb24gbW9iaWxlIHNvbGlkIGV2ZXJ5d2hlcmVcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxuICAgIC8vIGNvbnRyb2xzIG9uIHRvdWNoIGVuYWJsZWQgbGFwdG9wcyBsaWtlIHRoZSBDaHJvbWUgUGl4ZWxcbiAgICBpZiAoKGJyb3dzZXIuVE9VQ0hfRU5BQkxFRCB8fCBicm93c2VyLklTX0lQSE9ORSB8fCBicm93c2VyLklTX05BVElWRV9BTkRST0lEKSAmJiBvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggPT09IHRydWUpIHtcbiAgICAgIHRoaXMuc2V0Q29udHJvbHModHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgfVxuXG4gIC8qIEhUTUw1IFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLypcbiAgKiBFbGVtZW50IGZvciB0ZXN0aW5nIGJyb3dzZXIgSFRNTDUgdmlkZW8gY2FwYWJpbGl0aWVzXG4gICpcbiAgKiBAdHlwZSB7RWxlbWVudH1cbiAgKiBAY29uc3RhbnRcbiAgKiBAcHJpdmF0ZVxuICAqL1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIGh0bWw1IG1lZGlhIGVsZW1lbnRcbiAgICpcbiAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIFVuLVByb3h5TmF0aXZlVHJhY2tzXG4gICAgWydhdWRpbycsICd2aWRlbycsICd0ZXh0J10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGNhcGl0YWxUeXBlID0gX3V0aWxzVG9UaXRsZUNhc2VKczJbJ2RlZmF1bHQnXSh0eXBlKTtcbiAgICAgIHZhciB0bCA9IF90aGlzMi5lbF9bdHlwZSArICdUcmFja3MnXTtcblxuICAgICAgaWYgKHRsICYmIHRsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdGwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgX3RoaXMyWydoYW5kbGUnICsgY2FwaXRhbFR5cGUgKyAnVHJhY2tDaGFuZ2VfJ10pO1xuICAgICAgICB0bC5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIF90aGlzMlsnaGFuZGxlJyArIGNhcGl0YWxUeXBlICsgJ1RyYWNrQWRkXyddKTtcbiAgICAgICAgdGwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBfdGhpczJbJ2hhbmRsZScgKyBjYXBpdGFsVHlwZSArICdUcmFja1JlbW92ZV8nXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3AgcmVtb3Zpbmcgb2xkIHRleHQgdHJhY2tzXG4gICAgICBpZiAodGwpIHtcbiAgICAgICAgX3RoaXMyLm9mZignbG9hZHN0YXJ0JywgX3RoaXMyWydyZW1vdmVPbGQnICsgY2FwaXRhbFR5cGUgKyAnVHJhY2tzXyddKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIEh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICAgIC8vIHRlY2ggd2lsbCBoYW5kbGUgY2xlYXJpbmcgb2YgdGhlIGVtdWxhdGVkIHRyYWNrIGxpc3RcbiAgICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqIEBtZXRob2QgY3JlYXRlRWxcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5vcHRpb25zXy50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8IHRoaXNbJ21vdmluZ01lZGlhRWxlbWVudEluRE9NJ10gPT09IGZhbHNlKSB7XG5cbiAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0YWcgaXMgc3RpbGwgdGhlcmUsIGNsb25lIGFuZCByZW1vdmUgaXQuXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZSwgZWwpO1xuICAgICAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KGVsKTtcbiAgICAgICAgZWwgPSBjbG9uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgICAgICB2YXIgdGFnQXR0cmlidXRlcyA9IHRoaXMub3B0aW9uc18udGFnICYmIERvbS5nZXRFbEF0dHJpYnV0ZXModGhpcy5vcHRpb25zXy50YWcpO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IF91dGlsc01lcmdlT3B0aW9uc0pzMlsnZGVmYXVsdCddKHt9LCB0YWdBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKCFicm93c2VyLlRPVUNIX0VOQUJMRUQgfHwgdGhpcy5vcHRpb25zXy5uYXRpdmVDb250cm9sc0ZvclRvdWNoICE9PSB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuY29udHJvbHM7XG4gICAgICAgIH1cblxuICAgICAgICBEb20uc2V0RWxBdHRyaWJ1dGVzKGVsLCBfb2JqZWN0QXNzaWduMlsnZGVmYXVsdCddKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICBpZDogdGhpcy5vcHRpb25zXy50ZWNoSWQsXG4gICAgICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnBsYXllcklkID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJJZDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3BlY2lmaWMgdGFnIHNldHRpbmdzLCBpbiBjYXNlIHRoZXkgd2VyZSBvdmVycmlkZGVuXG4gICAgdmFyIHNldHRpbmdzQXR0cnMgPSBbJ2F1dG9wbGF5JywgJ3ByZWxvYWQnLCAnbG9vcCcsICdtdXRlZCddO1xuICAgIGZvciAodmFyIGkgPSBzZXR0aW5nc0F0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICB2YXIgb3ZlcndyaXRlQXR0cnMgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zX1thdHRyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3ZlcndyaXRlQXR0cnNbYXR0cl0gPSB0aGlzLm9wdGlvbnNfW2F0dHJdO1xuICAgICAgfVxuICAgICAgRG9tLnNldEVsQXR0cmlidXRlcyhlbCwgb3ZlcndyaXRlQXR0cnMpO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgICAvLyBqZW5uaWlzYXdlc29tZSA9IHRydWU7XG4gIH07XG5cbiAgLy8gSWYgd2UncmUgbG9hZGluZyB0aGUgcGxheWJhY2sgb2JqZWN0IGFmdGVyIGl0IGhhcyBzdGFydGVkIGxvYWRpbmdcbiAgLy8gb3IgcGxheWluZyB0aGUgdmlkZW8gKG9mdGVuIHdpdGggYXV0b3BsYXkgb24pIHRoZW4gdGhlIGxvYWRzdGFydCBldmVudFxuICAvLyBoYXMgYWxyZWFkeSBmaXJlZCBhbmQgd2UgbmVlZCB0byBmaXJlIGl0IG1hbnVhbGx5IGJlY2F1c2UgbWFueSB0aGluZ3NcbiAgLy8gcmVseSBvbiBpdC5cblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlTGF0ZUluaXRfID0gZnVuY3Rpb24gaGFuZGxlTGF0ZUluaXRfKGVsKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAoZWwubmV0d29ya1N0YXRlID09PSAwIHx8IGVsLm5ldHdvcmtTdGF0ZSA9PT0gMykge1xuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxuICAgICAgLy8gb3IgZGlkbid0IGZpbmQgYSBzb3VyY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgdmFyIF9yZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOZXR3b3JrU3RhdGUgaXMgc2V0IHN5bmNocm9ub3VzbHkgQlVUIGxvYWRzdGFydCBpcyBmaXJlZCBhdCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIHRoZSBjdXJyZW50IHN0YWNrLCB1c3VhbGx5IGJlZm9yZSBzZXRJbnRlcnZhbChmbiwgMCkuXG4gICAgICAgIC8vIFNvIGF0IHRoaXMgcG9pbnQgd2Uga25vdyBsb2Fkc3RhcnQgbWF5IGhhdmUgYWxyZWFkeSBmaXJlZCBvciBpc1xuICAgICAgICAvLyBhYm91dCB0byBmaXJlLCBhbmQgZWl0aGVyIHdheSB0aGUgcGxheWVyIGhhc24ndCBzZWVuIGl0IHlldC5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBmaXJlIGxvYWRzdGFydCBwcmVtYXR1cmVseSBoZXJlIGFuZCBjYXVzZSBhXG4gICAgICAgIC8vIGRvdWJsZSBsb2Fkc3RhcnQgc28gd2UnbGwgd2FpdCBhbmQgc2VlIGlmIGl0IGhhcHBlbnMgYmV0d2VlbiBub3dcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IGxvb3AsIGFuZCBmaXJlIGl0IGlmIG5vdC5cbiAgICAgICAgLy8gSE9XRVZFUiwgd2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSBpdCBmaXJlcyBiZWZvcmUgbG9hZGVkbWV0YWRhdGFcbiAgICAgICAgLy8gd2hpY2ggY291bGQgYWxzbyBoYXBwZW4gYmV0d2VlbiBub3cgYW5kIHRoZSBuZXh0IGxvb3AsIHNvIHdlJ2xsXG4gICAgICAgIC8vIHdhdGNoIGZvciB0aGF0IGFsc28uXG4gICAgICAgIHZhciBsb2Fkc3RhcnRGaXJlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2V0TG9hZHN0YXJ0RmlyZWQgPSBmdW5jdGlvbiBzZXRMb2Fkc3RhcnRGaXJlZCgpIHtcbiAgICAgICAgICBsb2Fkc3RhcnRGaXJlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuXG4gICAgICAgIHZhciB0cmlnZ2VyTG9hZHN0YXJ0ID0gZnVuY3Rpb24gdHJpZ2dlckxvYWRzdGFydCgpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbG9hZHN0YXJ0LiBNYWtlIHN1cmUgdGhlIHBsYXllclxuICAgICAgICAgIC8vIHNlZXMgbG9hZHN0YXJ0IGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgICAgIGlmICghbG9hZHN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpczMub24oJ2xvYWRlZG1ldGFkYXRhJywgdHJpZ2dlckxvYWRzdGFydCk7XG5cbiAgICAgICAgX3RoaXMzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLm9mZignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuICAgICAgICAgIHRoaXMub2ZmKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xuXG4gICAgICAgICAgaWYgKCFsb2Fkc3RhcnRGaXJlZCkge1xuICAgICAgICAgICAgLy8gV2UgZGlkIG1pc3MgdGhlIG9yaWdpbmFsIG5hdGl2ZSBsb2Fkc3RhcnQuIEZpcmUgaXQgbm93LlxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuXG4gICAgICBpZiAodHlwZW9mIF9yZXQgPT09ICdvYmplY3QnKSByZXR1cm4gX3JldC52O1xuICAgIH1cblxuICAgIC8vIEZyb20gaGVyZSBvbiB3ZSBrbm93IHRoYXQgbG9hZHN0YXJ0IGFscmVhZHkgZmlyZWQgYW5kIHdlIG1pc3NlZCBpdC5cbiAgICAvLyBUaGUgb3RoZXIgcmVhZHlTdGF0ZSBldmVudHMgYXJlbid0IGFzIG11Y2ggb2YgYSBwcm9ibGVtIGlmIHdlIGRvdWJsZVxuICAgIC8vIHRoZW0sIHNvIG5vdCBnb2luZyB0byBnbyB0byBhcyBtdWNoIHRyb3VibGUgYXMgbG9hZHN0YXJ0IHRvIHByZXZlbnRcbiAgICAvLyB0aGF0IHVubGVzcyB3ZSBmaW5kIHJlYXNvbiB0by5cbiAgICB2YXIgZXZlbnRzVG9UcmlnZ2VyID0gWydsb2Fkc3RhcnQnXTtcblxuICAgIC8vIGxvYWRlZG1ldGFkYXRhOiBuZXdseSBlcXVhbCB0byBIQVZFX01FVEFEQVRBICgxKSBvciBncmVhdGVyXG4gICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZG1ldGFkYXRhJyk7XG5cbiAgICAvLyBsb2FkZWRkYXRhOiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9DVVJSRU5UX0RBVEEgKDIpIG9yIGdyZWF0ZXJcbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnbG9hZGVkZGF0YScpO1xuICAgIH1cblxuICAgIC8vIGNhbnBsYXk6IG5ld2x5IGluY3JlYXNlZCB0byBIQVZFX0ZVVFVSRV9EQVRBICgzKSBvciBncmVhdGVyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMykge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2NhbnBsYXknKTtcbiAgICB9XG5cbiAgICAvLyBjYW5wbGF5dGhyb3VnaDogbmV3bHkgZXF1YWwgdG8gSEFWRV9FTk9VR0hfREFUQSAoNClcbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA+PSA0KSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnY2FucGxheXRocm91Z2gnKTtcbiAgICB9XG5cbiAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIGdpdmUgdGhlIHBsYXllciB0aW1lIHRvIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0eXBlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIEh0bWw1LnByb3RvdHlwZS5wcm94eU5hdGl2ZVRleHRUcmFja3NfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUZXh0VHJhY2tzXygpIHtcbiAgICB2YXIgdHQgPSB0aGlzLmVsKCkudGV4dFRyYWNrcztcblxuICAgIGlmICh0dCkge1xuICAgICAgLy8gQWRkIHRyYWNrcyAtIGlmIHBsYXllciBpcyBpbml0aWFsaXNlZCBhZnRlciBET00gbG9hZGVkLCB0ZXh0VHJhY2tzXG4gICAgICAvLyB3aWxsIG5vdCB0cmlnZ2VyIGFkZHRyYWNrXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudGV4dFRyYWNrcygpLmFkZFRyYWNrXyh0dFtpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0dC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHR0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuaGFuZGxlVGV4dFRyYWNrQ2hhbmdlXyk7XG4gICAgICAgIHR0LmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGhpcy5oYW5kbGVUZXh0VHJhY2tBZGRfKTtcbiAgICAgICAgdHQuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0aGlzLmhhbmRsZVRleHRUcmFja1JlbW92ZV8pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgKG5hdGl2ZSkgdGV4dHRyYWNrcyB0aGF0IGFyZSBub3QgdXNlZCBhbnltb3JlXG4gICAgICB0aGlzLm9uKCdsb2Fkc3RhcnQnLCB0aGlzLnJlbW92ZU9sZFRleHRUcmFja3NfKTtcbiAgICB9XG4gIH07XG5cbiAgSHRtbDUucHJvdG90eXBlLmhhbmRsZVRleHRUcmFja0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRleHRUcmFja0NoYW5nZShlKSB7XG4gICAgdmFyIHR0ID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdGhpcy50ZXh0VHJhY2tzKCkudHJpZ2dlcih7XG4gICAgICB0eXBlOiAnY2hhbmdlJyxcbiAgICAgIHRhcmdldDogdHQsXG4gICAgICBjdXJyZW50VGFyZ2V0OiB0dCxcbiAgICAgIHNyY0VsZW1lbnQ6IHR0XG4gICAgfSk7XG4gIH07XG5cbiAgSHRtbDUucHJvdG90eXBlLmhhbmRsZVRleHRUcmFja0FkZCA9IGZ1bmN0aW9uIGhhbmRsZVRleHRUcmFja0FkZChlKSB7XG4gICAgdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2tfKGUudHJhY2spO1xuICB9O1xuXG4gIEh0bWw1LnByb3RvdHlwZS5oYW5kbGVUZXh0VHJhY2tSZW1vdmUgPSBmdW5jdGlvbiBoYW5kbGVUZXh0VHJhY2tSZW1vdmUoZSkge1xuICAgIHRoaXMudGV4dFRyYWNrcygpLnJlbW92ZVRyYWNrXyhlLnRyYWNrKTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlVmlkZW9UcmFja0NoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVWaWRlb1RyYWNrQ2hhbmdlXyhlKSB7XG4gICAgdmFyIHZ0ID0gdGhpcy52aWRlb1RyYWNrcygpO1xuICAgIHRoaXMudmlkZW9UcmFja3MoKS50cmlnZ2VyKHtcbiAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgdGFyZ2V0OiB2dCxcbiAgICAgIGN1cnJlbnRUYXJnZXQ6IHZ0LFxuICAgICAgc3JjRWxlbWVudDogdnRcbiAgICB9KTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlVmlkZW9UcmFja0FkZF8gPSBmdW5jdGlvbiBoYW5kbGVWaWRlb1RyYWNrQWRkXyhlKSB7XG4gICAgdGhpcy52aWRlb1RyYWNrcygpLmFkZFRyYWNrXyhlLnRyYWNrKTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlVmlkZW9UcmFja1JlbW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVWaWRlb1RyYWNrUmVtb3ZlXyhlKSB7XG4gICAgdGhpcy52aWRlb1RyYWNrcygpLnJlbW92ZVRyYWNrXyhlLnRyYWNrKTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlQXVkaW9UcmFja0NoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVBdWRpb1RyYWNrQ2hhbmdlXyhlKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tMaXN0ID0gdGhpcy5hdWRpb1RyYWNrcygpO1xuICAgIHRoaXMuYXVkaW9UcmFja3MoKS50cmlnZ2VyKHtcbiAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgdGFyZ2V0OiBhdWRpb1RyYWNrTGlzdCxcbiAgICAgIGN1cnJlbnRUYXJnZXQ6IGF1ZGlvVHJhY2tMaXN0LFxuICAgICAgc3JjRWxlbWVudDogYXVkaW9UcmFja0xpc3RcbiAgICB9KTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlQXVkaW9UcmFja0FkZF8gPSBmdW5jdGlvbiBoYW5kbGVBdWRpb1RyYWNrQWRkXyhlKSB7XG4gICAgdGhpcy5hdWRpb1RyYWNrcygpLmFkZFRyYWNrXyhlLnRyYWNrKTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlQXVkaW9UcmFja1JlbW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVBdWRpb1RyYWNrUmVtb3ZlXyhlKSB7XG4gICAgdGhpcy5hdWRpb1RyYWNrcygpLnJlbW92ZVRyYWNrXyhlLnRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgaW4gcmVtb3ZlT2xkVGV4dFRyYWNrc18sIHJlbW92ZU9sZEF1ZGlvVHJhY2tzXyBhbmRcbiAgICogcmVtb3ZlT2xkVmlkZW9UcmFja3NfXG4gICAqIEBwYXJhbSB7VHJhY2tbXX0gdGVjaFRyYWNrcyBUcmFja3MgZm9yIHRoaXMgdGVjaFxuICAgKiBAcGFyYW0ge1RyYWNrW119IGVsVHJhY2tzIFRyYWNrcyBmb3IgdGhlIEhUTUw1IHZpZGVvIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlbW92ZU9sZFRyYWNrc18gPSBmdW5jdGlvbiByZW1vdmVPbGRUcmFja3NfKHRlY2hUcmFja3MsIGVsVHJhY2tzKSB7XG4gICAgLy8gVGhpcyB3aWxsIGxvb3Agb3ZlciB0aGUgdGVjaFRyYWNrcyBhbmQgY2hlY2sgaWYgdGhleSBhcmUgc3RpbGwgdXNlZCBieSB0aGUgSFRNTDUgdmlkZW8gZWxlbWVudFxuICAgIC8vIElmIG5vdCwgdGhleSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZW11bGF0ZWQgbGlzdFxuICAgIHZhciByZW1vdmVUcmFja3MgPSBbXTtcbiAgICBpZiAoIWVsVHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWNoVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGVjaFRyYWNrID0gdGVjaFRyYWNrc1tpXTtcblxuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsVHJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChlbFRyYWNrc1tqXSA9PT0gdGVjaFRyYWNrKSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgcmVtb3ZlVHJhY2tzLnB1c2godGVjaFRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZVRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF90cmFjayA9IHJlbW92ZVRyYWNrc1tpXTtcbiAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2tfKF90cmFjayk7XG4gICAgfVxuICB9O1xuXG4gIEh0bWw1LnByb3RvdHlwZS5yZW1vdmVPbGRUZXh0VHJhY2tzXyA9IGZ1bmN0aW9uIHJlbW92ZU9sZFRleHRUcmFja3NfKCkge1xuICAgIHZhciB0ZWNoVHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGVsVHJhY2tzID0gdGhpcy5lbCgpLnRleHRUcmFja3M7XG4gICAgdGhpcy5yZW1vdmVPbGRUcmFja3NfKHRlY2hUcmFja3MsIGVsVHJhY2tzKTtcbiAgfTtcblxuICBIdG1sNS5wcm90b3R5cGUucmVtb3ZlT2xkQXVkaW9UcmFja3NfID0gZnVuY3Rpb24gcmVtb3ZlT2xkQXVkaW9UcmFja3NfKCkge1xuICAgIHZhciB0ZWNoVHJhY2tzID0gdGhpcy5hdWRpb1RyYWNrcygpO1xuICAgIHZhciBlbFRyYWNrcyA9IHRoaXMuZWwoKS5hdWRpb1RyYWNrcztcbiAgICB0aGlzLnJlbW92ZU9sZFRyYWNrc18odGVjaFRyYWNrcywgZWxUcmFja3MpO1xuICB9O1xuXG4gIEh0bWw1LnByb3RvdHlwZS5yZW1vdmVPbGRWaWRlb1RyYWNrc18gPSBmdW5jdGlvbiByZW1vdmVPbGRWaWRlb1RyYWNrc18oKSB7XG4gICAgdmFyIHRlY2hUcmFja3MgPSB0aGlzLnZpZGVvVHJhY2tzKCk7XG4gICAgdmFyIGVsVHJhY2tzID0gdGhpcy5lbCgpLnZpZGVvVHJhY2tzO1xuICAgIHRoaXMucmVtb3ZlT2xkVHJhY2tzXyh0ZWNoVHJhY2tzLCBlbFRyYWNrcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBsYXkgZm9yIGh0bWw1IHRlY2hcbiAgICpcbiAgICogQG1ldGhvZCBwbGF5XG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcbiAgICB2YXIgcGxheVByb21pc2UgPSB0aGlzLmVsXy5wbGF5KCk7XG5cbiAgICAvLyBDYXRjaC9zaWxlbmNlIGVycm9yIHdoZW4gYSBwYXVzZSBpbnRlcnJ1cHRzIGEgcGxheSByZXF1ZXN0XG4gICAgLy8gb24gYnJvd3NlcnMgd2hpY2ggcmV0dXJuIGEgcHJvbWlzZVxuICAgIGlmIChwbGF5UHJvbWlzZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwbGF5UHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbGF5UHJvbWlzZS50aGVuKG51bGwsIGZ1bmN0aW9uIChlKSB7fSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXVzZSBmb3IgaHRtbDUgdGVjaFxuICAgKlxuICAgKiBAbWV0aG9kIHBhdXNlXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMuZWxfLnBhdXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlZCBmb3IgaHRtbDUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAbWV0aG9kIHBhdXNlZFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5wYXVzZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRpbWVcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIGN1cnJlbnRUaW1lXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uIGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5jdXJyZW50VGltZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyBDdXJyZW50IHRpbWUgb2YgdmlkZW9cbiAgICogQG1ldGhvZCBzZXRDdXJyZW50VGltZVxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiBzZXRDdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZWxfLmN1cnJlbnRUaW1lID0gc2Vjb25kcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXShlLCAnVmlkZW8gaXMgbm90IHJlYWR5LiAoVmlkZW8uanMpJyk7XG4gICAgICAvLyB0aGlzLndhcm5pbmcoVmlkZW9KUy53YXJuaW5ncy52aWRlb05vdFJlYWR5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBkdXJhdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBtZXRob2QgZHVyYXRpb25cbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLmR1cmF0aW9uIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRpbWVSYW5nZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBpbnRlcnNlY3Rpb25cbiAgICogb2YgdGhlIHRpbWUgcmFuZ2VzIGZvciB3aGljaCB0aGUgdXNlciBhZ2VudCBoYXMgYWxsXG4gICAqIHJlbGV2YW50IG1lZGlhXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZU9iamVjdH1cbiAgICogQG1ldGhvZCBidWZmZXJlZFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8uYnVmZmVyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2b2x1bWUgbGV2ZWxcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIHZvbHVtZVxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy52b2x1bWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB2b2x1bWUgbGV2ZWxcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBlcmNlbnRBc0RlY2ltYWwgVm9sdW1lIHBlcmNlbnQgYXMgYSBkZWNpbWFsXG4gICAqIEBtZXRob2Qgc2V0Vm9sdW1lXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiBzZXRWb2x1bWUocGVyY2VudEFzRGVjaW1hbCkge1xuICAgIHRoaXMuZWxfLnZvbHVtZSA9IHBlcmNlbnRBc0RlY2ltYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpZiBtdXRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAbWV0aG9kIG11dGVkXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uIG11dGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5tdXRlZDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG11dGVkXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gSWYgcGxheWVyIGlzIHRvIGJlIG11dGVkIG9yIG5vdGVcbiAgICogQG1ldGhvZCBzZXRNdXRlZFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0TXV0ZWQgPSBmdW5jdGlvbiBzZXRNdXRlZChtdXRlZCkge1xuICAgIHRoaXMuZWxfLm11dGVkID0gbXV0ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwbGF5ZXIgd2lkdGhcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIHdpZHRoXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBsYXllciBoZWlnaHRcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIGhlaWdodFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpZiB0aGVyZSBpcyBmdWxsc2NyZWVuIHN1cHBvcnRcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQG1ldGhvZCBzdXBwb3J0c0Z1bGxTY3JlZW5cbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnN1cHBvcnRzRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWxfLndlYmtpdEVudGVyRnVsbFNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHVzZXJBZ2VudCA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgIC8vIFNlZW1zIHRvIGJlIGJyb2tlbiBpbiBDaHJvbWl1bS9DaHJvbWUgJiYgU2FmYXJpIGluIExlb3BhcmRcbiAgICAgIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpIHx8ICEvQ2hyb21lfE1hYyBPUyBYIDEwLjUvLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGVudGVyIGZ1bGxzY3JlZW5cbiAgICpcbiAgICogQG1ldGhvZCBlbnRlckZ1bGxTY3JlZW5cbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmVudGVyRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLmVsXztcblxuICAgIGlmICgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHZpZGVvKSB7XG4gICAgICB0aGlzLm9uZSgnd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uZSgnd2Via2l0ZW5kZnVsbHNjcmVlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB7IGlzRnVsbHNjcmVlbjogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiB0cnVlIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvLnBhdXNlZCAmJiB2aWRlby5uZXR3b3JrU3RhdGUgPD0gdmlkZW8uSEFWRV9NRVRBREFUQSkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBwcmltZSB0aGUgdmlkZW8gZWxlbWVudCBmb3IgcHJvZ3JhbW1hdGljIGFjY2Vzc1xuICAgICAgLy8gdGhpcyBpc24ndCBuZWNlc3Nhcnkgb24gdGhlIGRlc2t0b3AgYnV0IHNob3VsZG4ndCBodXJ0XG4gICAgICB0aGlzLmVsXy5wbGF5KCk7XG5cbiAgICAgIC8vIHBsYXlpbmcgYW5kIHBhdXNpbmcgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIHRyYW5zaXRpb24gdG8gZnVsbHNjcmVlblxuICAgICAgLy8gY2FuIGdldCBpT1MgfjYuMSBkZXZpY2VzIGludG8gYSBwbGF5L3BhdXNlIGxvb3BcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0byBleGl0IGZ1bGxzY3JlZW5cbiAgICpcbiAgICogQG1ldGhvZCBleGl0RnVsbFNjcmVlblxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbFNjcmVlbigpIHtcbiAgICB0aGlzLmVsXy53ZWJraXRFeGl0RnVsbFNjcmVlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHZpZGVvXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gc3JjIFNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAbWV0aG9kIHNyY1xuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKF9zcmMpIHtcbiAgICBpZiAoX3NyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbF8uc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIGluc3RlYWQgb2YgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgICB0aGlzLnNldFNyYyhfc3JjKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB2aWRlb1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIFNvdXJjZSBvYmplY3RcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG1ldGhvZCBzZXRTcmNcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uIHNldFNyYyhzcmMpIHtcbiAgICB0aGlzLmVsXy5zcmMgPSBzcmM7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgbWVkaWEgaW50byBwbGF5ZXJcbiAgICpcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCgpIHtcbiAgICB0aGlzLmVsXy5sb2FkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0ZWNoLiBSZW1vdmVzIGFsbCBzb3VyY2VzIGFuZCBjYWxscyBgbG9hZGAuXG4gICAqXG4gICAqIEBtZXRob2QgcmVzZXRcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBzb3VyY2VcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAbWV0aG9kIGN1cnJlbnRTcmNcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlXy5zcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy5jdXJyZW50U3JjO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBvc3RlclxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBtZXRob2QgcG9zdGVyXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5wb3N0ZXIgPSBmdW5jdGlvbiBwb3N0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLnBvc3RlcjtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHBvc3RlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFVSTCB0byBwb3N0ZXIgaW1hZ2VcbiAgICogQG1ldGhvZFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0UG9zdGVyID0gZnVuY3Rpb24gc2V0UG9zdGVyKHZhbCkge1xuICAgIHRoaXMuZWxfLnBvc3RlciA9IHZhbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHByZWxvYWQgYXR0cmlidXRlXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQG1ldGhvZCBwcmVsb2FkXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8ucHJlbG9hZDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHByZWxvYWQgYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVmFsdWUgZm9yIHByZWxvYWQgYXR0cmlidXRlXG4gICAqIEBtZXRob2Qgc2V0UHJlbG9hZFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0UHJlbG9hZCA9IGZ1bmN0aW9uIHNldFByZWxvYWQodmFsKSB7XG4gICAgdGhpcy5lbF8ucHJlbG9hZCA9IHZhbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGF1dG9wbGF5IGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBtZXRob2QgYXV0b3BsYXlcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmF1dG9wbGF5ID0gZnVuY3Rpb24gYXV0b3BsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLmF1dG9wbGF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYXV0b3BsYXkgYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVmFsdWUgZm9yIHByZWxvYWQgYXR0cmlidXRlXG4gICAqIEBtZXRob2Qgc2V0QXV0b3BsYXlcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldEF1dG9wbGF5ID0gZnVuY3Rpb24gc2V0QXV0b3BsYXkodmFsKSB7XG4gICAgdGhpcy5lbF8uYXV0b3BsYXkgPSB2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjb250cm9scyBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAbWV0aG9kIGNvbnRyb2xzXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5jb250cm9scztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNvbnRyb2xzIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFZhbHVlIGZvciBjb250cm9scyBhdHRyaWJ1dGVcbiAgICogQG1ldGhvZCBzZXRDb250cm9sc1xuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q29udHJvbHMgPSBmdW5jdGlvbiBzZXRDb250cm9scyh2YWwpIHtcbiAgICB0aGlzLmVsXy5jb250cm9scyA9ICEhdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgbG9vcCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAbWV0aG9kIGxvb3BcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiBsb29wKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5sb29wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgbG9vcCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBWYWx1ZSBmb3IgbG9vcCBhdHRyaWJ1dGVcbiAgICogQG1ldGhvZCBzZXRMb29wXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gc2V0TG9vcCh2YWwpIHtcbiAgICB0aGlzLmVsXy5sb29wID0gdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZXJyb3IgdmFsdWVcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAbWV0aG9kIGVycm9yXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5lcnJvcjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwic2Vla2luZ1wiIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBtZXRob2Qgc2Vla2luZ1xuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUuc2Vla2luZyA9IGZ1bmN0aW9uIHNlZWtpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLnNlZWtpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRpbWVSYW5nZXMgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgICogcmFuZ2VzIG9mIHRoZSBtZWRpYSByZXNvdXJjZSB0byB3aGljaCBpdCBpcyBwb3NzaWJsZVxuICAgKiBmb3IgdGhlIHVzZXIgYWdlbnQgdG8gc2Vlay5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlT2JqZWN0fVxuICAgKiBAbWV0aG9kIHNlZWthYmxlXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5zZWVrYWJsZSA9IGZ1bmN0aW9uIHNlZWthYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5zZWVrYWJsZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGlmIHZpZGVvIGVuZGVkXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBtZXRob2QgZW5kZWRcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmVuZGVkID0gZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLmVuZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBtdXRlZCBjb250ZW50IGF0dHJpYnV0ZVxuICAgKiBUaGlzIGF0dHJpYnV0ZSBoYXMgbm8gZHluYW1pYyBlZmZlY3QsIGl0IG9ubHlcbiAgICogY29udHJvbHMgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQG1ldGhvZCBkZWZhdWx0TXV0ZWRcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmRlZmF1bHRNdXRlZCA9IGZ1bmN0aW9uIGRlZmF1bHRNdXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8uZGVmYXVsdE11dGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZGVzaXJlZCBzcGVlZCBhdCB3aGljaCB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgdG8gcGxheVxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBtZXRob2QgcGxheWJhY2tSYXRlXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5wbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLnBsYXliYWNrUmF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIFRpbWVSYW5nZXMgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmFuZ2VzIG9mIHRoZVxuICAgKiBtZWRpYSByZXNvdXJjZSB0aGF0IHRoZSB1c2VyIGFnZW50IGhhcyBwbGF5ZWQuXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZU9iamVjdH0gdGhlIHJhbmdlIG9mIHBvaW50cyBvbiB0aGUgbWVkaWFcbiAgICogdGltZWxpbmUgdGhhdCBoYXMgYmVlbiByZWFjaGVkIHRocm91Z2ggbm9ybWFsIHBsYXliYWNrXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5ZWRcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnBsYXllZCA9IGZ1bmN0aW9uIHBsYXllZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8ucGxheWVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZGVzaXJlZCBzcGVlZCBhdCB3aGljaCB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgdG8gcGxheVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIFNwZWVkIGF0IHdoaWNoIHRoZSBtZWRpYSByZXNvdXJjZSBpcyB0byBwbGF5XG4gICAqIEBtZXRob2Qgc2V0UGxheWJhY2tSYXRlXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBzZXRQbGF5YmFja1JhdGUodmFsKSB7XG4gICAgdGhpcy5lbF8ucGxheWJhY2tSYXRlID0gdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgbmV0d29yayBhY3Rpdml0eSBmb3IgdGhlIGVsZW1lbnQsIGZyb21cbiAgICogdGhlIGxpc3QgYmVsb3dcbiAgICogTkVUV09SS19FTVBUWSAobnVtZXJpYyB2YWx1ZSAwKVxuICAgKiBORVRXT1JLX0lETEUgKG51bWVyaWMgdmFsdWUgMSlcbiAgICogTkVUV09SS19MT0FESU5HIChudW1lcmljIHZhbHVlIDIpXG4gICAqIE5FVFdPUktfTk9fU09VUkNFIChudW1lcmljIHZhbHVlIDMpXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQG1ldGhvZCBuZXR3b3JrU3RhdGVcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLm5ldHdvcmtTdGF0ZSA9IGZ1bmN0aW9uIG5ldHdvcmtTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8ubmV0d29ya1N0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSB0aGF0IGV4cHJlc3NlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICAgKiB3aXRoIHJlc3BlY3QgdG8gcmVuZGVyaW5nIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uLCBmcm9tXG4gICAqIHRoZSBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvd1xuICAgKiBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMClcbiAgICogSEFWRV9NRVRBREFUQSAobnVtZXJpYyB2YWx1ZSAxKVxuICAgKiBIQVZFX0NVUlJFTlRfREFUQSAobnVtZXJpYyB2YWx1ZSAyKVxuICAgKiBIQVZFX0ZVVFVSRV9EQVRBIChudW1lcmljIHZhbHVlIDMpXG4gICAqIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIHJlYWR5U3RhdGVcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlYWR5U3RhdGUgPSBmdW5jdGlvbiByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5yZWFkeVN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2lkdGggb2YgdmlkZW9cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIHZpZGVvV2lkdGhcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnZpZGVvV2lkdGggPSBmdW5jdGlvbiB2aWRlb1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy52aWRlb1dpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaGVpZ2h0IG9mIHZpZGVvXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQG1ldGhvZCB2aWRlb0hlaWdodFxuICAgKi9cblxuICBIdG1sNS5wcm90b3R5cGUudmlkZW9IZWlnaHQgPSBmdW5jdGlvbiB2aWRlb0hlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8udmlkZW9IZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0ZXh0IHRyYWNrc1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tMaXN0fVxuICAgKiBAbWV0aG9kIHRleHRUcmFja3NcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnRleHRUcmFja3MgPSBmdW5jdGlvbiB0ZXh0VHJhY2tzKCkge1xuICAgIHJldHVybiBfVGVjaC5wcm90b3R5cGUudGV4dFRyYWNrcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdGV4dCB0cmFjayBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtpbmQgVGV4dCB0cmFjayBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFwdGVycyBhbmQgbWV0YWRhdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbGFiZWwgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBsYW5ndWFnZSBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tPYmplY3R9XG4gICAqIEBtZXRob2QgYWRkVGV4dFRyYWNrXG4gICAqL1xuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCF0aGlzWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2suY2FsbCh0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlbW90ZSB0ZXh0IHRyYWNrIG9iamVjdCBhbmQgcmV0dXJucyBhIGh0bWwgdHJhY2sgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHZhbHVlcyBmb3JcbiAgICoga2luZCwgbGFuZ3VhZ2UsIGxhYmVsIGFuZCBzcmMgKGxvY2F0aW9uIG9mIHRoZSBXZWJWVFQgZmlsZSlcbiAgICogQHJldHVybiB7SFRNTFRyYWNrRWxlbWVudH1cbiAgICogQG1ldGhvZCBhZGRSZW1vdGVUZXh0VHJhY2tcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgaWYgKCF0aGlzWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbFRyYWNrRWxlbWVudCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gICAgaWYgKG9wdGlvbnMua2luZCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5raW5kID0gb3B0aW9ucy5raW5kO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZykge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5zcmNsYW5nID0gb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0J10pIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnRbJ2RlZmF1bHQnXSA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjID0gb3B0aW9ucy5zcmM7XG4gICAgfVxuXG4gICAgdGhpcy5lbCgpLmFwcGVuZENoaWxkKGh0bWxUcmFja0VsZW1lbnQpO1xuXG4gICAgLy8gc3RvcmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIHRvIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5hZGRUcmFja0VsZW1lbnRfKGh0bWxUcmFja0VsZW1lbnQpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrXyhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgcmVtb3RlIHRleHQgdHJhY2sgZnJvbSBUZXh0VHJhY2tMaXN0IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja09iamVjdH0gdHJhY2sgVGV4dHRyYWNrIG9iamVjdCB0byByZW1vdmVcbiAgICogQG1ldGhvZCByZW1vdmVSZW1vdGVUZXh0VHJhY2tcbiAgICovXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpc1snZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgIHJldHVybiBfVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MgPSB1bmRlZmluZWQsXG4gICAgICAgIGkgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgdHJhY2tFbGVtZW50ID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0cmFjayk7XG5cbiAgICAvLyByZW1vdmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIGZyb20gcmVtb3RlIGxpc3RcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLnJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFja18odHJhY2spO1xuXG4gICAgdHJhY2tzID0gdGhpcy4kJCgndHJhY2snKTtcblxuICAgIGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0cmFjayA9PT0gdHJhY2tzW2ldIHx8IHRyYWNrID09PSB0cmFja3NbaV0udHJhY2spIHtcbiAgICAgICAgdGhpcy5lbCgpLnJlbW92ZUNoaWxkKHRyYWNrc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBIdG1sNTtcbn0pKF90ZWNoSnMyWydkZWZhdWx0J10pO1xuXG5IdG1sNS5URVNUX1ZJRCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xudmFyIHRyYWNrID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG50cmFjay5raW5kID0gJ2NhcHRpb25zJztcbnRyYWNrLnNyY2xhbmcgPSAnZW4nO1xudHJhY2subGFiZWwgPSAnRW5nbGlzaCc7XG5IdG1sNS5URVNUX1ZJRC5hcHBlbmRDaGlsZCh0cmFjayk7XG5cbi8qXG4gKiBDaGVjayBpZiBIVE1MNSB2aWRlbyBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkh0bWw1LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAvLyBJRTkgd2l0aCBubyBNZWRpYSBQbGF5ZXIgaXMgYSBMSUFSISAoIzk4NClcbiAgdHJ5IHtcbiAgICBIdG1sNS5URVNUX1ZJRFsndm9sdW1lJ10gPSAwLjU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZTtcbn07XG5cbi8vIEFkZCBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuIGZ1bmN0aW9ucyB0byB0aGlzIHRlY2hcbl90ZWNoSnMyWydkZWZhdWx0J10ud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcblxuLypcbiAqIFRoZSBkZWZhdWx0IG5hdGl2ZSBzb3VyY2UgaGFuZGxlci5cbiAqIFRoaXMgc2ltcGx5IHBhc3NlcyB0aGUgc291cmNlIHRvIHRoZSB2aWRlbyBlbGVtZW50LiBOb3RoaW5nIGZhbmN5LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge0h0bWw1fSB0ZWNoICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEhUTUw1IHRlY2hcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xuXG4vKlxuICogQ2hlY2sgaWYgdGhlIHZpZGVvIGVsZW1lbnQgY2FuIHBsYXkgdGhlIGdpdmVuIHZpZGVvdHlwZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgLy8gSUU5IG9uIFdpbmRvd3MgNyB3aXRob3V0IE1lZGlhUGxheWVyIHRocm93cyBhbiBlcnJvciBoZXJlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy81MTlcbiAgdHJ5IHtcbiAgICByZXR1cm4gSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUodHlwZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8qXG4gKiBDaGVjayBpZiB0aGUgdmlkZW8gZWxlbWVudCBjYW4gaGFuZGxlIHRoZSBzb3VyY2UgbmF0aXZlbHlcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1hdGNoLCBleHQ7XG5cbiAgLy8gSWYgYSB0eXBlIHdhcyBwcm92aWRlZCB3ZSBzaG91bGQgcmVseSBvbiB0aGF0XG4gIGlmIChzb3VyY2UudHlwZSkge1xuICAgIHJldHVybiBIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKHNvdXJjZS50eXBlKTtcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgICBleHQgPSBVcmwuZ2V0RmlsZUV4dGVuc2lvbihzb3VyY2Uuc3JjKTtcblxuICAgIHJldHVybiBIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKCd2aWRlby8nICsgZXh0KTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qXG4gKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIHZpZGVvIGVsZW1lbnRcbiAqIEFkYXB0aXZlIHNvdXJjZSBoYW5kbGVycyB3aWxsIGhhdmUgbW9yZSBjb21wbGljYXRlZCB3b3JrZmxvd3MgYmVmb3JlIHBhc3NpbmdcbiAqIHZpZGVvIGRhdGEgdG8gdGhlIHZpZGVvIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNvdXJjZSAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gIHtIdG1sNX0gIHRlY2ggICAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgSHRtbDUgdGVjaFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2VcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5oYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCB0ZWNoLCBvcHRpb25zKSB7XG4gIHRlY2guc2V0U3JjKHNvdXJjZS5zcmMpO1xufTtcblxuLypcbiogQ2xlYW4gdXAgdGhlIHNvdXJjZSBoYW5kbGVyIHdoZW4gZGlzcG9zaW5nIHRoZSBwbGF5ZXIgb3Igc3dpdGNoaW5nIHNvdXJjZXMuLlxuKiAobm8gY2xlYW51cCBpcyBuZWVkZWQgd2hlbiBzdXBwb3J0aW5nIHRoZSBmb3JtYXQgbmF0aXZlbHkpXG4qL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFJlZ2lzdGVyIHRoZSBuYXRpdmUgc291cmNlIGhhbmRsZXJcbkh0bWw1LnJlZ2lzdGVyU291cmNlSGFuZGxlcihIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyKTtcblxuLypcbiAqIENoZWNrIGlmIHRoZSB2b2x1bWUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqIFZvbHVtZSBjYW5ub3QgYmUgY2hhbmdlZCBpbiBhIGxvdCBvZiBtb2JpbGUgZGV2aWNlcy5cbiAqIFNwZWNpZmljYWxseSwgaXQgY2FuJ3QgYmUgY2hhbmdlZCBmcm9tIDEgb24gaU9TLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciB2b2x1bWUgPSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG4gICAgSHRtbDUuVEVTVF9WSUQudm9sdW1lID0gdm9sdW1lIC8gMiArIDAuMTtcbiAgICByZXR1cm4gdm9sdW1lICE9PSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qXG4gKiBDaGVjayBpZiBwbGF5YmFja1JhdGUgaXMgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUGxheWJhY2sgcmF0ZSBBUEkgaXMgaW1wbGVtZW50ZWQgaW4gQW5kcm9pZCBDaHJvbWUsIGJ1dCBkb2Vzbid0IGRvIGFueXRoaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8zMTgwXG4gIGlmIChicm93c2VyLklTX0FORFJPSUQgJiYgYnJvd3Nlci5JU19DSFJPTUUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XG4gIHRyeSB7XG4gICAgdmFyIHBsYXliYWNrUmF0ZSA9IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbiAgICBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGUgLyAyICsgMC4xO1xuICAgIHJldHVybiBwbGF5YmFja1JhdGUgIT09IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLypcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgdGV4dCB0cmFja3MgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydHNUZXh0VHJhY2tzO1xuXG4gIC8vIEZpZ3VyZSBvdXQgbmF0aXZlIHRleHQgdHJhY2sgc3VwcG9ydFxuICAvLyBJZiBtb2RlIGlzIGEgbnVtYmVyLCB3ZSBjYW5ub3QgY2hhbmdlIGl0IGJlY2F1c2UgaXQnbGwgZGlzYXBwZWFyIGZyb20gdmlldy5cbiAgLy8gQnJvd3NlcnMgd2l0aCBudW1lcmljIG1vZGVzIGluY2x1ZGUgSUUxMCBhbmQgb2xkZXIgKDw9MjAxMykgc2Ftc3VuZyBhbmRyb2lkIG1vZGVscy5cbiAgLy8gRmlyZWZveCBpc24ndCBwbGF5aW5nIG5pY2UgZWl0aGVyIHdpdGggbW9kaWZ5aW5nIHRoZSBtb2RlXG4gIC8vIFRPRE86IEludmVzdGlnYXRlIGZpcmVmb3g6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8xODYyXG4gIHN1cHBvcnRzVGV4dFRyYWNrcyA9ICEhSHRtbDUuVEVTVF9WSUQudGV4dFRyYWNrcztcbiAgaWYgKHN1cHBvcnRzVGV4dFRyYWNrcyAmJiBIdG1sNS5URVNUX1ZJRC50ZXh0VHJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICBzdXBwb3J0c1RleHRUcmFja3MgPSB0eXBlb2YgSHRtbDUuVEVTVF9WSUQudGV4dFRyYWNrc1swXVsnbW9kZSddICE9PSAnbnVtYmVyJztcbiAgfVxuICBpZiAoc3VwcG9ydHNUZXh0VHJhY2tzICYmIGJyb3dzZXIuSVNfRklSRUZPWCkge1xuICAgIHN1cHBvcnRzVGV4dFRyYWNrcyA9IGZhbHNlO1xuICB9XG4gIGlmIChzdXBwb3J0c1RleHRUcmFja3MgJiYgISgnb25yZW1vdmV0cmFjaycgaW4gSHRtbDUuVEVTVF9WSUQudGV4dFRyYWNrcykpIHtcbiAgICBzdXBwb3J0c1RleHRUcmFja3MgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1RleHRUcmFja3M7XG59O1xuXG4vKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSB2aWRlbyB0cmFja3MgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1cHBvcnRzVmlkZW9UcmFja3MgPSAhIUh0bWw1LlRFU1RfVklELnZpZGVvVHJhY2tzO1xuICByZXR1cm4gc3VwcG9ydHNWaWRlb1RyYWNrcztcbn07XG5cbi8qXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGF1ZGlvIHRyYWNrcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5IdG1sNS5zdXBwb3J0c05hdGl2ZUF1ZGlvVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydHNBdWRpb1RyYWNrcyA9ICEhSHRtbDUuVEVTVF9WSUQuYXVkaW9UcmFja3M7XG4gIHJldHVybiBzdXBwb3J0c0F1ZGlvVHJhY2tzO1xufTtcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBldmVudHMgYXZhaWxhYmxlIG9uIHRoZSBIdG1sNSB0ZWNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbkh0bWw1LkV2ZW50cyA9IFsnbG9hZHN0YXJ0JywgJ3N1c3BlbmQnLCAnYWJvcnQnLCAnZXJyb3InLCAnZW1wdGllZCcsICdzdGFsbGVkJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZGRhdGEnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdwbGF5aW5nJywgJ3dhaXRpbmcnLCAnc2Vla2luZycsICdzZWVrZWQnLCAnZW5kZWQnLCAnZHVyYXRpb25jaGFuZ2UnLCAndGltZXVwZGF0ZScsICdwcm9ncmVzcycsICdwbGF5JywgJ3BhdXNlJywgJ3JhdGVjaGFuZ2UnLCAndm9sdW1lY2hhbmdlJ107XG5cbi8qXG4gKiBTZXQgdGhlIHRlY2gncyB2b2x1bWUgY29udHJvbCBzdXBwb3J0IHN0YXR1c1xuICpcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzVm9sdW1lQ29udHJvbCddID0gSHRtbDUuY2FuQ29udHJvbFZvbHVtZSgpO1xuXG4vKlxuICogU2V0IHRoZSB0ZWNoJ3MgcGxheWJhY2tSYXRlIHN1cHBvcnQgc3RhdHVzXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNQbGF5YmFja1JhdGUnXSA9IEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUoKTtcblxuLypcbiAqIFNldCB0aGUgdGVjaCdzIHN0YXR1cyBvbiBtb3ZpbmcgdGhlIHZpZGVvIGVsZW1lbnQuXG4gKiBJbiBpT1MsIGlmIHlvdSBtb3ZlIGEgdmlkZW8gZWxlbWVudCBpbiB0aGUgRE9NLCBpdCBicmVha3MgdmlkZW8gcGxheWJhY2suXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnbW92aW5nTWVkaWFFbGVtZW50SW5ET00nXSA9ICFicm93c2VyLklTX0lPUztcblxuLypcbiAqIFNldCB0aGUgdGhlIHRlY2gncyBmdWxsc2NyZWVuIHJlc2l6ZSBzdXBwb3J0IHN0YXR1cy5cbiAqIEhUTUwgdmlkZW8gaXMgYWJsZSB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB3aGVuIGdvaW5nIHRvIGZ1bGxzY3JlZW4uXG4gKiAoTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuKVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSddID0gdHJ1ZTtcblxuLypcbiAqIFNldCB0aGUgdGVjaCdzIHByb2dyZXNzIGV2ZW50IHN1cHBvcnQgc3RhdHVzXG4gKiAodGhpcyBkaXNhYmxlcyB0aGUgbWFudWFsIHByb2dyZXNzIGV2ZW50cyBvZiB0aGUgVGVjaClcbiAqL1xuSHRtbDUucHJvdG90eXBlWydmZWF0dXJlc1Byb2dyZXNzRXZlbnRzJ10gPSB0cnVlO1xuXG4vKlxuICogU2V0cyB0aGUgdGVjaCdzIHN0YXR1cyBvbiBuYXRpdmUgdGV4dCB0cmFjayBzdXBwb3J0XG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkh0bWw1LnByb3RvdHlwZVsnZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10gPSBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3MoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0ZWNoJ3Mgc3RhdHVzIG9uIG5hdGl2ZSB0ZXh0IHRyYWNrIHN1cHBvcnRcbiAqXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuSHRtbDUucHJvdG90eXBlWydmZWF0dXJlc05hdGl2ZVZpZGVvVHJhY2tzJ10gPSBIdG1sNS5zdXBwb3J0c05hdGl2ZVZpZGVvVHJhY2tzKCk7XG5cbi8qKlxuICogU2V0cyB0aGUgdGVjaCdzIHN0YXR1cyBvbiBuYXRpdmUgYXVkaW8gdHJhY2sgc3VwcG9ydFxuICpcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5IdG1sNS5wcm90b3R5cGVbJ2ZlYXR1cmVzTmF0aXZlQXVkaW9UcmFja3MnXSA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MoKTtcblxuLy8gSFRNTDUgRmVhdHVyZSBkZXRlY3Rpb24gYW5kIERldmljZSBGaXhlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbnZhciBjYW5QbGF5VHlwZSA9IHVuZGVmaW5lZDtcbnZhciBtcGVndXJsUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86eC18dm5kXFwuYXBwbGVcXC4pbXBlZ3VybC9pO1xudmFyIG1wNFJFID0gL152aWRlb1xcL21wNC9pO1xuXG5IdG1sNS5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24gKCkge1xuICAvLyBBbmRyb2lkIDQuMCBhbmQgYWJvdmUgY2FuIHBsYXkgSExTIHRvIHNvbWUgZXh0ZW50IGJ1dCBpdCByZXBvcnRzIGJlaW5nIHVuYWJsZSB0byBkbyBzb1xuICBpZiAoYnJvd3Nlci5BTkRST0lEX1ZFUlNJT04gPj0gNC4wKSB7XG4gICAgaWYgKCFjYW5QbGF5VHlwZSkge1xuICAgICAgY2FuUGxheVR5cGUgPSBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG4gICAgfVxuXG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIEFuZHJvaWQgMi4yIGFuZCBsZXNzIGNhblBsYXlUeXBlIG1ldGhvZCB3aGljaCBpcyBicm9rZW5cbiAgaWYgKGJyb3dzZXIuSVNfT0xEX0FORFJPSUQpIHtcbiAgICBpZiAoIWNhblBsYXlUeXBlKSB7XG4gICAgICBjYW5QbGF5VHlwZSA9IEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcbiAgICB9XG5cbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgJiYgbXA0UkUudGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ21heWJlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5QbGF5VHlwZS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgIH07XG4gIH1cbn07XG5cbkh0bWw1LnVucGF0Y2hDYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG4gIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGNhblBsYXlUeXBlO1xuICBjYW5QbGF5VHlwZSA9IG51bGw7XG4gIHJldHVybiByO1xufTtcblxuLy8gYnkgZGVmYXVsdCwgcGF0Y2ggdGhlIHZpZGVvIGVsZW1lbnRcbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUoKTtcblxuSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgY2hpbGQgdHJhY2sgb3Igc291cmNlIG5vZGVzIHRvIHByZXZlbnQgdGhlaXIgbG9hZGluZ1xuICB3aGlsZSAoZWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IHNyYyByZWZlcmVuY2UuIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCBjYXVzZXMgYSB3YXJuaW5nXG4gIC8vIGluIGZpcmVmb3hcbiAgZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcblxuICAvLyBmb3JjZSB0aGUgbWVkaWEgZWxlbWVudCB0byB1cGRhdGUgaXRzIGxvYWRpbmcgc3RhdGUgYnkgY2FsbGluZyBsb2FkKClcbiAgLy8gaG93ZXZlciBJRSBvbiBXaW5kb3dzIDdOIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBhbiBlcnJvciBzbyBuZWVkIGEgdHJ5L2NhdGNoICgjNzkzKVxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB3cmFwcGluZyBpbiBhbiBpaWZlIHNvIGl0J3Mgbm90IGRlb3B0aW1pemVkICgjMTA2MCNkaXNjdXNzaW9uX3IxMDMyNDQ3MylcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzb3VyY2VzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnc291cmNlJyk7XG4gIHZhciBpID0gc291cmNlcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbC5yZW1vdmVDaGlsZChzb3VyY2VzW2ldKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS5cbiAgLy8gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IHRocm93cyBhbiBlcnJvclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbl9jb21wb25lbnQyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ0h0bWw1JywgSHRtbDUpO1xuX3RlY2hKczJbJ2RlZmF1bHQnXS5yZWdpc3RlclRlY2goJ0h0bWw1JywgSHRtbDUpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gSHRtbDU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi8uLi8uLi9zcmMvanMvdHJhY2tzL3RleHQtdHJhY2suanNcIjoxMzQsXCIuLi9jb21wb25lbnRcIjo2NyxcIi4uL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuLi91dGlscy9kb20uanNcIjoxNDIsXCIuLi91dGlscy9mbi5qc1wiOjE0NCxcIi4uL3V0aWxzL2xvZy5qc1wiOjE0NyxcIi4uL3V0aWxzL21lcmdlLW9wdGlvbnMuanNcIjoxNDgsXCIuLi91dGlscy90by10aXRsZS1jYXNlLmpzXCI6MTUxLFwiLi4vdXRpbHMvdXJsLmpzXCI6MTUyLFwiLi90ZWNoLmpzXCI6MTI0LFwiZ2xvYmFsL2RvY3VtZW50XCI6MSxcImdsb2JhbC93aW5kb3dcIjoyLFwib2JqZWN0LmFzc2lnblwiOjQ1LFwidHNtbFwiOjU1fV0sMTIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgbG9hZGVyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnRKcyA9IF9kZXJlcV8oJy4uL2NvbXBvbmVudC5qcycpO1xuXG52YXIgX2NvbXBvbmVudEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudEpzKTtcblxudmFyIF90ZWNoSnMgPSBfZGVyZXFfKCcuL3RlY2guanMnKTtcblxudmFyIF90ZWNoSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGVjaEpzKTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfdXRpbHNUb1RpdGxlQ2FzZUpzID0gX2RlcmVxXygnLi4vdXRpbHMvdG8tdGl0bGUtY2FzZS5qcycpO1xuXG52YXIgX3V0aWxzVG9UaXRsZUNhc2VKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc1RvVGl0bGVDYXNlSnMpO1xuXG4vKipcbiAqIFRoZSBNZWRpYSBMb2FkZXIgaXMgdGhlIGNvbXBvbmVudCB0aGF0IGRlY2lkZXMgd2hpY2ggcGxheWJhY2sgdGVjaG5vbG9neSB0byBsb2FkXG4gKiB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXllciAgTWFpbiBQbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgTWVkaWFMb2FkZXJcbiAqL1xuXG52YXIgTWVkaWFMb2FkZXIgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lZGlhTG9hZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZWRpYUxvYWRlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhTG9hZGVyKTtcblxuICAgIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzIHdoZW4gdGhlIHBsYXllciBpcyBpbml0aWFsaXplZCxcbiAgICAvLyBsb2FkIHRoZSBmaXJzdCBzdXBwb3J0ZWQgcGxheWJhY2sgdGVjaG5vbG9neS5cblxuICAgIGlmICghb3B0aW9ucy5wbGF5ZXJPcHRpb25zWydzb3VyY2VzJ10gfHwgb3B0aW9ucy5wbGF5ZXJPcHRpb25zWydzb3VyY2VzJ10ubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG9wdGlvbnMucGxheWVyT3B0aW9uc1sndGVjaE9yZGVyJ107IGkgPCBqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ZWNoTmFtZSA9IF91dGlsc1RvVGl0bGVDYXNlSnMyWydkZWZhdWx0J10oaltpXSk7XG4gICAgICAgIHZhciB0ZWNoID0gX3RlY2hKczJbJ2RlZmF1bHQnXS5nZXRUZWNoKHRlY2hOYW1lKTtcbiAgICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgICAvLyBSZW1vdmUgb25jZSB0aGF0IGRlcHJlY2F0ZWQgYmVoYXZpb3IgaXMgcmVtb3ZlZC5cbiAgICAgICAgaWYgKCF0ZWNoTmFtZSkge1xuICAgICAgICAgIHRlY2ggPSBfY29tcG9uZW50SnMyWydkZWZhdWx0J10uZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGVjaCAmJiB0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICBwbGF5ZXIubG9hZFRlY2hfKHRlY2hOYW1lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAvLyBMb29wIHRocm91Z2ggcGxheWJhY2sgdGVjaG5vbG9naWVzIChIVE1MNSwgRmxhc2gpIGFuZCBjaGVjayBmb3Igc3VwcG9ydC5cbiAgICAgIC8vIC8vIFRoZW4gbG9hZCB0aGUgYmVzdCBzb3VyY2UuXG4gICAgICAvLyAvLyBBIGZldyBhc3N1bXB0aW9ucyBoZXJlOlxuICAgICAgLy8gLy8gICBBbGwgcGxheWJhY2sgdGVjaG5vbG9naWVzIHJlc3BlY3QgcHJlbG9hZCBmYWxzZS5cbiAgICAgIHBsYXllci5zcmMob3B0aW9ucy5wbGF5ZXJPcHRpb25zWydzb3VyY2VzJ10pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNZWRpYUxvYWRlcjtcbn0pKF9jb21wb25lbnRKczJbJ2RlZmF1bHQnXSk7XG5cbl9jb21wb25lbnRKczJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnTWVkaWFMb2FkZXInLCBNZWRpYUxvYWRlcik7XG5leHBvcnRzWydkZWZhdWx0J10gPSBNZWRpYUxvYWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2NvbXBvbmVudC5qc1wiOjY3LFwiLi4vdXRpbHMvdG8tdGl0bGUtY2FzZS5qc1wiOjE1MSxcIi4vdGVjaC5qc1wiOjEyNCxcImdsb2JhbC93aW5kb3dcIjoyfV0sMTI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgdGVjaC5qc1xuICogTWVkaWEgVGVjaG5vbG9neSBDb250cm9sbGVyIC0gQmFzZSBjbGFzcyBmb3IgbWVkaWEgcGxheWJhY2tcbiAqIHRlY2hub2xvZ3kgY29udHJvbGxlcnMgbGlrZSBGbGFzaCBhbmQgSFRNTDVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29tcG9uZW50ID0gX2RlcmVxXygnLi4vY29tcG9uZW50Jyk7XG5cbnZhciBfY29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudCk7XG5cbnZhciBfdHJhY2tzSHRtbFRyYWNrRWxlbWVudCA9IF9kZXJlcV8oJy4uL3RyYWNrcy9odG1sLXRyYWNrLWVsZW1lbnQnKTtcblxudmFyIF90cmFja3NIdG1sVHJhY2tFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYWNrc0h0bWxUcmFja0VsZW1lbnQpO1xuXG52YXIgX3RyYWNrc0h0bWxUcmFja0VsZW1lbnRMaXN0ID0gX2RlcmVxXygnLi4vdHJhY2tzL2h0bWwtdHJhY2stZWxlbWVudC1saXN0Jyk7XG5cbnZhciBfdHJhY2tzSHRtbFRyYWNrRWxlbWVudExpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzSHRtbFRyYWNrRWxlbWVudExpc3QpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zSnMgPSBfZGVyZXFfKCcuLi91dGlscy9tZXJnZS1vcHRpb25zLmpzJyk7XG5cbnZhciBfdXRpbHNNZXJnZU9wdGlvbnNKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc01lcmdlT3B0aW9uc0pzKTtcblxudmFyIF90cmFja3NUZXh0VHJhY2sgPSBfZGVyZXFfKCcuLi90cmFja3MvdGV4dC10cmFjaycpO1xuXG52YXIgX3RyYWNrc1RleHRUcmFjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja3NUZXh0VHJhY2spO1xuXG52YXIgX3RyYWNrc1RleHRUcmFja0xpc3QgPSBfZGVyZXFfKCcuLi90cmFja3MvdGV4dC10cmFjay1saXN0Jyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja3NUZXh0VHJhY2tMaXN0KTtcblxudmFyIF90cmFja3NWaWRlb1RyYWNrID0gX2RlcmVxXygnLi4vdHJhY2tzL3ZpZGVvLXRyYWNrJyk7XG5cbnZhciBfdHJhY2tzVmlkZW9UcmFjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja3NWaWRlb1RyYWNrKTtcblxudmFyIF90cmFja3NWaWRlb1RyYWNrTGlzdCA9IF9kZXJlcV8oJy4uL3RyYWNrcy92aWRlby10cmFjay1saXN0Jyk7XG5cbnZhciBfdHJhY2tzVmlkZW9UcmFja0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzVmlkZW9UcmFja0xpc3QpO1xuXG52YXIgX3RyYWNrc0F1ZGlvVHJhY2tMaXN0ID0gX2RlcmVxXygnLi4vdHJhY2tzL2F1ZGlvLXRyYWNrLWxpc3QnKTtcblxudmFyIF90cmFja3NBdWRpb1RyYWNrTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFja3NBdWRpb1RyYWNrTGlzdCk7XG5cbnZhciBfdHJhY2tzQXVkaW9UcmFjayA9IF9kZXJlcV8oJy4uL3RyYWNrcy9hdWRpby10cmFjaycpO1xuXG52YXIgX3RyYWNrc0F1ZGlvVHJhY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzQXVkaW9UcmFjayk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNMb2dKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2xvZy5qcycpO1xuXG52YXIgX3V0aWxzTG9nSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNMb2dKcyk7XG5cbnZhciBfdXRpbHNUaW1lUmFuZ2VzSnMgPSBfZGVyZXFfKCcuLi91dGlscy90aW1lLXJhbmdlcy5qcycpO1xuXG52YXIgX3V0aWxzQnVmZmVySnMgPSBfZGVyZXFfKCcuLi91dGlscy9idWZmZXIuanMnKTtcblxudmFyIF9tZWRpYUVycm9ySnMgPSBfZGVyZXFfKCcuLi9tZWRpYS1lcnJvci5qcycpO1xuXG52YXIgX21lZGlhRXJyb3JKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZWRpYUVycm9ySnMpO1xuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtZWRpYSAoSFRNTDUgVmlkZW8sIEZsYXNoKSBjb250cm9sbGVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbj19IHJlYWR5IFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBUZWNoXG4gKi9cblxudmFyIFRlY2ggPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRlY2gsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRlY2goKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcmVhZHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZWNoKTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHRlY2ggdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHkgYXV0b21hdGljYWxseS5cbiAgICAvLyBUaGlzIGlzIGRvbmUgbWFudWFsbHkgaW4gYWRkQ29udHJvbHNMaXN0ZW5lcnNcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcbiAgICBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpO1xuXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBjdXJyZW50IHNvdXJjZSBoYXMgcGxheWVkIGF0IGFsbCB0b1xuICAgIC8vIGltcGxlbWVudCBhIHZlcnkgbGltaXRlZCBwbGF5ZWQoKVxuICAgIHRoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm9uKCdwbGF5aW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5vbignbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgdGhpcy50ZXh0VHJhY2tzXyA9IG9wdGlvbnMudGV4dFRyYWNrcztcbiAgICB0aGlzLnZpZGVvVHJhY2tzXyA9IG9wdGlvbnMudmlkZW9UcmFja3M7XG4gICAgdGhpcy5hdWRpb1RyYWNrc18gPSBvcHRpb25zLmF1ZGlvVHJhY2tzO1xuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgcHJvZ3Jlc3MgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghdGhpcy5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzKSB7XG4gICAgICB0aGlzLm1hbnVhbFByb2dyZXNzT24oKTtcbiAgICB9XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayB0aW1ldXBkYXRlcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cykge1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09uKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubmF0aXZlQ2FwdGlvbnMgPT09IGZhbHNlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgdGhpcy5vbigncmVhZHknLCB0aGlzLmVtdWxhdGVUZXh0VHJhY2tzKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRUZXh0VHJhY2tMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmluaXRUcmFja0xpc3RlbmVycygpO1xuXG4gICAgLy8gVHVybiBvbiBjb21wb25lbnQgdGFwIGV2ZW50c1xuICAgIHRoaXMuZW1pdFRhcEV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzb2NpYXRlZCB0ZXh0IHRyYWNrc1xuICAgKlxuICAgKiBAdHlwZSB7VGV4dFRyYWNrTGlzdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgLyogRmFsbGJhY2tzIGZvciB1bnN1cHBvcnRlZCBldmVudCB0eXBlc1xuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAvLyBNYW51YWxseSB0cmlnZ2VyIHByb2dyZXNzIGV2ZW50cyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHRoZSBidWZmZXJlZCBhbW91bnRcbiAgLy8gTWFueSBmbGFzaCBwbGF5ZXJzIGFuZCBvbGRlciBIVE1MNSBicm93c2VycyBkb24ndCBzZW5kIHByb2dyZXNzIG9yIHByb2dyZXNzLWxpa2UgZXZlbnRzXG4gIC8qKlxuICAgKiBUdXJuIG9uIHByb2dyZXNzIGV2ZW50c1xuICAgKlxuICAgKiBAbWV0aG9kIG1hbnVhbFByb2dyZXNzT25cbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsUHJvZ3Jlc3NPbiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT24oKSB7XG4gICAgdGhpcy5vbignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IHRydWU7XG5cbiAgICAvLyBUcmlnZ2VyIHByb2dyZXNzIHdhdGNoaW5nIHdoZW4gYSBzb3VyY2UgYmVnaW5zIGxvYWRpbmdcbiAgICB0aGlzLm9uZSgncmVhZHknLCB0aGlzLnRyYWNrUHJvZ3Jlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiBwcm9ncmVzcyBldmVudHNcbiAgICpcbiAgICogQG1ldGhvZCBtYW51YWxQcm9ncmVzc09mZlxuICAgKi9cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG5cbiAgICB0aGlzLm9mZignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFjayBwcm9ncmVzc1xuICAgKlxuICAgKiBAbWV0aG9kIHRyYWNrUHJvZ3Jlc3NcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUudHJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIHRyYWNrUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgIHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIHVubGVzcyBidWZmZXJlZCBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIGxhc3QgdGltZVxuXG4gICAgICB2YXIgbnVtQnVmZmVyZWRQZXJjZW50ID0gdGhpcy5idWZmZXJlZFBlcmNlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuYnVmZmVyZWRQZXJjZW50XyAhPT0gbnVtQnVmZmVyZWRQZXJjZW50KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncHJvZ3Jlc3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXJlZFBlcmNlbnRfID0gbnVtQnVmZmVyZWRQZXJjZW50O1xuXG4gICAgICBpZiAobnVtQnVmZmVyZWRQZXJjZW50ID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcbiAgICAgIH1cbiAgICB9KSwgNTAwKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGR1cmF0aW9uXG4gICAqXG4gICAqIEBtZXRob2Qgb25EdXJhdGlvbkNoYW5nZVxuICAgKi9cblxuICBUZWNoLnByb3RvdHlwZS5vbkR1cmF0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25EdXJhdGlvbkNoYW5nZSgpIHtcbiAgICB0aGlzLmR1cmF0aW9uXyA9IHRoaXMuZHVyYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBnZXQgVGltZVJhbmdlIG9iamVjdCBmb3IgYnVmZmVyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZU9iamVjdH1cbiAgICogQG1ldGhvZCBidWZmZXJlZFxuICAgKi9cblxuICBUZWNoLnByb3RvdHlwZS5idWZmZXJlZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkKCkge1xuICAgIHJldHVybiBfdXRpbHNUaW1lUmFuZ2VzSnMuY3JlYXRlVGltZVJhbmdlKDAsIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYnVmZmVyZWQgcGVyY2VudFxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBtZXRob2QgYnVmZmVyZWRQZXJjZW50XG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLmJ1ZmZlcmVkUGVyY2VudCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudCgpIHtcbiAgICByZXR1cm4gX3V0aWxzQnVmZmVySnMuYnVmZmVyZWRQZXJjZW50KHRoaXMuYnVmZmVyZWQoKSwgdGhpcy5kdXJhdGlvbl8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wcyB0cmFja2luZyBwcm9ncmVzcyBieSBjbGVhcmluZyBwcm9ncmVzcyBpbnRlcnZhbFxuICAgKlxuICAgKiBAbWV0aG9kIHN0b3BUcmFja2luZ1Byb2dyZXNzXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ1Byb2dyZXNzID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH07XG5cbiAgLyohIFRpbWUgVHJhY2tpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgLyoqXG4gICAqIFNldCBldmVudCBsaXN0ZW5lcnMgZm9yIG9uIHBsYXkgYW5kIHBhdXNlIGFuZCB0cmFja2luZyBjdXJyZW50IHRpbWVcbiAgICpcbiAgICogQG1ldGhvZCBtYW51YWxUaW1lVXBkYXRlc09uXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT24gPSBmdW5jdGlvbiBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5vbigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3Igb24gcGxheSBhbmQgcGF1c2UgYW5kIHRyYWNraW5nIGN1cnJlbnQgdGltZVxuICAgKlxuICAgKiBAbWV0aG9kIG1hbnVhbFRpbWVVcGRhdGVzT2ZmXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT2ZmID0gZnVuY3Rpb24gbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB0aGlzLm9mZigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBjdXJyZW50IHRpbWVcbiAgICpcbiAgICogQG1ldGhvZCB0cmFja0N1cnJlbnRUaW1lXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrQ3VycmVudFRpbWUgPSBmdW5jdGlvbiB0cmFja0N1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZUludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gICAgfSwgMjUwKTsgLy8gNDIgPSAyNCBmcHMgLy8gMjUwIGlzIHdoYXQgV2Via2l0IHVzZXMgLy8gRkYgdXNlcyAxNVxuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiBwbGF5IHByb2dyZXNzIHRyYWNraW5nICh3aGVuIHBhdXNlZCBvciBkcmFnZ2luZylcbiAgICpcbiAgICogQG1ldGhvZCBzdG9wVHJhY2tpbmdDdXJyZW50VGltZVxuICAgKi9cblxuICBUZWNoLnByb3RvdHlwZS5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCkge1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpO1xuXG4gICAgLy8gIzEwMDIgLSBpZiB0aGUgdmlkZW8gZW5kcyByaWdodCBiZWZvcmUgdGhlIG5leHQgdGltZXVwZGF0ZSB3b3VsZCBoYXBwZW4sXG4gICAgLy8gdGhlIHByb2dyZXNzIGJhciB3b24ndCBtYWtlIGl0IGFsbCB0aGUgd2F5IHRvIHRoZSBlbmRcbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIGFueSBtYW51YWwgcHJvZ3Jlc3Mgb3IgdGltZXVwZGF0ZSB0cmFja2luZ1xuICAgKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xuICAgIHRoaXMuY2xlYXJUcmFja3MoWydhdWRpbycsICd2aWRlbycsICd0ZXh0J10pO1xuXG4gICAgLy8gVHVybiBvZmYgYW55IG1hbnVhbCBwcm9ncmVzcyBvciB0aW1ldXBkYXRlIHRyYWNraW5nXG4gICAgaWYgKHRoaXMubWFudWFsUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMubWFudWFsUHJvZ3Jlc3NPZmYoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYW51YWxUaW1lVXBkYXRlcykge1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09mZigpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogY2xlYXIgb3V0IGEgdHJhY2sgbGlzdCwgb3IgbXVsdGlwbGUgdHJhY2sgbGlzdHNcbiAgICpcbiAgICogTm90ZTogVGVjaHMgd2l0aG91dCBzb3VyY2UgaGFuZGxlcnMgc2hvdWxkIGNhbGwgdGhpcyBiZXR3ZWVuXG4gICAqIHNvdXJjZXMgZm9yIHZpZGVvICYgYXVkaW8gdHJhY2tzLCBhcyB1c3VhbGx5IHlvdSBkb24ndCB3YW50XG4gICAqIHRvIHVzZSB0aGVtIGJldHdlZW4gdHJhY2tzIGFuZCB3ZSBoYXZlIG5vIGF1dG9tYXRpYyB3YXkgdG8gZG9cbiAgICogaXQgZm9yIHlvdVxuICAgKlxuICAgKiBAbWV0aG9kIGNsZWFyVHJhY2tzXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSB0eXBlcyB0eXBlKHMpIG9mIHRyYWNrIGxpc3RzIHRvIGVtcHR5XG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFyVHJhY2tzID0gZnVuY3Rpb24gY2xlYXJUcmFja3ModHlwZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdHlwZXMgPSBbXS5jb25jYXQodHlwZXMpO1xuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGxpc3QgPSBfdGhpc1t0eXBlICsgJ1RyYWNrcyddKCkgfHwgW107XG4gICAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgX3RoaXMucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnJlbW92ZVRyYWNrXyh0cmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0ZWNoLiBSZW1vdmVzIGFsbCBzb3VyY2VzIGFuZCByZXNldHMgcmVhZHlTdGF0ZS5cbiAgICpcbiAgICogQG1ldGhvZCByZXNldFxuICAgKi9cblxuICBUZWNoLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge307XG5cbiAgLyoqXG4gICAqIFdoZW4gaW52b2tlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCByZXR1cm5zIGEgTWVkaWFFcnJvciBvYmplY3RcbiAgICogcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGVycm9yIHN0YXRlIG9mIHRoZSBwbGF5ZXIgb3IgbnVsbCBpZlxuICAgKiB0aGVyZSBpcyBubyBlcnJvci4gV2hlbiBpbnZva2VkIHdpdGggYW4gYXJndW1lbnQsIHNldCB0aGUgY3VycmVudFxuICAgKiBlcnJvciBzdGF0ZSBvZiB0aGUgcGxheWVyLlxuICAgKiBAcGFyYW0ge01lZGlhRXJyb3I9fSBlcnIgICAgT3B0aW9uYWwgYW4gZXJyb3Igb2JqZWN0XG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J9ICAgICAgICB0aGUgY3VycmVudCBlcnJvciBvYmplY3Qgb3IgbnVsbFxuICAgKiBAbWV0aG9kIGVycm9yXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yXyA9IG5ldyBfbWVkaWFFcnJvckpzMlsnZGVmYXVsdCddKGVycik7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aW1lIHJhbmdlcyB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQgdGhyb3VnaCBmb3IgdGhlXG4gICAqIGN1cnJlbnQgc291cmNlLiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGUuIEl0IGRvZXMgbm90XG4gICAqIHRyYWNrIHRoZSBwbGF5ZWQgdGltZSByYW5nZXMsIG9ubHkgd2hldGhlciB0aGUgc291cmNlIGhhcyBwbGF5ZWRcbiAgICogYXQgYWxsIG9yIG5vdC5cbiAgICogQHJldHVybiB7VGltZVJhbmdlT2JqZWN0fSBhIHNpbmdsZSB0aW1lIHJhbmdlIGlmIHRoaXMgdmlkZW8gaGFzXG4gICAqIHBsYXllZCBvciBhbiBlbXB0eSBzZXQgb2YgcmFuZ2VzIGlmIG5vdC5cbiAgICogQG1ldGhvZCBwbGF5ZWRcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xuICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICByZXR1cm4gX3V0aWxzVGltZVJhbmdlc0pzLmNyZWF0ZVRpbWVSYW5nZSgwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIF91dGlsc1RpbWVSYW5nZXNKcy5jcmVhdGVUaW1lUmFuZ2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZVxuICAgKlxuICAgKiBAbWV0aG9kIHNldEN1cnJlbnRUaW1lXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgbWFudWFsIHRpbWV1cGRhdGVzXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHtcbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGV4dHRyYWNrIGxpc3RlbmVyc1xuICAgKlxuICAgKiBAbWV0aG9kIGluaXRUZXh0VHJhY2tMaXN0ZW5lcnNcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUuaW5pdFRleHRUcmFja0xpc3RlbmVycyA9IGZ1bmN0aW9uIGluaXRUZXh0VHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIHRleHRUcmFja0xpc3RDaGFuZ2VzID0gRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3RleHR0cmFja2NoYW5nZScpO1xuICAgIH0pO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCF0cmFja3MpIHJldHVybjtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja0xpc3RDaGFuZ2VzKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgfSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGF1ZGlvIGFuZCB2aWRlbyB0cmFjayBsaXN0ZW5lcnNcbiAgICpcbiAgICogQG1ldGhvZCBpbml0VHJhY2tMaXN0ZW5lcnNcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUuaW5pdFRyYWNrTGlzdGVuZXJzID0gZnVuY3Rpb24gaW5pdFRyYWNrTGlzdGVuZXJzKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHRyYWNrVHlwZXMgPSBbJ3ZpZGVvJywgJ2F1ZGlvJ107XG5cbiAgICB0cmFja1R5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciB0cmFja0xpc3RDaGFuZ2VzID0gZnVuY3Rpb24gdHJhY2tMaXN0Q2hhbmdlcygpIHtcbiAgICAgICAgX3RoaXMyLnRyaWdnZXIodHlwZSArICd0cmFja2NoYW5nZScpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRyYWNrcyA9IF90aGlzMlt0eXBlICsgJ1RyYWNrcyddKCk7XG5cbiAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG5cbiAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtdWxhdGUgdGV4dHRyYWNrc1xuICAgKlxuICAgKiBAbWV0aG9kIGVtdWxhdGVUZXh0VHJhY2tzXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLmVtdWxhdGVUZXh0VHJhY2tzID0gZnVuY3Rpb24gZW11bGF0ZVRleHRUcmFja3MoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIV9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J11bJ1dlYlZUVCddICYmIHRoaXMuZWwoKS5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBfdGhpczMub3B0aW9uc19bJ3Z0dC5qcyddIHx8ICdodHRwczovL2Nkbi5yYXdnaXQuY29tL2drYXRzZXYvdnR0LmpzL3Zqcy12MC4xMi4xL2Rpc3QvdnR0Lm1pbi5qcyc7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy50cmlnZ2VyKCd2dHRqc2Vycm9yJyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBidXQgaGF2ZSBub3QgbG9hZGVkIHlldCBhbmQgd2Ugc2V0IGl0IHRvIHRydWUgYmVmb3JlIHRoZSBpbmplY3Qgc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIGluamVjdGVkIHdpbmRvdy5XZWJWVFQgaWYgaXQgbG9hZHMgcmlnaHQgYXdheVxuICAgICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddWydXZWJWVFQnXSA9IHRydWU7XG4gICAgICAgIF90aGlzMy5lbCgpLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgcmV0dXJuIF90aGlzMy50cmlnZ2VyKCd0ZXh0dHJhY2tjaGFuZ2UnKTtcbiAgICB9O1xuICAgIHZhciB0ZXh0VHJhY2tzQ2hhbmdlcyA9IGZ1bmN0aW9uIHRleHRUcmFja3NDaGFuZ2VzKCkge1xuICAgICAgdXBkYXRlRGlzcGxheSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgICBpZiAodHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGV4dFRyYWNrc0NoYW5nZXMoKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2aWRlb3RyYWNrc1xuICAgKlxuICAgKiBAcmV0dXJucyB7VmlkZW9UcmFja0xpc3R9XG4gICAqIEBtZXRob2QgdmlkZW9UcmFja3NcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUudmlkZW9UcmFja3MgPSBmdW5jdGlvbiB2aWRlb1RyYWNrcygpIHtcbiAgICB0aGlzLnZpZGVvVHJhY2tzXyA9IHRoaXMudmlkZW9UcmFja3NfIHx8IG5ldyBfdHJhY2tzVmlkZW9UcmFja0xpc3QyWydkZWZhdWx0J10oKTtcbiAgICByZXR1cm4gdGhpcy52aWRlb1RyYWNrc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhdWRpb3RyYWNrbGlzdFxuICAgKlxuICAgKiBAcmV0dXJucyB7QXVkaW9UcmFja0xpc3R9XG4gICAqIEBtZXRob2QgYXVkaW9UcmFja3NcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUuYXVkaW9UcmFja3MgPSBmdW5jdGlvbiBhdWRpb1RyYWNrcygpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzXyA9IHRoaXMuYXVkaW9UcmFja3NfIHx8IG5ldyBfdHJhY2tzQXVkaW9UcmFja0xpc3QyWydkZWZhdWx0J10oKTtcbiAgICByZXR1cm4gdGhpcy5hdWRpb1RyYWNrc187XG4gIH07XG5cbiAgLypcbiAgICogUHJvdmlkZSBkZWZhdWx0IG1ldGhvZHMgZm9yIHRleHQgdHJhY2tzLlxuICAgKlxuICAgKiBIdG1sNSB0ZWNoIG92ZXJyaWRlcyB0aGVzZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0ZXh0dHJhY2tzXG4gICAqXG4gICAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICAgKiBAbWV0aG9kIHRleHRUcmFja3NcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUudGV4dFRyYWNrcyA9IGZ1bmN0aW9uIHRleHRUcmFja3MoKSB7XG4gICAgdGhpcy50ZXh0VHJhY2tzXyA9IHRoaXMudGV4dFRyYWNrc18gfHwgbmV3IF90cmFja3NUZXh0VHJhY2tMaXN0MlsnZGVmYXVsdCddKCk7XG4gICAgcmV0dXJuIHRoaXMudGV4dFRyYWNrc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCByZW1vdGUgdGV4dHRyYWNrc1xuICAgKlxuICAgKiBAcmV0dXJucyB7VGV4dFRyYWNrTGlzdH1cbiAgICogQG1ldGhvZCByZW1vdGVUZXh0VHJhY2tzXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja3MgPSBmdW5jdGlvbiByZW1vdGVUZXh0VHJhY2tzKCkge1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrc18gPSB0aGlzLnJlbW90ZVRleHRUcmFja3NfIHx8IG5ldyBfdHJhY2tzVGV4dFRyYWNrTGlzdDJbJ2RlZmF1bHQnXSgpO1xuICAgIHJldHVybiB0aGlzLnJlbW90ZVRleHRUcmFja3NfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcmVtb3RlIGh0bWx0cmFja2VsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MVHJhY2tFbGVtZW50TGlzdH1cbiAgICogQG1ldGhvZCByZW1vdGVUZXh0VHJhY2tFbHNcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrRWxzID0gZnVuY3Rpb24gcmVtb3RlVGV4dFRyYWNrRWxzKCkge1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzXyA9IHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzXyB8fCBuZXcgX3RyYWNrc0h0bWxUcmFja0VsZW1lbnRMaXN0MlsnZGVmYXVsdCddKCk7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzXztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHJlbW90ZSB0ZXh0IHRyYWNrIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2luZCBUZXh0IHRyYWNrIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXB0ZXJzIGFuZCBtZXRhZGF0YSlcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBsYWJlbCBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKiBAcGFyYW0ge1N0cmluZz19IGxhbmd1YWdlIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqIEByZXR1cm4ge1RleHRUcmFja09iamVjdH1cbiAgICogQG1ldGhvZCBhZGRUZXh0VHJhY2tcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICgha2luZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0VHJhY2sga2luZCBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVUcmFja0hlbHBlcih0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGEgZW11bGF0ZWQgaHRtbCB0cmFjayBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdmFsdWVzIGZvclxuICAgKiBraW5kLCBsYW5ndWFnZSwgbGFiZWwgYW5kIHNyYyAobG9jYXRpb24gb2YgdGhlIFdlYlZUVCBmaWxlKVxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiBAbWV0aG9kIGFkZFJlbW90ZVRleHRUcmFja1xuICAgKi9cblxuICBUZWNoLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIHZhciB0cmFjayA9IF91dGlsc01lcmdlT3B0aW9uc0pzMlsnZGVmYXVsdCddKG9wdGlvbnMsIHtcbiAgICAgIHRlY2g6IHRoaXNcbiAgICB9KTtcblxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gbmV3IF90cmFja3NIdG1sVHJhY2tFbGVtZW50MlsnZGVmYXVsdCddKHRyYWNrKTtcblxuICAgIC8vIHN0b3JlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayB0byByZW1vdGUgbGlzdFxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuYWRkVHJhY2tFbGVtZW50XyhodG1sVHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFja18oaHRtbFRyYWNrRWxlbWVudC50cmFjayk7XG5cbiAgICAvLyBtdXN0IGNvbWUgYWZ0ZXIgcmVtb3RlVGV4dFRyYWNrcygpXG4gICAgdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2tfKGh0bWxUcmFja0VsZW1lbnQudHJhY2spO1xuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZW1vdGUgdGV4dHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrT2JqZWN0fSB0cmFjayBUZXh0dHJhY2sgdG8gcmVtb3ZlXG4gICAqIEBtZXRob2QgcmVtb3ZlUmVtb3RlVGV4dFRyYWNrXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIHRoaXMudGV4dFRyYWNrcygpLnJlbW92ZVRyYWNrXyh0cmFjayk7XG5cbiAgICB2YXIgdHJhY2tFbGVtZW50ID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0cmFjayk7XG5cbiAgICAvLyByZW1vdmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIGZyb20gcmVtb3RlIGxpc3RcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLnJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFja18odHJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGVmYXVsdCBzZXRQb3N0ZXIgbWV0aG9kIGZvciB0ZWNoc1xuICAgKiBQb3N0ZXIgc3VwcG9ydCBmb3IgdGVjaHMgc2hvdWxkIGJlIG9wdGlvbmFsLCBzbyB3ZSBkb24ndCB3YW50IHRlY2hzIHRvXG4gICAqIGJyZWFrIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHdheSB0byBzZXQgYSBwb3N0ZXIuXG4gICAqXG4gICAqIEBtZXRob2Qgc2V0UG9zdGVyXG4gICAqL1xuXG4gIFRlY2gucHJvdG90eXBlLnNldFBvc3RlciA9IGZ1bmN0aW9uIHNldFBvc3RlcigpIHt9O1xuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiB0eXBlXG4gICAqXG4gICAqIFRoZSBiYXNlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBhbnkgdHlwZSwgYnV0IHNvdXJjZSBoYW5kbGVycyBtaWdodFxuICAgKiBvdmVyd3JpdGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG5cbiAgVGVjaC5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLypcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgVGVjaCBvciBub3QuXG4gICAqIENhbiBiZSBwYXNzZWQgZWl0aGVyIGEgQ2xhc3MgbGlrZSBgSHRtbDVgIG9yIGEgaW5zdGFuY2UgbGlrZSBgcGxheWVyLnRlY2hfYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IEFuIGl0ZW0gdG8gY2hlY2tcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICBXaGV0aGVyIGl0IGlzIGEgdGVjaCBvciBub3RcbiAgICovXG5cbiAgVGVjaC5pc1RlY2ggPSBmdW5jdGlvbiBpc1RlY2goY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBUZWNoIHx8IGNvbXBvbmVudCBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50ID09PSBUZWNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBUZWNoXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIFRlY2ggdG8gcmVnaXN0ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRlY2ggVGhlIHRlY2ggdG8gcmVnaXN0ZXJcbiAgICogQHN0YXRpY1xuICAgKiBAbWV0aG9kIHJlZ2lzdGVyQ29tcG9uZW50XG4gICAqL1xuXG4gIFRlY2gucmVnaXN0ZXJUZWNoID0gZnVuY3Rpb24gcmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpIHtcbiAgICBpZiAoIVRlY2gudGVjaHNfKSB7XG4gICAgICBUZWNoLnRlY2hzXyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghVGVjaC5pc1RlY2godGVjaCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaCAnICsgbmFtZSArICcgbXVzdCBiZSBhIFRlY2gnKTtcbiAgICB9XG5cbiAgICBUZWNoLnRlY2hzX1tuYW1lXSA9IHRlY2g7XG4gICAgcmV0dXJuIHRlY2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBjb21wb25lbnQgYnkgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0XG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQHN0YXRpY1xuICAgKiBAbWV0aG9kIGdldENvbXBvbmVudFxuICAgKi9cblxuICBUZWNoLmdldFRlY2ggPSBmdW5jdGlvbiBnZXRUZWNoKG5hbWUpIHtcbiAgICBpZiAoVGVjaC50ZWNoc18gJiYgVGVjaC50ZWNoc19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBUZWNoLnRlY2hzX1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXSAmJiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnZpZGVvanMgJiYgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS52aWRlb2pzW25hbWVdKSB7XG4gICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS53YXJuKCdUaGUgJyArIG5hbWUgKyAnIHRlY2ggd2FzIGFkZGVkIHRvIHRoZSB2aWRlb2pzIG9iamVjdCB3aGVuIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpJyk7XG4gICAgICByZXR1cm4gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGVjaDtcbn0pKF9jb21wb25lbnQyWydkZWZhdWx0J10pO1xuXG5UZWNoLnByb3RvdHlwZS50ZXh0VHJhY2tzXztcblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgYXVkaW8gdHJhY2tzXG4gKlxuICogQHR5cGUge0F1ZGlvVHJhY2tMaXN0fVxuICogQHByaXZhdGVcbiAqL1xuVGVjaC5wcm90b3R5cGUuYXVkaW9UcmFja3NfO1xuXG4vKipcbiAqIExpc3Qgb2YgYXNzb2NpYXRlZCB2aWRlbyB0cmFja3NcbiAqXG4gKiBAdHlwZSB7VmlkZW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICovXG5UZWNoLnByb3RvdHlwZS52aWRlb1RyYWNrc187XG5cbnZhciBjcmVhdGVUcmFja0hlbHBlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYWNrSGVscGVyKHNlbGYsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzRdO1xuXG4gIHZhciB0cmFja3MgPSBzZWxmLnRleHRUcmFja3MoKTtcblxuICBvcHRpb25zLmtpbmQgPSBraW5kO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIG9wdGlvbnMubGFiZWwgPSBsYWJlbDtcbiAgfVxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gIH1cbiAgb3B0aW9ucy50ZWNoID0gc2VsZjtcblxuICB2YXIgdHJhY2sgPSBuZXcgX3RyYWNrc1RleHRUcmFjazJbJ2RlZmF1bHQnXShvcHRpb25zKTtcbiAgdHJhY2tzLmFkZFRyYWNrXyh0cmFjayk7XG5cbiAgcmV0dXJuIHRyYWNrO1xufTtcblxuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gdHJ1ZTtcblxuLy8gUmVzaXppbmcgcGx1Z2lucyB1c2luZyByZXF1ZXN0IGZ1bGxzY3JlZW4gcmVsb2FkcyB0aGUgcGx1Z2luXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSBmYWxzZTtcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gZmFsc2U7XG5cbi8vIE9wdGlvbmFsIGV2ZW50cyB0aGF0IHdlIGNhbiBtYW51YWxseSBtaW1pYyB3aXRoIHRpbWVyc1xuLy8gY3VycmVudGx5IG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gZmFsc2U7XG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMgPSBmYWxzZTtcblxuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG5cbi8qXG4gKiBBIGZ1bmN0aW9uYWwgbWl4aW4gZm9yIHRlY2hzIHRoYXQgd2FudCB0byB1c2UgdGhlIFNvdXJjZSBIYW5kbGVyIHBhdHRlcm4uXG4gKlxuICogIyMjIyMgRVhBTVBMRTpcbiAqXG4gKiAgIFRlY2gud2l0aFNvdXJjZUhhbmRsZXJzLmNhbGwoTXlUZWNoKTtcbiAqXG4gKi9cblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzID0gZnVuY3Rpb24gKF9UZWNoKSB7XG4gIC8qXG4gICAqIFJlZ2lzdGVyIGEgc291cmNlIGhhbmRsZXJcbiAgICogU291cmNlIGhhbmRsZXJzIGFyZSBzY3JpcHRzIGZvciBoYW5kbGluZyBzcGVjaWZpYyBmb3JtYXRzLlxuICAgKiBUaGUgc291cmNlIGhhbmRsZXIgcGF0dGVybiBpcyB1c2VkIGZvciBhZGFwdGl2ZSBmb3JtYXRzIChITFMsIERBU0gpIHRoYXRcbiAgICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGhhbmRsZXIgIFRoZSBzb3VyY2UgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgZmlyc3QgICAgUmVnaXN0ZXIgaXQgYmVmb3JlIGFueSBleGlzdGluZyBoYW5kbGVyc1xuICAgKi9cbiAgX1RlY2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGluZGV4KSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICBpbmRleCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDAsIGhhbmRsZXIpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiB0eXBlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBfVGVjaC5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgfHwgW107XG4gICAgdmFyIGNhbiA9IHVuZGVmaW5lZDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhblBsYXlUeXBlKHR5cGUpO1xuXG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIHJldHVybiBjYW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qXG4gICAqIFJldHVybiB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqIFRPRE86IEFuc3dlciBxdWVzdGlvbjogc2hvdWxkICdwcm9iYWJseScgYmUgcHJpb3JpdGl6ZWQgb3ZlciAnbWF5YmUnXG4gICAqIEBwYXJhbSAge09iamVjdH0gc291cmNlICBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgIFRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2VcbiAgICogQHJldHVybnMge251bGx9ICAgICAgICAgTnVsbCBpZiBubyBzb3VyY2UgaGFuZGxlciBpcyBmb3VuZFxuICAgKi9cbiAgX1RlY2guc2VsZWN0U291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyB8fCBbXTtcbiAgICB2YXIgY2FuID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FuID0gaGFuZGxlcnNbaV0uY2FuSGFuZGxlU291cmNlKHNvdXJjZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2VcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzcmNPYmogIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBfVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xuICAgIHZhciBzaCA9IF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIoc3JjT2JqLCBvcHRpb25zKTtcblxuICAgIGlmIChzaCkge1xuICAgICAgcmV0dXJuIHNoLmNhbkhhbmRsZVNvdXJjZShzcmNPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKlxuICAgKiBXaGVuIHVzaW5nIGEgc291cmNlIGhhbmRsZXIsIHByZWZlciBpdHMgaW1wbGVtZW50YXRpb24gb2ZcbiAgICogYW55IGZ1bmN0aW9uIG5vcm1hbGx5IHByb3ZpZGVkIGJ5IHRoZSB0ZWNoLlxuICAgKi9cbiAgdmFyIGRlZmVycmFibGUgPSBbJ3NlZWthYmxlJywgJ2R1cmF0aW9uJ107XG5cbiAgZGVmZXJyYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgICB2YXIgb3JpZ2luYWxGbiA9IHRoaXNbZm5OYW1lXTtcblxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNbZm5OYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfICYmIHRoaXMuc291cmNlSGFuZGxlcl9bZm5OYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VIYW5kbGVyX1tmbk5hbWVdLmFwcGx5KHRoaXMuc291cmNlSGFuZGxlcl8sIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sIF9UZWNoLnByb3RvdHlwZSk7XG5cbiAgLypcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNldHRpbmcgdGhlIHNvdXJjZSB1c2luZyBhIHNvdXJjZSBvYmplY3RcbiAgICogYW5kIHNvdXJjZSBoYW5kbGVycy5cbiAgICogU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3MgYSBzb3VyY2UgaGFuZGxlciB3YXMgZm91bmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgIEEgc291cmNlIG9iamVjdCB3aXRoIHNyYyBhbmQgdHlwZSBrZXlzXG4gICAqIEByZXR1cm4ge1RlY2h9IHNlbGZcbiAgICovXG4gIF9UZWNoLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzb3VyY2UsIHRoaXMub3B0aW9uc18pO1xuXG4gICAgaWYgKCFzaCkge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGEgbmF0aXZlIHNvdXJjZSBoYW5kZXIgd2hlbiB1bnN1cHBvcnRlZCBzb3VyY2VzIGFyZVxuICAgICAgLy8gZGVsaWJlcmF0ZWx5IHNldFxuICAgICAgaWYgKF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgc2ggPSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10uZXJyb3IoJ05vIHNvdXJjZSBoYW5kZXIgZm91bmQgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHNvdXJjZSBhbmQgZ2V0IGFub3RoZXIgb25lXG4gICAgLy8gdGhlbiB3ZSBhcmUgbG9hZGluZyBzb21ldGhpbmcgbmV3XG4gICAgLy8gdGhhbiBjbGVhciBhbGwgb2Ygb3VyIGN1cnJlbnQgdHJhY2tzXG4gICAgaWYgKHRoaXMuY3VycmVudFNvdXJjZV8pIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja3MoWydhdWRpbycsICd2aWRlbyddKTtcblxuICAgICAgdGhpcy5jdXJyZW50U291cmNlXyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHNoICE9PSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XG5cbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBzb3VyY2U7XG5cbiAgICAgIC8vIENhdGNoIGlmIHNvbWVvbmUgcmVwbGFjZWQgdGhlIHNyYyB3aXRob3V0IGNhbGxpbmcgc2V0U291cmNlLlxuICAgICAgLy8gSWYgdGhleSBkbywgc2V0IGN1cnJlbnRTb3VyY2VfIHRvIG51bGwgYW5kIGRpc3Bvc2Ugb3VyIHNvdXJjZSBoYW5kbGVyLlxuICAgICAgdGhpcy5vZmYodGhpcy5lbF8sICdsb2Fkc3RhcnQnLCBfVGVjaC5wcm90b3R5cGUuZmlyc3RMb2FkU3RhcnRMaXN0ZW5lcl8pO1xuICAgICAgdGhpcy5vZmYodGhpcy5lbF8sICdsb2Fkc3RhcnQnLCBfVGVjaC5wcm90b3R5cGUuc3VjY2Vzc2l2ZUxvYWRTdGFydExpc3RlbmVyXyk7XG4gICAgICB0aGlzLm9uZSh0aGlzLmVsXywgJ2xvYWRzdGFydCcsIF9UZWNoLnByb3RvdHlwZS5maXJzdExvYWRTdGFydExpc3RlbmVyXyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VIYW5kbGVyXyA9IHNoLmhhbmRsZVNvdXJjZShzb3VyY2UsIHRoaXMsIHRoaXMub3B0aW9uc18pO1xuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2VTb3VyY2VIYW5kbGVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9uIHRoZSBmaXJzdCBsb2Fkc3RhcnQgYWZ0ZXIgc2V0U291cmNlXG4gIF9UZWNoLnByb3RvdHlwZS5maXJzdExvYWRTdGFydExpc3RlbmVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uZSh0aGlzLmVsXywgJ2xvYWRzdGFydCcsIF9UZWNoLnByb3RvdHlwZS5zdWNjZXNzaXZlTG9hZFN0YXJ0TGlzdGVuZXJfKTtcbiAgfTtcblxuICAvLyBPbiBzdWNjZXNzaXZlIGxvYWRzdGFydHMgd2hlbiBzZXRTb3VyY2UgaGFzIG5vdCBiZWVuIGNhbGxlZCBhZ2FpblxuICBfVGVjaC5wcm90b3R5cGUuc3VjY2Vzc2l2ZUxvYWRTdGFydExpc3RlbmVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gbnVsbDtcbiAgICB0aGlzLmRpc3Bvc2VTb3VyY2VIYW5kbGVyKCk7XG4gICAgdGhpcy5vbmUodGhpcy5lbF8sICdsb2Fkc3RhcnQnLCBfVGVjaC5wcm90b3R5cGUuc3VjY2Vzc2l2ZUxvYWRTdGFydExpc3RlbmVyXyk7XG4gIH07XG5cbiAgLypcbiAgICogQ2xlYW4gdXAgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAqL1xuICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZVNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc291cmNlSGFuZGxlcl8gJiYgdGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XG4gICAgICB0aGlzLm9mZih0aGlzLmVsXywgJ2xvYWRzdGFydCcsIF9UZWNoLnByb3RvdHlwZS5maXJzdExvYWRTdGFydExpc3RlbmVyXyk7XG4gICAgICB0aGlzLm9mZih0aGlzLmVsXywgJ2xvYWRzdGFydCcsIF9UZWNoLnByb3RvdHlwZS5zdWNjZXNzaXZlTG9hZFN0YXJ0TGlzdGVuZXJfKTtcbiAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5zb3VyY2VIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuICB9O1xufTtcblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnVGVjaCcsIFRlY2gpO1xuLy8gT2xkIG5hbWUgZm9yIFRlY2hcbl9jb21wb25lbnQyWydkZWZhdWx0J10ucmVnaXN0ZXJDb21wb25lbnQoJ01lZGlhVGVjaENvbnRyb2xsZXInLCBUZWNoKTtcblRlY2gucmVnaXN0ZXJUZWNoKCdUZWNoJywgVGVjaCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBUZWNoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50XCI6NjcsXCIuLi9tZWRpYS1lcnJvci5qc1wiOjEwOCxcIi4uL3RyYWNrcy9hdWRpby10cmFja1wiOjEyNixcIi4uL3RyYWNrcy9hdWRpby10cmFjay1saXN0XCI6MTI1LFwiLi4vdHJhY2tzL2h0bWwtdHJhY2stZWxlbWVudFwiOjEyOCxcIi4uL3RyYWNrcy9odG1sLXRyYWNrLWVsZW1lbnQtbGlzdFwiOjEyNyxcIi4uL3RyYWNrcy90ZXh0LXRyYWNrXCI6MTM0LFwiLi4vdHJhY2tzL3RleHQtdHJhY2stbGlzdFwiOjEzMixcIi4uL3RyYWNrcy92aWRlby10cmFja1wiOjEzOSxcIi4uL3RyYWNrcy92aWRlby10cmFjay1saXN0XCI6MTM4LFwiLi4vdXRpbHMvYnVmZmVyLmpzXCI6MTQxLFwiLi4vdXRpbHMvZm4uanNcIjoxNDQsXCIuLi91dGlscy9sb2cuanNcIjoxNDcsXCIuLi91dGlscy9tZXJnZS1vcHRpb25zLmpzXCI6MTQ4LFwiLi4vdXRpbHMvdGltZS1yYW5nZXMuanNcIjoxNTAsXCJnbG9iYWwvZG9jdW1lbnRcIjoxLFwiZ2xvYmFsL3dpbmRvd1wiOjJ9XSwxMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1saXN0LmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90cmFja0xpc3QgPSBfZGVyZXFfKCcuL3RyYWNrLWxpc3QnKTtcblxudmFyIF90cmFja0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tMaXN0KTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Jyb3dzZXIuanMnKTtcblxudmFyIGJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNCcm93c2VySnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG4vKipcbiAqIGFueXdoZXJlIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3ZSBkaXZlcmdlIGZyb20gdGhlIHNwZWNcbiAqIGFzIHdlIG9ubHkgc3VwcG9ydCBvbmUgZW5hYmxlZCBhdWRpb3RyYWNrIGF0IGEgdGltZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl8QXVkaW9UcmFja0xpc3R9IGxpc3QgbGlzdCB0byB3b3JrIG9uXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrIHRoZSB0cmFjayB0byBza2lwXG4gKi9cbnZhciBkaXNhYmxlT3RoZXJzID0gZnVuY3Rpb24gZGlzYWJsZU90aGVycyhsaXN0LCB0cmFjaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHJhY2suaWQgPT09IGxpc3RbaV0uaWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBhbm90aGVyIGF1ZGlvIHRyYWNrIGlzIGVuYWJsZWQsIGRpc2FibGUgaXRcbiAgICBsaXN0W2ldLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbi8qKlxuICogQSBsaXN0IG9mIHBvc3NpYmxlIGF1ZGlvIHRyYWNrcy4gQWxsIGZ1bmN0aW9uYWxpdHkgaXMgaW4gdGhlXG4gKiBiYXNlIGNsYXNzIFRyYWNrbGlzdCBhbmQgdGhlIHNwZWMgZm9yIEF1ZGlvVHJhY2tMaXN0IGlzIGxvY2F0ZWQgYXQ6XG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja2xpc3RcbiAqXG4gKiBpbnRlcmZhY2UgQXVkaW9UcmFja0xpc3QgOiBFdmVudFRhcmdldCB7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSB1bnNpZ25lZCBsb25nIGxlbmd0aDtcbiAqICAgZ2V0dGVyIEF1ZGlvVHJhY2sgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBBdWRpb1RyYWNrPyBnZXRUcmFja0J5SWQoRE9NU3RyaW5nIGlkKTtcbiAqXG4gKiAgIGF0dHJpYnV0ZSBFdmVudEhhbmRsZXIgb25jaGFuZ2U7XG4gKiAgIGF0dHJpYnV0ZSBFdmVudEhhbmRsZXIgb25hZGR0cmFjaztcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbnJlbW92ZXRyYWNrO1xuICogfTtcbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2tbXX0gdHJhY2tzIGEgbGlzdCBvZiBhdWRpbyB0cmFja3MgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aFxuICogQGV4dGVuZHMgVHJhY2tMaXN0XG4gKiBAY2xhc3MgQXVkaW9UcmFja0xpc3RcbiAqL1xuXG52YXIgQXVkaW9UcmFja0xpc3QgPSAoZnVuY3Rpb24gKF9UcmFja0xpc3QpIHtcbiAgX2luaGVyaXRzKEF1ZGlvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICBmdW5jdGlvbiBBdWRpb1RyYWNrTGlzdCgpIHtcbiAgICB2YXIgdHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbMF07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5lbmFibGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnModHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChicm93c2VyLklTX0lFOCkge1xuICAgICAgbGlzdCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gX3RyYWNrTGlzdDJbJ2RlZmF1bHQnXS5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gX3RyYWNrTGlzdDJbJ2RlZmF1bHQnXS5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IEF1ZGlvVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSBfVHJhY2tMaXN0LmNhbGwodGhpcywgdHJhY2tzLCBsaXN0KTtcbiAgICBsaXN0LmNoYW5naW5nXyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2tfID0gZnVuY3Rpb24gYWRkVHJhY2tfKHRyYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0cmFjay5lbmFibGVkKSB7XG4gICAgICBkaXNhYmxlT3RoZXJzKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFja18uY2FsbCh0aGlzLCB0cmFjayk7XG4gICAgLy8gbmF0aXZlIHRyYWNrcyBkb24ndCBoYXZlIHRoaXNcbiAgICBpZiAoIXRyYWNrLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gd2hlbiB3ZSBhcmUgZGlzYWJsaW5nIG90aGVyIHRyYWNrcyAoc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbW9yZSB0aGFuIG9uZSB0cmFjayBhdCBhIHRpbWUpIHdlIHdpbGwgc2V0IGNoYW5naW5nX1xuICAgICAgLy8gdG8gdHJ1ZSBzbyB0aGF0IHdlIGRvbid0IHRyaWdnZXIgYWRkaXRpb25hbCBjaGFuZ2UgZXZlbnRzXG4gICAgICBpZiAoX3RoaXMuY2hhbmdpbmdfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzKF90aGlzLCB0cmFjayk7XG4gICAgICBfdGhpcy5jaGFuZ2luZ18gPSBmYWxzZTtcbiAgICAgIF90aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIEF1ZGlvVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdGhpcy5hZGRUcmFja18odHJhY2spO1xuICB9O1xuXG4gIEF1ZGlvVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHRyYWNrKSB7XG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2tfLmNhbGwodGhpcywgdHJhY2spO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrTGlzdDtcbn0pKF90cmFja0xpc3QyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBdWRpb1RyYWNrTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuL3RyYWNrLWxpc3RcIjoxMzYsXCJnbG9iYWwvZG9jdW1lbnRcIjoxfV0sMTI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90cmFja0VudW1zID0gX2RlcmVxXygnLi90cmFjay1lbnVtcycpO1xuXG52YXIgX3RyYWNrID0gX2RlcmVxXygnLi90cmFjaycpO1xuXG52YXIgX3RyYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYWNrKTtcblxudmFyIF91dGlsc01lcmdlT3B0aW9ucyA9IF9kZXJlcV8oJy4uL3V0aWxzL21lcmdlLW9wdGlvbnMnKTtcblxudmFyIF91dGlsc01lcmdlT3B0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc01lcmdlT3B0aW9ucyk7XG5cbnZhciBfdXRpbHNCcm93c2VySnMgPSBfZGVyZXFfKCcuLi91dGlscy9icm93c2VyLmpzJyk7XG5cbnZhciBicm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzQnJvd3NlckpzKTtcblxuLyoqXG4gKiBBIHNpbmdsZSBhdWRpbyB0ZXh0IHRyYWNrIGFzIGRlZmluZWQgaW46XG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja1xuICpcbiAqIGludGVyZmFjZSBBdWRpb1RyYWNrIHtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBpZDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBraW5kO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIGxhYmVsO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIGxhbmd1YWdlO1xuICogICBhdHRyaWJ1dGUgYm9vbGVhbiBlbmFibGVkO1xuICogfTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gKiBAY2xhc3MgQXVkaW9UcmFja1xuICovXG5cbnZhciBBdWRpb1RyYWNrID0gKGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgX2luaGVyaXRzKEF1ZGlvVHJhY2ssIF9UcmFjayk7XG5cbiAgZnVuY3Rpb24gQXVkaW9UcmFjaygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2spO1xuXG4gICAgdmFyIHNldHRpbmdzID0gX3V0aWxzTWVyZ2VPcHRpb25zMlsnZGVmYXVsdCddKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IF90cmFja0VudW1zLkF1ZGlvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcbiAgICB9KTtcbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHJhY2sgPSBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgdmFyIGVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmIChicm93c2VyLklTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBBdWRpb1RyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gQXVkaW9UcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdlbmFibGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBlbmFibGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0VuYWJsZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdFbmFibGVkICE9PSAnYm9vbGVhbicgfHwgbmV3RW5hYmxlZCA9PT0gZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVkID0gbmV3RW5hYmxlZDtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmFibGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgICB0cmFjay5lbmFibGVkID0gc2V0dGluZ3MuZW5hYmxlZDtcbiAgICB9XG4gICAgdHJhY2subG9hZGVkXyA9IHRydWU7XG5cbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICByZXR1cm4gQXVkaW9UcmFjaztcbn0pKF90cmFjazJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEF1ZGlvVHJhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi91dGlscy9icm93c2VyLmpzXCI6MTQwLFwiLi4vdXRpbHMvbWVyZ2Utb3B0aW9uc1wiOjE0OCxcIi4vdHJhY2tcIjoxMzcsXCIuL3RyYWNrLWVudW1zXCI6MTM1fV0sMTI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LWxpc3QuanNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBfdXRpbHNCcm93c2VySnMgPSBfZGVyZXFfKCcuLi91dGlscy9icm93c2VyLmpzJyk7XG5cbnZhciBicm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzQnJvd3NlckpzKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIEh0bWxUcmFja0VsZW1lbnRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSHRtbFRyYWNrRWxlbWVudExpc3QoKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVHJhY2tFbGVtZW50TGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7XG5cbiAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgIGxpc3QgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QudHJhY2tFbGVtZW50c18gPSBbXTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBfbGVuZ3RoID0gdHJhY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBfbGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QuYWRkVHJhY2tFbGVtZW50Xyh0cmFja0VsZW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZS5hZGRUcmFja0VsZW1lbnRfID0gZnVuY3Rpb24gYWRkVHJhY2tFbGVtZW50Xyh0cmFja0VsZW1lbnQpIHtcbiAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnB1c2godHJhY2tFbGVtZW50KTtcbiAgfTtcblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18gPSBmdW5jdGlvbiBnZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0cmFjaykge1xuICAgIHZhciB0cmFja0VsZW1lbnRfID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIF9sZW5ndGgyID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7IGkgPCBfbGVuZ3RoMjsgaSsrKSB7XG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0udHJhY2spIHtcbiAgICAgICAgdHJhY2tFbGVtZW50XyA9IHRoaXMudHJhY2tFbGVtZW50c19baV07XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrRWxlbWVudF87XG4gIH07XG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiByZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBfbGVuZ3RoMyA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoOyBpIDwgX2xlbmd0aDM7IGkrKykge1xuICAgICAgaWYgKHRyYWNrRWxlbWVudCA9PT0gdGhpcy50cmFja0VsZW1lbnRzX1tpXSkge1xuICAgICAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnNwbGljZShpLCAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEh0bWxUcmFja0VsZW1lbnRMaXN0O1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSHRtbFRyYWNrRWxlbWVudExpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi91dGlscy9icm93c2VyLmpzXCI6MTQwLFwiZ2xvYmFsL2RvY3VtZW50XCI6MX1dLDEyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGh0bWwtdHJhY2stZWxlbWVudC5qc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Jyb3dzZXIuanMnKTtcblxudmFyIGJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNCcm93c2VySnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX2V2ZW50VGFyZ2V0ID0gX2RlcmVxXygnLi4vZXZlbnQtdGFyZ2V0Jyk7XG5cbnZhciBfZXZlbnRUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRUYXJnZXQpO1xuXG52YXIgX3RyYWNrc1RleHRUcmFjayA9IF9kZXJlcV8oJy4uL3RyYWNrcy90ZXh0LXRyYWNrJyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYWNrc1RleHRUcmFjayk7XG5cbnZhciBOT05FID0gMDtcbnZhciBMT0FESU5HID0gMTtcbnZhciBMT0FERUQgPSAyO1xudmFyIEVSUk9SID0gMztcblxuLyoqXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjaHRtbHRyYWNrZWxlbWVudFxuICpcbiAqIGludGVyZmFjZSBIVE1MVHJhY2tFbGVtZW50IDogSFRNTEVsZW1lbnQge1xuICogICBhdHRyaWJ1dGUgRE9NU3RyaW5nIGtpbmQ7XG4gKiAgIGF0dHJpYnV0ZSBET01TdHJpbmcgc3JjO1xuICogICBhdHRyaWJ1dGUgRE9NU3RyaW5nIHNyY2xhbmc7XG4gKiAgIGF0dHJpYnV0ZSBET01TdHJpbmcgbGFiZWw7XG4gKiAgIGF0dHJpYnV0ZSBib29sZWFuIGRlZmF1bHQ7XG4gKlxuICogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBOT05FID0gMDtcbiAqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgTE9BRElORyA9IDE7XG4gKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IExPQURFRCA9IDI7XG4gKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IEVSUk9SID0gMztcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIHVuc2lnbmVkIHNob3J0IHJlYWR5U3RhdGU7XG4gKlxuICogICByZWFkb25seSBhdHRyaWJ1dGUgVGV4dFRyYWNrIHRyYWNrO1xuICogfTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUZXh0VHJhY2sgY29uZmlndXJhdGlvblxuICogQGNsYXNzIEhUTUxUcmFja0VsZW1lbnRcbiAqL1xuXG52YXIgSFRNTFRyYWNrRWxlbWVudCA9IChmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIF9pbmhlcml0cyhIVE1MVHJhY2tFbGVtZW50LCBfRXZlbnRUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIEhUTUxUcmFja0VsZW1lbnQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MVHJhY2tFbGVtZW50KTtcblxuICAgIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHJlYWR5U3RhdGUgPSB1bmRlZmluZWQsXG4gICAgICAgIHRyYWNrRWxlbWVudCA9IHRoaXM7XG5cbiAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgIHRyYWNrRWxlbWVudCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrRWxlbWVudFtwcm9wXSA9IEhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrID0gbmV3IF90cmFja3NUZXh0VHJhY2syWydkZWZhdWx0J10ob3B0aW9ucyk7XG5cbiAgICB0cmFja0VsZW1lbnQua2luZCA9IHRyYWNrLmtpbmQ7XG4gICAgdHJhY2tFbGVtZW50LnNyYyA9IHRyYWNrLnNyYztcbiAgICB0cmFja0VsZW1lbnQuc3JjbGFuZyA9IHRyYWNrLmxhbmd1YWdlO1xuICAgIHRyYWNrRWxlbWVudC5sYWJlbCA9IHRyYWNrLmxhYmVsO1xuICAgIHRyYWNrRWxlbWVudFsnZGVmYXVsdCddID0gdHJhY2tbJ2RlZmF1bHQnXTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFja0VsZW1lbnQsICdyZWFkeVN0YXRlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiByZWFkeVN0YXRlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrRWxlbWVudCwgJ3RyYWNrJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWR5U3RhdGUgPSBOT05FO1xuXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlYWR5U3RhdGUgPSBMT0FERUQ7XG5cbiAgICAgIHRyYWNrRWxlbWVudC50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrRWxlbWVudFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgIHJldHVybiB0cmFja0VsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEhUTUxUcmFja0VsZW1lbnQ7XG59KShfZXZlbnRUYXJnZXQyWydkZWZhdWx0J10pO1xuXG5IVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgbG9hZDogJ2xvYWQnXG59O1xuXG5IVE1MVHJhY2tFbGVtZW50Lk5PTkUgPSBOT05FO1xuSFRNTFRyYWNrRWxlbWVudC5MT0FESU5HID0gTE9BRElORztcbkhUTUxUcmFja0VsZW1lbnQuTE9BREVEID0gTE9BREVEO1xuSFRNTFRyYWNrRWxlbWVudC5FUlJPUiA9IEVSUk9SO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBIVE1MVHJhY2tFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vZXZlbnQtdGFyZ2V0XCI6MTA0LFwiLi4vdHJhY2tzL3RleHQtdHJhY2tcIjoxMzQsXCIuLi91dGlscy9icm93c2VyLmpzXCI6MTQwLFwiZ2xvYmFsL2RvY3VtZW50XCI6MX1dLDEyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stY3VlLWxpc3QuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX3V0aWxzQnJvd3NlckpzID0gX2RlcmVxXygnLi4vdXRpbHMvYnJvd3Nlci5qcycpO1xuXG52YXIgYnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0Jyb3dzZXJKcyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQgPSBfZGVyZXFfKCdnbG9iYWwvZG9jdW1lbnQnKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxEb2N1bWVudCk7XG5cbi8qKlxuICogQSBMaXN0IG9mIHRleHQgdHJhY2sgY3VlcyBhcyBkZWZpbmVkIGluOlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2N1ZWxpc3RcbiAqXG4gKiBpbnRlcmZhY2UgVGV4dFRyYWNrQ3VlTGlzdCB7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSB1bnNpZ25lZCBsb25nIGxlbmd0aDtcbiAqICAgZ2V0dGVyIFRleHRUcmFja0N1ZSAodW5zaWduZWQgbG9uZyBpbmRleCk7XG4gKiAgIFRleHRUcmFja0N1ZT8gZ2V0Q3VlQnlJZChET01TdHJpbmcgaWQpO1xuICogfTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjdWVzIEEgbGlzdCBvZiBjdWVzIHRvIGJlIGluaXRpYWxpemVkIHdpdGhcbiAqIEBjbGFzcyBUZXh0VHJhY2tDdWVMaXN0XG4gKi9cblxudmFyIFRleHRUcmFja0N1ZUxpc3QgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZXh0VHJhY2tDdWVMaXN0KGN1ZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQ3VlTGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7XG5cbiAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgIGxpc3QgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXy5jYWxsKGxpc3QsIGN1ZXMpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChicm93c2VyLklTX0lFOCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0dGVyIGZvciBjdWVzIGluIHRoaXMgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzIGFuIGFycmF5IG9mIGN1ZXNcbiAgICogQG1ldGhvZCBzZXRDdWVzX1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5zZXRDdWVzXyA9IGZ1bmN0aW9uIHNldEN1ZXNfKGN1ZXMpIHtcbiAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBjdWVzLmxlbmd0aDtcblxuICAgIHRoaXMuY3Vlc18gPSBjdWVzO1xuICAgIHRoaXMubGVuZ3RoXyA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgdmFyIGRlZmluZVByb3AgPSBmdW5jdGlvbiBkZWZpbmVQcm9wKGluZGV4KSB7XG4gICAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnJyArIGluZGV4LCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdWVzX1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9sZExlbmd0aCA8IGwpIHtcbiAgICAgIGkgPSBvbGRMZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGRlZmluZVByb3AuY2FsbCh0aGlzLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGN1ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgQ3VlIGxpc3QgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEBtZXRob2QgZ2V0Q3VlQnlJZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgc2luZ2xlIGN1ZVxuICAgKi9cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5nZXRDdWVCeUlkID0gZnVuY3Rpb24gZ2V0Q3VlQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmIChjdWUuaWQgPT09IGlkKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrQ3VlTGlzdDtcbn0pKCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRleHRUcmFja0N1ZUxpc3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi91dGlscy9icm93c2VyLmpzXCI6MTQwLFwiZ2xvYmFsL2RvY3VtZW50XCI6MX1dLDEzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stZGlzcGxheS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29tcG9uZW50ID0gX2RlcmVxXygnLi4vY29tcG9uZW50Jyk7XG5cbnZhciBfY29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudCk7XG5cbnZhciBfbWVudU1lbnVKcyA9IF9kZXJlcV8oJy4uL21lbnUvbWVudS5qcycpO1xuXG52YXIgX21lbnVNZW51SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVudU1lbnVKcyk7XG5cbnZhciBfbWVudU1lbnVJdGVtSnMgPSBfZGVyZXFfKCcuLi9tZW51L21lbnUtaXRlbS5qcycpO1xuXG52YXIgX21lbnVNZW51SXRlbUpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVNZW51SXRlbUpzKTtcblxudmFyIF9tZW51TWVudUJ1dHRvbkpzID0gX2RlcmVxXygnLi4vbWVudS9tZW51LWJ1dHRvbi5qcycpO1xuXG52YXIgX21lbnVNZW51QnV0dG9uSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVudU1lbnVCdXR0b25Kcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQgPSBfZGVyZXFfKCdnbG9iYWwvZG9jdW1lbnQnKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxEb2N1bWVudCk7XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gX2RlcmVxXygnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgZGFya0dyYXkgPSAnIzIyMic7XG52YXIgbGlnaHRHcmF5ID0gJyNjY2MnO1xudmFyIGZvbnRNYXAgPSB7XG4gIG1vbm9zcGFjZTogJ21vbm9zcGFjZScsXG4gIHNhbnNTZXJpZjogJ3NhbnMtc2VyaWYnLFxuICBzZXJpZjogJ3NlcmlmJyxcbiAgbW9ub3NwYWNlU2Fuc1NlcmlmOiAnXCJBbmRhbGUgTW9ub1wiLCBcIkx1Y2lkYSBDb25zb2xlXCIsIG1vbm9zcGFjZScsXG4gIG1vbm9zcGFjZVNlcmlmOiAnXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UnLFxuICBwcm9wb3J0aW9uYWxTYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgcHJvcG9ydGlvbmFsU2VyaWY6ICdzZXJpZicsXG4gIGNhc3VhbDogJ1wiQ29taWMgU2FucyBNU1wiLCBJbXBhY3QsIGZhbnRhc3knLFxuICBzY3JpcHQ6ICdcIk1vbm90eXBlIENvcnNpdmFcIiwgY3Vyc2l2ZScsXG4gIHNtYWxsY2FwczogJ1wiQW5kYWxlIE1vbm9cIiwgXCJMdWNpZGEgQ29uc29sZVwiLCBtb25vc3BhY2UsIHNhbnMtc2VyaWYnXG59O1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXllciAgTWFpbiBQbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSByZWFkeSAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvblxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKiBAY2xhc3MgVGV4dFRyYWNrRGlzcGxheVxuICovXG5cbnZhciBUZXh0VHJhY2tEaXNwbGF5ID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhUZXh0VHJhY2tEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUZXh0VHJhY2tEaXNwbGF5KHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbiAgICBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIEZuLmJpbmQodGhpcywgdGhpcy50b2dnbGVEaXNwbGF5KSk7XG4gICAgcGxheWVyLm9uKCd0ZXh0dHJhY2tjaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIGNhbGxlZCBkdXJpbmcgcGxheWVyIGluaXQsIGJ1dCB3YXMgY2F1c2luZyBhbiBlcnJvclxuICAgIC8vIGlmIGEgdHJhY2sgc2hvdWxkIHNob3cgYnkgZGVmYXVsdCBhbmQgdGhlIGRpc3BsYXkgaGFkbid0IGxvYWRlZCB5ZXQuXG4gICAgLy8gU2hvdWxkIHByb2JhYmx5IGJlIG1vdmVkIHRvIGFuIGV4dGVybmFsIHRyYWNrIGxvYWRlciB3aGVuIHdlIHN1cHBvcnRcbiAgICAvLyB0cmFja3MgdGhhdCBkb24ndCBuZWVkIGEgZGlzcGxheS5cbiAgICBwbGF5ZXIucmVhZHkoRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfICYmIHBsYXllci50ZWNoX1snZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzJ10pIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9uc1sndHJhY2tzJ10gfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIHRoaXMucGxheWVyXy5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kZXMgPSB7ICdjYXB0aW9ucyc6IDEsICdzdWJ0aXRsZXMnOiAxIH07XG4gICAgICB2YXIgdHJhY2tMaXN0ID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcbiAgICAgIHZhciBmaXJzdERlc2MgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmlyc3RDYXB0aW9ucyA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRyYWNrTGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrTGlzdFtpXTtcbiAgICAgICAgICBpZiAodHJhY2tbJ2RlZmF1bHQnXSkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdkZXNjcmlwdGlvbnMnICYmICFmaXJzdERlc2MpIHtcbiAgICAgICAgICAgICAgZmlyc3REZXNjID0gdHJhY2s7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgaW4gbW9kZXMgJiYgIWZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgICAgICAgICAgZmlyc3RDYXB0aW9ucyA9IHRyYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gc2hvdyB0aGUgZmlyc3QgZGVmYXVsdCB0cmFjayBidXQgY2FwdGlvbnMgYW5kIHN1YnRpdGxlc1xuICAgICAgICAvLyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBkZXNjcmlwdGlvbnMuXG4gICAgICAgIC8vIFNvLCBkaXNwbGF5IHRoZSBmaXJzdCBkZWZhdWx0IGNhcHRpb25zIG9yIHN1YnRpdGxlcyB0cmFja1xuICAgICAgICAvLyBhbmQgb3RoZXJ3aXNlIHRoZSBmaXJzdCBkZWZhdWx0IGRlc2NyaXB0aW9ucyB0cmFjay5cbiAgICAgICAgaWYgKGZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgICAgICBmaXJzdENhcHRpb25zLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3REZXNjKSB7XG4gICAgICAgICAgZmlyc3REZXNjLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgKiBBZGQgY3VlIEhUTUwgdG8gZGlzcGxheVxuICAqXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvbG9yIEhleCBudW1iZXIgZm9yIGNvbG9yLCBsaWtlICNmMGVcbiAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eSBWYWx1ZSBmb3Igb3BhY2l0eSwwLjAgLSAxLjBcbiAgKiBAcmV0dXJuIHtSR0JBQ29sb3J9IEluIHRoZSBmb3JtICdyZ2JhKDI1NSwgMCwgMCwgMC4zKSdcbiAgKiBAbWV0aG9kIGNvbnN0cnVjdENvbG9yXG4gICovXG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBkaXNwbGF5IHRleHR0cmFja3NcbiAgICpcbiAgICogQG1ldGhvZCB0b2dnbGVEaXNwbGF5XG4gICAqL1xuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnRvZ2dsZURpc3BsYXkgPSBmdW5jdGlvbiB0b2dnbGVEaXNwbGF5KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8udGVjaF8gJiYgdGhpcy5wbGF5ZXJfLnRlY2hfWydmZWF0dXJlc05hdGl2ZVRleHRUcmFja3MnXSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10ZXh0LXRyYWNrLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdhc3NlcnRpdmUnLFxuICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGRpc3BsYXkgdGV4dHRyYWNrc1xuICAgKlxuICAgKiBAbWV0aG9kIGNsZWFyRGlzcGxheVxuICAgKi9cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS5jbGVhckRpc3BsYXkgPSBmdW5jdGlvbiBjbGVhckRpc3BsYXkoKSB7XG4gICAgaWYgKHR5cGVvZiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddWydXZWJWVFQnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXVsnV2ViVlRUJ11bJ3Byb2Nlc3NDdWVzJ10oX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXSwgW10sIHRoaXMuZWxfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkaXNwbGF5IHRleHR0cmFja3NcbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVEaXNwbGF5XG4gICAqL1xuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgdGhpcy5jbGVhckRpc3BsYXkoKTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgZGlzcGxheSBwcmlvcml0aXphdGlvbiBtb2RlbDogaWYgbXVsdGlwbGUgdHJhY2tzIGFyZSAnc2hvd2luZycsXG4gICAgLy8gIGRpc3BsYXkgdGhlIGZpcnN0ICdzdWJ0aXRsZXMnIG9yICdjYXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnLFxuICAgIC8vICBvdGhlcndpc2UgZGlzcGxheSB0aGUgZmlyc3QgJ2Rlc2NyaXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnXG5cbiAgICB2YXIgZGVzY3JpcHRpb25zVHJhY2sgPSBudWxsO1xuICAgIHZhciBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gbnVsbDtcblxuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAodHJhY2tbJ21vZGUnXSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGlmICh0cmFja1sna2luZCddID09PSAnZGVzY3JpcHRpb25zJykge1xuICAgICAgICAgIGRlc2NyaXB0aW9uc1RyYWNrID0gdHJhY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayA9IHRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhcHRpb25zU3VidGl0bGVzVHJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayk7XG4gICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbnNUcmFjaykge1xuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhkZXNjcmlwdGlvbnNUcmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGV4dHRyYWNrIHRvIHRleHR0cmFjayBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrT2JqZWN0fSB0cmFjayBUZXh0dHJhY2sgb2JqZWN0IHRvIGJlIGFkZGVkIHRvIGxpc3RcbiAgICogQG1ldGhvZCB1cGRhdGVGb3JUcmFja1xuICAgKi9cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JUcmFjayA9IGZ1bmN0aW9uIHVwZGF0ZUZvclRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddWydXZWJWVFQnXSAhPT0gJ2Z1bmN0aW9uJyB8fCAhdHJhY2tbJ2FjdGl2ZUN1ZXMnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdmVycmlkZXMgPSB0aGlzLnBsYXllcl9bJ3RleHRUcmFja1NldHRpbmdzJ10uZ2V0VmFsdWVzKCk7XG5cbiAgICB2YXIgY3VlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0cmFja1snYWN0aXZlQ3VlcyddLmxlbmd0aDsgX2krKykge1xuICAgICAgY3Vlcy5wdXNoKHRyYWNrWydhY3RpdmVDdWVzJ11bX2ldKTtcbiAgICB9XG5cbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddWydXZWJWVFQnXVsncHJvY2Vzc0N1ZXMnXShfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLCBjdWVzLCB0aGlzLmVsXyk7XG5cbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKCFjdWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdWVEaXYgPSBjdWUuZGlzcGxheVN0YXRlO1xuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdiwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcycHggMnB4IDNweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDRweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDVweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCAnICsgZGFya0dyYXkgKyAnLCAzcHggM3B4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ucGFyc2VGbG9hdChjdWVEaXYuc3R5bGUuZm9udFNpemUpO1xuICAgICAgICBjdWVEaXYuc3R5bGUuZm9udFNpemUgPSBmb250U2l6ZSAqIG92ZXJyaWRlcy5mb250UGVyY2VudCArICdweCc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS50b3AgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5ib3R0b20gPSAnMnB4JztcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSAmJiBvdmVycmlkZXMuZm9udEZhbWlseSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSA9PT0gJ3NtYWxsLWNhcHMnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udFZhcmlhbnQgPSAnc21hbGwtY2Fwcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRNYXBbb3ZlcnJpZGVzLmZvbnRGYW1pbHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tEaXNwbGF5O1xufSkoX2NvbXBvbmVudDJbJ2RlZmF1bHQnXSk7XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHJldHVybiAncmdiYSgnICtcbiAgLy8gY29sb3IgbG9va3MgbGlrZSBcIiNmMGVcIlxuICBwYXJzZUludChjb2xvclsxXSArIGNvbG9yWzFdLCAxNikgKyAnLCcgKyBwYXJzZUludChjb2xvclsyXSArIGNvbG9yWzJdLCAxNikgKyAnLCcgKyBwYXJzZUludChjb2xvclszXSArIGNvbG9yWzNdLCAxNikgKyAnLCcgKyBvcGFjaXR5ICsgJyknO1xufVxuXG4vKipcbiAqIFRyeSB0byB1cGRhdGUgc3R5bGVcbiAqIFNvbWUgc3R5bGUgY2hhbmdlcyB3aWxsIHRocm93IGFuIGVycm9yLCBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBiZSBzdHlsZXNcbiAqIEBwYXJhbSB7Q1NTUHJvcGVydHl9IHN0eWxlIFRoZSBDU1MgcHJvcGVydHkgdG8gYmUgc3R5bGVkXG4gKiBAcGFyYW0ge0NTU1N0eWxlfSBydWxlIFRoZSBhY3R1YWwgc3R5bGUgdG8gYmUgYXBwbGllZCB0byB0aGUgcHJvcGVydHlcbiAqIEBtZXRob2QgdHJ5VXBkYXRlU3R5bGVcbiAqL1xuZnVuY3Rpb24gdHJ5VXBkYXRlU3R5bGUoZWwsIHN0eWxlLCBydWxlKSB7XG4gIC8vXG4gIHRyeSB7XG4gICAgZWwuc3R5bGVbc3R5bGVdID0gcnVsZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrRGlzcGxheScsIFRleHRUcmFja0Rpc3BsYXkpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gVGV4dFRyYWNrRGlzcGxheTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2NvbXBvbmVudFwiOjY3LFwiLi4vbWVudS9tZW51LWJ1dHRvbi5qc1wiOjEwOSxcIi4uL21lbnUvbWVudS1pdGVtLmpzXCI6MTEwLFwiLi4vbWVudS9tZW51LmpzXCI6MTExLFwiLi4vdXRpbHMvZm4uanNcIjoxNDQsXCJnbG9iYWwvZG9jdW1lbnRcIjoxLFwiZ2xvYmFsL3dpbmRvd1wiOjJ9XSwxMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGNhcHR1cmluZyB0ZXh0IHRyYWNrIHN0YXRlIGFuZCByZS1jcmVhdGluZyB0cmFja3NcbiAqIGJhc2VkIG9uIGEgY2FwdHVyZS5cbiAqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyLmpzXG4gKi9cblxuLyoqXG4gKiBFeGFtaW5lIGEgc2luZ2xlIHRleHQgdHJhY2sgYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0XG4gKiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB0ZXh0IHRyYWNrJ3Mgc3RhdGUuXG4gKiBAcGFyYW0gdHJhY2sge1RleHRUcmFja09iamVjdH0gdGhlIHRleHQgdHJhY2sgdG8gcXVlcnlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAqIEBwcml2YXRlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciB0cmFja1RvSnNvbl8gPSBmdW5jdGlvbiB0cmFja1RvSnNvbl8odHJhY2spIHtcbiAgdmFyIHJldCA9IFsna2luZCcsICdsYWJlbCcsICdsYW5ndWFnZScsICdpZCcsICdpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlJywgJ21vZGUnLCAnc3JjJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3AsIGkpIHtcbiAgICBpZiAodHJhY2tbcHJvcF0pIHtcbiAgICAgIGFjY1twcm9wXSA9IHRyYWNrW3Byb3BdO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHtcbiAgICBjdWVzOiB0cmFjay5jdWVzICYmIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFjay5jdWVzLCBmdW5jdGlvbiAoY3VlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRpbWU6IGN1ZS5zdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IGN1ZS5lbmRUaW1lLFxuICAgICAgICB0ZXh0OiBjdWUudGV4dCxcbiAgICAgICAgaWQ6IGN1ZS5pZFxuICAgICAgfTtcbiAgICB9KVxuICB9KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBFeGFtaW5lIGEgdGVjaCBhbmQgcmV0dXJuIGEgSlNPTi1jb21wYXRpYmxlIGphdmFzY3JpcHQgYXJyYXkgdGhhdFxuICogcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgYWxsIHRleHQgdHJhY2tzIGN1cnJlbnRseSBjb25maWd1cmVkLiBUaGVcbiAqIHJldHVybiBhcnJheSBpcyBjb21wYXRpYmxlIHdpdGggYGpzb25Ub1RleHRUcmFja3NgLlxuICogQHBhcmFtIHRlY2gge3RlY2h9IHRoZSB0ZWNoIG9iamVjdCB0byBxdWVyeVxuICogQHJldHVybiB7QXJyYXl9IGEgc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gKiBAZnVuY3Rpb24gdGV4dFRyYWNrc1RvSnNvblxuICovXG52YXIgdGV4dFRyYWNrc1RvSnNvbiA9IGZ1bmN0aW9uIHRleHRUcmFja3NUb0pzb24odGVjaCkge1xuXG4gIHZhciB0cmFja0VscyA9IHRlY2guJCQoJ3RyYWNrJyk7XG5cbiAgdmFyIHRyYWNrT2JqcyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFja0VscywgZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC50cmFjaztcbiAgfSk7XG4gIHZhciB0cmFja3MgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2tFbHMsIGZ1bmN0aW9uICh0cmFja0VsKSB7XG4gICAgdmFyIGpzb24gPSB0cmFja1RvSnNvbl8odHJhY2tFbC50cmFjayk7XG4gICAgaWYgKHRyYWNrRWwuc3JjKSB7XG4gICAgICBqc29uLnNyYyA9IHRyYWNrRWwuc3JjO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYWNrcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRlY2gudGV4dFRyYWNrcygpLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICByZXR1cm4gdHJhY2tPYmpzLmluZGV4T2YodHJhY2spID09PSAtMTtcbiAgfSkubWFwKHRyYWNrVG9Kc29uXykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9mIHJlbW90ZSB0ZXh0IHRyYWNrcyBvbiBhIHRlY2ggYmFzZWQgb24gYW4gYXJyYXkgb2ZcbiAqIGphdmFzY3JpcHQgdGV4dCB0cmFjayByZXByZXNlbnRhdGlvbnMuXG4gKiBAcGFyYW0ganNvbiB7QXJyYXl9IGFuIGFycmF5IG9mIHRleHQgdHJhY2sgcmVwcmVzZW50YXRpb24gb2JqZWN0cyxcbiAqIGxpa2UgdGhvc2UgdGhhdCB3b3VsZCBiZSBwcm9kdWNlZCBieSBgdGV4dFRyYWNrc1RvSnNvbmBcbiAqIEBwYXJhbSB0ZWNoIHt0ZWNofSB0aGUgdGVjaCB0byBjcmVhdGUgdGV4dCB0cmFja3Mgb25cbiAqIEBmdW5jdGlvbiBqc29uVG9UZXh0VHJhY2tzXG4gKi9cbnZhciBqc29uVG9UZXh0VHJhY2tzID0gZnVuY3Rpb24ganNvblRvVGV4dFRyYWNrcyhqc29uLCB0ZWNoKSB7XG4gIGpzb24uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgYWRkZWRUcmFjayA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrKS50cmFjaztcbiAgICBpZiAoIXRyYWNrLnNyYyAmJiB0cmFjay5jdWVzKSB7XG4gICAgICB0cmFjay5jdWVzLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICByZXR1cm4gYWRkZWRUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRlY2gudGV4dFRyYWNrcygpO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0geyB0ZXh0VHJhY2tzVG9Kc29uOiB0ZXh0VHJhY2tzVG9Kc29uLCBqc29uVG9UZXh0VHJhY2tzOiBqc29uVG9UZXh0VHJhY2tzLCB0cmFja1RvSnNvbl86IHRyYWNrVG9Kc29uXyB9O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se31dLDEzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdHJhY2tMaXN0ID0gX2RlcmVxXygnLi90cmFjay1saXN0Jyk7XG5cbnZhciBfdHJhY2tMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYWNrTGlzdCk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNCcm93c2VySnMgPSBfZGVyZXFfKCcuLi91dGlscy9icm93c2VyLmpzJyk7XG5cbnZhciBicm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzQnJvd3NlckpzKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgcG9zc2libGUgdGV4dCB0cmFja3MuIEFsbCBmdW5jdGlvbmFsaXR5IGlzIGluIHRoZVxuICogYmFzZSBjbGFzcyBUcmFja0xpc3QuIFRoZSBzcGVjIGZvciBUZXh0VHJhY2tMaXN0IGlzIGxvY2F0ZWQgYXQ6XG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdFxuICpcbiAqIGludGVyZmFjZSBUZXh0VHJhY2tMaXN0IDogRXZlbnRUYXJnZXQge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBsZW5ndGg7XG4gKiAgIGdldHRlciBUZXh0VHJhY2sgKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICogICBUZXh0VHJhY2s/IGdldFRyYWNrQnlJZChET01TdHJpbmcgaWQpO1xuICpcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmNoYW5nZTtcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmFkZHRyYWNrO1xuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9ucmVtb3ZldHJhY2s7XG4gKiB9O1xuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrW119IHRyYWNrcyBBIGxpc3Qgb2YgdHJhY2tzIHRvIGluaXRpYWxpemUgdGhlIGxpc3Qgd2l0aFxuICogQGV4dGVuZHMgVHJhY2tMaXN0XG4gKiBAY2xhc3MgVGV4dFRyYWNrTGlzdFxuICovXG5cbnZhciBUZXh0VHJhY2tMaXN0ID0gKGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIF9pbmhlcml0cyhUZXh0VHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICBmdW5jdGlvbiBUZXh0VHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgIGxpc3QgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIF90cmFja0xpc3QyWydkZWZhdWx0J10ucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IF90cmFja0xpc3QyWydkZWZhdWx0J10ucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRleHRUcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRleHRUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2tfID0gZnVuY3Rpb24gYWRkVHJhY2tfKHRyYWNrKSB7XG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2tfLmNhbGwodGhpcywgdHJhY2spO1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgVGV4dFRyYWNrIGZyb20gVGV4dFRyYWNrTGlzdFxuICAgKiBOT1RFOiBCZSBtaW5kZnVsIG9mIHdoYXQgaXMgcGFzc2VkIGluIGFzIGl0IG1heSBiZSBhIEhUTUxUcmFja0VsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHJ0cmFja1xuICAgKiBAbWV0aG9kIHJlbW92ZVRyYWNrX1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFja18gPSBmdW5jdGlvbiByZW1vdmVUcmFja18ocnRyYWNrKSB7XG4gICAgdmFyIHRyYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRoaXNbaV0gPT09IHJ0cmFjaykge1xuICAgICAgICB0cmFjayA9IHRoaXNbaV07XG4gICAgICAgIGlmICh0cmFjay5vZmYpIHtcbiAgICAgICAgICB0cmFjay5vZmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhY2tzXy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICB0cmFjazogdHJhY2ssXG4gICAgICB0eXBlOiAncmVtb3ZldHJhY2snXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRleHRUcmFjayBmcm9tIFRleHRUcmFja0xpc3QgYnkgYSB0cmFja3MgaWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSB0cmFjayB0byBnZXRcbiAgICogQG1ldGhvZCBnZXRUcmFja0J5SWRcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbiBnZXRUcmFja0J5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0cmFjay5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0xpc3Q7XG59KShfdHJhY2tMaXN0MlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVGV4dFRyYWNrTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuLi91dGlscy9mbi5qc1wiOjE0NCxcIi4vdHJhY2stbGlzdFwiOjEzNixcImdsb2JhbC9kb2N1bWVudFwiOjF9XSwxMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLXNldHRpbmdzLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuLi9jb21wb25lbnQnKTtcblxudmFyIF9jb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9uZW50KTtcblxudmFyIF91dGlsc0V2ZW50c0pzID0gX2RlcmVxXygnLi4vdXRpbHMvZXZlbnRzLmpzJyk7XG5cbnZhciBFdmVudHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNFdmVudHNKcyk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNMb2dKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2xvZy5qcycpO1xuXG52YXIgX3V0aWxzTG9nSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNMb2dKcyk7XG5cbnZhciBfc2FmZUpzb25QYXJzZVR1cGxlID0gX2RlcmVxXygnc2FmZS1qc29uLXBhcnNlL3R1cGxlJyk7XG5cbnZhciBfc2FmZUpzb25QYXJzZVR1cGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NhZmVKc29uUGFyc2VUdXBsZSk7XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gX2RlcmVxXygnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG4vKipcbiAqIE1hbmlwdWxhdGUgc2V0dGluZ3Mgb2YgdGV4dHRyYWNrc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXIgIE1haW4gUGxheWVyXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqIEBjbGFzcyBUZXh0VHJhY2tTZXR0aW5nc1xuICovXG5cbnZhciBUZXh0VHJhY2tTZXR0aW5ncyA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVGV4dFRyYWNrU2V0dGluZ3MsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRleHRUcmFja1NldHRpbmdzKHBsYXllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbiAgICBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmhpZGUoKTtcblxuICAgIC8vIEdyYWIgYHBlcnNpc3RUZXh0VHJhY2tTZXR0aW5nc2AgZnJvbSB0aGUgcGxheWVyIG9wdGlvbnMgaWYgbm90IHBhc3NlZCBpbiBjaGlsZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncztcbiAgICB9XG5cbiAgICBFdmVudHMub24odGhpcy4kKCcudmpzLWRvbmUtYnV0dG9uJyksICdjbGljaycsIEZuLmJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pKTtcblxuICAgIEV2ZW50cy5vbih0aGlzLiQoJy52anMtZGVmYXVsdC1idXR0b24nKSwgJ2NsaWNrJywgRm4uYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiQoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuJCgnLnZqcy1iZy1jb2xvciA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy4kKCcud2luZG93LWNvbG9yID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLiQoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLiQoJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcpLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgdGhpcy4kKCcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB0aGlzLiQoJy52anMtZWRnZS1zdHlsZSBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuJCgnLnZqcy1mb250LWZhbWlseSBzZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgIHRoaXMuJCgnLnZqcy1mb250LXBlcmNlbnQgc2VsZWN0Jykuc2VsZWN0ZWRJbmRleCA9IDI7XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KSk7XG5cbiAgICBFdmVudHMub24odGhpcy4kKCcudmpzLWZnLWNvbG9yID4gc2VsZWN0JyksICdjaGFuZ2UnLCBGbi5iaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIEV2ZW50cy5vbih0aGlzLiQoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuJCgnLndpbmRvdy1jb2xvciA+IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy4kKCcudmpzLXRleHQtb3BhY2l0eSA+IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy4kKCcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuJCgnLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy4kKCcudmpzLWZvbnQtcGVyY2VudCBzZWxlY3QnKSwgJ2NoYW5nZScsIEZuLmJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgRXZlbnRzLm9uKHRoaXMuJCgnLnZqcy1lZGdlLXN0eWxlIHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBFdmVudHMub24odGhpcy4kKCcudmpzLWZvbnQtZmFtaWx5IHNlbGVjdCcpLCAnY2hhbmdlJywgRm4uYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgdGhpcy5yZXN0b3JlU2V0dGluZ3MoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsXG4gICAqL1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciB1bmlxdWVJZCA9IHRoaXMuaWRfO1xuICAgIHZhciBkaWFsb2dMYWJlbElkID0gJ1RUc2V0dGluZ3NEaWFsb2dMYWJlbC0nICsgdW5pcXVlSWQ7XG4gICAgdmFyIGRpYWxvZ0Rlc2NyaXB0aW9uSWQgPSAnVFRzZXR0aW5nc0RpYWxvZ0Rlc2NyaXB0aW9uLScgKyB1bmlxdWVJZDtcblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY2FwdGlvbi1zZXR0aW5ncyB2anMtbW9kYWwtb3ZlcmxheScsXG4gICAgICBpbm5lckhUTUw6IGNhcHRpb25PcHRpb25zTWVudVRlbXBsYXRlKHVuaXF1ZUlkLCBkaWFsb2dMYWJlbElkLCBkaWFsb2dEZXNjcmlwdGlvbklkKSxcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0sIHtcbiAgICAgIHJvbGU6ICdkaWFsb2cnLFxuICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGRpYWxvZ0xhYmVsSWQsXG4gICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGRpYWxvZ0Rlc2NyaXB0aW9uSWRcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRleHR0cmFjayBzZXR0aW5nc1xuICAgKiBTZXR0aW5ncyBhcmVcbiAgICogLnZqcy1lZGdlLXN0eWxlXG4gICAqIC52anMtZm9udC1mYW1pbHlcbiAgICogLnZqcy1mZy1jb2xvclxuICAgKiAudmpzLXRleHQtb3BhY2l0eVxuICAgKiAudmpzLWJnLWNvbG9yXG4gICAqIC52anMtYmctb3BhY2l0eVxuICAgKiAud2luZG93LWNvbG9yXG4gICAqIC52anMtd2luZG93LW9wYWNpdHlcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAbWV0aG9kIGdldFZhbHVlc1xuICAgKi9cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gZ2V0VmFsdWVzKCkge1xuICAgIHZhciB0ZXh0RWRnZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUodGhpcy4kKCcudmpzLWVkZ2Utc3R5bGUgc2VsZWN0JykpO1xuICAgIHZhciBmb250RmFtaWx5ID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0aGlzLiQoJy52anMtZm9udC1mYW1pbHkgc2VsZWN0JykpO1xuICAgIHZhciBmZ0NvbG9yID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0aGlzLiQoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgdmFyIHRleHRPcGFjaXR5ID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0aGlzLiQoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JykpO1xuICAgIHZhciBiZ0NvbG9yID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0aGlzLiQoJy52anMtYmctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgdmFyIGJnT3BhY2l0eSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUodGhpcy4kKCcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnKSk7XG4gICAgdmFyIHdpbmRvd0NvbG9yID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0aGlzLiQoJy53aW5kb3ctY29sb3IgPiBzZWxlY3QnKSk7XG4gICAgdmFyIHdpbmRvd09wYWNpdHkgPSBnZXRTZWxlY3RlZE9wdGlvblZhbHVlKHRoaXMuJCgnLnZqcy13aW5kb3ctb3BhY2l0eSA+IHNlbGVjdCcpKTtcbiAgICB2YXIgZm9udFBlcmNlbnQgPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddWydwYXJzZUZsb2F0J10oZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0aGlzLiQoJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JykpKTtcblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAnYmFja2dyb3VuZE9wYWNpdHknOiBiZ09wYWNpdHksXG4gICAgICAndGV4dE9wYWNpdHknOiB0ZXh0T3BhY2l0eSxcbiAgICAgICd3aW5kb3dPcGFjaXR5Jzogd2luZG93T3BhY2l0eSxcbiAgICAgICdlZGdlU3R5bGUnOiB0ZXh0RWRnZSxcbiAgICAgICdmb250RmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICdjb2xvcic6IGZnQ29sb3IsXG4gICAgICAnYmFja2dyb3VuZENvbG9yJzogYmdDb2xvcixcbiAgICAgICd3aW5kb3dDb2xvcic6IHdpbmRvd0NvbG9yLFxuICAgICAgJ2ZvbnRQZXJjZW50JzogZm9udFBlcmNlbnRcbiAgICB9O1xuICAgIGZvciAodmFyIF9uYW1lIGluIHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdFtfbmFtZV0gPT09ICcnIHx8IHJlc3VsdFtfbmFtZV0gPT09ICdub25lJyB8fCBfbmFtZSA9PT0gJ2ZvbnRQZXJjZW50JyAmJiByZXN1bHRbX25hbWVdID09PSAxLjAwKSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHRbX25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGV4dHRyYWNrIHNldHRpbmdzXG4gICAqIFNldHRpbmdzIGFyZVxuICAgKiAudmpzLWVkZ2Utc3R5bGVcbiAgICogLnZqcy1mb250LWZhbWlseVxuICAgKiAudmpzLWZnLWNvbG9yXG4gICAqIC52anMtdGV4dC1vcGFjaXR5XG4gICAqIC52anMtYmctY29sb3JcbiAgICogLnZqcy1iZy1vcGFjaXR5XG4gICAqIC53aW5kb3ctY29sb3JcbiAgICogLnZqcy13aW5kb3ctb3BhY2l0eVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIE9iamVjdCB3aXRoIHRleHR0cmFjayBzZXR0aW5nIHZhbHVlc1xuICAgKiBAbWV0aG9kIHNldFZhbHVlc1xuICAgKi9cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKHRoaXMuJCgnLnZqcy1lZGdlLXN0eWxlIHNlbGVjdCcpLCB2YWx1ZXMuZWRnZVN0eWxlKTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbih0aGlzLiQoJy52anMtZm9udC1mYW1pbHkgc2VsZWN0JyksIHZhbHVlcy5mb250RmFtaWx5KTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbih0aGlzLiQoJy52anMtZmctY29sb3IgPiBzZWxlY3QnKSwgdmFsdWVzLmNvbG9yKTtcbiAgICBzZXRTZWxlY3RlZE9wdGlvbih0aGlzLiQoJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyksIHZhbHVlcy50ZXh0T3BhY2l0eSk7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24odGhpcy4kKCcudmpzLWJnLWNvbG9yID4gc2VsZWN0JyksIHZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHNldFNlbGVjdGVkT3B0aW9uKHRoaXMuJCgnLnZqcy1iZy1vcGFjaXR5ID4gc2VsZWN0JyksIHZhbHVlcy5iYWNrZ3JvdW5kT3BhY2l0eSk7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24odGhpcy4kKCcud2luZG93LWNvbG9yID4gc2VsZWN0JyksIHZhbHVlcy53aW5kb3dDb2xvcik7XG4gICAgc2V0U2VsZWN0ZWRPcHRpb24odGhpcy4kKCcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyksIHZhbHVlcy53aW5kb3dPcGFjaXR5KTtcblxuICAgIHZhciBmb250UGVyY2VudCA9IHZhbHVlcy5mb250UGVyY2VudDtcblxuICAgIGlmIChmb250UGVyY2VudCkge1xuICAgICAgZm9udFBlcmNlbnQgPSBmb250UGVyY2VudC50b0ZpeGVkKDIpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGVkT3B0aW9uKHRoaXMuJCgnLnZqcy1mb250LXBlcmNlbnQgPiBzZWxlY3QnKSwgZm9udFBlcmNlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRleHR0cmFjayBzZXR0aW5nc1xuICAgKlxuICAgKiBAbWV0aG9kIHJlc3RvcmVTZXR0aW5nc1xuICAgKi9cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUucmVzdG9yZVNldHRpbmdzID0gZnVuY3Rpb24gcmVzdG9yZVNldHRpbmdzKCkge1xuICAgIHZhciBlcnIgPSB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlcyA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3NhZmVQYXJzZVR1cGxlID0gX3NhZmVKc29uUGFyc2VUdXBsZTJbJ2RlZmF1bHQnXShfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCd2anMtdGV4dC10cmFjay1zZXR0aW5ncycpKTtcblxuICAgICAgZXJyID0gX3NhZmVQYXJzZVR1cGxlWzBdO1xuICAgICAgdmFsdWVzID0gX3NhZmVQYXJzZVR1cGxlWzFdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10ud2FybihlKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2F2ZSB0ZXh0dHJhY2sgc2V0dGluZ3MgdG8gbG9jYWwgc3RvcmFnZVxuICAgKlxuICAgKiBAbWV0aG9kIHNhdmVTZXR0aW5nc1xuICAgKi9cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2F2ZVNldHRpbmdzID0gZnVuY3Rpb24gc2F2ZVNldHRpbmdzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlcykubGVuZ3RoID4gMCkge1xuICAgICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCd2anMtdGV4dC10cmFjay1zZXR0aW5ncycsIEpTT04uc3RyaW5naWZ5KHZhbHVlcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndmpzLXRleHQtdHJhY2stc2V0dGluZ3MnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS53YXJuKGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGRpc3BsYXkgb2YgdGV4dHRyYWNrIHNldHRpbmdzXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlRGlzcGxheVxuICAgKi9cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgdmFyIHR0RGlzcGxheSA9IHRoaXMucGxheWVyXy5nZXRDaGlsZCgndGV4dFRyYWNrRGlzcGxheScpO1xuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tTZXR0aW5ncztcbn0pKF9jb21wb25lbnQyWydkZWZhdWx0J10pO1xuXG5fY29tcG9uZW50MlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZSh0YXJnZXQpIHtcbiAgdmFyIHNlbGVjdGVkT3B0aW9uID0gdW5kZWZpbmVkO1xuICAvLyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgc2VsZWN0ZWRPcHRpb25zLCBzbywgZmFsbGJhY2sgdG8gb3B0aW9uc1xuICBpZiAodGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0LnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgfSBlbHNlIGlmICh0YXJnZXQub3B0aW9ucykge1xuICAgIHNlbGVjdGVkT3B0aW9uID0gdGFyZ2V0Lm9wdGlvbnNbdGFyZ2V0Lm9wdGlvbnMuc2VsZWN0ZWRJbmRleF07XG4gIH1cblxuICByZXR1cm4gc2VsZWN0ZWRPcHRpb24udmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0Lm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3B0aW9uID0gdGFyZ2V0Lm9wdGlvbnNbaV07XG4gICAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5zZWxlY3RlZEluZGV4ID0gaTtcbn1cblxuZnVuY3Rpb24gY2FwdGlvbk9wdGlvbnNNZW51VGVtcGxhdGUodW5pcXVlSWQsIGRpYWxvZ0xhYmVsSWQsIGRpYWxvZ0Rlc2NyaXB0aW9uSWQpIHtcblxuICB2YXIgdGVtcGxhdGUgPSAnXFxuICAgIDxkaXYgcm9sZT1cImRvY3VtZW50XCI+XFxuICAgICAgPGRpdiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCIxXCIgaWQ9XCInICsgZGlhbG9nTGFiZWxJZCArICdcIiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj5DYXB0aW9ucyBTZXR0aW5ncyBEaWFsb2c8L2Rpdj5cXG4gICAgICA8ZGl2IGlkPVwiJyArIGRpYWxvZ0Rlc2NyaXB0aW9uSWQgKyAnXCIgY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+QmVnaW5uaW5nIG9mIGRpYWxvZyB3aW5kb3cuIEVzY2FwZSB3aWxsIGNhbmNlbCBhbmQgY2xvc2UgdGhlIHdpbmRvdy48L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVwidmpzLXRyYWNrc2V0dGluZ3NcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ2anMtdHJhY2tzZXR0aW5ncy1jb2xvcnNcIj5cXG4gICAgICAgICAgPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFja3NldHRpbmdcIj5cXG4gICAgICAgICAgICA8bGVnZW5kPlRleHQ8L2xlZ2VuZD5cXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIiBmb3I9XCJjYXB0aW9ucy1mb3JlZ3JvdW5kLWNvbG9yLScgKyB1bmlxdWVJZCArICdcIj5Db2xvcjwvbGFiZWw+XFxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cImNhcHRpb25zLWZvcmVncm91bmQtY29sb3ItJyArIHVuaXF1ZUlkICsgJ1wiPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRkZcIiBzZWxlY3RlZD5XaGl0ZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwMDBcIj5CbGFjazwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGMDBcIj5SZWQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEYwXCI+R3JlZW48L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDBGXCI+Qmx1ZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiNGRjBcIj5ZZWxsb3c8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjBGXCI+TWFnZW50YTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiMwRkZcIj5DeWFuPC9vcHRpb24+XFxuICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtdGV4dC1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+XFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIiBmb3I9XCJjYXB0aW9ucy1mb3JlZ3JvdW5kLW9wYWNpdHktJyArIHVuaXF1ZUlkICsgJ1wiPlRyYW5zcGFyZW5jeTwvbGFiZWw+XFxuICAgICAgICAgICAgICA8c2VsZWN0IGlkPVwiY2FwdGlvbnMtZm9yZWdyb3VuZC1vcGFjaXR5LScgKyB1bmlxdWVJZCArICdcIj5cXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIiBzZWxlY3RlZD5PcGFxdWU8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNVwiPlNlbWktT3BhcXVlPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDwvZmllbGRzZXQ+XFxuICAgICAgICAgIDxmaWVsZHNldCBjbGFzcz1cInZqcy1iZy1jb2xvciB2anMtdHJhY2tzZXR0aW5nXCI+XFxuICAgICAgICAgICAgPGxlZ2VuZD5CYWNrZ3JvdW5kPC9sZWdlbmQ+XFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidmpzLWxhYmVsXCIgZm9yPVwiY2FwdGlvbnMtYmFja2dyb3VuZC1jb2xvci0nICsgdW5pcXVlSWQgKyAnXCI+Q29sb3I8L2xhYmVsPlxcbiAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJjYXB0aW9ucy1iYWNrZ3JvdW5kLWNvbG9yLScgKyB1bmlxdWVJZCArICdcIj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDAwXCIgc2VsZWN0ZWQ+QmxhY2s8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkZGXCI+V2hpdGU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjAwXCI+UmVkPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGMFwiPkdyZWVuPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwRlwiPkJsdWU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkYwXCI+WWVsbG93PC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwRlwiPk1hZ2VudGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEZGXCI+Q3lhbjwvb3B0aW9uPlxcbiAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLWJnLW9wYWNpdHkgdmpzLW9wYWNpdHlcIj5cXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiIGZvcj1cImNhcHRpb25zLWJhY2tncm91bmQtb3BhY2l0eS0nICsgdW5pcXVlSWQgKyAnXCI+VHJhbnNwYXJlbmN5PC9sYWJlbD5cXG4gICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJjYXB0aW9ucy1iYWNrZ3JvdW5kLW9wYWNpdHktJyArIHVuaXF1ZUlkICsgJ1wiPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMVwiIHNlbGVjdGVkPk9wYXF1ZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41XCI+U2VtaS1UcmFuc3BhcmVudDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMFwiPlRyYW5zcGFyZW50PC9vcHRpb24+XFxuICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDwvZmllbGRzZXQ+XFxuICAgICAgICAgIDxmaWVsZHNldCBjbGFzcz1cIndpbmRvdy1jb2xvciB2anMtdHJhY2tzZXR0aW5nXCI+XFxuICAgICAgICAgICAgPGxlZ2VuZD5XaW5kb3c8L2xlZ2VuZD5cXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIiBmb3I9XCJjYXB0aW9ucy13aW5kb3ctY29sb3ItJyArIHVuaXF1ZUlkICsgJ1wiPkNvbG9yPC9sYWJlbD5cXG4gICAgICAgICAgICA8c2VsZWN0IGlkPVwiY2FwdGlvbnMtd2luZG93LWNvbG9yLScgKyB1bmlxdWVJZCArICdcIj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMDAwXCIgc2VsZWN0ZWQ+QmxhY2s8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkZGXCI+V2hpdGU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRjAwXCI+UmVkPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzBGMFwiPkdyZWVuPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIzAwRlwiPkJsdWU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjRkYwXCI+WWVsbG93PC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiI0YwRlwiPk1hZ2VudGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIjMEZGXCI+Q3lhbjwvb3B0aW9uPlxcbiAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+XFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIiBmb3I9XCJjYXB0aW9ucy13aW5kb3ctb3BhY2l0eS0nICsgdW5pcXVlSWQgKyAnXCI+VHJhbnNwYXJlbmN5PC9sYWJlbD5cXG4gICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJjYXB0aW9ucy13aW5kb3ctb3BhY2l0eS0nICsgdW5pcXVlSWQgKyAnXCI+XFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCIgc2VsZWN0ZWQ+VHJhbnNwYXJlbnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNVwiPlNlbWktVHJhbnNwYXJlbnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj5PcGFxdWU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPC9maWVsZHNldD5cXG4gICAgICAgIDwvZGl2PiA8IS0tIHZqcy10cmFja3NldHRpbmdzLWNvbG9ycyAtLT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ2anMtdHJhY2tzZXR0aW5ncy1mb250XCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2anMtZm9udC1wZXJjZW50IHZqcy10cmFja3NldHRpbmdcIj5cXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIiBmb3I9XCJjYXB0aW9ucy1mb250LXNpemUtJyArIHVuaXF1ZUlkICsgJ1wiPkZvbnQgU2l6ZTwvbGFiZWw+XFxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cImNhcHRpb25zLWZvbnQtc2l6ZS0nICsgdW5pcXVlSWQgKyAnXCI+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMC41MFwiPjUwJTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjAuNzVcIj43NSU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjAwXCIgc2VsZWN0ZWQ+MTAwJTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEuMjVcIj4xMjUlPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMS41MFwiPjE1MCU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxLjc1XCI+MTc1JTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjIuMDBcIj4yMDAlPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMy4wMFwiPjMwMCU8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI0LjAwXCI+NDAwJTwvb3B0aW9uPlxcbiAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFja3NldHRpbmdcIj5cXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ2anMtbGFiZWxcIiBmb3I9XCJjYXB0aW9ucy1lZGdlLXN0eWxlLScgKyB1bmlxdWVJZCArICdcIj5UZXh0IEVkZ2UgU3R5bGU8L2xhYmVsPlxcbiAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJjYXB0aW9ucy1lZGdlLXN0eWxlLScgKyB1bmlxdWVJZCArICdcIj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub25lXCIgc2VsZWN0ZWQ+Tm9uZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJhaXNlZFwiPlJhaXNlZDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImRlcHJlc3NlZFwiPkRlcHJlc3NlZDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInVuaWZvcm1cIj5Vbmlmb3JtPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZHJvcHNoYWRvd1wiPkRyb3BzaGFkb3c8L29wdGlvbj5cXG4gICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2anMtZm9udC1mYW1pbHkgdmpzLXRyYWNrc2V0dGluZ1wiPlxcbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInZqcy1sYWJlbFwiIGZvcj1cImNhcHRpb25zLWZvbnQtZmFtaWx5LScgKyB1bmlxdWVJZCArICdcIj5Gb250IEZhbWlseTwvbGFiZWw+XFxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cImNhcHRpb25zLWZvbnQtZmFtaWx5LScgKyB1bmlxdWVJZCArICdcIj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJwcm9wb3J0aW9uYWxTYW5zU2VyaWZcIiBzZWxlY3RlZD5Qcm9wb3J0aW9uYWwgU2Fucy1TZXJpZjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1vbm9zcGFjZVNhbnNTZXJpZlwiPk1vbm9zcGFjZSBTYW5zLVNlcmlmPC9vcHRpb24+XFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicHJvcG9ydGlvbmFsU2VyaWZcIj5Qcm9wb3J0aW9uYWwgU2VyaWY8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtb25vc3BhY2VTZXJpZlwiPk1vbm9zcGFjZSBTZXJpZjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImNhc3VhbFwiPkNhc3VhbDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNjcmlwdFwiPlNjcmlwdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNtYWxsLWNhcHNcIj5TbWFsbCBDYXBzPC9vcHRpb24+XFxuICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+IDwhLS0gdmpzLXRyYWNrc2V0dGluZ3MtZm9udCAtLT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ2anMtdHJhY2tzZXR0aW5ncy1jb250cm9sc1wiPlxcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwidmpzLWRlZmF1bHQtYnV0dG9uXCI+RGVmYXVsdHM8L2J1dHRvbj5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInZqcy1kb25lLWJ1dHRvblwiPkRvbmU8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PiA8IS0tIHZqcy10cmFja3NldHRpbmdzIC0tPlxcbiAgICA8L2Rpdj4gPCEtLSAgcm9sZT1cImRvY3VtZW50XCIgLS0+JztcblxuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRleHRUcmFja1NldHRpbmdzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vY29tcG9uZW50XCI6NjcsXCIuLi91dGlscy9ldmVudHMuanNcIjoxNDMsXCIuLi91dGlscy9mbi5qc1wiOjE0NCxcIi4uL3V0aWxzL2xvZy5qc1wiOjE0NyxcImdsb2JhbC93aW5kb3dcIjoyLFwic2FmZS1qc29uLXBhcnNlL3R1cGxlXCI6NTR9XSwxMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90ZXh0VHJhY2tDdWVMaXN0ID0gX2RlcmVxXygnLi90ZXh0LXRyYWNrLWN1ZS1saXN0Jyk7XG5cbnZhciBfdGV4dFRyYWNrQ3VlTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0VHJhY2tDdWVMaXN0KTtcblxudmFyIF91dGlsc0ZuSnMgPSBfZGVyZXFfKCcuLi91dGlscy9mbi5qcycpO1xuXG52YXIgRm4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNGbkpzKTtcblxudmFyIF90cmFja0VudW1zID0gX2RlcmVxXygnLi90cmFjay1lbnVtcycpO1xuXG52YXIgX3V0aWxzTG9nSnMgPSBfZGVyZXFfKCcuLi91dGlscy9sb2cuanMnKTtcblxudmFyIF91dGlsc0xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTG9nSnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF90cmFja0pzID0gX2RlcmVxXygnLi90cmFjay5qcycpO1xuXG52YXIgX3RyYWNrSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tKcyk7XG5cbnZhciBfdXRpbHNVcmxKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL3VybC5qcycpO1xuXG52YXIgX3hociA9IF9kZXJlcV8oJ3hocicpO1xuXG52YXIgX3hocjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94aHIpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zID0gX2RlcmVxXygnLi4vdXRpbHMvbWVyZ2Utb3B0aW9ucycpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTWVyZ2VPcHRpb25zKTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Jyb3dzZXIuanMnKTtcblxudmFyIGJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNCcm93c2VySnMpO1xuXG4vKipcbiAqIHRha2VzIGEgd2VidnR0IGZpbGUgY29udGVudHMgYW5kIHBhcnNlcyBpdCBpbnRvIGN1ZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjQ29udGVudCB3ZWJWVFQgZmlsZSBjb250ZW50c1xuICogQHBhcmFtIHtUcmFja30gdHJhY2sgdHJhY2sgdG8gYWRkY3VlcyB0b1xuICovXG52YXIgcGFyc2VDdWVzID0gZnVuY3Rpb24gcGFyc2VDdWVzKHNyY0NvbnRlbnQsIHRyYWNrKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5XZWJWVFQuUGFyc2VyKF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10sIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10udnR0anMsIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uV2ViVlRULlN0cmluZ0RlY29kZXIoKSk7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gIH07XG5cbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9O1xuXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRyYWNrLnRyaWdnZXIoe1xuICAgICAgdHlwZTogJ2xvYWRlZGRhdGEnLFxuICAgICAgdGFyZ2V0OiB0cmFja1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlci5wYXJzZShzcmNDb250ZW50KTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQpIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJ1RleHQgVHJhY2sgcGFyc2luZyBlcnJvcnMgZm9yICcgKyB0cmFjay5zcmMpO1xuICAgIH1cbiAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgaWYgKGNvbnNvbGUuZ3JvdXBFbmQpIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZXIuZmx1c2goKTtcbn07XG5cbi8qKlxuICogbG9hZCBhIHRyYWNrIGZyb20gYSAgc3BlY2lmZWQgdXJsXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNyYyB1cmwgdG8gbG9hZCB0cmFjayBmcm9tXG4gKiBAcGFyYW0ge1RyYWNrfSB0cmFjayB0cmFjayB0byBhZGRjdWVzIHRvXG4gKi9cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbiBsb2FkVHJhY2soc3JjLCB0cmFjaykge1xuICB2YXIgb3B0cyA9IHtcbiAgICB1cmk6IHNyY1xuICB9O1xuICB2YXIgY3Jvc3NPcmlnaW4gPSBfdXRpbHNVcmxKcy5pc0Nyb3NzT3JpZ2luKHNyYyk7XG5cbiAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgb3B0cy5jb3JzID0gY3Jvc3NPcmlnaW47XG4gIH1cblxuICBfeGhyMlsnZGVmYXVsdCddKG9wdHMsIEZuLmJpbmQodGhpcywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlQm9keSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBfdXRpbHNMb2dKczJbJ2RlZmF1bHQnXS5lcnJvcihlcnIsIHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHZ0dGpzIGhhcyBsb2FkZWQsIG90aGVyd2lzZSwgd2FpdCB0aWxsIGl0IGZpbmlzaGVkIGxvYWRpbmdcbiAgICAvLyBOT1RFOiB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgdGhlIGFsdC92aWRlby5ub3Z0dC5qcyBidWlsZFxuICAgIGlmICh0eXBlb2YgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5XZWJWVFQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0cmFjay50ZWNoXykge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxvYWRIYW5kbGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ3VlcyhyZXNwb25zZUJvZHksIHRyYWNrKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgICB0cmFjay50ZWNoXy5vbigndnR0anNlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLmVycm9yKCd2dHRqcyBmYWlsZWQgdG8gbG9hZCwgc3RvcHBpbmcgdHJ5aW5nIHRvIHByb2Nlc3MgJyArIHRyYWNrLnNyYyk7XG4gICAgICAgICAgICB0cmFjay50ZWNoXy5vZmYoJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XG4gICAgfVxuICB9KSk7XG59O1xuXG4vKipcbiAqIEEgc2luZ2xlIHRleHQgdHJhY2sgYXMgZGVmaW5lZCBpbjpcbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tcbiAqXG4gKiBpbnRlcmZhY2UgVGV4dFRyYWNrIDogRXZlbnRUYXJnZXQge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgVGV4dFRyYWNrS2luZCBraW5kO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIGxhYmVsO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIGxhbmd1YWdlO1xuICpcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBpZDtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyBpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlO1xuICpcbiAqICAgYXR0cmlidXRlIFRleHRUcmFja01vZGUgbW9kZTtcbiAqXG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBUZXh0VHJhY2tDdWVMaXN0PyBjdWVzO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgVGV4dFRyYWNrQ3VlTGlzdD8gYWN0aXZlQ3VlcztcbiAqXG4gKiAgIHZvaWQgYWRkQ3VlKFRleHRUcmFja0N1ZSBjdWUpO1xuICogICB2b2lkIHJlbW92ZUN1ZShUZXh0VHJhY2tDdWUgY3VlKTtcbiAqXG4gKiAgIGF0dHJpYnV0ZSBFdmVudEhhbmRsZXIgb25jdWVjaGFuZ2U7XG4gKiB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBleHRlbmRzIFRyYWNrXG4gKiBAY2xhc3MgVGV4dFRyYWNrXG4gKi9cblxudmFyIFRleHRUcmFjayA9IChmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIF9pbmhlcml0cyhUZXh0VHJhY2ssIF9UcmFjayk7XG5cbiAgZnVuY3Rpb24gVGV4dFRyYWNrKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrKTtcblxuICAgIGlmICghb3B0aW9ucy50ZWNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGVjaCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIHZhciBzZXR0aW5ncyA9IF91dGlsc01lcmdlT3B0aW9uczJbJ2RlZmF1bHQnXShvcHRpb25zLCB7XG4gICAgICBraW5kOiBfdHJhY2tFbnVtcy5UZXh0VHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJ3N1YnRpdGxlcycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcgfHwgJydcbiAgICB9KTtcbiAgICB2YXIgbW9kZSA9IF90cmFja0VudW1zLlRleHRUcmFja01vZGVbc2V0dGluZ3MubW9kZV0gfHwgJ2Rpc2FibGVkJztcbiAgICB2YXIgZGVmYXVsdF8gPSBzZXR0aW5nc1snZGVmYXVsdCddO1xuXG4gICAgaWYgKHNldHRpbmdzLmtpbmQgPT09ICdtZXRhZGF0YScgfHwgc2V0dGluZ3Mua2luZCA9PT0gJ2NoYXB0ZXJzJykge1xuICAgICAgbW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHQgPSBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgdHQudGVjaF8gPSBzZXR0aW5ncy50ZWNoO1xuXG4gICAgaWYgKGJyb3dzZXIuSVNfSUU4KSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRleHRUcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0dFtwcm9wXSA9IFRleHRUcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dC5jdWVzXyA9IFtdO1xuICAgIHR0LmFjdGl2ZUN1ZXNfID0gW107XG5cbiAgICB2YXIgY3VlcyA9IG5ldyBfdGV4dFRyYWNrQ3VlTGlzdDJbJ2RlZmF1bHQnXSh0dC5jdWVzXyk7XG4gICAgdmFyIGFjdGl2ZUN1ZXMgPSBuZXcgX3RleHRUcmFja0N1ZUxpc3QyWydkZWZhdWx0J10odHQuYWN0aXZlQ3Vlc18pO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIHRpbWV1cGRhdGVIYW5kbGVyID0gRm4uYmluZCh0dCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hY3RpdmVDdWVzO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjdWVjaGFuZ2UnKTtcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1vZGUgIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHR0LnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2RlZmF1bHQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRfO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ21vZGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TW9kZSkge1xuICAgICAgICBpZiAoIV90cmFja0VudW1zLlRleHRUcmFja01vZGVbbmV3TW9kZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0aGlzLnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignbW9kZWNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnY3VlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1ZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7fVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnYWN0aXZlQ3VlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICBpZiAodGhpcy5jdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0ID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgICB2YXIgYWN0aXZlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmN1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc1tpXTtcblxuICAgICAgICAgIGlmIChjdWUuc3RhcnRUaW1lIDw9IGN0ICYmIGN1ZS5lbmRUaW1lID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA9PT0gY3VlLmVuZFRpbWUgJiYgY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuc3RhcnRUaW1lICsgMC41ID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCAhPT0gdGhpcy5hY3RpdmVDdWVzXy5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ3Vlc18uaW5kZXhPZihhY3RpdmVbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZUN1ZXNfID0gYWN0aXZlO1xuICAgICAgICBhY3RpdmVDdWVzLnNldEN1ZXNfKHRoaXMuYWN0aXZlQ3Vlc18pO1xuXG4gICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgICB9KTtcblxuICAgIGlmIChzZXR0aW5ncy5zcmMpIHtcbiAgICAgIHR0LnNyYyA9IHNldHRpbmdzLnNyYztcbiAgICAgIGxvYWRUcmFjayhzZXR0aW5ncy5zcmMsIHR0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHQubG9hZGVkXyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR0O1xuICB9XG5cbiAgLyoqXG4gICAqIGN1ZWNoYW5nZSAtIE9uZSBvciBtb3JlIGN1ZXMgaW4gdGhlIHRyYWNrIGhhdmUgYmVjb21lIGFjdGl2ZSBvciBzdG9wcGVkIGJlaW5nIGFjdGl2ZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIGFkZCBhIGN1ZSB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdWUgdGhlIGN1ZSB0byBhZGQgdG8gb3VyIGludGVybmFsIGxpc3RcbiAgICogQG1ldGhvZCBhZGRDdWVcbiAgICovXG5cbiAgVGV4dFRyYWNrLnByb3RvdHlwZS5hZGRDdWUgPSBmdW5jdGlvbiBhZGRDdWUoY3VlKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudGVjaF8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKHRyYWNrcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRyYWNrc1tpXSAhPT0gdGhpcykge1xuICAgICAgICAgIHRyYWNrc1tpXS5yZW1vdmVDdWUoY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3Vlc18ucHVzaChjdWUpO1xuICAgIHRoaXMuY3Vlcy5zZXRDdWVzXyh0aGlzLmN1ZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogcmVtdm9lIGEgY3VlIGZyb20gb3VyIGludGVybmFsIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlbW92ZUN1ZSB0aGUgY3VlIHRvIHJlbW92ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqIEBtZXRob2QgcmVtb3ZlQ3VlXG4gICAqL1xuXG4gIFRleHRUcmFjay5wcm90b3R5cGUucmVtb3ZlQ3VlID0gZnVuY3Rpb24gcmVtb3ZlQ3VlKF9yZW1vdmVDdWUpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmN1ZXNfLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc19baV07XG5cbiAgICAgIGlmIChjdWUgPT09IF9yZW1vdmVDdWUpIHtcbiAgICAgICAgdGhpcy5jdWVzXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2s7XG59KShfdHJhY2tKczJbJ2RlZmF1bHQnXSk7XG5cblRleHRUcmFjay5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGN1ZWNoYW5nZTogJ2N1ZWNoYW5nZSdcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRleHRUcmFjaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuLi91dGlscy9mbi5qc1wiOjE0NCxcIi4uL3V0aWxzL2xvZy5qc1wiOjE0NyxcIi4uL3V0aWxzL21lcmdlLW9wdGlvbnNcIjoxNDgsXCIuLi91dGlscy91cmwuanNcIjoxNTIsXCIuL3RleHQtdHJhY2stY3VlLWxpc3RcIjoxMjksXCIuL3RyYWNrLWVudW1zXCI6MTM1LFwiLi90cmFjay5qc1wiOjEzNyxcImdsb2JhbC9kb2N1bWVudFwiOjEsXCJnbG9iYWwvd2luZG93XCI6MixcInhoclwiOjU2fV0sMTM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgdHJhY2sta2luZHMuanNcbiAqL1xuXG4vKipcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tdmlkZW90cmFjay1raW5kXG4gKlxuICogZW51bSBWaWRlb1RyYWNrS2luZCB7XG4gKiAgIFwiYWx0ZXJuYXRpdmVcIixcbiAqICAgXCJjYXB0aW9uc1wiLFxuICogICBcIm1haW5cIixcbiAqICAgXCJzaWduXCIsXG4gKiAgIFwic3VidGl0bGVzXCIsXG4gKiAgIFwiY29tbWVudGFyeVwiLFxuICogICBcIlwiLFxuICogfTtcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFZpZGVvVHJhY2tLaW5kID0ge1xuICBhbHRlcm5hdGl2ZTogJ2FsdGVybmF0aXZlJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIG1haW46ICdtYWluJyxcbiAgc2lnbjogJ3NpZ24nLFxuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjb21tZW50YXJ5OiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1hdWRpb3RyYWNrLWtpbmRcbiAqXG4gKiBlbnVtIEF1ZGlvVHJhY2tLaW5kIHtcbiAqICAgXCJhbHRlcm5hdGl2ZVwiLFxuICogICBcImRlc2NyaXB0aW9uc1wiLFxuICogICBcIm1haW5cIixcbiAqICAgXCJtYWluLWRlc2NcIixcbiAqICAgXCJ0cmFuc2xhdGlvblwiLFxuICogICBcImNvbW1lbnRhcnlcIixcbiAqICAgXCJcIixcbiAqIH07XG4gKi9cbnZhciBBdWRpb1RyYWNrS2luZCA9IHtcbiAgYWx0ZXJuYXRpdmU6ICdhbHRlcm5hdGl2ZScsXG4gIGRlc2NyaXB0aW9uczogJ2Rlc2NyaXB0aW9ucycsXG4gIG1haW46ICdtYWluJyxcbiAgJ21haW4tZGVzYyc6ICdtYWluLWRlc2MnLFxuICB0cmFuc2xhdGlvbjogJ3RyYW5zbGF0aW9uJyxcbiAgY29tbWVudGFyeTogJ2NvbW1lbnRhcnknXG59O1xuXG4vKipcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2traW5kXG4gKlxuICogZW51bSBUZXh0VHJhY2tLaW5kIHtcbiAqICAgXCJzdWJ0aXRsZXNcIixcbiAqICAgXCJjYXB0aW9uc1wiLFxuICogICBcImRlc2NyaXB0aW9uc1wiLFxuICogICBcImNoYXB0ZXJzXCIsXG4gKiAgIFwibWV0YWRhdGFcIlxuICogfTtcbiAqL1xudmFyIFRleHRUcmFja0tpbmQgPSB7XG4gIHN1YnRpdGxlczogJ3N1YnRpdGxlcycsXG4gIGNhcHRpb25zOiAnY2FwdGlvbnMnLFxuICBkZXNjcmlwdGlvbnM6ICdkZXNjcmlwdGlvbnMnLFxuICBjaGFwdGVyczogJ2NoYXB0ZXJzJyxcbiAgbWV0YWRhdGE6ICdtZXRhZGF0YSdcbn07XG5cbi8qKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja21vZGVcbiAqXG4gKiBlbnVtIFRleHRUcmFja01vZGUgeyBcImRpc2FibGVkXCIsICBcImhpZGRlblwiLCAgXCJzaG93aW5nXCIgfTtcbiAqL1xudmFyIFRleHRUcmFja01vZGUgPSB7XG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBzaG93aW5nOiAnc2hvd2luZydcbn07XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbi8vIHdlIGlnbm9yZSBqc2hpbnQgaGVyZSBiZWNhdXNlIGl0IGRvZXMgbm90IHNlZVxuLy8gQXVkaW9UcmFja0tpbmQgYXMgZGVmaW5lZCBoZXJlXG5leHBvcnRzWydkZWZhdWx0J10gPSB7IFZpZGVvVHJhY2tLaW5kOiBWaWRlb1RyYWNrS2luZCwgQXVkaW9UcmFja0tpbmQ6IEF1ZGlvVHJhY2tLaW5kLCBUZXh0VHJhY2tLaW5kOiBUZXh0VHJhY2tLaW5kLCBUZXh0VHJhY2tNb2RlOiBUZXh0VHJhY2tNb2RlIH07XG5cbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7fV0sMTM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgdHJhY2stbGlzdC5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZXZlbnRUYXJnZXQgPSBfZGVyZXFfKCcuLi9ldmVudC10YXJnZXQnKTtcblxudmFyIF9ldmVudFRhcmdldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudFRhcmdldCk7XG5cbnZhciBfdXRpbHNGbkpzID0gX2RlcmVxXygnLi4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdXRpbHNCcm93c2VySnMgPSBfZGVyZXFfKCcuLi91dGlscy9icm93c2VyLmpzJyk7XG5cbnZhciBicm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzQnJvd3NlckpzKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxuLyoqXG4gKiBDb21tb24gZnVuY3Rpb25hbGl5IGJldHdlZW4gVGV4dCwgQXVkaW8sIGFuZCBWaWRlbyBUcmFja0xpc3RzXG4gKiBJbnRlcmZhY2VzIGRlZmluZWQgaW4gdGhlIGZvbGxvd2luZyBzcGVjOlxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sXG4gKlxuICogQHBhcmFtIHtUcmFja1tdfSB0cmFja3MgQSBsaXN0IG9mIHRyYWNrcyB0byBpbml0aWFsaXplIHRoZSBsaXN0IHdpdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0IHRoZSBjaGlsZCBvYmplY3Qgd2l0aCBpbmhlcml0YW5jZSBkb25lIG1hbnVhbGx5IGZvciBpZThcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAY2xhc3MgVHJhY2tMaXN0XG4gKi9cblxudmFyIFRyYWNrTGlzdCA9IChmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIF9pbmhlcml0cyhUcmFja0xpc3QsIF9FdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2tMaXN0KTtcblxuICAgIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IHRoaXM7XG4gICAgICBpZiAoYnJvd3Nlci5JU19JRTgpIHtcbiAgICAgICAgbGlzdCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QudHJhY2tzXyA9IFtdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc18ubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QuYWRkVHJhY2tfKHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogY2hhbmdlIC0gT25lIG9yIG1vcmUgdHJhY2tzIGluIHRoZSB0cmFjayBsaXN0IGhhdmUgYmVlbiBlbmFibGVkIG9yIGRpc2FibGVkLlxuICAgKiBhZGR0cmFjayAtIEEgdHJhY2sgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHRyYWNrIGxpc3QuXG4gICAqIHJlbW92ZXRyYWNrIC0gQSB0cmFjayBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyYWNrIGxpc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBZGQgYSBUcmFjayBmcm9tIFRyYWNrTGlzdFxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSB0cmFja1xuICAgKiBAbWV0aG9kIGFkZFRyYWNrX1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBUcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrXyA9IGZ1bmN0aW9uIGFkZFRyYWNrXyh0cmFjaykge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzX1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBhZGQgZHVwbGljYXRlIHRyYWNrc1xuICAgIGlmICh0aGlzLnRyYWNrc18uaW5kZXhPZih0cmFjaykgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XG4gICAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgIHR5cGU6ICdhZGR0cmFjaydcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgVHJhY2sgZnJvbSBUcmFja0xpc3RcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gcnRyYWNrIHRyYWNrIHRvIGJlIHJlbW92ZWRcbiAgICogQG1ldGhvZCByZW1vdmVUcmFja19cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFja18gPSBmdW5jdGlvbiByZW1vdmVUcmFja18ocnRyYWNrKSB7XG4gICAgdmFyIHRyYWNrID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRoaXNbaV0gPT09IHJ0cmFjaykge1xuICAgICAgICB0cmFjayA9IHRoaXNbaV07XG4gICAgICAgIGlmICh0cmFjay5vZmYpIHtcbiAgICAgICAgICB0cmFjay5vZmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhY2tzXy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICB0cmFjazogdHJhY2ssXG4gICAgICB0eXBlOiAncmVtb3ZldHJhY2snXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRyYWNrIGZyb20gdGhlIFRyYWNrTGlzdCBieSBhIHRyYWNrcyBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHRyYWNrIHRvIGdldFxuICAgKiBAbWV0aG9kIGdldFRyYWNrQnlJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbiBnZXRUcmFja0J5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXNbaV07XG4gICAgICBpZiAodHJhY2suaWQgPT09IGlkKSB7XG4gICAgICAgIHJlc3VsdCA9IHRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBUcmFja0xpc3Q7XG59KShfZXZlbnRUYXJnZXQyWydkZWZhdWx0J10pO1xuXG5UcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjaGFuZ2U6ICdjaGFuZ2UnLFxuICBhZGR0cmFjazogJ2FkZHRyYWNrJyxcbiAgcmVtb3ZldHJhY2s6ICdyZW1vdmV0cmFjaydcbn07XG5cbi8vIGVtdWxhdGUgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBzdXBwb3J0IHRvIGFsbG93IGZvciBmZWF0dXJlIGRldGVjdGlvblxuZm9yICh2YXIgX2V2ZW50IGluIFRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18pIHtcbiAgVHJhY2tMaXN0LnByb3RvdHlwZVsnb24nICsgX2V2ZW50XSA9IG51bGw7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRyYWNrTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2V2ZW50LXRhcmdldFwiOjEwNCxcIi4uL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuLi91dGlscy9mbi5qc1wiOjE0NCxcImdsb2JhbC9kb2N1bWVudFwiOjF9XSwxMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB0cmFjay5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdXRpbHNCcm93c2VySnMgPSBfZGVyZXFfKCcuLi91dGlscy9icm93c2VyLmpzJyk7XG5cbnZhciBicm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzQnJvd3NlckpzKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIF91dGlsc0d1aWRKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2d1aWQuanMnKTtcblxudmFyIEd1aWQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNHdWlkSnMpO1xuXG52YXIgX2V2ZW50VGFyZ2V0ID0gX2RlcmVxXygnLi4vZXZlbnQtdGFyZ2V0Jyk7XG5cbnZhciBfZXZlbnRUYXJnZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRUYXJnZXQpO1xuXG4vKipcbiAqIHNldHVwIHRoZSBjb21tb24gcGFydHMgb2YgYW4gYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrXG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0cmFjayB3ZSBhcmUgZGVhbGluZyB3aXRoIGF1ZGlvfHZpZGVvfHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAY2xhc3MgVHJhY2tcbiAqL1xuXG52YXIgVHJhY2sgPSAoZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBfaW5oZXJpdHMoVHJhY2ssIF9FdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gVHJhY2soKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFjayk7XG5cbiAgICBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0cmFjayA9IHRoaXM7XG4gICAgaWYgKGJyb3dzZXIuSVNfSUU4KSB7XG4gICAgICB0cmFjayA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tbcHJvcF0gPSBUcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJhY2tQcm9wcyA9IHtcbiAgICAgIGlkOiBvcHRpb25zLmlkIHx8ICd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kIHx8ICcnLFxuICAgICAgbGFiZWw6IG9wdGlvbnMubGFiZWwgfHwgJycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCAnJ1xuICAgIH07XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tQcm9wc1trZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHt9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrUHJvcHMpIHtcbiAgICAgIF9sb29wKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrO1xufSkoX2V2ZW50VGFyZ2V0MlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVHJhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi9ldmVudC10YXJnZXRcIjoxMDQsXCIuLi91dGlscy9icm93c2VyLmpzXCI6MTQwLFwiLi4vdXRpbHMvZ3VpZC5qc1wiOjE0NixcImdsb2JhbC9kb2N1bWVudFwiOjF9XSwxMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB2aWRlby10cmFjay1saXN0LmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF90cmFja0xpc3QgPSBfZGVyZXFfKCcuL3RyYWNrLWxpc3QnKTtcblxudmFyIF90cmFja0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tMaXN0KTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Jyb3dzZXIuanMnKTtcblxudmFyIGJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNCcm93c2VySnMpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG4vKipcbiAqIGRpc2FibGUgb3RoZXIgdmlkZW8gdHJhY2tzIGJlZm9yZSBzZWxlY3RpbmcgdGhlIG5ldyBvbmVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fFZpZGVvVHJhY2tMaXN0fSBsaXN0IGxpc3QgdG8gd29yayBvblxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFjayB0aGUgdHJhY2sgdG8gc2tpcFxuICovXG52YXIgZGlzYWJsZU90aGVycyA9IGZ1bmN0aW9uIGRpc2FibGVPdGhlcnMobGlzdCwgdHJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciBhdWRpbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiogQSBsaXN0IG9mIHBvc3NpYmxlZSB2aWRlbyB0cmFja3MuIE1vc3QgZnVuY3Rpb25hbGl0eSBpcyBpbiB0aGVcbiAqIGJhc2UgY2xhc3MgVHJhY2tsaXN0IGFuZCB0aGUgc3BlYyBmb3IgVmlkZW9UcmFja0xpc3QgaXMgbG9jYXRlZCBhdDpcbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdFxuICpcbiAqIGludGVyZmFjZSBWaWRlb1RyYWNrTGlzdCA6IEV2ZW50VGFyZ2V0IHtcbiAqICAgcmVhZG9ubHkgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbGVuZ3RoO1xuICogICBnZXR0ZXIgVmlkZW9UcmFjayAodW5zaWduZWQgbG9uZyBpbmRleCk7XG4gKiAgIFZpZGVvVHJhY2s/IGdldFRyYWNrQnlJZChET01TdHJpbmcgaWQpO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgbG9uZyBzZWxlY3RlZEluZGV4O1xuICpcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmNoYW5nZTtcbiAqICAgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBvbmFkZHRyYWNrO1xuICogICBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIG9ucmVtb3ZldHJhY2s7XG4gKiB9O1xuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja1tdfSB0cmFja3MgYSBsaXN0IG9mIHZpZGVvIHRyYWNrcyB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoXG4gIyBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqIEBjbGFzcyBWaWRlb1RyYWNrTGlzdFxuICovXG5cbnZhciBWaWRlb1RyYWNrTGlzdCA9IChmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBfaW5oZXJpdHMoVmlkZW9UcmFja0xpc3QsIF9UcmFja0xpc3QpO1xuXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1swXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb1RyYWNrTGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIG1ha2Ugc3VyZSBvbmx5IDEgdHJhY2sgaXMgZW5hYmxlZFxuICAgIC8vIHNvcnRlZCBmcm9tIGxhc3QgaW5kZXggdG8gZmlyc3QgaW5kZXhcbiAgICBmb3IgKHZhciBpID0gdHJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodHJhY2tzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnModHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChicm93c2VyLklTX0lFOCkge1xuICAgICAgbGlzdCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gX3RyYWNrTGlzdDJbJ2RlZmF1bHQnXS5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gX3RyYWNrTGlzdDJbJ2RlZmF1bHQnXS5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSBfVHJhY2tMaXN0LmNhbGwodGhpcywgdHJhY2tzLCBsaXN0KTtcbiAgICBsaXN0LmNoYW5naW5nXyA9IGZhbHNlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdzZWxlY3RlZEluZGV4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgICB9KTtcblxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgVmlkZW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrXyA9IGZ1bmN0aW9uIGFkZFRyYWNrXyh0cmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodHJhY2suc2VsZWN0ZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnModGhpcywgdHJhY2spO1xuICAgIH1cblxuICAgIF9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrXy5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMuY2hhbmdpbmdfID0gdHJ1ZTtcbiAgICAgIGRpc2FibGVPdGhlcnMoX3RoaXMsIHRyYWNrKTtcbiAgICAgIF90aGlzLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgVmlkZW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB0aGlzLmFkZFRyYWNrXyh0cmFjayk7XG4gIH07XG5cbiAgVmlkZW9UcmFja0xpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2sodHJhY2spIHtcbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFja18uY2FsbCh0aGlzLCB0cmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2tMaXN0O1xufSkoX3RyYWNrTGlzdDJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZpZGVvVHJhY2tMaXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vdXRpbHMvYnJvd3Nlci5qc1wiOjE0MCxcIi4vdHJhY2stbGlzdFwiOjEzNixcImdsb2JhbC9kb2N1bWVudFwiOjF9XSwxMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3RyYWNrRW51bXMgPSBfZGVyZXFfKCcuL3RyYWNrLWVudW1zJyk7XG5cbnZhciBfdHJhY2sgPSBfZGVyZXFfKCcuL3RyYWNrJyk7XG5cbnZhciBfdHJhY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2spO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zID0gX2RlcmVxXygnLi4vdXRpbHMvbWVyZ2Utb3B0aW9ucycpO1xuXG52YXIgX3V0aWxzTWVyZ2VPcHRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzTWVyZ2VPcHRpb25zKTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4uL3V0aWxzL2Jyb3dzZXIuanMnKTtcblxudmFyIGJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNCcm93c2VySnMpO1xuXG4vKipcbiAqIEEgc2luZ2xlIHZpZGVvIHRleHQgdHJhY2sgYXMgZGVmaW5lZCBpbjpcbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrXG4gKlxuICogaW50ZXJmYWNlIFZpZGVvVHJhY2sge1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIGlkO1xuICogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIGtpbmQ7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgbGFiZWw7XG4gKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgbGFuZ3VhZ2U7XG4gKiAgIGF0dHJpYnV0ZSBib29sZWFuIHNlbGVjdGVkO1xuICogfTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gKiBAY2xhc3MgVmlkZW9UcmFja1xuICovXG5cbnZhciBWaWRlb1RyYWNrID0gKGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgX2luaGVyaXRzKFZpZGVvVHJhY2ssIF9UcmFjayk7XG5cbiAgZnVuY3Rpb24gVmlkZW9UcmFjaygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2spO1xuXG4gICAgdmFyIHNldHRpbmdzID0gX3V0aWxzTWVyZ2VPcHRpb25zMlsnZGVmYXVsdCddKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IF90cmFja0VudW1zLlZpZGVvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcbiAgICB9KTtcblxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0cmFjayA9IF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKTtcbiAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChicm93c2VyLklTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBWaWRlb1RyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVmlkZW9UcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdzZWxlY3RlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3U2VsZWN0ZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdTZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nIHx8IG5ld1NlbGVjdGVkID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RlZCA9IG5ld1NlbGVjdGVkO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5zZWxlY3RlZCkge1xuICAgICAgdHJhY2suc2VsZWN0ZWQgPSBzZXR0aW5ncy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICByZXR1cm4gVmlkZW9UcmFjaztcbn0pKF90cmFjazJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZpZGVvVHJhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuLi91dGlscy9icm93c2VyLmpzXCI6MTQwLFwiLi4vdXRpbHMvbWVyZ2Utb3B0aW9uc1wiOjE0OCxcIi4vdHJhY2tcIjoxMzcsXCIuL3RyYWNrLWVudW1zXCI6MTM1fV0sMTQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgYnJvd3Nlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBVU0VSX0FHRU5UID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5uYXZpZ2F0b3IudXNlckFnZW50O1xudmFyIHdlYmtpdFZlcnNpb25NYXAgPSAvQXBwbGVXZWJLaXRcXC8oW1xcZC5dKykvaS5leGVjKFVTRVJfQUdFTlQpO1xudmFyIGFwcGxlV2Via2l0VmVyc2lvbiA9IHdlYmtpdFZlcnNpb25NYXAgPyBwYXJzZUZsb2F0KHdlYmtpdFZlcnNpb25NYXAucG9wKCkpIDogbnVsbDtcblxuLypcbiAqIERldmljZSBpcyBhbiBpUGhvbmVcbiAqXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIElTX0lQQUQgPSAvaVBhZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG5cbmV4cG9ydHMuSVNfSVBBRCA9IElTX0lQQUQ7XG4vLyBUaGUgRmFjZWJvb2sgYXBwJ3MgVUlXZWJWaWV3IGlkZW50aWZpZXMgYXMgYm90aCBhbiBpUGhvbmUgYW5kIGlQYWQsIHNvXG4vLyB0byBpZGVudGlmeSBpUGhvbmVzLCB3ZSBuZWVkIHRvIGV4Y2x1ZGUgaVBhZHMuXG4vLyBodHRwOi8vYXJ0c3kuZ2l0aHViLmlvL2Jsb2cvMjAxMi8xMC8xOC90aGUtcGVyaWxzLW9mLWlvcy11c2VyLWFnZW50LXNuaWZmaW5nL1xudmFyIElTX0lQSE9ORSA9IC9pUGhvbmUvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19JUEFEO1xuZXhwb3J0cy5JU19JUEhPTkUgPSBJU19JUEhPTkU7XG52YXIgSVNfSVBPRCA9IC9pUG9kL2kudGVzdChVU0VSX0FHRU5UKTtcbmV4cG9ydHMuSVNfSVBPRCA9IElTX0lQT0Q7XG52YXIgSVNfSU9TID0gSVNfSVBIT05FIHx8IElTX0lQQUQgfHwgSVNfSVBPRDtcblxuZXhwb3J0cy5JU19JT1MgPSBJU19JT1M7XG52YXIgSU9TX1ZFUlNJT04gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9PUyAoXFxkKylfL2kpO1xuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbn0pKCk7XG5cbmV4cG9ydHMuSU9TX1ZFUlNJT04gPSBJT1NfVkVSU0lPTjtcbnZhciBJU19BTkRST0lEID0gL0FuZHJvaWQvaS50ZXN0KFVTRVJfQUdFTlQpO1xuZXhwb3J0cy5JU19BTkRST0lEID0gSVNfQU5EUk9JRDtcbnZhciBBTkRST0lEX1ZFUlNJT04gPSAoZnVuY3Rpb24gKCkge1xuICAvLyBUaGlzIG1hdGNoZXMgQW5kcm9pZCBNYWpvci5NaW5vci5QYXRjaCB2ZXJzaW9uc1xuICAvLyBBTkRST0lEX1ZFUlNJT04gaXMgTWFqb3IuTWlub3IgYXMgYSBOdW1iZXIsIGlmIE1pbm9yIGlzbid0IGF2YWlsYWJsZSwgdGhlbiBvbmx5IE1ham9yIGlzIHJldHVybmVkXG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL0FuZHJvaWQgKFxcZCspKD86XFwuKFxcZCspKT8oPzpcXC4oXFxkKykpKi9pKSxcbiAgICAgIG1ham9yLFxuICAgICAgbWlub3I7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbWFqb3IgPSBtYXRjaFsxXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgbWlub3IgPSBtYXRjaFsyXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcblxuICBpZiAobWFqb3IgJiYgbWlub3IpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSArICcuJyArIG1hdGNoWzJdKTtcbiAgfSBlbHNlIGlmIChtYWpvcikge1xuICAgIHJldHVybiBtYWpvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSkoKTtcbmV4cG9ydHMuQU5EUk9JRF9WRVJTSU9OID0gQU5EUk9JRF9WRVJTSU9OO1xuLy8gT2xkIEFuZHJvaWQgaXMgZGVmaW5lZCBhcyBWZXJzaW9uIG9sZGVyIHRoYW4gMi4zLCBhbmQgcmVxdWlyaW5nIGEgd2Via2l0IHZlcnNpb24gb2YgdGhlIGFuZHJvaWQgYnJvd3NlclxudmFyIElTX09MRF9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiAvd2Via2l0L2kudGVzdChVU0VSX0FHRU5UKSAmJiBBTkRST0lEX1ZFUlNJT04gPCAyLjM7XG5leHBvcnRzLklTX09MRF9BTkRST0lEID0gSVNfT0xEX0FORFJPSUQ7XG52YXIgSVNfTkFUSVZFX0FORFJPSUQgPSBJU19BTkRST0lEICYmIEFORFJPSURfVkVSU0lPTiA8IDUgJiYgYXBwbGVXZWJraXRWZXJzaW9uIDwgNTM3O1xuXG5leHBvcnRzLklTX05BVElWRV9BTkRST0lEID0gSVNfTkFUSVZFX0FORFJPSUQ7XG52YXIgSVNfRklSRUZPWCA9IC9GaXJlZm94L2kudGVzdChVU0VSX0FHRU5UKTtcbmV4cG9ydHMuSVNfRklSRUZPWCA9IElTX0ZJUkVGT1g7XG52YXIgSVNfRURHRSA9IC9FZGdlL2kudGVzdChVU0VSX0FHRU5UKTtcbmV4cG9ydHMuSVNfRURHRSA9IElTX0VER0U7XG52YXIgSVNfQ0hST01FID0gIUlTX0VER0UgJiYgL0Nocm9tZS9pLnRlc3QoVVNFUl9BR0VOVCk7XG5leHBvcnRzLklTX0NIUk9NRSA9IElTX0NIUk9NRTtcbnZhciBJU19JRTggPSAvTVNJRVxcczhcXC4wLy50ZXN0KFVTRVJfQUdFTlQpO1xuZXhwb3J0cy5JU19JRTggPSBJU19JRTg7XG52YXIgSUVfVkVSU0lPTiA9IChmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQgJiYgcGFyc2VGbG9hdChyZXN1bHRbMV0pO1xufSkoL01TSUVcXHMoXFxkKylcXC5cXGQvLmV4ZWMoVVNFUl9BR0VOVCkpO1xuXG5leHBvcnRzLklFX1ZFUlNJT04gPSBJRV9WRVJTSU9OO1xudmFyIFRPVUNIX0VOQUJMRUQgPSAhISgnb250b3VjaHN0YXJ0JyBpbiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddIHx8IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uRG9jdW1lbnRUb3VjaCAmJiBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10gaW5zdGFuY2VvZiBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLkRvY3VtZW50VG91Y2gpO1xuZXhwb3J0cy5UT1VDSF9FTkFCTEVEID0gVE9VQ0hfRU5BQkxFRDtcbnZhciBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEID0gKCdiYWNrZ3JvdW5kU2l6ZScgaW4gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJykuc3R5bGUpO1xuZXhwb3J0cy5CQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEID0gQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRDtcblxufSx7XCJnbG9iYWwvZG9jdW1lbnRcIjoxLFwiZ2xvYmFsL3dpbmRvd1wiOjJ9XSwxNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBidWZmZXIuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5idWZmZXJlZFBlcmNlbnQgPSBidWZmZXJlZFBlcmNlbnQ7XG5cbnZhciBfdGltZVJhbmdlc0pzID0gX2RlcmVxXygnLi90aW1lLXJhbmdlcy5qcycpO1xuXG4vKipcbiAqIENvbXB1dGUgaG93IG11Y2ggeW91ciB2aWRlbyBoYXMgYmVlbiBidWZmZXJlZFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gQnVmZmVyZWQgb2JqZWN0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFRvdGFsIGR1cmF0aW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFBlcmNlbnQgYnVmZmVyZWQgb2YgdGhlIHRvdGFsIGR1cmF0aW9uXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudFxuICovXG5cbmZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudChidWZmZXJlZCwgZHVyYXRpb24pIHtcbiAgdmFyIGJ1ZmZlcmVkRHVyYXRpb24gPSAwLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQ7XG5cbiAgaWYgKCFkdXJhdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgYnVmZmVyZWQgPSBfdGltZVJhbmdlc0pzLmNyZWF0ZVRpbWVSYW5nZSgwLCAwKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcblxuICAgIC8vIGJ1ZmZlcmVkIGVuZCBjYW4gYmUgYmlnZ2VyIHRoYW4gZHVyYXRpb24gYnkgYSB2ZXJ5IHNtYWxsIGZyYWN0aW9uXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICBidWZmZXJlZER1cmF0aW9uICs9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcmVkRHVyYXRpb24gLyBkdXJhdGlvbjtcbn1cblxufSx7XCIuL3RpbWUtcmFuZ2VzLmpzXCI6MTUwfV0sMTQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgZG9tLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ2V0RWwgPSBnZXRFbDtcbmV4cG9ydHMuY3JlYXRlRWwgPSBjcmVhdGVFbDtcbmV4cG9ydHMudGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudDtcbmV4cG9ydHMuaW5zZXJ0RWxGaXJzdCA9IGluc2VydEVsRmlyc3Q7XG5leHBvcnRzLmdldEVsRGF0YSA9IGdldEVsRGF0YTtcbmV4cG9ydHMuaGFzRWxEYXRhID0gaGFzRWxEYXRhO1xuZXhwb3J0cy5yZW1vdmVFbERhdGEgPSByZW1vdmVFbERhdGE7XG5leHBvcnRzLmhhc0VsQ2xhc3MgPSBoYXNFbENsYXNzO1xuZXhwb3J0cy5hZGRFbENsYXNzID0gYWRkRWxDbGFzcztcbmV4cG9ydHMucmVtb3ZlRWxDbGFzcyA9IHJlbW92ZUVsQ2xhc3M7XG5leHBvcnRzLnRvZ2dsZUVsQ2xhc3MgPSB0b2dnbGVFbENsYXNzO1xuZXhwb3J0cy5zZXRFbEF0dHJpYnV0ZXMgPSBzZXRFbEF0dHJpYnV0ZXM7XG5leHBvcnRzLmdldEVsQXR0cmlidXRlcyA9IGdldEVsQXR0cmlidXRlcztcbmV4cG9ydHMuYmxvY2tUZXh0U2VsZWN0aW9uID0gYmxvY2tUZXh0U2VsZWN0aW9uO1xuZXhwb3J0cy51bmJsb2NrVGV4dFNlbGVjdGlvbiA9IHVuYmxvY2tUZXh0U2VsZWN0aW9uO1xuZXhwb3J0cy5maW5kRWxQb3NpdGlvbiA9IGZpbmRFbFBvc2l0aW9uO1xuZXhwb3J0cy5nZXRQb2ludGVyUG9zaXRpb24gPSBnZXRQb2ludGVyUG9zaXRpb247XG5leHBvcnRzLmlzRWwgPSBpc0VsO1xuZXhwb3J0cy5pc1RleHROb2RlID0gaXNUZXh0Tm9kZTtcbmV4cG9ydHMuZW1wdHlFbCA9IGVtcHR5RWw7XG5leHBvcnRzLm5vcm1hbGl6ZUNvbnRlbnQgPSBub3JtYWxpemVDb250ZW50O1xuZXhwb3J0cy5hcHBlbmRDb250ZW50ID0gYXBwZW5kQ29udGVudDtcbmV4cG9ydHMuaW5zZXJ0Q29udGVudCA9IGluc2VydENvbnRlbnQ7XG5cbnZhciBfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydTZXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIHNlY29uZCBhcmd1bWVudCBvZiBjcmVhdGVFbCgpXFxuICAgICAgICAgICAgICAgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgdGhpcmQgYXJndW1lbnQgaW5zdGVhZC5cXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwodHlwZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykuIEF0dGVtcHRpbmcgdG8gc2V0ICcsICcgdG8gJywgJy4nXSwgWydTZXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIHNlY29uZCBhcmd1bWVudCBvZiBjcmVhdGVFbCgpXFxuICAgICAgICAgICAgICAgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgdGhpcmQgYXJndW1lbnQgaW5zdGVhZC5cXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwodHlwZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykuIEF0dGVtcHRpbmcgdG8gc2V0ICcsICcgdG8gJywgJy4nXSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykgeyBzdHJpbmdzLnJhdyA9IHJhdzsgcmV0dXJuIHN0cmluZ3M7IH1cblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfZ3VpZEpzID0gX2RlcmVxXygnLi9ndWlkLmpzJyk7XG5cbnZhciBHdWlkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2d1aWRKcyk7XG5cbnZhciBfbG9nSnMgPSBfZGVyZXFfKCcuL2xvZy5qcycpO1xuXG52YXIgX2xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ0pzKTtcblxudmFyIF90c21sID0gX2RlcmVxXygndHNtbCcpO1xuXG52YXIgX3RzbWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHNtbCk7XG5cbi8qKlxuICogRGV0ZWN0IGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgd2l0aCBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOb25CbGFua1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3Qoc3RyKTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBhc3NlZCBzdHJpbmcgaGFzIHdoaXRlc3BhY2UuIFRoaXMgaXMgdXNlZCBieVxuICogY2xhc3MgbWV0aG9kcyB0byBiZSByZWxhdGl2ZWx5IGNvbnNpc3RlbnQgd2l0aCB0aGUgY2xhc3NMaXN0IEFQSS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZldoaXRlc3BhY2Uoc3RyKSB7XG4gIGlmICgvXFxzLy50ZXN0KHN0cikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGhhcyBpbGxlZ2FsIHdoaXRlc3BhY2UgY2hhcmFjdGVycycpO1xuICB9XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgYSBjbGFzcyBuYW1lLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGNsYXNzUmVnRXhwKGNsYXNzTmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzTmFtZSArICcoJHxcXFxccyknKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGZ1bmN0aW9ucyB0byBxdWVyeSB0aGUgRE9NIHVzaW5nIGEgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVRdWVyaWVyXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U3RyaW5nfSBtZXRob2RcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVRdWVyaWVyKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc05vbkJsYW5rU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXVttZXRob2RdKG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNOb25CbGFua1N0cmluZyhjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5xdWVyeVNlbGVjdG9yKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gKGlzRWwoY29udGV4dCkgPyBjb250ZXh0IDogX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddKVttZXRob2RdKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKClcbiAqIEFsc28gYWxsb3dzIGZvciBDU1MgKGpRdWVyeSkgSUQgc3ludGF4LiBCdXQgbm90aGluZyBvdGhlciB0aGFuIElEcy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkICBFbGVtZW50IElEXG4gKiBAcmV0dXJuIHtFbGVtZW50fSAgICBFbGVtZW50IHdpdGggc3VwcGxpZWQgSURcbiAqIEBmdW5jdGlvbiBnZXRFbFxuICovXG5cbmZ1bmN0aW9uIGdldEVsKGlkKSB7XG4gIGlmIChpZC5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5nZXRFbGVtZW50QnlJZChpZCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBbdGFnTmFtZT0nZGl2J10gTmFtZSBvZiB0YWcgdG8gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSAge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIEVsZW1lbnQgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtICB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV0gRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogQGZ1bmN0aW9uIGNyZWF0ZUVsXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gIHZhciB0YWdOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJ2RpdicgOiBhcmd1bWVudHNbMF07XG4gIHZhciBwcm9wZXJ0aWVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG4gIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgdmFyIGVsID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgdmFsID0gcHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAvLyBTZWUgIzIxNzZcbiAgICAvLyBXZSBvcmlnaW5hbGx5IHdlcmUgYWNjZXB0aW5nIGJvdGggcHJvcGVydGllcyBhbmQgYXR0cmlidXRlcyBpbiB0aGVcbiAgICAvLyBzYW1lIG9iamVjdCwgYnV0IHRoYXQgZG9lc24ndCB3b3JrIHNvIHdlbGwuXG4gICAgaWYgKHByb3BOYW1lLmluZGV4T2YoJ2FyaWEtJykgIT09IC0xIHx8IHByb3BOYW1lID09PSAncm9sZScgfHwgcHJvcE5hbWUgPT09ICd0eXBlJykge1xuICAgICAgX2xvZ0pzMlsnZGVmYXVsdCddLndhcm4oX3RzbWwyWydkZWZhdWx0J10oX3RlbXBsYXRlT2JqZWN0LCBwcm9wTmFtZSwgdmFsKSk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcE5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsW3Byb3BOYW1lXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgdmFyIHZhbCA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cmlidXRlc1thdHRyTmFtZV0pO1xuICB9KTtcblxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogSW5qZWN0cyB0ZXh0IGludG8gYW4gZWxlbWVudCwgcmVwbGFjaW5nIGFueSBleGlzdGluZyBjb250ZW50cyBlbnRpcmVseS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogQGZ1bmN0aW9uIHRleHRDb250ZW50XG4gKi9cblxuZnVuY3Rpb24gdGV4dENvbnRlbnQoZWwsIHRleHQpIHtcbiAgaWYgKHR5cGVvZiBlbC50ZXh0Q29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbC5pbm5lclRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxufVxuXG4vKipcbiAqIEluc2VydCBhbiBlbGVtZW50IGFzIHRoZSBmaXJzdCBjaGlsZCBub2RlIG9mIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBjaGlsZCAgIEVsZW1lbnQgdG8gaW5zZXJ0XG4gKiBAcGFyYW0gIHtFbGVtZW50fSBwYXJlbnQgRWxlbWVudCB0byBpbnNlcnQgY2hpbGQgaW50b1xuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBpbnNlcnRFbEZpcnN0XG4gKi9cblxuZnVuY3Rpb24gaW5zZXJ0RWxGaXJzdChjaGlsZCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogRWxlbWVudCBEYXRhIFN0b3JlLiBBbGxvd3MgZm9yIGJpbmRpbmcgZGF0YSB0byBhbiBlbGVtZW50IHdpdGhvdXQgcHV0dGluZyBpdCBkaXJlY3RseSBvbiB0aGUgZWxlbWVudC5cbiAqIEV4LiBFdmVudCBsaXN0ZW5lcnMgYXJlIHN0b3JlZCBoZXJlLlxuICogKGFsc28gZnJvbSBqc25pbmphLmNvbSwgc2xpZ2h0bHkgbW9kaWZpZWQgYW5kIHVwZGF0ZWQgZm9yIGNsb3N1cmUgY29tcGlsZXIpXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbERhdGEgPSB7fTtcblxuLypcbiAqIFVuaXF1ZSBhdHRyaWJ1dGUgbmFtZSB0byBzdG9yZSBhbiBlbGVtZW50J3MgZ3VpZCBpblxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbElkQXR0ciA9ICd2ZGF0YScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgd2hlcmUgZGF0YSBmb3IgYW4gZWxlbWVudCBpcyBzdG9yZWRcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIHN0b3JlIGRhdGEgZm9yLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGZ1bmN0aW9uIGdldEVsRGF0YVxuICovXG5cbmZ1bmN0aW9uIGdldEVsRGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIGlkID0gZWxbZWxJZEF0dHJdID0gR3VpZC5uZXdHVUlEKCk7XG4gIH1cblxuICBpZiAoIWVsRGF0YVtpZF0pIHtcbiAgICBlbERhdGFbaWRdID0ge307XG4gIH1cblxuICByZXR1cm4gZWxEYXRhW2lkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgQSBkb20gZWxlbWVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gaGFzRWxEYXRhXG4gKi9cblxuZnVuY3Rpb24gaGFzRWxEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZWxEYXRhW2lkXSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIERlbGV0ZSBkYXRhIGZvciB0aGUgZWxlbWVudCBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIGd1aWQgYXR0ciBmcm9tIGdldEVsZW1lbnRCeUlkXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgUmVtb3ZlIGRhdGEgZm9yIGFuIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gcmVtb3ZlRWxEYXRhXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlRWxEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBzdG9yZWQgZGF0YVxuICBkZWxldGUgZWxEYXRhW2lkXTtcblxuICAvLyBSZW1vdmUgdGhlIGVsSWRBdHRyIHByb3BlcnR5IGZyb20gdGhlIERPTSBub2RlXG4gIHRyeSB7XG4gICAgZGVsZXRlIGVsW2VsSWRBdHRyXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShlbElkQXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIGRvZXNuJ3QgYXBwZWFyIHRvIHN1cHBvcnQgcmVtb3ZlQXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICBlbFtlbElkQXR0cl0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKlxuICogQGZ1bmN0aW9uIGhhc0VsQ2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NUb0NoZWNrIENsYXNzbmFtZSB0byBjaGVja1xuICovXG5cbmZ1bmN0aW9uIGhhc0VsQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0NoZWNrKSB7XG4gIHRocm93SWZXaGl0ZXNwYWNlKGNsYXNzVG9DaGVjayk7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc1RvQ2hlY2spO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjbGFzc1JlZ0V4cChjbGFzc1RvQ2hlY2spLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBmdW5jdGlvbiBhZGRFbENsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICovXG5cbmZ1bmN0aW9uIGFkZEVsQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NUb0FkZCk7XG5cbiAgICAvLyBEb24ndCBuZWVkIHRvIGB0aHJvd0lmV2hpdGVzcGFjZWAgaGVyZSBiZWNhdXNlIGBoYXNFbENsYXNzYCB3aWxsIGRvIGl0XG4gICAgLy8gaW4gdGhlIGNhc2Ugb2YgY2xhc3NMaXN0IG5vdCBiZWluZyBzdXBwb3J0ZWQuXG4gIH0gZWxzZSBpZiAoIWhhc0VsQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gKGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NUb0FkZCkudHJpbSgpO1xuICAgIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAZnVuY3Rpb24gcmVtb3ZlRWxDbGFzc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgIEVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gY2xhc3MgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9SZW1vdmUgQ2xhc3NuYW1lIHRvIHJlbW92ZVxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUVsQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1JlbW92ZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NUb1JlbW92ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dJZldoaXRlc3BhY2UoY2xhc3NUb1JlbW92ZSk7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgIT09IGNsYXNzVG9SZW1vdmU7XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAZnVuY3Rpb24gdG9nZ2xlRWxDbGFzc1xuICogQHBhcmFtICAgIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0gICAge1N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICogQHBhcmFtICAgIHtCb29sZWFufEZ1bmN0aW9ufSBbcHJlZGljYXRlXVxuICogICAgICAgICAgIENhbiBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIEJvb2xlYW4uIElmIGB0cnVlYCwgdGhlIGNsYXNzXG4gKiAgICAgICAgICAgd2lsbCBiZSBhZGRlZDsgaWYgYGZhbHNlYCwgdGhlIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgbm90XG4gKiAgICAgICAgICAgZ2l2ZW4sIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIGlmIG5vdCBwcmVzZW50IGFuZCB2aWNlIHZlcnNhLlxuICovXG5cbmZ1bmN0aW9uIHRvZ2dsZUVsQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKSB7XG5cbiAgLy8gVGhpcyBDQU5OT1QgdXNlIGBjbGFzc0xpc3RgIGludGVybmFsbHkgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICAvLyBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoZSBgY2xhc3NMaXN0LnRvZ2dsZSgpYCBtZXRob2QhIFdoaWNoIGlzIGZpbmUgYmVjYXVzZVxuICAvLyBgY2xhc3NMaXN0YCB3aWxsIGJlIHVzZWQgYnkgdGhlIGFkZC9yZW1vdmUgZnVuY3Rpb25zLlxuICB2YXIgaGFzID0gaGFzRWxDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZShlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnYm9vbGVhbicpIHtcbiAgICBwcmVkaWNhdGUgPSAhaGFzO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5lY2Vzc2FyeSBjbGFzcyBvcGVyYXRpb24gbWF0Y2hlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAgLy8gZWxlbWVudCwgbm8gYWN0aW9uIGlzIHJlcXVpcmVkLlxuICBpZiAocHJlZGljYXRlID09PSBoYXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJlZGljYXRlKSB7XG4gICAgYWRkRWxDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVFbENsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gZWwgICAgICAgICBUYXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSAge09iamVjdD19IGF0dHJpYnV0ZXMgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIHNldEVsQXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIHNldEVsQXR0cmlidXRlcyhlbCwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgIGlmIChhdHRyVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0clZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUgPT09IHRydWUgPyAnJyA6IGF0dHJWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSB0YWcgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCB0YWcgYXR0cmlidXRlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBnZXRFbEF0dHJpYnV0ZXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRFbEF0dHJpYnV0ZXModGFnKSB7XG4gIHZhciBvYmosIGtub3duQm9vbGVhbnMsIGF0dHJzLCBhdHRyTmFtZSwgYXR0clZhbDtcblxuICBvYmogPSB7fTtcblxuICAvLyBrbm93biBib29sZWFuIGF0dHJpYnV0ZXNcbiAgLy8gd2UgY2FuIGNoZWNrIGZvciBtYXRjaGluZyBib29sZWFuIHByb3BlcnRpZXMsIGJ1dCBvbGRlciBicm93c2Vyc1xuICAvLyB3b24ndCBrbm93IGFib3V0IEhUTUw1IGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IHdlIHN0aWxsIHJlYWQgZnJvbVxuICBrbm93bkJvb2xlYW5zID0gJywnICsgJ2F1dG9wbGF5LGNvbnRyb2xzLGxvb3AsbXV0ZWQsZGVmYXVsdCcgKyAnLCc7XG5cbiAgaWYgKHRhZyAmJiB0YWcuYXR0cmlidXRlcyAmJiB0YWcuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cnMgPSB0YWcuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGkgPSBhdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYXR0ck5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgYXR0clZhbCA9IGF0dHJzW2ldLnZhbHVlO1xuXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBlbGVtZW50IHByb3BlcnR5IHdpbGwgcmV0dXJuIGEgdmFsdWUgZm9yIHR5cGVvZlxuICAgICAgaWYgKHR5cGVvZiB0YWdbYXR0ck5hbWVdID09PSAnYm9vbGVhbicgfHwga25vd25Cb29sZWFucy5pbmRleE9mKCcsJyArIGF0dHJOYW1lICsgJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9ialthdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBibG9jayB0aGUgYWJpbGl0eSB0byBzZWxlY3QgdGV4dCB3aGlsZSBkcmFnZ2luZyBjb250cm9sc1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZnVuY3Rpb24gYmxvY2tUZXh0U2VsZWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gYmxvY2tUZXh0U2VsZWN0aW9uKCkge1xuICBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uYm9keS5mb2N1cygpO1xuICBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10ub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVHVybiBvZmYgdGV4dCBzZWxlY3Rpb24gYmxvY2tpbmdcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGZ1bmN0aW9uIHVuYmxvY2tUZXh0U2VsZWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gdW5ibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG4vKipcbiAqIE9mZnNldCBMZWZ0XG4gKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdGVjaG5pcXVlIGZyb21cbiAqIEpvaG4gUmVzaWcgaHR0cDovL2Vqb2huLm9yZy9ibG9nL2dldGJvdW5kaW5nY2xpZW50cmVjdC1pcy1hd2Vzb21lL1xuICpcbiAqIEBmdW5jdGlvbiBmaW5kRWxQb3NpdGlvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IGZyb20gd2hpY2ggdG8gZ2V0IG9mZnNldFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGZpbmRFbFBvc2l0aW9uKGVsKSB7XG4gIHZhciBib3ggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBpZiAoIWJveCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkb2NFbCA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBib2R5ID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmJvZHk7XG5cbiAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ucGFnZVhPZmZzZXQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cbiAgdmFyIGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICB2YXIgc2Nyb2xsVG9wID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5wYWdlWU9mZnNldCB8fCBib2R5LnNjcm9sbFRvcDtcbiAgdmFyIHRvcCA9IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XG5cbiAgLy8gQW5kcm9pZCBzb21ldGltZXMgcmV0dXJucyBzbGlnaHRseSBvZmYgZGVjaW1hbCB2YWx1ZXMsIHNvIG5lZWQgdG8gcm91bmRcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBNYXRoLnJvdW5kKGxlZnQpLFxuICAgIHRvcDogTWF0aC5yb3VuZCh0b3ApXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHBvaW50ZXIgcG9zaXRpb24gaW4gZWxlbWVudFxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuICogVGhlIGJhc2Ugb24gdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgYm90dG9tIGxlZnQgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IG9uIHdoaWNoIHRvIGdldCB0aGUgcG9pbnRlciBwb3NpdGlvbiBvblxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoaXMgb2JqZWN0IHdpbGwgaGF2ZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdXNlIHBvc2l0aW9uXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGVsLCBldmVudCkge1xuICB2YXIgcG9zaXRpb24gPSB7fTtcbiAgdmFyIGJveCA9IGZpbmRFbFBvc2l0aW9uKGVsKTtcbiAgdmFyIGJveFcgPSBlbC5vZmZzZXRXaWR0aDtcbiAgdmFyIGJveEggPSBlbC5vZmZzZXRIZWlnaHQ7XG5cbiAgdmFyIGJveFkgPSBib3gudG9wO1xuICB2YXIgYm94WCA9IGJveC5sZWZ0O1xuICB2YXIgcGFnZVkgPSBldmVudC5wYWdlWTtcbiAgdmFyIHBhZ2VYID0gZXZlbnQucGFnZVg7XG5cbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgcGFnZVggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICBwYWdlWSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICB9XG5cbiAgcG9zaXRpb24ueSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChib3hZIC0gcGFnZVkgKyBib3hIKSAvIGJveEgpKTtcbiAgcG9zaXRpb24ueCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChwYWdlWCAtIGJveFgpIC8gYm94VykpO1xuXG4gIHJldHVybiBwb3NpdGlvbjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gaXNFbFxuICogQHBhcmFtICAgIHtNaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4gICB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0VsKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSAge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1RleHROb2RlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUubm9kZVR5cGUgPT09IDM7XG59XG5cbi8qKlxuICogRW1wdGllcyB0aGUgY29udGVudHMgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gZW1wdHlFbFxuICogQHBhcmFtICAgIHtFbGVtZW50fSBlbFxuICogQHJldHVybiAgIHtFbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIGVtcHR5RWwoZWwpIHtcbiAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBjb250ZW50IGZvciBldmVudHVhbCBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICpcbiAqIFRoaXMgYWxsb3dzIGEgd2lkZSByYW5nZSBvZiBjb250ZW50IGRlZmluaXRpb24gbWV0aG9kcywgYnV0IHByb3RlY3RzXG4gKiBmcm9tIGZhbGxpbmcgaW50byB0aGUgdHJhcCBvZiBzaW1wbHkgd3JpdGluZyB0byBgaW5uZXJIVE1MYCwgd2hpY2ggaXNcbiAqIGFuIFhTUyBjb25jZXJuLlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogLSBTdHJpbmdcbiAqICAgTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICpcbiAqIC0gRWxlbWVudCwgVGV4dE5vZGVcbiAqICAgUGFzc2VkIHRocm91Z2guXG4gKlxuICogLSBBcnJheVxuICogICBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9ucyAod2hpY2hcbiAqICAgcmV0dXJuIHNpbmdsZSBzdHJpbmdzLCBlbGVtZW50cywgb3Igbm9kZXMpLlxuICpcbiAqIC0gRnVuY3Rpb25cbiAqICAgSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgIG5vZGUsIG9yIGFycmF5LlxuICpcbiAqIEBmdW5jdGlvbiBub3JtYWxpemVDb250ZW50XG4gKiBAcGFyYW0gICAge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiBAcmV0dXJuICAge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkge1xuXG4gIC8vIEZpcnN0LCBpbnZva2UgY29udGVudCBpZiBpdCBpcyBhIGZ1bmN0aW9uLiBJZiBpdCBwcm9kdWNlcyBhbiBhcnJheSxcbiAgLy8gdGhhdCBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIG5vcm1hbGl6YXRpb24uXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50KCk7XG4gIH1cblxuICAvLyBOZXh0IHVwLCBub3JtYWxpemUgdG8gYW4gYXJyYXksIHNvIG9uZSBvciBtYW55IGl0ZW1zIGNhbiBiZSBub3JtYWxpemVkLFxuICAvLyBmaWx0ZXJlZCwgYW5kIHJldHVybmVkLlxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAvLyBGaXJzdCwgaW52b2tlIHZhbHVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyB2YWx1ZSxcbiAgICAvLyB3aGljaCB3aWxsIGJlIHN1YnNlcXVlbnRseSBub3JtYWxpemVkIHRvIGEgTm9kZSBvZiBzb21lIGtpbmQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc0VsKHZhbHVlKSB8fCBpc1RleHROb2RlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICB9XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW5kIGFwcGVuZHMgY29udGVudCB0byBhbiBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBhcHBlbmRDb250ZW50XG4gKiBAcGFyYW0gICAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gICAge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgICAgU2VlOiBgbm9ybWFsaXplQ29udGVudGBcbiAqIEByZXR1cm4gICB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgfSk7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBpbnNlcnRzIGNvbnRlbnQgaW50byBhbiBlbGVtZW50OyB0aGlzIGlzIGlkZW50aWNhbCB0b1xuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxuICpcbiAqIEBmdW5jdGlvbiBpbnNlcnRDb250ZW50XG4gKiBAcGFyYW0gICAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gICAge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgICAgU2VlOiBgbm9ybWFsaXplQ29udGVudGBcbiAqIEByZXR1cm4gICB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBpbnNlcnRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIHJldHVybiBhcHBlbmRDb250ZW50KGVtcHR5RWwoZWwpLCBjb250ZW50KTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHNpbmdsZSBET00gZWxlbWVudCBtYXRjaGluZyBgc2VsZWN0b3JgIHdpdGhpbiB0aGUgb3B0aW9uYWxcbiAqIGBjb250ZXh0YCBvZiBhbm90aGVyIERPTSBlbGVtZW50IChkZWZhdWx0aW5nIHRvIGBkb2N1bWVudGApLlxuICpcbiAqIEBmdW5jdGlvbiAkXG4gKiBAcGFyYW0gICAge1N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSAgICB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiAgIHtFbGVtZW50fG51bGx9XG4gKi9cbnZhciAkID0gY3JlYXRlUXVlcmllcigncXVlcnlTZWxlY3RvcicpO1xuXG5leHBvcnRzLiQgPSAkO1xuLyoqXG4gKiBGaW5kcyBhIGFsbCBET00gZWxlbWVudHMgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAZnVuY3Rpb24gJCRcbiAqIEBwYXJhbSAgICB7U3RyaW5nfSBzZWxlY3RvclxuICogICAgICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGAuXG4gKlxuICogQHBhcmFtICAgIHtFbGVtZW50fFN0cmluZ30gW2NvbnRleHQ9ZG9jdW1lbnRdXG4gKiAgICAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3JcbiAqICAgICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcbiAqICAgICAgICAgICBhcyBjb250ZXh0LiBJZiBtaXNzaW5nIChvciBubyBlbGVtZW50IG1hdGNoZXMgc2VsZWN0b3IpLCBmYWxsc1xuICogICAgICAgICAgIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAqXG4gKiBAcmV0dXJuICAge05vZGVMaXN0fVxuICovXG52YXIgJCQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yQWxsJyk7XG5leHBvcnRzLiQkID0gJCQ7XG5cbn0se1wiLi9ndWlkLmpzXCI6MTQ2LFwiLi9sb2cuanNcIjoxNDcsXCJnbG9iYWwvZG9jdW1lbnRcIjoxLFwiZ2xvYmFsL3dpbmRvd1wiOjIsXCJ0c21sXCI6NTV9XSwxNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBldmVudHMuanNcbiAqXG4gKiBFdmVudCBTeXN0ZW0gKEpvaG4gUmVzaWcgLSBTZWNyZXRzIG9mIGEgSlMgTmluamEgaHR0cDovL2pzbmluamEuY29tLylcbiAqIChPcmlnaW5hbCBib29rIHZlcnNpb24gd2Fzbid0IGNvbXBsZXRlbHkgdXNhYmxlLCBzbyBmaXhlZCBzb21lIHRoaW5ncyBhbmQgbWFkZSBDbG9zdXJlIENvbXBpbGVyIGNvbXBhdGlibGUpXG4gKiBUaGlzIHNob3VsZCB3b3JrIHZlcnkgc2ltaWxhcmx5IHRvIGpRdWVyeSdzIGV2ZW50cywgaG93ZXZlciBpdCdzIGJhc2VkIG9mZiB0aGUgYm9vayB2ZXJzaW9uIHdoaWNoIGlzbid0IGFzXG4gKiByb2J1c3QgYXMganF1ZXJ5J3MsIHNvIHRoZXJlJ3MgcHJvYmFibHkgc29tZSBkaWZmZXJlbmNlcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLm9uID0gb247XG5leHBvcnRzLm9mZiA9IG9mZjtcbmV4cG9ydHMudHJpZ2dlciA9IHRyaWdnZXI7XG5leHBvcnRzLm9uZSA9IG9uZTtcbmV4cG9ydHMuZml4RXZlbnQgPSBmaXhFdmVudDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgX2RvbUpzID0gX2RlcmVxXygnLi9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9kb21Kcyk7XG5cbnZhciBfZ3VpZEpzID0gX2RlcmVxXygnLi9ndWlkLmpzJyk7XG5cbnZhciBHdWlkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2d1aWRKcyk7XG5cbnZhciBfbG9nSnMgPSBfZGVyZXFfKCcuL2xvZy5qcycpO1xuXG52YXIgX2xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ0pzKTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQgPSBfZGVyZXFfKCdnbG9iYWwvZG9jdW1lbnQnKTtcblxudmFyIF9nbG9iYWxEb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxEb2N1bWVudCk7XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICB0eXBlIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIEV2ZW50IGxpc3RlbmVyLlxuICogQG1ldGhvZCBvblxuICovXG5cbmZ1bmN0aW9uIG9uKGVsZW0sIHR5cGUsIGZuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbiwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBEb20uZ2V0RWxEYXRhKGVsZW0pO1xuXG4gIC8vIFdlIG5lZWQgYSBwbGFjZSB0byBzdG9yZSBhbGwgb3VyIGhhbmRsZXIgZGF0YVxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIGRhdGEuaGFuZGxlcnMgPSB7fTtcblxuICBpZiAoIWRhdGEuaGFuZGxlcnNbdHlwZV0pIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBbXTtcblxuICBpZiAoIWZuLmd1aWQpIGZuLmd1aWQgPSBHdWlkLm5ld0dVSUQoKTtcblxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xuXG4gIGlmICghZGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5kaXNwYXRjaGVyID0gZnVuY3Rpb24gKGV2ZW50LCBoYXNoKSB7XG5cbiAgICAgIGlmIChkYXRhLmRpc2FibGVkKSByZXR1cm47XG4gICAgICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAgICAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1tldmVudC50eXBlXTtcblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIC8vIENvcHkgaGFuZGxlcnMgc28gaWYgaGFuZGxlcnMgYXJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIHRoZSBwcm9jZXNzIGl0IGRvZXNuJ3QgdGhyb3cgZXZlcnl0aGluZyBvZmYuXG4gICAgICAgIHZhciBoYW5kbGVyc0NvcHkgPSBoYW5kbGVycy5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBtID0gMCwgbiA9IGhhbmRsZXJzQ29weS5sZW5ndGg7IG0gPCBuOyBtKyspIHtcbiAgICAgICAgICBpZiAoZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzQ29weVttXS5jYWxsKGVsZW0sIGV2ZW50LCBoYXNoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgX2xvZ0pzMlsnZGVmYXVsdCddLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBkYXRhLmRpc3BhdGNoZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbVxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5PX0gICB0eXBlIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudCB0eXBlLlxuICogQG1ldGhvZCBvZmZcbiAqL1xuXG5mdW5jdGlvbiBvZmYoZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXRFbERhdGEgaWYgbm90IG5lZWRlZFxuICBpZiAoIURvbS5oYXNFbERhdGEoZWxlbSkpIHJldHVybjtcblxuICB2YXIgZGF0YSA9IERvbS5nZXRFbERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24gcmVtb3ZlVHlwZSh0KSB7XG4gICAgZGF0YS5oYW5kbGVyc1t0XSA9IFtdO1xuICAgIF9jbGVhblVwRXZlbnRzKGVsZW0sIHQpO1xuICB9O1xuXG4gIC8vIEFyZSB3ZSByZW1vdmluZyBhbGwgYm91bmQgZXZlbnRzP1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKHZhciB0IGluIGRhdGEuaGFuZGxlcnMpIHtcbiAgICAgIHJlbW92ZVR5cGUodCk7XG4gICAgfXJldHVybjtcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbdHlwZV07XG5cbiAgLy8gSWYgbm8gaGFuZGxlcnMgZXhpc3QsIG5vdGhpbmcgdG8gdW5iaW5kXG4gIGlmICghaGFuZGxlcnMpIHJldHVybjtcblxuICAvLyBJZiBubyBsaXN0ZW5lciB3YXMgcHJvdmlkZWQsIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0eXBlXG4gIGlmICghZm4pIHtcbiAgICByZW1vdmVUeXBlKHR5cGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdlJ3JlIG9ubHkgcmVtb3ZpbmcgYSBzaW5nbGUgaGFuZGxlclxuICBpZiAoZm4uZ3VpZCkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaGFuZGxlcnMubGVuZ3RoOyBuKyspIHtcbiAgICAgIGlmIChoYW5kbGVyc1tuXS5ndWlkID09PSBmbi5ndWlkKSB7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShuLS0sIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jbGVhblVwRXZlbnRzKGVsZW0sIHR5cGUpO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gICAgICBlbGVtICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cbiAqIEBwYXJhbSAge0V2ZW50fE9iamVjdHxTdHJpbmd9IGV2ZW50IEEgc3RyaW5nICh0aGUgdHlwZSkgb3IgYW4gZXZlbnQgb2JqZWN0IHdpdGggYSB0eXBlIGF0dHJpYnV0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBbaGFzaF0gZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW49fSBSZXR1cm5lZCBvbmx5IGlmIGRlZmF1bHQgd2FzIHByZXZlbnRlZFxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKi9cblxuZnVuY3Rpb24gdHJpZ2dlcihlbGVtLCBldmVudCwgaGFzaCkge1xuICAvLyBGZXRjaGVzIGVsZW1lbnQgZGF0YSBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCAoZm9yIGJ1YmJsaW5nKS5cbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBkYXRhIG9iamVjdCB0byBjYWNoZSBmb3IgZXZlcnkgcGFyZW50LFxuICAvLyBzbyBjaGVja2luZyBoYXNFbERhdGEgZmlyc3QuXG4gIHZhciBlbGVtRGF0YSA9IERvbS5oYXNFbERhdGEoZWxlbSkgPyBEb20uZ2V0RWxEYXRhKGVsZW0pIDoge307XG4gIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUgfHwgZWxlbS5vd25lckRvY3VtZW50O1xuICAvLyB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudCxcbiAgLy8gaGFuZGxlcjtcblxuICAvLyBJZiBhbiBldmVudCBuYW1lIHdhcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGNyZWF0ZXMgYW4gZXZlbnQgb3V0IG9mIGl0XG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6IGV2ZW50LCB0YXJnZXQ6IGVsZW0gfTtcbiAgfVxuICAvLyBOb3JtYWxpemVzIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAvLyBJZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIGEgZGlzcGF0Y2hlciwgZXhlY3V0ZXMgdGhlIGVzdGFibGlzaGVkIGhhbmRsZXJzLlxuICBpZiAoZWxlbURhdGEuZGlzcGF0Y2hlcikge1xuICAgIGVsZW1EYXRhLmRpc3BhdGNoZXIuY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gIH1cblxuICAvLyBVbmxlc3MgZXhwbGljaXRseSBzdG9wcGVkIG9yIHRoZSBldmVudCBkb2VzIG5vdCBidWJibGUgKGUuZy4gbWVkaWEgZXZlbnRzKVxuICAvLyByZWN1cnNpdmVseSBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIERPTS5cbiAgaWYgKHBhcmVudCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBldmVudC5idWJibGVzID09PSB0cnVlKSB7XG4gICAgdHJpZ2dlci5jYWxsKG51bGwsIHBhcmVudCwgZXZlbnQsIGhhc2gpO1xuXG4gICAgLy8gSWYgYXQgdGhlIHRvcCBvZiB0aGUgRE9NLCB0cmlnZ2VycyB0aGUgZGVmYXVsdCBhY3Rpb24gdW5sZXNzIGRpc2FibGVkLlxuICB9IGVsc2UgaWYgKCFwYXJlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHZhciB0YXJnZXREYXRhID0gRG9tLmdldEVsRGF0YShldmVudC50YXJnZXQpO1xuXG4gICAgICAvLyBDaGVja3MgaWYgdGhlIHRhcmdldCBoYXMgYSBkZWZhdWx0IGFjdGlvbiBmb3IgdGhpcyBldmVudC5cbiAgICAgIGlmIChldmVudC50YXJnZXRbZXZlbnQudHlwZV0pIHtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcgb24gdGhlIHRhcmdldCBhcyB3ZSBoYXZlIGFscmVhZHkgZXhlY3V0ZWQgdGhlIGhhbmRsZXIuXG4gICAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAvLyBFeGVjdXRlcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtZW5hYmxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAgICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAvLyBJbmZvcm0gdGhlIHRyaWdnZXJlciBpZiB0aGUgZGVmYXVsdCB3YXMgcHJldmVudGVkIGJ5IHJldHVybmluZyBmYWxzZVxuICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gICBlbGVtIEVsZW1lbnQgb3Igb2JqZWN0IHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9ICAgdHlwZSBOYW1lL3R5cGUgb2YgZXZlbnRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAbWV0aG9kIG9uZVxuICovXG5cbmZ1bmN0aW9uIG9uZShlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob25lLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIG9mZihlbGVtLCB0eXBlLCBmdW5jKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICAvLyBjb3B5IHRoZSBndWlkIHRvIHRoZSBuZXcgZnVuY3Rpb24gc28gaXQgY2FuIHJlbW92ZWQgdXNpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uJ3MgSURcbiAgZnVuYy5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgR3VpZC5uZXdHVUlEKCk7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufVxuXG4vKipcbiAqIEZpeCBhIG5hdGl2ZSBldmVudCB0byBoYXZlIHN0YW5kYXJkIHByb3BlcnR5IHZhbHVlc1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0IHRvIGZpeFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgZml4RXZlbnRcbiAqL1xuXG5mdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBmaXhpbmcgdXAgaXMgbmVlZGVkXG4gIC8vIFVzZWQgdG8gY2hlY2sgaWYgIWV2ZW50LnN0b3BQcm9wYWdhdGlvbiBpbnN0ZWFkIG9mIGlzUHJvcGFnYXRpb25TdG9wcGVkXG4gIC8vIEJ1dCBuYXRpdmUgZXZlbnRzIHJldHVybiB0cnVlIGZvciBzdG9wUHJvcGFnYXRpb24sIGJ1dCBkb24ndCBoYXZlXG4gIC8vIG90aGVyIGV4cGVjdGVkIG1ldGhvZHMgbGlrZSBpc1Byb3BhZ2F0aW9uU3RvcHBlZC4gU2VlbXMgdG8gYmUgYSBwcm9ibGVtXG4gIC8vIHdpdGggdGhlIEphdmFzY3JpcHQgTmluamEgY29kZS4gU28gd2UncmUganVzdCBvdmVycmlkaW5nIGFsbCBldmVudHMgbm93LlxuICBpZiAoIWV2ZW50IHx8ICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgIHZhciBvbGQgPSBldmVudCB8fCBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmV2ZW50O1xuXG4gICAgZXZlbnQgPSB7fTtcbiAgICAvLyBDbG9uZSB0aGUgb2xkIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgdGhlIHZhbHVlcyBldmVudCA9IHt9O1xuICAgIC8vIElFOCBEb2Vzbid0IGxpa2Ugd2hlbiB5b3UgbWVzcyB3aXRoIG5hdGl2ZSBldmVudCBwcm9wZXJ0aWVzXG4gICAgLy8gRmlyZWZveCByZXR1cm5zIGZhbHNlIGZvciBldmVudC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpIGFuZCBvdGhlciBwcm9wc1xuICAgIC8vICB3aGljaCBtYWtlcyBjb3B5aW5nIG1vcmUgZGlmZmljdWx0LlxuICAgIC8vIFRPRE86IFByb2JhYmx5IGJlc3QgdG8gY3JlYXRlIGEgd2hpdGVsaXN0IG9mIGV2ZW50IHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9sZCkge1xuICAgICAgLy8gU2FmYXJpIDYuMC4zIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBsYXllclgvWVxuICAgICAgLy8gQ2hyb21lIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBrZXlib2FyZEV2ZW50LmtleUxvY2F0aW9uXG4gICAgICAvLyBhbmQgd2Via2l0TW92ZW1lbnRYL1lcbiAgICAgIGlmIChrZXkgIT09ICdsYXllclgnICYmIGtleSAhPT0gJ2xheWVyWScgJiYga2V5ICE9PSAna2V5TG9jYXRpb24nICYmIGtleSAhPT0gJ3dlYmtpdE1vdmVtZW50WCcgJiYga2V5ICE9PSAnd2Via2l0TW92ZW1lbnRZJykge1xuICAgICAgICAvLyBDaHJvbWUgMzIrIHdhcm5zIGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIHJldHVyblZhbHVlLCBidXRcbiAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBpZiBwcmV2ZW50RGVmYXVsdCBpc24ndCBzdXBwb3J0ZWQgKElFOCkuXG4gICAgICAgIGlmICghKGtleSA9PT0gJ3JldHVyblZhbHVlJyAmJiBvbGQucHJldmVudERlZmF1bHQpKSB7XG4gICAgICAgICAgZXZlbnRba2V5XSA9IG9sZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGV2ZW50IG9jY3VycmVkIG9uIHRoaXMgZWxlbWVudFxuICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2hpY2ggb3RoZXIgZWxlbWVudCB0aGUgZXZlbnQgaXMgcmVsYXRlZCB0b1xuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIG9sZC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIG9sZC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmdcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgb2xkLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nIGFuZCBleGVjdXRpbmcgb3RoZXIgaGFuZGxlcnNcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBwb3NpdGlvblxuICAgIGlmIChldmVudC5jbGllbnRYICE9IG51bGwpIHtcbiAgICAgIHZhciBkb2MgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgIGJvZHkgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uYm9keTtcblxuICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXkgcHJlc3Nlc1xuICAgIGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcblxuICAgIC8vIEZpeCBidXR0b24gZm9yIG1vdXNlIGNsaWNrczpcbiAgICAvLyAwID09IGxlZnQ7IDEgPT0gbWlkZGxlOyAyID09IHJpZ2h0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSBudWxsKSB7XG4gICAgICBldmVudC5idXR0b24gPSBldmVudC5idXR0b24gJiAxID8gMCA6IGV2ZW50LmJ1dHRvbiAmIDQgPyAxIDogZXZlbnQuYnV0dG9uICYgMiA/IDIgOiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgZml4ZWQtdXAgaW5zdGFuY2VcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBsaXN0ZW5lciBjYWNoZSBhbmQgZGlzcGF0Y2hlcnNcbipcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEVsZW1lbnQgdG8gY2xlYW4gdXBcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSBUeXBlIG9mIGV2ZW50IHRvIGNsZWFuIHVwXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfY2xlYW5VcEV2ZW50c1xuICovXG5mdW5jdGlvbiBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKSB7XG4gIHZhciBkYXRhID0gRG9tLmdldEVsRGF0YShlbGVtKTtcblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvZiBhIHBhcnRpY3VsYXIgdHlwZSBpZiB0aGVyZSBhcmUgbm9uZSBsZWZ0XG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xuICAgIC8vIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBudWxsO1xuICAgIC8vIFNldHRpbmcgdG8gbnVsbCB3YXMgY2F1c2luZyBhbiBlcnJvciB3aXRoIGRhdGEuaGFuZGxlcnNcblxuICAgIC8vIFJlbW92ZSB0aGUgbWV0YS1oYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBkYXRhLmRpc3BhdGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gdHlwZXMgbGVmdFxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YS5oYW5kbGVycykubGVuZ3RoIDw9IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVycztcbiAgICBkZWxldGUgZGF0YS5kaXNwYXRjaGVyO1xuICAgIGRlbGV0ZSBkYXRhLmRpc2FibGVkO1xuICB9XG5cbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGVsZW1lbnQgZGF0YSBpZiB0aGVyZSBpcyBubyBkYXRhIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgIERvbS5yZW1vdmVFbERhdGEoZWxlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIFRoZSBldmVudCBtZXRob2Qgd2Ugd2FudCB0byB1c2UuXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gZWxlbSBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICogQHBhcmFtICB7U3RyaW5nfSAgIHR5cGUgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAgRXZlbnQgbGlzdGVuZXIuXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50c1xuICovXG5mdW5jdGlvbiBfaGFuZGxlTXVsdGlwbGVFdmVudHMoZm4sIGVsZW0sIHR5cGVzLCBjYWxsYmFjaykge1xuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgLy9DYWxsIHRoZSBldmVudCBtZXRob2QgZm9yIGVhY2ggb25lIG9mIHRoZSB0eXBlc1xuICAgIGZuKGVsZW0sIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbn0se1wiLi9kb20uanNcIjoxNDIsXCIuL2d1aWQuanNcIjoxNDYsXCIuL2xvZy5qc1wiOjE0NyxcImdsb2JhbC9kb2N1bWVudFwiOjEsXCJnbG9iYWwvd2luZG93XCI6Mn1dLDE0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGZuLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ndWlkSnMgPSBfZGVyZXFfKCcuL2d1aWQuanMnKTtcblxuLyoqXG4gKiBCaW5kIChhLmsuYSBwcm94eSBvciBDb250ZXh0KS4gQSBzaW1wbGUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgY29udGV4dCBvZiBhIGZ1bmN0aW9uXG4gKiBJdCBhbHNvIHN0b3JlcyBhIHVuaXF1ZSBpZCBvbiB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGZyb20gZXZlbnRzXG4gKlxuICogQHBhcmFtICB7Kn0gICBjb250ZXh0IFRoZSBvYmplY3QgdG8gYmluZCBhcyBzY29wZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGJvdW5kIHRvIGEgc2NvcGVcbiAqIEBwYXJhbSAge051bWJlcj19ICAgdWlkICAgICBBbiBvcHRpb25hbCB1bmlxdWUgSUQgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYmluZFxuICovXG52YXIgYmluZCA9IGZ1bmN0aW9uIGJpbmQoY29udGV4dCwgZm4sIHVpZCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZ1bmN0aW9uIGhhcyBhIHVuaXF1ZSBJRFxuICBpZiAoIWZuLmd1aWQpIHtcbiAgICBmbi5ndWlkID0gX2d1aWRKcy5uZXdHVUlEKCk7XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5ldyBmdW5jdGlvbiB0aGF0IGNoYW5nZXMgdGhlIGNvbnRleHRcbiAgdmFyIHJldCA9IGZ1bmN0aW9uIHJldCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBbGxvdyBmb3IgdGhlIGFiaWxpdHkgdG8gaW5kaXZpZHVhbGl6ZSB0aGlzIGZ1bmN0aW9uXG4gIC8vIE5lZWRlZCBpbiB0aGUgY2FzZSB3aGVyZSBtdWx0aXBsZSBvYmplY3RzIG1pZ2h0IHNoYXJlIHRoZSBzYW1lIHByb3RvdHlwZVxuICAvLyBJRiBib3RoIGl0ZW1zIGFkZCBhbiBldmVudCBsaXN0ZW5lciB3aXRoIHRoZSBzYW1lIGZ1bmN0aW9uLCB0aGVuIHlvdSB0cnkgdG8gcmVtb3ZlIGp1c3Qgb25lXG4gIC8vIGl0IHdpbGwgcmVtb3ZlIGJvdGggYmVjYXVzZSB0aGV5IGJvdGggaGF2ZSB0aGUgc2FtZSBndWlkLlxuICAvLyB3aGVuIHVzaW5nIHRoaXMsIHlvdSBuZWVkIHRvIHVzZSB0aGUgYmluZCBtZXRob2Qgd2hlbiB5b3UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhcyB3ZWxsLlxuICAvLyBjdXJyZW50bHkgdXNlZCBpbiB0ZXh0IHRyYWNrc1xuICByZXQuZ3VpZCA9IHVpZCA/IHVpZCArICdfJyArIGZuLmd1aWQgOiBmbi5ndWlkO1xuXG4gIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5iaW5kID0gYmluZDtcblxufSx7XCIuL2d1aWQuanNcIjoxNDZ9XSwxNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBmb3JtYXQtdGltZS5qc1xuICpcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTU1xuICogU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICogdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNlY29uZHMgTnVtYmVyIG9mIHNlY29uZHMgdG8gYmUgdHVybmVkIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSAge051bWJlcn0gZ3VpZGUgICBOdW1iZXIgKGluIHNlY29uZHMpIHRvIG1vZGVsIHRoZSBzdHJpbmcgYWZ0ZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBUaW1lIGZvcm1hdHRlZCBhcyBIOk1NOlNTIG9yIE06U1NcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gZm9ybWF0VGltZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBmb3JtYXRUaW1lKHNlY29uZHMpIHtcbiAgdmFyIGd1aWRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gc2Vjb25kcyA6IGFyZ3VtZW50c1sxXTtcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgPCAwID8gMCA6IHNlY29uZHM7XG4gICAgdmFyIHMgPSBNYXRoLmZsb29yKHNlY29uZHMgJSA2MCk7XG4gICAgdmFyIG0gPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCAlIDYwKTtcbiAgICB2YXIgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICAgIHZhciBnbSA9IE1hdGguZmxvb3IoZ3VpZGUgLyA2MCAlIDYwKTtcbiAgICB2YXIgZ2ggPSBNYXRoLmZsb29yKGd1aWRlIC8gMzYwMCk7XG5cbiAgICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xuICAgIGlmIChpc05hTihzZWNvbmRzKSB8fCBzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgICAgLy8gJy0nIGlzIGZhbHNlIGZvciBhbGwgcmVsYXRpb25hbCBvcGVyYXRvcnMgKGUuZy4gPCwgPj0pIHNvIHRoaXMgc2V0dGluZ1xuICAgICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXG4gICAgICBoID0gbSA9IHMgPSAnLSc7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGhvdXJzXG4gICAgaCA9IGggPiAwIHx8IGdoID4gMCA/IGggKyAnOicgOiAnJztcblxuICAgIC8vIElmIGhvdXJzIGFyZSBzaG93aW5nLCB3ZSBtYXkgbmVlZCB0byBhZGQgYSBsZWFkaW5nIHplcm8uXG4gICAgLy8gQWx3YXlzIHNob3cgYXQgbGVhc3Qgb25lIGRpZ2l0IG9mIG1pbnV0ZXMuXG4gICAgbSA9ICgoaCB8fCBnbSA+PSAxMCkgJiYgbSA8IDEwID8gJzAnICsgbSA6IG0pICsgJzonO1xuXG4gICAgLy8gQ2hlY2sgaWYgbGVhZGluZyB6ZXJvIGlzIG5lZWQgZm9yIHNlY29uZHNcbiAgICBzID0gcyA8IDEwID8gJzAnICsgcyA6IHM7XG5cbiAgICByZXR1cm4gaCArIG0gKyBzO1xuICB9KSgpO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmb3JtYXRUaW1lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se31dLDE0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGd1aWQuanNcbiAqXG4gKiBVbmlxdWUgSUQgZm9yIGFuIGVsZW1lbnQgb3IgZnVuY3Rpb25cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubmV3R1VJRCA9IG5ld0dVSUQ7XG52YXIgX2d1aWQgPSAxO1xuXG4vKipcbiAqIEdldCB0aGUgbmV4dCB1bmlxdWUgSURcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFxuICogQGZ1bmN0aW9uIG5ld0dVSURcbiAqL1xuXG5mdW5jdGlvbiBuZXdHVUlEKCkge1xuICByZXR1cm4gX2d1aWQrKztcbn1cblxufSx7fV0sMTQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgbG9nLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IF9kZXJlcV8oJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF9icm93c2VyID0gX2RlcmVxXygnLi9icm93c2VyJyk7XG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlIGFuZCBoaXN0b3J5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbnNvbGUgbWV0aG9kIHRvIHVzZS5cbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBtYXRjaGluZyBjb25zb2xlIG1ldGhvZC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpbmdpZnldXG4gKiAgICAgICAgIEJ5IGRlZmF1bHQsIG9ubHkgb2xkIElFcyBzaG91bGQgZ2V0IGNvbnNvbGUgYXJndW1lbnQgc3RyaW5naWZpY2F0aW9uLFxuICogICAgICAgICBidXQgdGhpcyBpcyBleHBvc2VkIGFzIGEgcGFyYW1ldGVyIHRvIGZhY2lsaXRhdGUgdGVzdGluZy5cbiAqL1xudmFyIGxvZ0J5VHlwZSA9IGZ1bmN0aW9uIGxvZ0J5VHlwZSh0eXBlLCBhcmdzKSB7XG4gIHZhciBzdHJpbmdpZnkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAhIV9icm93c2VyLklFX1ZFUlNJT04gJiYgX2Jyb3dzZXIuSUVfVkVSU0lPTiA8IDExIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBjb25zb2xlID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5jb25zb2xlO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gY29uc29sZSB0aGVuIGRvbid0IHRyeSB0byBvdXRwdXQgbWVzc2FnZXMsIGJ1dCB0aGV5IHdpbGxcbiAgLy8gc3RpbGwgYmUgc3RvcmVkIGluIGBsb2cuaGlzdG9yeWAuXG4gIC8vXG4gIC8vIFdhcyBzZXR0aW5nIHRoZXNlIG9uY2Ugb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgY29udGFpbmluZyB0aGVtXG4gIC8vIGluIHRoZSBmdW5jdGlvbiBtYWtlcyBpdCBlYXNpZXIgdG8gdGVzdCBjYXNlcyB3aGVyZSBjb25zb2xlIGRvZXNuJ3QgZXhpc3RcbiAgLy8gd2hlbiB0aGUgbW9kdWxlIGlzIGV4ZWN1dGVkLlxuICB2YXIgZm4gPSBjb25zb2xlICYmIGNvbnNvbGVbdHlwZV0gfHwgZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKHR5cGUgIT09ICdsb2cnKSB7XG5cbiAgICAvLyBhZGQgdGhlIHR5cGUgdG8gdGhlIGZyb250IG9mIHRoZSBtZXNzYWdlIHdoZW4gaXQncyBub3QgXCJsb2dcIlxuICAgIGFyZ3MudW5zaGlmdCh0eXBlLnRvVXBwZXJDYXNlKCkgKyAnOicpO1xuICB9XG5cbiAgLy8gYWRkIHRvIGhpc3RvcnlcbiAgbG9nLmhpc3RvcnkucHVzaChhcmdzKTtcblxuICAvLyBhZGQgY29uc29sZSBwcmVmaXggYWZ0ZXIgYWRkaW5nIHRvIGhpc3RvcnlcbiAgYXJncy51bnNoaWZ0KCdWSURFT0pTOicpO1xuXG4gIC8vIElFcyBwcmV2aW91cyB0byAxMSBsb2cgb2JqZWN0cyB1c2VsZXNzbHkgYXMgXCJbb2JqZWN0IE9iamVjdF1cIjsgc28sIEpTT05pZnlcbiAgLy8gb2JqZWN0cyBhbmQgYXJyYXlzIGZvciB0aG9zZSBsZXNzLWNhcGFibGUgYnJvd3NlcnMuXG4gIGlmIChzdHJpbmdpZnkpIHtcbiAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGlmIChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgfVxuXG4gICAgICAvLyBDYXN0IHRvIHN0cmluZyBiZWZvcmUgam9pbmluZywgc28gd2UgZ2V0IG51bGwgYW5kIHVuZGVmaW5lZCBleHBsaWNpdGx5XG4gICAgICAvLyBpbmNsdWRlZCBpbiBvdXRwdXQgKGFzIHdlIHdvdWxkIGluIGEgbW9kZXJuIGNvbnNvbGUpLlxuICAgICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICAvLyBPbGQgSUUgdmVyc2lvbnMgZG8gbm90IGFsbG93IC5hcHBseSgpIGZvciBjb25zb2xlIG1ldGhvZHMgKHRoZXkgYXJlXG4gIC8vIHJlcG9ydGVkIGFzIG9iamVjdHMgcmF0aGVyIHRoYW4gZnVuY3Rpb25zKS5cbiAgaWYgKCFmbi5hcHBseSkge1xuICAgIGZuKGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGZuW0FycmF5LmlzQXJyYXkoYXJncykgPyAnYXBwbHknIDogJ2NhbGwnXShjb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcblxuZXhwb3J0cy5sb2dCeVR5cGUgPSBsb2dCeVR5cGU7XG4vKipcbiAqIExvZyBwbGFpbiBkZWJ1ZyBtZXNzYWdlc1xuICpcbiAqIEBmdW5jdGlvbiBsb2dcbiAqL1xuZnVuY3Rpb24gbG9nKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2dCeVR5cGUoJ2xvZycsIGFyZ3MpO1xufVxuXG4vKipcbiAqIEtlZXAgYSBoaXN0b3J5IG9mIGxvZyBtZXNzYWdlc1xuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xubG9nLmhpc3RvcnkgPSBbXTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgbWVzc2FnZXNcbiAqXG4gKiBAbWV0aG9kIGVycm9yXG4gKi9cbmxvZy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCdlcnJvcicsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2cgd2FybmluZyBtZXNzYWdlc1xuICpcbiAqIEBtZXRob2Qgd2FyblxuICovXG5sb2cud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCd3YXJuJywgYXJncyk7XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBsb2c7XG5cbn0se1wiLi9icm93c2VyXCI6MTQwLFwiZ2xvYmFsL3dpbmRvd1wiOjJ9XSwxNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBtZXJnZS1vcHRpb25zLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IG1lcmdlT3B0aW9ucztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2xvZGFzaENvbXBhdE9iamVjdE1lcmdlID0gX2RlcmVxXygnbG9kYXNoLWNvbXBhdC9vYmplY3QvbWVyZ2UnKTtcblxudmFyIF9sb2Rhc2hDb21wYXRPYmplY3RNZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2hDb21wYXRPYmplY3RNZXJnZSk7XG5cbmZ1bmN0aW9uIGlzUGxhaW4ob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmoudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogTWVyZ2UgY3VzdG9taXplci4gdmlkZW8uanMgc2ltcGx5IG92ZXJ3cml0ZXMgbm9uLXNpbXBsZSBvYmplY3RzXG4gKiAobGlrZSBhcnJheXMpIGluc3RlYWQgb2YgYXR0ZW1wdGluZyB0byBvdmVybGF5IHRoZW0uXG4gKiBAc2VlIGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzI21lcmdlXG4gKi9cbnZhciBjdXN0b21pemVyID0gZnVuY3Rpb24gY3VzdG9taXplcihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIC8vIElmIHdlJ3JlIG5vdCB3b3JraW5nIHdpdGggYSBwbGFpbiBvYmplY3QsIGNvcHkgdGhlIHZhbHVlIGFzIGlzXG4gIC8vIElmIHNvdXJjZSBpcyBhbiBhcnJheSwgZm9yIGluc3RhbmNlLCBpdCB3aWxsIHJlcGxhY2UgZGVzdGluYXRpb25cbiAgaWYgKCFpc1BsYWluKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5ldyB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCBidXQgdGhlIGZpcnN0IG9iamVjdCB2YWx1ZSBpcyBub3RcbiAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IGZvciB0aGUgZmlyc3Qgb2JqZWN0IHRvIG1lcmdlIHdpdGguXG4gIC8vIFRoaXMgbWFrZXMgaXQgY29uc2lzdGVudCB3aXRoIGhvdyBtZXJnZSgpIHdvcmtzIGJ5IGRlZmF1bHRcbiAgLy8gYW5kIGFsc28gcHJvdGVjdHMgZnJvbSBsYXRlciBjaGFuZ2VzIHRoZSB0byBmaXJzdCBvYmplY3QgYWZmZWN0aW5nXG4gIC8vIHRoZSBzZWNvbmQgb2JqZWN0J3MgdmFsdWVzLlxuICBpZiAoIWlzUGxhaW4oZGVzdGluYXRpb24pKSB7XG4gICAgcmV0dXJuIG1lcmdlT3B0aW9ucyhzb3VyY2UpO1xuICB9XG59O1xuXG4vKipcbiAqIE1lcmdlIG9uZSBvciBtb3JlIG9wdGlvbnMgb2JqZWN0cywgcmVjdXJzaXZlbHkgbWVyZ2luZyAqKm9ubHkqKlxuICogcGxhaW4gb2JqZWN0IHByb3BlcnRpZXMuICBQcmV2aW91c2x5IGBkZWVwTWVyZ2VgLlxuICpcbiAqIEBwYXJhbSAgey4uLk9iamVjdH0gc291cmNlIE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgIGEgbmV3IG9iamVjdCB0aGF0IGlzIHRoZSB1bmlvbiBvZiBhbGxcbiAqIHByb3ZpZGVkIG9iamVjdHNcbiAqIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoKSB7XG4gIC8vIGNvbnRydWN0IHRoZSBjYWxsIGR5bmFtaWNhbGx5IHRvIGhhbmRsZSB0aGUgdmFyaWFibGUgbnVtYmVyIG9mXG4gIC8vIG9iamVjdHMgdG8gbWVyZ2VcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIC8vIHVuc2hpZnQgYW4gZW1wdHkgb2JqZWN0IGludG8gdGhlIGZyb250IG9mIHRoZSBjYWxsIGFzIHRoZSB0YXJnZXRcbiAgLy8gb2YgdGhlIG1lcmdlXG4gIGFyZ3MudW5zaGlmdCh7fSk7XG5cbiAgLy8gY3VzdG9taXplIGNvbmZsaWN0IHJlc29sdXRpb24gdG8gbWF0Y2ggb3VyIGhpc3RvcmljYWwgbWVyZ2UgYmVoYXZpb3JcbiAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuXG4gIF9sb2Rhc2hDb21wYXRPYmplY3RNZXJnZTJbJ2RlZmF1bHQnXS5hcHBseShudWxsLCBhcmdzKTtcblxuICAvLyByZXR1cm4gdGhlIG11dGF0ZWQgcmVzdWx0IG9iamVjdFxuICByZXR1cm4gYXJnc1swXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wibG9kYXNoLWNvbXBhdC9vYmplY3QvbWVyZ2VcIjo0MH1dLDE0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIGNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChjbGFzc05hbWUpIHtcbiAgdmFyIHN0eWxlID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudDtcbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIGlmIChlbC5zdHlsZVNoZWV0KSB7XG4gICAgZWwuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gIH1cbn07XG5leHBvcnRzLnNldFRleHRDb250ZW50ID0gc2V0VGV4dENvbnRlbnQ7XG5cbn0se1wiZ2xvYmFsL2RvY3VtZW50XCI6MX1dLDE1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVRpbWVSYW5nZXMgPSBjcmVhdGVUaW1lUmFuZ2VzO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfbG9nSnMgPSBfZGVyZXFfKCcuL2xvZy5qcycpO1xuXG52YXIgX2xvZ0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ0pzKTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXJhbmdlcy5qc1xuICpcbiAqIFNob3VsZCBjcmVhdGUgYSBmYWtlIFRpbWVSYW5nZSBvYmplY3RcbiAqIE1pbWljcyBhbiBIVE1MNSB0aW1lIHJhbmdlIGluc3RhbmNlLCB3aGljaCBoYXMgZnVuY3Rpb25zIHRoYXRcbiAqIHJldHVybiB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgYSByYW5nZVxuICogVGltZVJhbmdlcyBhcmUgcmV0dXJuZWQgYnkgdGhlIGJ1ZmZlcmVkKCkgbWV0aG9kXG4gKlxuICogQHBhcmFtICB7KE51bWJlcnxBcnJheSl9IFN0YXJ0IG9mIGEgc2luZ2xlIHJhbmdlIG9yIGFuIGFycmF5IG9mIHJhbmdlc1xuICogQHBhcmFtICB7TnVtYmVyfSBFbmQgb2YgYSBzaW5nbGUgcmFuZ2VcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIGNyZWF0ZVRpbWVSYW5nZXNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhcnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooc3RhcnQpO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaigpO1xuICB9XG4gIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKFtbc3RhcnQsIGVuZF1dKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVUaW1lUmFuZ2UgPSBjcmVhdGVUaW1lUmFuZ2VzO1xuXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzT2JqKHJhbmdlcykge1xuICBpZiAocmFuZ2VzID09PSB1bmRlZmluZWQgfHwgcmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfSxcbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVGltZVJhbmdlcyBvYmplY3QgaXMgZW1wdHknKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiByYW5nZXMubGVuZ3RoLFxuICAgIHN0YXJ0OiBnZXRSYW5nZS5iaW5kKG51bGwsICdzdGFydCcsIDAsIHJhbmdlcyksXG4gICAgZW5kOiBnZXRSYW5nZS5iaW5kKG51bGwsICdlbmQnLCAxLCByYW5nZXMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlKGZuTmFtZSwgdmFsdWVJbmRleCwgcmFuZ2VzLCByYW5nZUluZGV4KSB7XG4gIGlmIChyYW5nZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICBfbG9nSnMyWydkZWZhdWx0J10ud2FybignREVQUkVDQVRFRDogRnVuY3Rpb24gXFwnJyArIGZuTmFtZSArICdcXCcgb24gXFwnVGltZVJhbmdlc1xcJyBjYWxsZWQgd2l0aG91dCBhbiBpbmRleCBhcmd1bWVudC4nKTtcbiAgICByYW5nZUluZGV4ID0gMDtcbiAgfVxuICByYW5nZUNoZWNrKGZuTmFtZSwgcmFuZ2VJbmRleCwgcmFuZ2VzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gcmFuZ2VzW3JhbmdlSW5kZXhdW3ZhbHVlSW5kZXhdO1xufVxuXG5mdW5jdGlvbiByYW5nZUNoZWNrKGZuTmFtZSwgaW5kZXgsIG1heEluZGV4KSB7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgXFwnJyArIGZuTmFtZSArICdcXCcgb24gXFwnVGltZVJhbmdlc1xcJzogVGhlIGluZGV4IHByb3ZpZGVkICgnICsgaW5kZXggKyAnKSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1heGltdW0gYm91bmQgKCcgKyBtYXhJbmRleCArICcpLicpO1xuICB9XG59XG5cbn0se1wiLi9sb2cuanNcIjoxNDd9XSwxNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSB0by10aXRsZS1jYXNlLmpzXG4gKlxuICogVXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gYmUgdXBwZXJjYXNlZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgdG9UaXRsZUNhc2VcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiB0b1RpdGxlQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB0b1RpdGxlQ2FzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbn0se31dLDE1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHVybC5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9nbG9iYWxEb2N1bWVudCA9IF9kZXJlcV8oJ2dsb2JhbC9kb2N1bWVudCcpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbERvY3VtZW50KTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSBfZGVyZXFfKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byBwYXJzZVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgQW4gb2JqZWN0IG9mIHVybCBkZXRhaWxzXG4gKiBAbWV0aG9kIHBhcnNlVXJsXG4gKi9cbnZhciBwYXJzZVVybCA9IGZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgcHJvcHMgPSBbJ3Byb3RvY29sJywgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aG5hbWUnLCAnc2VhcmNoJywgJ2hhc2gnLCAnaG9zdCddO1xuXG4gIC8vIGFkZCB0aGUgdXJsIHRvIGFuIGFuY2hvciBhbmQgbGV0IHRoZSBicm93c2VyIHBhcnNlIHRoZSBVUkxcbiAgdmFyIGEgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnYScpO1xuICBhLmhyZWYgPSB1cmw7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIHZhciBhZGRUb0JvZHkgPSBhLmhvc3QgPT09ICcnICYmIGEucHJvdG9jb2wgIT09ICdmaWxlOic7XG4gIHZhciBkaXYgPSB1bmRlZmluZWQ7XG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkaXYgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9ICc8YSBocmVmPVwiJyArIHVybCArICdcIj48L2E+JztcbiAgICBhID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgLy8gcHJldmVudCB0aGUgZGl2IGZyb20gYWZmZWN0aW5nIGxheW91dFxuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZTsgcG9zaXRpb246YWJzb2x1dGU7Jyk7XG4gICAgX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxuICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIGZvciBJRTggYmVjYXVzZSB0aGUgYW5jaG9yIGxvc2VzIGl0c1xuICAvLyBwcm9wZXJ0aWVzIHdoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICB2YXIgZGV0YWlscyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGV0YWlsc1twcm9wc1tpXV0gPSBhW3Byb3BzW2ldXTtcbiAgfVxuXG4gIC8vIElFOSBhZGRzIHRoZSBwb3J0IHRvIHRoZSBob3N0IHByb3BlcnR5IHVubGlrZSBldmVyeW9uZSBlbHNlLiBJZlxuICAvLyBhIHBvcnQgaWRlbnRpZmllciBpcyBhZGRlZCBmb3Igc3RhbmRhcmQgcG9ydHMsIHN0cmlwIGl0LlxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86ODAkLywgJycpO1xuICB9XG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86NDQzJC8sICcnKTtcbiAgfVxuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG5cbiAgcmV0dXJuIGRldGFpbHM7XG59O1xuXG5leHBvcnRzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG4vKipcbiAqIEdldCBhYnNvbHV0ZSB2ZXJzaW9uIG9mIHJlbGF0aXZlIFVSTC4gVXNlZCB0byB0ZWxsIGZsYXNoIGNvcnJlY3QgVVJMLlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzA4MzIvZ2V0dGluZy1hbi1hYnNvbHV0ZS11cmwtZnJvbS1hLXJlbGF0aXZlLW9uZS1pZTYtaXNzdWVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVybCBVUkwgdG8gbWFrZSBhYnNvbHV0ZVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgQWJzb2x1dGUgVVJMXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBnZXRBYnNvbHV0ZVVSTFxuICovXG52YXIgZ2V0QWJzb2x1dGVVUkwgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQ2hlY2sgaWYgYWJzb2x1dGUgVVJMXG4gIGlmICghdXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pKSB7XG4gICAgLy8gQ29udmVydCB0byBhYnNvbHV0ZSBVUkwuIEZsYXNoIGhvc3RlZCBvZmYtc2l0ZSBuZWVkcyBhbiBhYnNvbHV0ZSBVUkwuXG4gICAgdmFyIGRpdiA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPng8L2E+JztcbiAgICB1cmwgPSBkaXYuZmlyc3RDaGlsZC5ocmVmO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cbmV4cG9ydHMuZ2V0QWJzb2x1dGVVUkwgPSBnZXRBYnNvbHV0ZVVSTDtcbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBwYXNzZWQgZmlsZSBuYW1lLiBJdCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmcgaWYgeW91IHBhc3MgYW4gaW52YWxpZCBwYXRoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICAgIHBhdGggICAgVGhlIGZpbGVOYW1lIHBhdGggbGlrZSAnL3BhdGgvdG8vZmlsZS5tcDQnXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAgICAgICAgICBUaGUgZXh0ZW5zaW9uIGluIGxvd2VyIGNhc2Ugb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIGV4dGVuc2lvbiBjb3VsZCBiZSBmb3VuZC5cbiAqIEBtZXRob2QgZ2V0RmlsZUV4dGVuc2lvblxuICovXG52YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvPykoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz8pKFxcLihbXlxcLlxcL1xcP10rKSkpKD86W1xcL10qfFtcXD9dLiopJC9pO1xuICAgIHZhciBwYXRoUGFydHMgPSBzcGxpdFBhdGhSZS5leGVjKHBhdGgpO1xuXG4gICAgaWYgKHBhdGhQYXJ0cykge1xuICAgICAgcmV0dXJuIHBhdGhQYXJ0cy5wb3AoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMuZ2V0RmlsZUV4dGVuc2lvbiA9IGdldEZpbGVFeHRlbnNpb247XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIHBhc3NlZCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgV2hldGhlciBpdCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdFxuICogQG1ldGhvZCBpc0Nyb3NzT3JpZ2luXG4gKi9cbnZhciBpc0Nyb3NzT3JpZ2luID0gZnVuY3Rpb24gaXNDcm9zc09yaWdpbih1cmwpIHtcbiAgdmFyIHdpbkxvYyA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ubG9jYXRpb247XG4gIHZhciB1cmxJbmZvID0gcGFyc2VVcmwodXJsKTtcblxuICAvLyBJRTggcHJvdG9jb2wgcmVsYXRpdmUgdXJscyB3aWxsIHJldHVybiAnOicgZm9yIHByb3RvY29sXG4gIHZhciBzcmNQcm90b2NvbCA9IHVybEluZm8ucHJvdG9jb2wgPT09ICc6JyA/IHdpbkxvYy5wcm90b2NvbCA6IHVybEluZm8ucHJvdG9jb2w7XG5cbiAgLy8gQ2hlY2sgaWYgdXJsIGlzIGZvciBhbm90aGVyIGRvbWFpbi9vcmlnaW5cbiAgLy8gSUU4IGRvZXNuJ3Qga25vdyBsb2NhdGlvbi5vcmlnaW4sIHNvIHdlIHdvbid0IHJlbHkgb24gaXQgaGVyZVxuICB2YXIgY3Jvc3NPcmlnaW4gPSBzcmNQcm90b2NvbCArIHVybEluZm8uaG9zdCAhPT0gd2luTG9jLnByb3RvY29sICsgd2luTG9jLmhvc3Q7XG5cbiAgcmV0dXJuIGNyb3NzT3JpZ2luO1xufTtcbmV4cG9ydHMuaXNDcm9zc09yaWdpbiA9IGlzQ3Jvc3NPcmlnaW47XG5cbn0se1wiZ2xvYmFsL2RvY3VtZW50XCI6MSxcImdsb2JhbC93aW5kb3dcIjoyfV0sMTUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgdmlkZW8uanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gX2RlcmVxXygnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gX2RlcmVxXygnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX3NldHVwID0gX2RlcmVxXygnLi9zZXR1cCcpO1xuXG52YXIgc2V0dXAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfc2V0dXApO1xuXG52YXIgX3V0aWxzU3R5bGVzaGVldEpzID0gX2RlcmVxXygnLi91dGlscy9zdHlsZXNoZWV0LmpzJyk7XG5cbnZhciBzdHlsZXNoZWV0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzU3R5bGVzaGVldEpzKTtcblxudmFyIF9jb21wb25lbnQgPSBfZGVyZXFfKCcuL2NvbXBvbmVudCcpO1xuXG52YXIgX2NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb25lbnQpO1xuXG52YXIgX2V2ZW50VGFyZ2V0ID0gX2RlcmVxXygnLi9ldmVudC10YXJnZXQnKTtcblxudmFyIF9ldmVudFRhcmdldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudFRhcmdldCk7XG5cbnZhciBfdXRpbHNFdmVudHNKcyA9IF9kZXJlcV8oJy4vdXRpbHMvZXZlbnRzLmpzJyk7XG5cbnZhciBFdmVudHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNFdmVudHNKcyk7XG5cbnZhciBfcGxheWVyID0gX2RlcmVxXygnLi9wbGF5ZXInKTtcblxudmFyIF9wbGF5ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheWVyKTtcblxudmFyIF9wbHVnaW5zSnMgPSBfZGVyZXFfKCcuL3BsdWdpbnMuanMnKTtcblxudmFyIF9wbHVnaW5zSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGx1Z2luc0pzKTtcblxudmFyIF9zcmNKc1V0aWxzTWVyZ2VPcHRpb25zSnMgPSBfZGVyZXFfKCcuLi8uLi9zcmMvanMvdXRpbHMvbWVyZ2Utb3B0aW9ucy5qcycpO1xuXG52YXIgX3NyY0pzVXRpbHNNZXJnZU9wdGlvbnNKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcmNKc1V0aWxzTWVyZ2VPcHRpb25zSnMpO1xuXG52YXIgX3V0aWxzRm5KcyA9IF9kZXJlcV8oJy4vdXRpbHMvZm4uanMnKTtcblxudmFyIEZuID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzRm5Kcyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrSnMgPSBfZGVyZXFfKCcuL3RyYWNrcy90ZXh0LXRyYWNrLmpzJyk7XG5cbnZhciBfdHJhY2tzVGV4dFRyYWNrSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzVGV4dFRyYWNrSnMpO1xuXG52YXIgX3RyYWNrc0F1ZGlvVHJhY2tKcyA9IF9kZXJlcV8oJy4vdHJhY2tzL2F1ZGlvLXRyYWNrLmpzJyk7XG5cbnZhciBfdHJhY2tzQXVkaW9UcmFja0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYWNrc0F1ZGlvVHJhY2tKcyk7XG5cbnZhciBfdHJhY2tzVmlkZW9UcmFja0pzID0gX2RlcmVxXygnLi90cmFja3MvdmlkZW8tdHJhY2suanMnKTtcblxudmFyIF90cmFja3NWaWRlb1RyYWNrSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJhY2tzVmlkZW9UcmFja0pzKTtcblxudmFyIF91dGlsc1RpbWVSYW5nZXNKcyA9IF9kZXJlcV8oJy4vdXRpbHMvdGltZS1yYW5nZXMuanMnKTtcblxudmFyIF91dGlsc0Zvcm1hdFRpbWVKcyA9IF9kZXJlcV8oJy4vdXRpbHMvZm9ybWF0LXRpbWUuanMnKTtcblxudmFyIF91dGlsc0Zvcm1hdFRpbWVKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0Zvcm1hdFRpbWVKcyk7XG5cbnZhciBfdXRpbHNMb2dKcyA9IF9kZXJlcV8oJy4vdXRpbHMvbG9nLmpzJyk7XG5cbnZhciBfdXRpbHNMb2dKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0xvZ0pzKTtcblxudmFyIF91dGlsc0RvbUpzID0gX2RlcmVxXygnLi91dGlscy9kb20uanMnKTtcblxudmFyIERvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0RvbUpzKTtcblxudmFyIF91dGlsc0Jyb3dzZXJKcyA9IF9kZXJlcV8oJy4vdXRpbHMvYnJvd3Nlci5qcycpO1xuXG52YXIgYnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlsc0Jyb3dzZXJKcyk7XG5cbnZhciBfdXRpbHNVcmxKcyA9IF9kZXJlcV8oJy4vdXRpbHMvdXJsLmpzJyk7XG5cbnZhciBVcmwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHNVcmxKcyk7XG5cbnZhciBfZXh0ZW5kSnMgPSBfZGVyZXFfKCcuL2V4dGVuZC5qcycpO1xuXG52YXIgX2V4dGVuZEpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZEpzKTtcblxudmFyIF9sb2Rhc2hDb21wYXRPYmplY3RNZXJnZSA9IF9kZXJlcV8oJ2xvZGFzaC1jb21wYXQvb2JqZWN0L21lcmdlJyk7XG5cbnZhciBfbG9kYXNoQ29tcGF0T2JqZWN0TWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9kYXNoQ29tcGF0T2JqZWN0TWVyZ2UpO1xuXG52YXIgX3hociA9IF9kZXJlcV8oJ3hocicpO1xuXG52YXIgX3hocjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94aHIpO1xuXG4vLyBJbmNsdWRlIHRoZSBidWlsdC1pbiB0ZWNoc1xuXG52YXIgX3RlY2hUZWNoSnMgPSBfZGVyZXFfKCcuL3RlY2gvdGVjaC5qcycpO1xuXG52YXIgX3RlY2hUZWNoSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGVjaFRlY2hKcyk7XG5cbnZhciBfdGVjaEh0bWw1SnMgPSBfZGVyZXFfKCcuL3RlY2gvaHRtbDUuanMnKTtcblxudmFyIF90ZWNoSHRtbDVKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZWNoSHRtbDVKcyk7XG5cbnZhciBfdGVjaEZsYXNoSnMgPSBfZGVyZXFfKCcuL3RlY2gvZmxhc2guanMnKTtcblxudmFyIF90ZWNoRmxhc2hKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZWNoRmxhc2hKcyk7XG5cbi8vIEhUTUw1IEVsZW1lbnQgU2hpbSBmb3IgSUU4XG5pZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gIF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XG59XG5cbi8qKlxuICogRG91YmxlcyBhcyB0aGUgbWFpbiBmdW5jdGlvbiBmb3IgdXNlcnMgdG8gY3JlYXRlIGEgcGxheWVyIGluc3RhbmNlIGFuZCBhbHNvXG4gKiB0aGUgbWFpbiBsaWJyYXJ5IG9iamVjdC5cbiAqIFRoZSBgdmlkZW9qc2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBvciByZXRyaWV2ZSBhIHBsYXllci5cbiAqIGBgYGpzXG4gKiAgICAgdmFyIG15UGxheWVyID0gdmlkZW9qcygnbXlfdmlkZW9faWQnKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xFbGVtZW50fSBpZCAgICAgIFZpZGVvIGVsZW1lbnQgb3IgdmlkZW8gZWxlbWVudCBJRFxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgZm9yIGNvbmZpZy9zZXR0aW5nc1xuICogQHBhcmFtICB7RnVuY3Rpb249fSByZWFkeSAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqIEByZXR1cm4ge1BsYXllcn0gICAgICAgICAgICAgICAgIEEgcGxheWVyIGluc3RhbmNlXG4gKiBAbWl4ZXMgdmlkZW9qc1xuICogQG1ldGhvZCB2aWRlb2pzXG4gKi9cbmZ1bmN0aW9uIHZpZGVvanMoaWQsIG9wdGlvbnMsIHJlYWR5KSB7XG4gIHZhciB0YWcgPSB1bmRlZmluZWQ7IC8vIEVsZW1lbnQgb2YgSURcblxuICAvLyBBbGxvdyBmb3IgZWxlbWVudCBvciBJRCB0byBiZSBwYXNzZWQgaW5cbiAgLy8gU3RyaW5nIElEXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAvLyBBZGp1c3QgZm9yIGpRdWVyeSBJRCBzeW50YXhcbiAgICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIC8vIElmIGEgcGxheWVyIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgdGhpcyBJRCByZXR1cm4gaXQuXG4gICAgaWYgKHZpZGVvanMuZ2V0UGxheWVycygpW2lkXSkge1xuXG4gICAgICAvLyBJZiBvcHRpb25zIG9yIHJlYWR5IGZ1bnRpb24gYXJlIHBhc3NlZCwgd2FyblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgX3V0aWxzTG9nSnMyWydkZWZhdWx0J10ud2FybignUGxheWVyIFwiJyArIGlkICsgJ1wiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5KSB7XG4gICAgICAgIHZpZGVvanMuZ2V0UGxheWVycygpW2lkXS5yZWFkeShyZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWRlb2pzLmdldFBsYXllcnMoKVtpZF07XG5cbiAgICAgIC8vIE90aGVyd2lzZSBnZXQgZWxlbWVudCBmb3IgSURcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YWcgPSBEb20uZ2V0RWwoaWQpO1xuICAgICAgfVxuXG4gICAgLy8gSUQgaXMgYSBtZWRpYSBlbGVtZW50XG4gIH0gZWxzZSB7XG4gICAgICB0YWcgPSBpZDtcbiAgICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGEgdXNlYWJsZSBlbGVtZW50XG4gIGlmICghdGFnIHx8ICF0YWcubm9kZU5hbWUpIHtcbiAgICAvLyByZTogbm9kZU5hbWUsIGNvdWxkIGJlIGEgYm94IGRpdiBhbHNvXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGVsZW1lbnQgb3IgSUQgc3VwcGxpZWQgaXMgbm90IHZhbGlkLiAodmlkZW9qcyknKTsgLy8gUmV0dXJuc1xuICB9XG5cbiAgLy8gRWxlbWVudCBtYXkgaGF2ZSBhIHBsYXllciBhdHRyIHJlZmVycmluZyB0byBhbiBhbHJlYWR5IGNyZWF0ZWQgcGxheWVyIGluc3RhbmNlLlxuICAvLyBJZiBub3QsIHNldCB1cCBhIG5ldyBwbGF5ZXIgYW5kIHJldHVybiB0aGUgaW5zdGFuY2UuXG4gIHJldHVybiB0YWdbJ3BsYXllciddIHx8IF9wbGF5ZXIyWydkZWZhdWx0J10ucGxheWVyc1t0YWcucGxheWVySWRdIHx8IG5ldyBfcGxheWVyMlsnZGVmYXVsdCddKHRhZywgb3B0aW9ucywgcmVhZHkpO1xufVxuXG4vLyBBZGQgZGVmYXVsdCBzdHlsZXNcbmlmIChfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSAhPT0gdHJ1ZSkge1xuICB2YXIgc3R5bGUgPSBEb20uJCgnLnZqcy1zdHlsZXMtZGVmYXVsdHMnKTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBzdHlsZXNoZWV0LmNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kZWZhdWx0cycpO1xuICAgIHZhciBoZWFkID0gRG9tLiQoJ2hlYWQnKTtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICBzdHlsZXNoZWV0LnNldFRleHRDb250ZW50KHN0eWxlLCAnXFxuICAgICAgLnZpZGVvLWpzIHtcXG4gICAgICAgIHdpZHRoOiAzMDBweDtcXG4gICAgICAgIGhlaWdodDogMTUwcHg7XFxuICAgICAgfVxcblxcbiAgICAgIC52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6IDU2LjI1JVxcbiAgICAgIH1cXG4gICAgJyk7XG4gIH1cbn1cblxuLy8gUnVuIEF1dG8tbG9hZCBwbGF5ZXJzXG4vLyBZb3UgaGF2ZSB0byB3YWl0IGF0IGxlYXN0IG9uY2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgYWZ0ZXIgeW91ciB2aWRlbyBpbiB0aGUgRE9NICh3ZWlyZCBiZWhhdmlvciBvbmx5IHdpdGggbWluaWZpZWQgdmVyc2lvbilcbnNldHVwLmF1dG9TZXR1cFRpbWVvdXQoMSwgdmlkZW9qcyk7XG5cbi8qXG4gKiBDdXJyZW50IHNvZnR3YXJlIHZlcnNpb24gKHNlbXZlcilcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG52aWRlb2pzLlZFUlNJT04gPSAnNS4xMS43JztcblxuLyoqXG4gKiBUaGUgZ2xvYmFsIG9wdGlvbnMgb2JqZWN0LiBUaGVzZSBhcmUgdGhlIHNldHRpbmdzIHRoYXQgdGFrZSBlZmZlY3RcbiAqIGlmIG5vIG92ZXJyaWRlcyBhcmUgc3BlY2lmaWVkIHdoZW4gdGhlIHBsYXllciBpcyBjcmVhdGVkLlxuICpcbiAqIGBgYGpzXG4gKiAgICAgdmlkZW9qcy5vcHRpb25zLmF1dG9wbGF5ID0gdHJ1ZVxuICogICAgIC8vIC0+IGFsbCBwbGF5ZXJzIHdpbGwgYXV0b3BsYXkgYnkgZGVmYXVsdFxuICogYGBgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmlkZW9qcy5vcHRpb25zID0gX3BsYXllcjJbJ2RlZmF1bHQnXS5wcm90b3R5cGUub3B0aW9uc187XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50bHkgY3JlYXRlZCBwbGF5ZXJzLCBrZXllZCBieSBwbGF5ZXIgSURcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjcmVhdGVkIHBsYXllcnNcbiAqIEBtaXhlcyB2aWRlb2pzXG4gKiBAbWV0aG9kIGdldFBsYXllcnNcbiAqL1xudmlkZW9qcy5nZXRQbGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX3BsYXllcjJbJ2RlZmF1bHQnXS5wbGF5ZXJzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgcGxheWVycyBvYmplY3QuXG4gKlxuICogQG1lbWJlck9mIHZpZGVvanNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwbGF5ZXJzXG4gKi9cbnZpZGVvanMucGxheWVycyA9IF9wbGF5ZXIyWydkZWZhdWx0J10ucGxheWVycztcblxuLyoqXG4gKiBHZXQgYSBjb21wb25lbnQgY2xhc3Mgb2JqZWN0IGJ5IG5hbWVcbiAqIGBgYGpzXG4gKiAgICAgdmFyIFZqc0J1dHRvbiA9IHZpZGVvanMuZ2V0Q29tcG9uZW50KCdCdXR0b24nKTtcbiAqICAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICogICAgIHZhciBteUJ1dHRvbiA9IG5ldyBWanNCdXR0b24obXlQbGF5ZXIpO1xuICogYGBgXG4gKlxuICogQHJldHVybiB7Q29tcG9uZW50fSBDb21wb25lbnQgaWRlbnRpZmllZCBieSBuYW1lXG4gKiBAbWl4ZXMgdmlkZW9qc1xuICogQG1ldGhvZCBnZXRDb21wb25lbnRcbiAqL1xudmlkZW9qcy5nZXRDb21wb25lbnQgPSBfY29tcG9uZW50MlsnZGVmYXVsdCddLmdldENvbXBvbmVudDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNvbXBvbmVudCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZVxuICogVXNlZCB3aGVuIGFkZGluZyB0byBvdGhlclxuICogY29tcG9uZW50cywgZWl0aGVyIHRocm91Z2ggYWRkQ2hpbGRcbiAqIGBjb21wb25lbnQuYWRkQ2hpbGQoJ215Q29tcG9uZW50JylgXG4gKiBvciB0aHJvdWdoIGRlZmF1bHQgY2hpbGRyZW4gb3B0aW9uc1xuICogYHsgY2hpbGRyZW46IFsnbXlDb21wb25lbnQnXSB9YC5cbiAqIGBgYGpzXG4gKiAgICAgLy8gR2V0IGEgY29tcG9uZW50IHRvIHN1YmNsYXNzXG4gKiAgICAgdmFyIFZqc0J1dHRvbiA9IHZpZGVvanMuZ2V0Q29tcG9uZW50KCdCdXR0b24nKTtcbiAqICAgICAvLyBTdWJjbGFzcyB0aGUgY29tcG9uZW50IChzZWUgJ2V4dGVuZCcgZG9jIGZvciBtb3JlIGluZm8pXG4gKiAgICAgdmFyIE15U3BlY2lhbEJ1dHRvbiA9IHZpZGVvanMuZXh0ZW5kKFZqc0J1dHRvbiwge30pO1xuICogICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XG4gKiAgICAgVmpzQnV0dG9uLnJlZ2lzdGVyQ29tcG9uZW50KCdNeVNlcGNpYWxCdXR0b24nLCBNeVNlcGNpYWxCdXR0b24pO1xuICogICAgIC8vIChvcHRpb25hbGx5KSBhZGQgdGhlIG5ldyBjb21wb25lbnQgYXMgYSBkZWZhdWx0IHBsYXllciBjaGlsZFxuICogICAgIG15UGxheWVyLmFkZENoaWxkKCdNeVNlcGNpYWxCdXR0b24nKTtcbiAqIGBgYFxuICogTk9URTogWW91IGNvdWxkIGFsc28ganVzdCBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgYmVmb3JlIGFkZGluZy5cbiAqIGBjb21wb25lbnQuYWRkQ2hpbGQobmV3IE15Q29tcG9uZW50KCkpO2BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gVGhlIGNsYXNzIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICogQHBhcmFtIHtDb21wb25lbnR9IFRoZSBjb21wb25lbnQgY2xhc3NcbiAqIEByZXR1cm4ge0NvbXBvbmVudH0gVGhlIG5ld2x5IHJlZ2lzdGVyZWQgY29tcG9uZW50XG4gKiBAbWl4ZXMgdmlkZW9qc1xuICogQG1ldGhvZCByZWdpc3RlckNvbXBvbmVudFxuICovXG52aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUsIGNvbXApIHtcbiAgaWYgKF90ZWNoVGVjaEpzMlsnZGVmYXVsdCddLmlzVGVjaChjb21wKSkge1xuICAgIF91dGlsc0xvZ0pzMlsnZGVmYXVsdCddLndhcm4oJ1RoZSAnICsgbmFtZSArICcgdGVjaCB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNvbXBvbmVudC4gSXQgc2hvdWxkIGluc3RlYWQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICB9XG5cbiAgX2NvbXBvbmVudDJbJ2RlZmF1bHQnXS5yZWdpc3RlckNvbXBvbmVudC5jYWxsKF9jb21wb25lbnQyWydkZWZhdWx0J10sIG5hbWUsIGNvbXApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBUZWNoIGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKiBgYGBqc1xuICogICAgIHZhciBIdG1sNSA9IHZpZGVvanMuZ2V0VGVjaCgnSHRtbDUnKTtcbiAqICAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxuICogICAgIHZhciBodG1sNSA9IG5ldyBIdG1sNShvcHRpb25zKTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm4ge1RlY2h9IFRlY2ggaWRlbnRpZmllZCBieSBuYW1lXG4gKiBAbWl4ZXMgdmlkZW9qc1xuICogQG1ldGhvZCBnZXRDb21wb25lbnRcbiAqL1xudmlkZW9qcy5nZXRUZWNoID0gX3RlY2hUZWNoSnMyWydkZWZhdWx0J10uZ2V0VGVjaDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIFRlY2ggc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuXG4gKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHRlY2ggb3JkZXIgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogYGBganNcbiAqICAgICAvLyBnZXQgdGhlIEh0bWw1IFRlY2hcbiAqICAgICB2YXIgSHRtbDUgPSB2aWRlb2pzLmdldFRlY2goJ0h0bWw1Jyk7XG4gKiAgICAgdmFyIE15VGVjaCA9IHZpZGVvanMuZXh0ZW5kKEh0bWw1LCB7fSk7XG4gKiAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldyBUZWNoXG4gKiAgICAgVmpzQnV0dG9uLnJlZ2lzdGVyVGVjaCgnVGVjaCcsIE15VGVjaCk7XG4gKiAgICAgdmFyIHBsYXllciA9IHZpZGVvanMoJ215cGxheWVyJywge1xuICogICAgICAgdGVjaE9yZGVyOiBbJ215VGVjaCcsICdodG1sNSddXG4gKiAgICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gVGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRlY2hcbiAqIEBwYXJhbSB7VGVjaH0gVGhlIHRlY2ggY2xhc3NcbiAqIEByZXR1cm4ge1RlY2h9IFRoZSBuZXdseSByZWdpc3RlcmVkIFRlY2hcbiAqIEBtaXhlcyB2aWRlb2pzXG4gKiBAbWV0aG9kIHJlZ2lzdGVyVGVjaFxuICovXG52aWRlb2pzLnJlZ2lzdGVyVGVjaCA9IF90ZWNoVGVjaEpzMlsnZGVmYXVsdCddLnJlZ2lzdGVyVGVjaDtcblxuLyoqXG4gKiBBIHN1aXRlIG9mIGJyb3dzZXIgYW5kIGRldmljZSB0ZXN0c1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52aWRlb2pzLmJyb3dzZXIgPSBicm93c2VyO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIHN1cHBvcnRzIHRvdWNoIGV2ZW50cy4gSW5jbHVkZWQgZm9yIGJhY2t3YXJkXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggNC54LCBidXQgZGVwcmVjYXRlZC4gVXNlIGB2aWRlb2pzLmJyb3dzZXIuVE9VQ0hfRU5BQkxFRGBcbiAqIGluc3RlYWQgZ29pbmcgZm9yd2FyZC5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbnZpZGVvanMuVE9VQ0hfRU5BQkxFRCA9IGJyb3dzZXIuVE9VQ0hfRU5BQkxFRDtcblxuLyoqXG4gKiBTdWJjbGFzcyBhbiBleGlzdGluZyBjbGFzc1xuICogTWltaWNzIEVTNiBzdWJjbGFzc2luZyB3aXRoIHRoZSBgZXh0ZW5kYCBrZXl3b3JkXG4gKiBgYGBqc1xuICogICAgIC8vIENyZWF0ZSBhIGJhc2ljIGphdmFzY3JpcHQgJ2NsYXNzJ1xuICogICAgIGZ1bmN0aW9uIE15Q2xhc3MobmFtZSl7XG4gKiAgICAgICAvLyBTZXQgYSBwcm9wZXJ0eSBhdCBpbml0aWFsaXphdGlvblxuICogICAgICAgdGhpcy5teU5hbWUgPSBuYW1lO1xuICogICAgIH1cbiAqICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2UgbWV0aG9kXG4gKiAgICAgTXlDbGFzcy5wcm90b3R5cGUuc2F5TXlOYW1lID0gZnVuY3Rpb24oKXtcbiAqICAgICAgIGFsZXJ0KHRoaXMubXlOYW1lKTtcbiAqICAgICB9O1xuICogICAgIC8vIFN1YmNsYXNzIHRoZSBleGlzaXRuZyBjbGFzcyBhbmQgY2hhbmdlIHRoZSBuYW1lXG4gKiAgICAgLy8gd2hlbiBpbml0aWFsaXppbmdcbiAqICAgICB2YXIgTXlTdWJDbGFzcyA9IHZpZGVvanMuZXh0ZW5kKE15Q2xhc3MsIHtcbiAqICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gKiAgICAgICAgIC8vIENhbGwgdGhlIHN1cGVyIGNsYXNzIGNvbnN0cnVjdG9yIGZvciB0aGUgc3ViY2xhc3NcbiAqICAgICAgICAgTXlDbGFzcy5jYWxsKHRoaXMsIG5hbWUpXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBuZXcgc3ViIGNsYXNzXG4gKiAgICAgdmFyIG15SW5zdGFuY2UgPSBuZXcgTXlTdWJDbGFzcygnSm9obicpO1xuICogICAgIG15SW5zdGFuY2Uuc2F5TXlOYW1lKCk7IC8vIC0+IHNob3VsZCBhbGVydCBcIkpvaG5cIlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gVGhlIENsYXNzIHRvIHN1YmNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IGluY2x1ZGluZyBpbnN0YWNlIG1ldGhvZHMgZm9yIHRoZSBuZXcgY2xhc3NcbiAqICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsbHkgaW5jbHVkaW5nIGEgYGNvbnN0cnVjdG9yYCBmdW5jdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBuZXdseSBjcmVhdGVkIHN1YmNsYXNzXG4gKiBAbWl4ZXMgdmlkZW9qc1xuICogQG1ldGhvZCBleHRlbmRcbiAqL1xudmlkZW9qcy5leHRlbmQgPSBfZXh0ZW5kSnMyWydkZWZhdWx0J107XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbnMgb2JqZWN0cyByZWN1cnNpdmVseVxuICogUGVyZm9ybXMgYSBkZWVwIG1lcmdlIGxpa2UgbG9kYXNoLm1lcmdlIGJ1dCAqKm9ubHkgbWVyZ2VzIHBsYWluIG9iamVjdHMqKlxuICogKG5vdCBhcnJheXMsIGVsZW1lbnRzLCBhbnl0aGluZyBlbHNlKVxuICogT3RoZXIgdmFsdWVzIHdpbGwgYmUgY29waWVkIGRpcmVjdGx5IGZyb20gdGhlIHNlY29uZCBvYmplY3QuXG4gKiBgYGBqc1xuICogICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAqICAgICAgIGZvbzogdHJ1ZSxcbiAqICAgICAgIGJhcjoge1xuICogICAgICAgICBhOiB0cnVlLFxuICogICAgICAgICBiOiBbMSwyLDNdXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqICAgICB2YXIgbmV3T3B0aW9ucyA9IHtcbiAqICAgICAgIGZvbzogZmFsc2UsXG4gKiAgICAgICBiYXI6IHtcbiAqICAgICAgICAgYjogWzQsNSw2XVxuICogICAgICAgfVxuICogICAgIH07XG4gKiAgICAgdmFyIHJlc3VsdCA9IHZpZGVvanMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAqICAgICAvLyByZXN1bHQuZm9vID0gZmFsc2U7XG4gKiAgICAgLy8gcmVzdWx0LmJhci5hID0gdHJ1ZTtcbiAqICAgICAvLyByZXN1bHQuYmFyLmIgPSBbNCw1LDZdO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzICBUaGUgb3B0aW9ucyBvYmplY3Qgd2hvc2UgdmFsdWVzIHdpbGwgYmUgb3ZlcnJpZGVuXG4gKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFRoZSBvcHRpb25zIG9iamVjdCB3aXRoIHZhbHVlcyB0byBvdmVycmlkZSB0aGUgZmlyc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBldGMgICAgICAgQW55IG51bWJlciBvZiBhZGRpdGlvbmFsIG9wdGlvbnMgb2JqZWN0c1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIG1lcmdlZCB2YWx1ZXNcbiAqIEBtaXhlcyB2aWRlb2pzXG4gKiBAbWV0aG9kIG1lcmdlT3B0aW9uc1xuICovXG52aWRlb2pzLm1lcmdlT3B0aW9ucyA9IF9zcmNKc1V0aWxzTWVyZ2VPcHRpb25zSnMyWydkZWZhdWx0J107XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBjb250ZXh0ICh0aGlzKSBvZiBhIGZ1bmN0aW9uXG4gKlxuICogICAgIHZpZGVvanMuYmluZChuZXdDb250ZXh0LCBmdW5jdGlvbigpe1xuICogICAgICAgdGhpcyA9PT0gbmV3Q29udGV4dFxuICogICAgIH0pO1xuICpcbiAqIE5PVEU6IGFzIG9mIHY1LjAgd2UgcmVxdWlyZSBhbiBFUzUgc2hpbSwgc28geW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZVxuICogYGZ1bmN0aW9uKCl7fS5iaW5kKG5ld0NvbnRleHQpO2AgaW5zdGVhZCBvZiB0aGlzLlxuICpcbiAqIEBwYXJhbSAgeyp9ICAgICAgICBjb250ZXh0IFRoZSBvYmplY3QgdG8gYmluZCBhcyBzY29wZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGJvdW5kIHRvIGEgc2NvcGVcbiAqIEBwYXJhbSAge051bWJlcj19ICB1aWQgICAgIEFuIG9wdGlvbmFsIHVuaXF1ZSBJRCBmb3IgdGhlIGZ1bmN0aW9uIHRvIGJlIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZpZGVvanMuYmluZCA9IEZuLmJpbmQ7XG5cbi8qKlxuICogQ3JlYXRlIGEgVmlkZW8uanMgcGxheWVyIHBsdWdpblxuICogUGx1Z2lucyBhcmUgb25seSBpbml0aWFsaXplZCB3aGVuIG9wdGlvbnMgZm9yIHRoZSBwbHVnaW4gYXJlIGluY2x1ZGVkXG4gKiBpbiB0aGUgcGxheWVyIG9wdGlvbnMsIG9yIHRoZSBwbHVnaW4gZnVuY3Rpb24gb24gdGhlIHBsYXllciBpbnN0YW5jZSBpc1xuICogY2FsbGVkLlxuICogKipTZWUgdGhlIHBsdWdpbiBndWlkZSBpbiB0aGUgZG9jcyBmb3IgYSBtb3JlIGRldGFpbGVkIGV4YW1wbGUqKlxuICogYGBganNcbiAqICAgICAvLyBNYWtlIGEgcGx1Z2luIHRoYXQgYWxlcnRzIHdoZW4gdGhlIHBsYXllciBwbGF5c1xuICogICAgIHZpZGVvanMucGx1Z2luKCdteVBsdWdpbicsIGZ1bmN0aW9uKG15UGx1Z2luT3B0aW9ucykge1xuICogICAgICAgbXlQbHVnaW5PcHRpb25zID0gbXlQbHVnaW5PcHRpb25zIHx8IHt9O1xuICpcbiAqICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzO1xuICogICAgICAgdmFyIGFsZXJ0VGV4dCA9IG15UGx1Z2luT3B0aW9ucy50ZXh0IHx8ICdQbGF5ZXIgaXMgcGxheWluZyEnXG4gKlxuICogICAgICAgcGxheWVyLm9uKCdwbGF5JywgZnVuY3Rpb24oKXtcbiAqICAgICAgICAgYWxlcnQoYWxlcnRUZXh0KTtcbiAqICAgICAgIH0pO1xuICogICAgIH0pO1xuICogICAgIC8vIFVTQUdFIEVYQU1QTEVTXG4gKiAgICAgLy8gRVhBTVBMRSAxOiBOZXcgcGxheWVyIHdpdGggcGx1Z2luIG9wdGlvbnMsIGNhbGwgcGx1Z2luIGltbWVkaWF0ZWx5XG4gKiAgICAgdmFyIHBsYXllcjEgPSB2aWRlb2pzKCdpZE9uZScsIHtcbiAqICAgICAgIG15UGx1Z2luOiB7XG4gKiAgICAgICAgIHRleHQ6ICdDdXN0b20gdGV4dCEnXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgLy8gQ2xpY2sgcGxheVxuICogICAgIC8vIC0tPiBTaG91bGQgYWxlcnQgJ0N1c3RvbSB0ZXh0ISdcbiAqICAgICAvLyBFWEFNUExFIDM6IE5ldyBwbGF5ZXIsIGluaXRpYWxpemUgcGx1Z2luIGxhdGVyXG4gKiAgICAgdmFyIHBsYXllcjMgPSB2aWRlb2pzKCdpZFRocmVlJyk7XG4gKiAgICAgLy8gQ2xpY2sgcGxheVxuICogICAgIC8vIC0tPiBOTyBBTEVSVFxuICogICAgIC8vIENsaWNrIHBhdXNlXG4gKiAgICAgLy8gSW5pdGlhbGl6ZSBwbHVnaW4gdXNpbmcgdGhlIHBsdWdpbiBmdW5jdGlvbiBvbiB0aGUgcGxheWVyIGluc3RhbmNlXG4gKiAgICAgcGxheWVyMy5teVBsdWdpbih7XG4gKiAgICAgICB0ZXh0OiAnUGx1Z2luIGFkZGVkIGxhdGVyISdcbiAqICAgICB9KTtcbiAqICAgICAvLyBDbGljayBwbGF5XG4gKiAgICAgLy8gLS0+IFNob3VsZCBhbGVydCAnUGx1Z2luIGFkZGVkIGxhdGVyISdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBwbHVnaW4gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHBsdWdpbiBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggb3B0aW9uc1xuICogQG1peGVzIHZpZGVvanNcbiAqIEBtZXRob2QgcGx1Z2luXG4gKi9cbnZpZGVvanMucGx1Z2luID0gX3BsdWdpbnNKczJbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBBZGRpbmcgbGFuZ3VhZ2VzIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgdG8gYWxsIHBsYXllcnMuXG4gKiBgYGBqc1xuICogICAgIHZpZGVvanMuYWRkTGFuZ3VhZ2UoJ2VzJywgeyAnSGVsbG8nOiAnSG9sYScgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNvZGUgVGhlIGxhbmd1YWdlIGNvZGUgb3IgZGljdGlvbmFyeSBwcm9wZXJ0eVxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgbGFuZ3VhZ2UgZGljdGlvbmFyeSBvYmplY3RcbiAqIEBtaXhlcyB2aWRlb2pzXG4gKiBAbWV0aG9kIGFkZExhbmd1YWdlXG4gKi9cbnZpZGVvanMuYWRkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICB2YXIgX21lcmdlO1xuXG4gIGNvZGUgPSAoJycgKyBjb2RlKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gX2xvZGFzaENvbXBhdE9iamVjdE1lcmdlMlsnZGVmYXVsdCddKHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMsIChfbWVyZ2UgPSB7fSwgX21lcmdlW2NvZGVdID0gZGF0YSwgX21lcmdlKSlbY29kZV07XG59O1xuXG4vKipcbiAqIExvZyBkZWJ1ZyBtZXNzYWdlcy5cbiAqXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gbWVzc2FnZXMgT25lIG9yIG1vcmUgbWVzc2FnZXMgdG8gbG9nXG4gKi9cbnZpZGVvanMubG9nID0gX3V0aWxzTG9nSnMyWydkZWZhdWx0J107XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXVsYXRlZCBUaW1lUmFuZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheX0gc3RhcnQgU3RhcnQgdGltZSBpbiBzZWNvbmRzIG9yIGFuIGFycmF5IG9mIHJhbmdlc1xuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgICBFbmQgdGltZSBpbiBzZWNvbmRzXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIEZha2UgVGltZVJhbmdlIG9iamVjdFxuICogQG1ldGhvZCBjcmVhdGVUaW1lUmFuZ2VcbiAqL1xudmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2UgPSB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXMgPSBfdXRpbHNUaW1lUmFuZ2VzSnMuY3JlYXRlVGltZVJhbmdlcztcblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcbiAqIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKSB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAqIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzIE51bWJlciBvZiBzZWNvbmRzIHRvIGJlIHR1cm5lZCBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGd1aWRlICAgTnVtYmVyIChpbiBzZWNvbmRzKSB0byBtb2RlbCB0aGUgc3RyaW5nIGFmdGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgVGltZSBmb3JtYXR0ZWQgYXMgSDpNTTpTUyBvciBNOlNTXG4gKiBAbWV0aG9kIGZvcm1hdFRpbWVcbiAqL1xudmlkZW9qcy5mb3JtYXRUaW1lID0gX3V0aWxzRm9ybWF0VGltZUpzMlsnZGVmYXVsdCddO1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gcGFyc2VcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIEFuIG9iamVjdCBvZiB1cmwgZGV0YWlsc1xuICogQG1ldGhvZCBwYXJzZVVybFxuICovXG52aWRlb2pzLnBhcnNlVXJsID0gVXJsLnBhcnNlVXJsO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIHBhc3NlZCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgV2hldGhlciBpdCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdFxuICogQG1ldGhvZCBpc0Nyb3NzT3JpZ2luXG4gKi9cbnZpZGVvanMuaXNDcm9zc09yaWdpbiA9IFVybC5pc0Nyb3NzT3JpZ2luO1xuXG4vKipcbiAqIEV2ZW50IHRhcmdldCBjbGFzcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZpZGVvanMuRXZlbnRUYXJnZXQgPSBfZXZlbnRUYXJnZXQyWydkZWZhdWx0J107XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICB0eXBlIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIEV2ZW50IGxpc3RlbmVyLlxuICogQG1ldGhvZCBvblxuICovXG52aWRlb2pzLm9uID0gRXZlbnRzLm9uO1xuXG4vKipcbiAqIFRyaWdnZXIgYSBsaXN0ZW5lciBvbmx5IG9uY2UgZm9yIGFuIGV2ZW50XG4gKlxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9ICAgZWxlbSBFbGVtZW50IG9yIG9iamVjdCB0b1xuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgIHR5cGUgTmFtZS90eXBlIG9mIGV2ZW50XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICogQG1ldGhvZCBvbmVcbiAqL1xudmlkZW9qcy5vbmUgPSBFdmVudHMub25lO1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSAgIGVsZW0gT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbVxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5PX0gICB0eXBlIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudCB0eXBlLlxuICogQG1ldGhvZCBvZmZcbiAqL1xudmlkZW9qcy5vZmYgPSBFdmVudHMub2ZmO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gICAgICBlbGVtICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cbiAqIEBwYXJhbSAge0V2ZW50fE9iamVjdHxTdHJpbmd9IGV2ZW50IEEgc3RyaW5nICh0aGUgdHlwZSkgb3IgYW4gZXZlbnQgb2JqZWN0IHdpdGggYSB0eXBlIGF0dHJpYnV0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBbaGFzaF0gZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW49fSBSZXR1cm5lZCBvbmx5IGlmIGRlZmF1bHQgd2FzIHByZXZlbnRlZFxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKi9cbnZpZGVvanMudHJpZ2dlciA9IEV2ZW50cy50cmlnZ2VyO1xuXG4vKipcbiAqIEEgY3Jvc3MtYnJvd3NlciBYTUxIdHRwUmVxdWVzdCB3cmFwcGVyLiBIZXJlJ3MgYSBzaW1wbGUgZXhhbXBsZTpcbiAqXG4gKiAgICAgdmlkZW9qcy54aHIoe1xuICogICAgICAgYm9keTogc29tZUpTT05TdHJpbmcsXG4gKiAgICAgICB1cmk6IFwiL2Zvb1wiLFxuICogICAgICAgaGVhZGVyczoge1xuICogICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICogICAgICAgfVxuICogICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3AsIGJvZHkpIHtcbiAqICAgICAgIC8vIGNoZWNrIHJlc3Auc3RhdHVzQ29kZVxuICogICAgIH0pO1xuICpcbiAqIENoZWNrIG91dCB0aGUgW2Z1bGxcbiAqIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyL2Jsb2IvdjIuMS4wL1JFQURNRS5tZClcbiAqIGZvciBtb3JlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgc2V0dGluZ3MgZm9yIHRoZSByZXF1ZXN0LlxuICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9IHRoZSByZXF1ZXN0IG9iamVjdC5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHJcbiAqL1xudmlkZW9qcy54aHIgPSBfeGhyMlsnZGVmYXVsdCddO1xuXG4vKipcbiAqIFRleHRUcmFjayBjbGFzc1xuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmlkZW9qcy5UZXh0VHJhY2sgPSBfdHJhY2tzVGV4dFRyYWNrSnMyWydkZWZhdWx0J107XG5cbi8qKlxuICogZXhwb3J0IHRoZSBBdWRpb1RyYWNrIGNsYXNzIHNvIHRoYXQgc291cmNlIGhhbmRsZXJzIGNhbiBjcmVhdGVcbiAqIEF1ZGlvVHJhY2tzIGFuZCB0aGVuIGFkZCB0aGVtIHRvIHRoZSBwbGF5ZXJzIEF1ZGlvVHJhY2tMaXN0XG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52aWRlb2pzLkF1ZGlvVHJhY2sgPSBfdHJhY2tzQXVkaW9UcmFja0pzMlsnZGVmYXVsdCddO1xuXG4vKipcbiAqIGV4cG9ydCB0aGUgVmlkZW9UcmFjayBjbGFzcyBzbyB0aGF0IHNvdXJjZSBoYW5kbGVycyBjYW4gY3JlYXRlXG4gKiBWaWRlb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBWaWRlb1RyYWNrTGlzdFxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmlkZW9qcy5WaWRlb1RyYWNrID0gX3RyYWNrc1ZpZGVvVHJhY2tKczJbJ2RlZmF1bHQnXTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIGlzRWxcbiAqIEBwYXJhbSAge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmlkZW9qcy5pc0VsID0gRG9tLmlzRWw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBtZXRob2QgaXNUZXh0Tm9kZVxuICogQHBhcmFtICB7TWl4ZWR9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52aWRlb2pzLmlzVGV4dE5vZGUgPSBEb20uaXNUZXh0Tm9kZTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVsZW1lbnQgYW5kIGFwcGxpZXMgcHJvcGVydGllcy5cbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFt0YWdOYW1lPSdkaXYnXSBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICogQHBhcmFtICB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gRWxlbWVudCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XSBFbGVtZW50IGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnZpZGVvanMuY3JlYXRlRWwgPSBEb20uY3JlYXRlRWw7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqXG4gKiBAbWV0aG9kIGhhc0NsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9DaGVjayBDbGFzc25hbWUgdG8gY2hlY2tcbiAqL1xudmlkZW9qcy5oYXNDbGFzcyA9IERvbS5oYXNFbENsYXNzO1xuXG4vKipcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIGFkZENsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9BZGQgQ2xhc3NuYW1lIHRvIGFkZFxuICovXG52aWRlb2pzLmFkZENsYXNzID0gRG9tLmFkZEVsQ2xhc3M7XG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQG1ldGhvZCByZW1vdmVDbGFzc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgIEVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gY2xhc3MgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzVG9SZW1vdmUgQ2xhc3NuYW1lIHRvIHJlbW92ZVxuICovXG52aWRlb2pzLnJlbW92ZUNsYXNzID0gRG9tLnJlbW92ZUVsQ2xhc3M7XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAbWV0aG9kIHRvZ2dsZUVsQ2xhc3NcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICogQHBhcmFtICB7Qm9vbGVhbnxGdW5jdGlvbn0gW3ByZWRpY2F0ZV1cbiAqICAgICAgICAgQ2FuIGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgQm9vbGVhbi4gSWYgYHRydWVgLCB0aGUgY2xhc3NcbiAqICAgICAgICAgd2lsbCBiZSBhZGRlZDsgaWYgYGZhbHNlYCwgdGhlIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgbm90XG4gKiAgICAgICAgIGdpdmVuLCB0aGUgY2xhc3Mgd2lsbCBiZSBhZGRlZCBpZiBub3QgcHJlc2VudCBhbmQgdmljZSB2ZXJzYS5cbiAqL1xudmlkZW9qcy50b2dnbGVDbGFzcyA9IERvbS50b2dnbGVFbENsYXNzO1xuXG4vKipcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgdG8gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBtZXRob2Qgc2V0QXR0cmlidXRlc1xuICogQHBhcmFtICB7RWxlbWVudH0gZWwgICAgICAgICBUYXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSAge09iamVjdD19IGF0dHJpYnV0ZXMgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKi9cbnZpZGVvanMuc2V0QXR0cmlidXRlcyA9IERvbS5zZXRFbEF0dHJpYnV0ZXM7XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXG4gKiBvciB3aXRoIHNldEF0dHJpYnV0ZSAod2hpY2ggc2hvdWxkbid0IGJlIHVzZWQgd2l0aCBIVE1MKVxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0gIHtFbGVtZW50fSB0YWcgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCB0YWcgYXR0cmlidXRlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52aWRlb2pzLmdldEF0dHJpYnV0ZXMgPSBEb20uZ2V0RWxBdHRyaWJ1dGVzO1xuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCBlbXB0eUVsXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xudmlkZW9qcy5lbXB0eUVsID0gRG9tLmVtcHR5RWw7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcbiAqIGNvbWJpbmF0aW9ucywgd2hvc2UgYmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIFN0cmluZ1xuICogICBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKlxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxuICogICBQYXNzZWQgdGhyb3VnaC5cbiAqXG4gKiAtIEFycmF5XG4gKiAgIEEgb25lLWRpbWVuc2lvbmFsIGFycmF5IG9mIHN0cmluZ3MsIGVsZW1lbnRzLCBub2Rlcywgb3IgZnVuY3Rpb25zICh3aGljaFxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKlxuICogLSBGdW5jdGlvblxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgbm9kZSwgb3IgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBhcHBlbmRDb250ZW50XG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnZpZGVvanMuYXBwZW5kQ29udGVudCA9IERvbS5hcHBlbmRDb250ZW50O1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW5kIGluc2VydHMgY29udGVudCBpbnRvIGFuIGVsZW1lbnQ7IHRoaXMgaXMgaWRlbnRpY2FsIHRvXG4gKiBgYXBwZW5kQ29udGVudCgpYCwgZXhjZXB0IGl0IGVtcHRpZXMgdGhlIGVsZW1lbnQgZmlyc3QuXG4gKlxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcbiAqIGNvbWJpbmF0aW9ucywgd2hvc2UgYmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIFN0cmluZ1xuICogICBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKlxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxuICogICBQYXNzZWQgdGhyb3VnaC5cbiAqXG4gKiAtIEFycmF5XG4gKiAgIEEgb25lLWRpbWVuc2lvbmFsIGFycmF5IG9mIHN0cmluZ3MsIGVsZW1lbnRzLCBub2Rlcywgb3IgZnVuY3Rpb25zICh3aGljaFxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKlxuICogLSBGdW5jdGlvblxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgbm9kZSwgb3IgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBpbnNlcnRDb250ZW50XG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnZpZGVvanMuaW5zZXJ0Q29udGVudCA9IERvbS5pbnNlcnRDb250ZW50O1xuXG4vKlxuICogQ3VzdG9tIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKVxuICpcbiAqIFZpZGVvLmpzIHdpbGwgbmV2ZXIgYmUgYSBub24tYnJvd3NlciBsaWIgc28gd2UgY2FuIHNpbXBsaWZ5IFVNRCBhIGJ1bmNoIGFuZFxuICogc3RpbGwgc3VwcG9ydCByZXF1aXJlanMgYW5kIGJyb3dzZXJpZnkuIFRoaXMgYWxzbyBuZWVkcyB0byBiZSBjbG9zdXJlXG4gKiBjb21waWxlciBjb21wYXRpYmxlLCBzbyBzdHJpbmcga2V5cyBhcmUgdXNlZC5cbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICBkZWZpbmUoJ3ZpZGVvanMnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2aWRlb2pzO1xuICB9KTtcblxuICAvLyBjaGVja2luZyB0aGF0IG1vZHVsZSBpcyBhbiBvYmplY3QgdG9vIGJlY2F1c2Ugb2YgdW1kanMvdW1kIzM1XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZVsnZXhwb3J0cyddID0gdmlkZW9qcztcbiAgfVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB2aWRlb2pzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi4vLi4vc3JjL2pzL3V0aWxzL21lcmdlLW9wdGlvbnMuanNcIjoxNDgsXCIuL2NvbXBvbmVudFwiOjY3LFwiLi9ldmVudC10YXJnZXRcIjoxMDQsXCIuL2V4dGVuZC5qc1wiOjEwNSxcIi4vcGxheWVyXCI6MTEzLFwiLi9wbHVnaW5zLmpzXCI6MTE0LFwiLi9zZXR1cFwiOjExOCxcIi4vdGVjaC9mbGFzaC5qc1wiOjEyMSxcIi4vdGVjaC9odG1sNS5qc1wiOjEyMixcIi4vdGVjaC90ZWNoLmpzXCI6MTI0LFwiLi90cmFja3MvYXVkaW8tdHJhY2suanNcIjoxMjYsXCIuL3RyYWNrcy90ZXh0LXRyYWNrLmpzXCI6MTM0LFwiLi90cmFja3MvdmlkZW8tdHJhY2suanNcIjoxMzksXCIuL3V0aWxzL2Jyb3dzZXIuanNcIjoxNDAsXCIuL3V0aWxzL2RvbS5qc1wiOjE0MixcIi4vdXRpbHMvZXZlbnRzLmpzXCI6MTQzLFwiLi91dGlscy9mbi5qc1wiOjE0NCxcIi4vdXRpbHMvZm9ybWF0LXRpbWUuanNcIjoxNDUsXCIuL3V0aWxzL2xvZy5qc1wiOjE0NyxcIi4vdXRpbHMvc3R5bGVzaGVldC5qc1wiOjE0OSxcIi4vdXRpbHMvdGltZS1yYW5nZXMuanNcIjoxNTAsXCIuL3V0aWxzL3VybC5qc1wiOjE1MixcImdsb2JhbC9kb2N1bWVudFwiOjEsXCJnbG9iYWwvd2luZG93XCI6MixcImxvZGFzaC1jb21wYXQvb2JqZWN0L21lcmdlXCI6NDAsXCJ4aHJcIjo1Nn1dfSx7fSxbMTUzXSkoMTUzKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlkZW8uanMubWFwXG4vKiB2dHQuanMgLSB2MC4xMi4xIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMpIGJ1aWx0IG9uIDA4LTA3LTIwMTUgKi9cblxuKGZ1bmN0aW9uKHJvb3QpIHtcbiAgdmFyIHZ0dGpzID0gcm9vdC52dHRqcyA9IHt9O1xuICB2YXIgY3VlU2hpbSA9IHZ0dGpzLlZUVEN1ZTtcbiAgdmFyIHJlZ2lvblNoaW0gPSB2dHRqcy5WVFRSZWdpb247XG4gIHZhciBvbGRWVFRDdWUgPSByb290LlZUVEN1ZTtcbiAgdmFyIG9sZFZUVFJlZ2lvbiA9IHJvb3QuVlRUUmVnaW9uO1xuXG4gIHZ0dGpzLnNoaW0gPSBmdW5jdGlvbigpIHtcbiAgICB2dHRqcy5WVFRDdWUgPSBjdWVTaGltO1xuICAgIHZ0dGpzLlZUVFJlZ2lvbiA9IHJlZ2lvblNoaW07XG4gIH07XG5cbiAgdnR0anMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZ0dGpzLlZUVEN1ZSA9IG9sZFZUVEN1ZTtcbiAgICB2dHRqcy5WVFRSZWdpb24gPSBvbGRWVFRSZWdpb247XG4gIH07XG59KHRoaXMpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24ocm9vdCwgdnR0anMpIHtcblxuICB2YXIgYXV0b0tleXdvcmQgPSBcImF1dG9cIjtcbiAgdmFyIGRpcmVjdGlvblNldHRpbmcgPSB7XG4gICAgXCJcIjogdHJ1ZSxcbiAgICBcImxyXCI6IHRydWUsXG4gICAgXCJybFwiOiB0cnVlXG4gIH07XG4gIHZhciBhbGlnblNldHRpbmcgPSB7XG4gICAgXCJzdGFydFwiOiB0cnVlLFxuICAgIFwibWlkZGxlXCI6IHRydWUsXG4gICAgXCJlbmRcIjogdHJ1ZSxcbiAgICBcImxlZnRcIjogdHJ1ZSxcbiAgICBcInJpZ2h0XCI6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgdmFyIGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgdmFyIGN1ZSA9IHRoaXM7XG4gICAgdmFyIGlzSUU4ID0gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciBiYXNlT2JqID0ge307XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICogdGhlIHNwZWMuXG4gICAgICovXG5cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgdmFyIF9pZCA9IFwiXCI7XG4gICAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIHZhciBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHZhciBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgICB2YXIgX3JlZ2lvbiA9IG51bGw7XG4gICAgdmFyIF92ZXJ0aWNhbCA9IFwiXCI7XG4gICAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gICAgdmFyIF9saW5lID0gXCJhdXRvXCI7XG4gICAgdmFyIF9saW5lQWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICAgIHZhciBfcG9zaXRpb25BbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgdmFyIF9zaXplID0gNTA7XG4gICAgdmFyIF9hbGlnbiA9IFwibWlkZGxlXCI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgICAgXCJpZFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgX2lkID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgICAgXCJwYXVzZU9uRXhpdFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwic3RhcnRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgICAgXCJlbmRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgICAgXCJ0ZXh0XCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIF90ZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwicmVnaW9uXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwidmVydGljYWxcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgICBcInNuYXBUb0xpbmVzXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwibGluZVwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgICAgXCJsaW5lQWxpZ25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgICAgXCJwb3NpdGlvblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpb24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwicG9zaXRpb25BbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwic2l6ZVwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICAgIFwiYWxpZ25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc0lFOCkge1xuICAgICAgcmV0dXJuIGN1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICovXG5cbiAgVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xuICB9O1xuXG4gIHJvb3QuVlRUQ3VlID0gcm9vdC5WVFRDdWUgfHwgVlRUQ3VlO1xuICB2dHRqcy5WVFRDdWUgPSBWVFRDdWU7XG59KHRoaXMsICh0aGlzLnZ0dGpzIHx8IHt9KSkpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbihmdW5jdGlvbihyb290LCB2dHRqcykge1xuXG4gIHZhciBzY3JvbGxTZXR0aW5nID0ge1xuICAgIFwiXCI6IHRydWUsXG4gICAgXCJ1cFwiOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzY3JvbGwgPSBzY3JvbGxTZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiBzY3JvbGwgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMDApO1xuICB9XG5cbiAgLy8gVlRUUmVnaW9uIHNoaW0gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRyZWdpb24taW50ZXJmYWNlXG4gIGZ1bmN0aW9uIFZUVFJlZ2lvbigpIHtcbiAgICB2YXIgX3dpZHRoID0gMTAwO1xuICAgIHZhciBfbGluZXMgPSAzO1xuICAgIHZhciBfcmVnaW9uQW5jaG9yWCA9IDA7XG4gICAgdmFyIF9yZWdpb25BbmNob3JZID0gMTAwO1xuICAgIHZhciBfdmlld3BvcnRBbmNob3JYID0gMDtcbiAgICB2YXIgX3ZpZXdwb3J0QW5jaG9yWSA9IDEwMDtcbiAgICB2YXIgX3Njcm9sbCA9IFwiXCI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBcIndpZHRoXCI6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3dpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF93aWR0aCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJsaW5lc1wiOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9saW5lcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMaW5lcyBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9saW5lcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJyZWdpb25BbmNob3JZXCI6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZ2lvbkFuY2hvclk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb25BbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVnaW9uQW5jaG9yWSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJyZWdpb25BbmNob3JYXCI6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZ2lvbkFuY2hvclg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZighaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWdpb25BbmNob3JYID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInZpZXdwb3J0QW5jaG9yWVwiOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF92aWV3cG9ydEFuY2hvclk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3cG9ydEFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF92aWV3cG9ydEFuY2hvclkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwidmlld3BvcnRBbmNob3JYXCI6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJzY3JvbGxcIjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfc2Nyb2xsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kU2Nyb2xsU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYXMgYW4gZW1wdHkgc3RyaW5nIGlzIGEgbGVnYWwgdmFsdWUuXG4gICAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc2Nyb2xsID0gc2V0dGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcm9vdC5WVFRSZWdpb24gPSByb290LlZUVFJlZ2lvbiB8fCBWVFRSZWdpb247XG4gIHZ0dGpzLlZUVFJlZ2lvbiA9IFZUVFJlZ2lvbjtcbn0odGhpcywgKHRoaXMudnR0anMgfHwge30pKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gIHZhciBfb2JqQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBzaGltIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicpO1xuICAgICAgfVxuICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvLyBDcmVhdGVzIGEgbmV3IFBhcnNlckVycm9yIG9iamVjdCBmcm9tIGFuIGVycm9yRGF0YSBvYmplY3QuIFRoZSBlcnJvckRhdGFcbiAgLy8gb2JqZWN0IHNob3VsZCBoYXZlIGRlZmF1bHQgY29kZSBhbmQgbWVzc2FnZSBwcm9wZXJ0aWVzLiBUaGUgZGVmYXVsdCBtZXNzYWdlXG4gIC8vIHByb3BlcnR5IGNhbiBiZSBvdmVycmlkZW4gYnkgcGFzc2luZyBpbiBhIG1lc3NhZ2UgcGFyYW1ldGVyLlxuICAvLyBTZWUgUGFyc2luZ0Vycm9yLkVycm9ycyBiZWxvdyBmb3IgYWNjZXB0YWJsZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIFBhcnNpbmdFcnJvcihlcnJvckRhdGEsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSBcIlBhcnNpbmdFcnJvclwiO1xuICAgIHRoaXMuY29kZSA9IGVycm9yRGF0YS5jb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgZXJyb3JEYXRhLm1lc3NhZ2U7XG4gIH1cbiAgUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgUGFyc2luZ0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNpbmdFcnJvcjtcblxuICAvLyBQYXJzaW5nRXJyb3IgbWV0YWRhdGEgZm9yIGFjY2VwdGFibGUgUGFyc2luZ0Vycm9ycy5cbiAgUGFyc2luZ0Vycm9yLkVycm9ycyA9IHtcbiAgICBCYWRTaWduYXR1cmU6IHtcbiAgICAgIGNvZGU6IDAsXG4gICAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLlwiXG4gICAgfSxcbiAgICBCYWRUaW1lU3RhbXA6IHtcbiAgICAgIGNvZGU6IDEsXG4gICAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCB0aW1lIHN0YW1wLlwiXG4gICAgfVxuICB9O1xuXG4gIC8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG4gIGZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XG4gICAgfVxuXG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICAgIGlmICghbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1bM10pIHtcbiAgICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoXCI6XCIsIFwiXCIpLCBtWzRdKTtcbiAgICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgIG1bNF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKDAsIG1bMV0sIG1bMl0sIG1bNF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEEgc2V0dGluZ3Mgb2JqZWN0IGhvbGRzIGtleS92YWx1ZSBwYWlycyBhbmQgd2lsbCBpZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdFxuICAvLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuICBmdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICB0aGlzLnZhbHVlcyA9IF9vYmpDcmVhdGUobnVsbCk7XG4gIH1cblxuICBTZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gICAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAgIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAgIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gICAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAgIC8vIGEgc2luZ2xlIHZhbHVlLlxuICAgIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICAgIH0sXG4gICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICAgIGhhczogZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gICAgfSxcbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgICBhbHQ6IGZ1bmN0aW9uKGssIHYsIGEpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gICAgaW50ZWdlcjogZnVuY3Rpb24oaywgdikge1xuICAgICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXG4gICAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gICAgcGVyY2VudDogZnVuY3Rpb24oaywgdikge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgICAgdiA9IHBhcnNlRmxvYXQodik7XG4gICAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgaW5wdXQgaW50byBncm91cHMgc2VwYXJhdGVkIGJ5ICdncm91cERlbGltJywgYW5kXG4gIC8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG4gIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgICB2YXIgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBrdlswXTtcbiAgICAgIHZhciB2ID0ga3ZbMV07XG4gICAgICBjYWxsYmFjayhrLCB2KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAgIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gICAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcbiAgICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZXN0YW1wOiBcIiArIG9JbnB1dCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCBcIlwiKTtcbiAgICAgIHJldHVybiB0cztcbiAgICB9XG5cbiAgICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gICAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlIFwicmVnaW9uXCI6XG4gICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJybFwiLCBcImxyXCJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzMCk7XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkgPyBzZXR0aW5ncy5zZXQoXCJzbmFwVG9MaW5lc1wiLCBmYWxzZSkgOiBudWxsO1xuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgW1wiYXV0b1wiXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJsaW5lQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJwb3NpdGlvbkFsaWduXCIsIHZhbHNbMV0sIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFsaWduXCI6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uXCIsIG51bGwpO1xuICAgICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KFwidmVydGljYWxcIiwgXCJcIik7XG4gICAgICBjdWUubGluZSA9IHNldHRpbmdzLmdldChcImxpbmVcIiwgXCJhdXRvXCIpO1xuICAgICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldChcImxpbmVBbGlnblwiLCBcInN0YXJ0XCIpO1xuICAgICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KFwic25hcFRvTGluZXNcIiwgdHJ1ZSk7XG4gICAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldChcInNpemVcIiwgMTAwKTtcbiAgICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldChcImFsaWduXCIsIFwibWlkZGxlXCIpO1xuICAgICAgY3VlLnBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KFwicG9zaXRpb25cIiwge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgbWlkZGxlOiA1MCxcbiAgICAgICAgZW5kOiAxMDAsXG4gICAgICAgIHJpZ2h0OiAxMDBcbiAgICAgIH0sIGN1ZS5hbGlnbik7XG4gICAgICBjdWUucG9zaXRpb25BbGlnbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uQWxpZ25cIiwge1xuICAgICAgICBzdGFydDogXCJzdGFydFwiLFxuICAgICAgICBsZWZ0OiBcInN0YXJ0XCIsXG4gICAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICByaWdodDogXCJlbmRcIlxuICAgICAgfSwgY3VlLmFsaWduKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgICB9XG5cbiAgICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gXCItLT5cIikgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoIFwiLS0+XCJcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5wdXQpO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cigzKTtcbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgICAgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xuICB9XG5cbiAgdmFyIEVTQ0FQRSA9IHtcbiAgICBcIiZhbXA7XCI6IFwiJlwiLFxuICAgIFwiJmx0O1wiOiBcIjxcIixcbiAgICBcIiZndDtcIjogXCI+XCIsXG4gICAgXCImbHJtO1wiOiBcIlxcdTIwMGVcIixcbiAgICBcIiZybG07XCI6IFwiXFx1MjAwZlwiLFxuICAgIFwiJm5ic3A7XCI6IFwiXFx1MDBhMFwiXG4gIH07XG5cbiAgdmFyIFRBR19OQU1FID0ge1xuICAgIGM6IFwic3BhblwiLFxuICAgIGk6IFwiaVwiLFxuICAgIGI6IFwiYlwiLFxuICAgIHU6IFwidVwiLFxuICAgIHJ1Ynk6IFwicnVieVwiLFxuICAgIHJ0OiBcInJ0XCIsXG4gICAgdjogXCJzcGFuXCIsXG4gICAgbGFuZzogXCJzcGFuXCJcbiAgfTtcblxuICB2YXIgVEFHX0FOTk9UQVRJT04gPSB7XG4gICAgdjogXCJ0aXRsZVwiLFxuICAgIGxhbmc6IFwibGFuZ1wiXG4gIH07XG5cbiAgdmFyIE5FRURTX1BBUkVOVCA9IHtcbiAgICBydDogXCJydWJ5XCJcbiAgfTtcblxuICAvLyBQYXJzZSBjb250ZW50IGludG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgZnVuY3Rpb24gcGFyc2VDb250ZW50KHdpbmRvdywgaW5wdXQpIHtcbiAgICBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgICAvLyBDaGVjayBmb3IgZW5kLW9mLXN0cmluZy5cbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnN1bWUgJ24nIGNoYXJhY3RlcnMgZnJvbSB0aGUgaW5wdXQuXG4gICAgICBmdW5jdGlvbiBjb25zdW1lKHJlc3VsdCkge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cihyZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihbXjxdKikoPFtePl0rPj8pPy8pO1xuICAgICAgLy8gSWYgdGhlcmUgaXMgc29tZSB0ZXh0IGJlZm9yZSB0aGUgbmV4dCB0YWcsIHJldHVybiBpdCwgb3RoZXJ3aXNlIHJldHVyblxuICAgICAgLy8gdGhlIHRhZy5cbiAgICAgIHJldHVybiBjb25zdW1lKG1bMV0gPyBtWzFdIDogbVsyXSk7XG4gICAgfVxuXG4gICAgLy8gVW5lc2NhcGUgYSBzdHJpbmcgJ3MnLlxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlMShlKSB7XG4gICAgICByZXR1cm4gRVNDQVBFW2VdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzKSB7XG4gICAgICB3aGlsZSAoKG0gPSBzLm1hdGNoKC8mKGFtcHxsdHxndHxscm18cmxtfG5ic3ApOy8pKSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKG1bMF0sIHVuZXNjYXBlMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRBZGQoY3VycmVudCwgZWxlbWVudCkge1xuICAgICAgcmV0dXJuICFORUVEU19QQVJFTlRbZWxlbWVudC5sb2NhbE5hbWVdIHx8XG4gICAgICAgICAgICAgTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSA9PT0gY3VycmVudC5sb2NhbE5hbWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIHRoaXMgdGFnLlxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgYW5ub3RhdGlvbikge1xuICAgICAgdmFyIHRhZ05hbWUgPSBUQUdfTkFNRVt0eXBlXTtcbiAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICBlbGVtZW50LmxvY2FsTmFtZSA9IHRhZ05hbWU7XG4gICAgICB2YXIgbmFtZSA9IFRBR19BTk5PVEFUSU9OW3R5cGVdO1xuICAgICAgaWYgKG5hbWUgJiYgYW5ub3RhdGlvbikge1xuICAgICAgICBlbGVtZW50W25hbWVdID0gYW5ub3RhdGlvbi50cmltKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgcm9vdERpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBjdXJyZW50ID0gcm9vdERpdixcbiAgICAgICAgdCxcbiAgICAgICAgdGFnU3RhY2sgPSBbXTtcblxuICAgIHdoaWxlICgodCA9IG5leHRUb2tlbigpKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRbMF0gPT09ICc8Jykge1xuICAgICAgICBpZiAodFsxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY2xvc2luZyB0YWcgbWF0Y2hlcywgbW92ZSBiYWNrIHVwIHRvIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgICAgICBpZiAodGFnU3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICAgIHRhZ1N0YWNrW3RhZ1N0YWNrLmxlbmd0aCAtIDFdID09PSB0LnN1YnN0cigyKS5yZXBsYWNlKFwiPlwiLCBcIlwiKSkge1xuICAgICAgICAgICAgdGFnU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBpZ25vcmUgdGhlIGVuZCB0YWcuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAodC5zdWJzdHIoMSwgdC5sZW5ndGggLSAyKSk7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHMpIHtcbiAgICAgICAgICAvLyBUaW1lc3RhbXBzIGFyZSBsZWFkIG5vZGVzIGFzIHdlbGwuXG4gICAgICAgICAgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oXCJ0aW1lc3RhbXBcIiwgdHMpO1xuICAgICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSB0Lm1hdGNoKC9ePChbXi5cXHMvMC05Pl0rKShcXC5bXlxcc1xcXFw+XSspPyhbXj5cXFxcXSspPyhcXFxcPyk+PyQvKTtcbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcGFyc2UgdGhlIHRhZywgc2tpcCB0byB0aGUgbmV4dCB0YWcuXG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYW4gZWxlbWVudCwgYW5kIGlnbm9yZSB0aGUgdGFnIGlmIHdlIGNvdWxkbid0LlxuICAgICAgICBub2RlID0gY3JlYXRlRWxlbWVudChtWzFdLCBtWzNdKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB0YWcgc2hvdWxkIGJlIGFkZGVkIGJhc2VkIG9uIHRoZSBjb250ZXh0IG9mIHdoZXJlIGl0XG4gICAgICAgIC8vIGlzIHBsYWNlZCBpbiB0aGUgY3VldGV4dC5cbiAgICAgICAgaWYgKCFzaG91bGRBZGQoY3VycmVudCwgbm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGNsYXNzIGxpc3QgKGFzIGEgbGlzdCBvZiBjbGFzc2VzLCBzZXBhcmF0ZWQgYnkgc3BhY2UpLlxuICAgICAgICBpZiAobVsyXSkge1xuICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbVsyXS5zdWJzdHIoMSkucmVwbGFjZSgnLicsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBub2RlIHRvIHRoZSBjdXJyZW50IG5vZGUsIGFuZCBlbnRlciB0aGUgc2NvcGUgb2YgdGhlIG5ld1xuICAgICAgICAvLyBub2RlLlxuICAgICAgICB0YWdTdGFjay5wdXNoKG1bMV0pO1xuICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBjdXJyZW50ID0gbm9kZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRleHQgbm9kZXMgYXJlIGxlYWYgbm9kZXMuXG4gICAgICBjdXJyZW50LmFwcGVuZENoaWxkKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1bmVzY2FwZSh0KSkpO1xuICAgIH1cblxuICAgIHJldHVybiByb290RGl2O1xuICB9XG5cbiAgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIHRoZSBVbmljb2RlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGEgc3Ryb25nXG4gIC8vIHJpZ2h0LXRvLWxlZnQgY2F0ZWdvcnkuIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IHRoZXNlIGNoYXJhY3RlcnMgYXJlXG4gIC8vIHdyaXR0ZW4gcmlnaHQtdG8tbGVmdCBmb3Igc3VyZS4gSXQgd2FzIGdlbmVyYXRlZCBieSBwdWxsaW5nIGFsbCB0aGUgc3Ryb25nXG4gIC8vIHJpZ2h0LXRvLWxlZnQgY2hhcmFjdGVycyBvdXQgb2YgdGhlIFVuaWNvZGUgZGF0YSB0YWJsZS4gVGhhdCB0YWJsZSBjYW5cbiAgLy8gZm91bmQgYXQ6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VOSURBVEEvVW5pY29kZURhdGEudHh0XG4gIHZhciBzdHJvbmdSVExDaGFycyA9IFsweDA1QkUsIDB4MDVDMCwgMHgwNUMzLCAweDA1QzYsIDB4MDVEMCwgMHgwNUQxLFxuICAgICAgMHgwNUQyLCAweDA1RDMsIDB4MDVENCwgMHgwNUQ1LCAweDA1RDYsIDB4MDVENywgMHgwNUQ4LCAweDA1RDksIDB4MDVEQSxcbiAgICAgIDB4MDVEQiwgMHgwNURDLCAweDA1REQsIDB4MDVERSwgMHgwNURGLCAweDA1RTAsIDB4MDVFMSwgMHgwNUUyLCAweDA1RTMsXG4gICAgICAweDA1RTQsIDB4MDVFNSwgMHgwNUU2LCAweDA1RTcsIDB4MDVFOCwgMHgwNUU5LCAweDA1RUEsIDB4MDVGMCwgMHgwNUYxLFxuICAgICAgMHgwNUYyLCAweDA1RjMsIDB4MDVGNCwgMHgwNjA4LCAweDA2MEIsIDB4MDYwRCwgMHgwNjFCLCAweDA2MUUsIDB4MDYxRixcbiAgICAgIDB4MDYyMCwgMHgwNjIxLCAweDA2MjIsIDB4MDYyMywgMHgwNjI0LCAweDA2MjUsIDB4MDYyNiwgMHgwNjI3LCAweDA2MjgsXG4gICAgICAweDA2MjksIDB4MDYyQSwgMHgwNjJCLCAweDA2MkMsIDB4MDYyRCwgMHgwNjJFLCAweDA2MkYsIDB4MDYzMCwgMHgwNjMxLFxuICAgICAgMHgwNjMyLCAweDA2MzMsIDB4MDYzNCwgMHgwNjM1LCAweDA2MzYsIDB4MDYzNywgMHgwNjM4LCAweDA2MzksIDB4MDYzQSxcbiAgICAgIDB4MDYzQiwgMHgwNjNDLCAweDA2M0QsIDB4MDYzRSwgMHgwNjNGLCAweDA2NDAsIDB4MDY0MSwgMHgwNjQyLCAweDA2NDMsXG4gICAgICAweDA2NDQsIDB4MDY0NSwgMHgwNjQ2LCAweDA2NDcsIDB4MDY0OCwgMHgwNjQ5LCAweDA2NEEsIDB4MDY2RCwgMHgwNjZFLFxuICAgICAgMHgwNjZGLCAweDA2NzEsIDB4MDY3MiwgMHgwNjczLCAweDA2NzQsIDB4MDY3NSwgMHgwNjc2LCAweDA2NzcsIDB4MDY3OCxcbiAgICAgIDB4MDY3OSwgMHgwNjdBLCAweDA2N0IsIDB4MDY3QywgMHgwNjdELCAweDA2N0UsIDB4MDY3RiwgMHgwNjgwLCAweDA2ODEsXG4gICAgICAweDA2ODIsIDB4MDY4MywgMHgwNjg0LCAweDA2ODUsIDB4MDY4NiwgMHgwNjg3LCAweDA2ODgsIDB4MDY4OSwgMHgwNjhBLFxuICAgICAgMHgwNjhCLCAweDA2OEMsIDB4MDY4RCwgMHgwNjhFLCAweDA2OEYsIDB4MDY5MCwgMHgwNjkxLCAweDA2OTIsIDB4MDY5MyxcbiAgICAgIDB4MDY5NCwgMHgwNjk1LCAweDA2OTYsIDB4MDY5NywgMHgwNjk4LCAweDA2OTksIDB4MDY5QSwgMHgwNjlCLCAweDA2OUMsXG4gICAgICAweDA2OUQsIDB4MDY5RSwgMHgwNjlGLCAweDA2QTAsIDB4MDZBMSwgMHgwNkEyLCAweDA2QTMsIDB4MDZBNCwgMHgwNkE1LFxuICAgICAgMHgwNkE2LCAweDA2QTcsIDB4MDZBOCwgMHgwNkE5LCAweDA2QUEsIDB4MDZBQiwgMHgwNkFDLCAweDA2QUQsIDB4MDZBRSxcbiAgICAgIDB4MDZBRiwgMHgwNkIwLCAweDA2QjEsIDB4MDZCMiwgMHgwNkIzLCAweDA2QjQsIDB4MDZCNSwgMHgwNkI2LCAweDA2QjcsXG4gICAgICAweDA2QjgsIDB4MDZCOSwgMHgwNkJBLCAweDA2QkIsIDB4MDZCQywgMHgwNkJELCAweDA2QkUsIDB4MDZCRiwgMHgwNkMwLFxuICAgICAgMHgwNkMxLCAweDA2QzIsIDB4MDZDMywgMHgwNkM0LCAweDA2QzUsIDB4MDZDNiwgMHgwNkM3LCAweDA2QzgsIDB4MDZDOSxcbiAgICAgIDB4MDZDQSwgMHgwNkNCLCAweDA2Q0MsIDB4MDZDRCwgMHgwNkNFLCAweDA2Q0YsIDB4MDZEMCwgMHgwNkQxLCAweDA2RDIsXG4gICAgICAweDA2RDMsIDB4MDZENCwgMHgwNkQ1LCAweDA2RTUsIDB4MDZFNiwgMHgwNkVFLCAweDA2RUYsIDB4MDZGQSwgMHgwNkZCLFxuICAgICAgMHgwNkZDLCAweDA2RkQsIDB4MDZGRSwgMHgwNkZGLCAweDA3MDAsIDB4MDcwMSwgMHgwNzAyLCAweDA3MDMsIDB4MDcwNCxcbiAgICAgIDB4MDcwNSwgMHgwNzA2LCAweDA3MDcsIDB4MDcwOCwgMHgwNzA5LCAweDA3MEEsIDB4MDcwQiwgMHgwNzBDLCAweDA3MEQsXG4gICAgICAweDA3MEYsIDB4MDcxMCwgMHgwNzEyLCAweDA3MTMsIDB4MDcxNCwgMHgwNzE1LCAweDA3MTYsIDB4MDcxNywgMHgwNzE4LFxuICAgICAgMHgwNzE5LCAweDA3MUEsIDB4MDcxQiwgMHgwNzFDLCAweDA3MUQsIDB4MDcxRSwgMHgwNzFGLCAweDA3MjAsIDB4MDcyMSxcbiAgICAgIDB4MDcyMiwgMHgwNzIzLCAweDA3MjQsIDB4MDcyNSwgMHgwNzI2LCAweDA3MjcsIDB4MDcyOCwgMHgwNzI5LCAweDA3MkEsXG4gICAgICAweDA3MkIsIDB4MDcyQywgMHgwNzJELCAweDA3MkUsIDB4MDcyRiwgMHgwNzRELCAweDA3NEUsIDB4MDc0RiwgMHgwNzUwLFxuICAgICAgMHgwNzUxLCAweDA3NTIsIDB4MDc1MywgMHgwNzU0LCAweDA3NTUsIDB4MDc1NiwgMHgwNzU3LCAweDA3NTgsIDB4MDc1OSxcbiAgICAgIDB4MDc1QSwgMHgwNzVCLCAweDA3NUMsIDB4MDc1RCwgMHgwNzVFLCAweDA3NUYsIDB4MDc2MCwgMHgwNzYxLCAweDA3NjIsXG4gICAgICAweDA3NjMsIDB4MDc2NCwgMHgwNzY1LCAweDA3NjYsIDB4MDc2NywgMHgwNzY4LCAweDA3NjksIDB4MDc2QSwgMHgwNzZCLFxuICAgICAgMHgwNzZDLCAweDA3NkQsIDB4MDc2RSwgMHgwNzZGLCAweDA3NzAsIDB4MDc3MSwgMHgwNzcyLCAweDA3NzMsIDB4MDc3NCxcbiAgICAgIDB4MDc3NSwgMHgwNzc2LCAweDA3NzcsIDB4MDc3OCwgMHgwNzc5LCAweDA3N0EsIDB4MDc3QiwgMHgwNzdDLCAweDA3N0QsXG4gICAgICAweDA3N0UsIDB4MDc3RiwgMHgwNzgwLCAweDA3ODEsIDB4MDc4MiwgMHgwNzgzLCAweDA3ODQsIDB4MDc4NSwgMHgwNzg2LFxuICAgICAgMHgwNzg3LCAweDA3ODgsIDB4MDc4OSwgMHgwNzhBLCAweDA3OEIsIDB4MDc4QywgMHgwNzhELCAweDA3OEUsIDB4MDc4RixcbiAgICAgIDB4MDc5MCwgMHgwNzkxLCAweDA3OTIsIDB4MDc5MywgMHgwNzk0LCAweDA3OTUsIDB4MDc5NiwgMHgwNzk3LCAweDA3OTgsXG4gICAgICAweDA3OTksIDB4MDc5QSwgMHgwNzlCLCAweDA3OUMsIDB4MDc5RCwgMHgwNzlFLCAweDA3OUYsIDB4MDdBMCwgMHgwN0ExLFxuICAgICAgMHgwN0EyLCAweDA3QTMsIDB4MDdBNCwgMHgwN0E1LCAweDA3QjEsIDB4MDdDMCwgMHgwN0MxLCAweDA3QzIsIDB4MDdDMyxcbiAgICAgIDB4MDdDNCwgMHgwN0M1LCAweDA3QzYsIDB4MDdDNywgMHgwN0M4LCAweDA3QzksIDB4MDdDQSwgMHgwN0NCLCAweDA3Q0MsXG4gICAgICAweDA3Q0QsIDB4MDdDRSwgMHgwN0NGLCAweDA3RDAsIDB4MDdEMSwgMHgwN0QyLCAweDA3RDMsIDB4MDdENCwgMHgwN0Q1LFxuICAgICAgMHgwN0Q2LCAweDA3RDcsIDB4MDdEOCwgMHgwN0Q5LCAweDA3REEsIDB4MDdEQiwgMHgwN0RDLCAweDA3REQsIDB4MDdERSxcbiAgICAgIDB4MDdERiwgMHgwN0UwLCAweDA3RTEsIDB4MDdFMiwgMHgwN0UzLCAweDA3RTQsIDB4MDdFNSwgMHgwN0U2LCAweDA3RTcsXG4gICAgICAweDA3RTgsIDB4MDdFOSwgMHgwN0VBLCAweDA3RjQsIDB4MDdGNSwgMHgwN0ZBLCAweDA4MDAsIDB4MDgwMSwgMHgwODAyLFxuICAgICAgMHgwODAzLCAweDA4MDQsIDB4MDgwNSwgMHgwODA2LCAweDA4MDcsIDB4MDgwOCwgMHgwODA5LCAweDA4MEEsIDB4MDgwQixcbiAgICAgIDB4MDgwQywgMHgwODBELCAweDA4MEUsIDB4MDgwRiwgMHgwODEwLCAweDA4MTEsIDB4MDgxMiwgMHgwODEzLCAweDA4MTQsXG4gICAgICAweDA4MTUsIDB4MDgxQSwgMHgwODI0LCAweDA4MjgsIDB4MDgzMCwgMHgwODMxLCAweDA4MzIsIDB4MDgzMywgMHgwODM0LFxuICAgICAgMHgwODM1LCAweDA4MzYsIDB4MDgzNywgMHgwODM4LCAweDA4MzksIDB4MDgzQSwgMHgwODNCLCAweDA4M0MsIDB4MDgzRCxcbiAgICAgIDB4MDgzRSwgMHgwODQwLCAweDA4NDEsIDB4MDg0MiwgMHgwODQzLCAweDA4NDQsIDB4MDg0NSwgMHgwODQ2LCAweDA4NDcsXG4gICAgICAweDA4NDgsIDB4MDg0OSwgMHgwODRBLCAweDA4NEIsIDB4MDg0QywgMHgwODRELCAweDA4NEUsIDB4MDg0RiwgMHgwODUwLFxuICAgICAgMHgwODUxLCAweDA4NTIsIDB4MDg1MywgMHgwODU0LCAweDA4NTUsIDB4MDg1NiwgMHgwODU3LCAweDA4NTgsIDB4MDg1RSxcbiAgICAgIDB4MDhBMCwgMHgwOEEyLCAweDA4QTMsIDB4MDhBNCwgMHgwOEE1LCAweDA4QTYsIDB4MDhBNywgMHgwOEE4LCAweDA4QTksXG4gICAgICAweDA4QUEsIDB4MDhBQiwgMHgwOEFDLCAweDIwMEYsIDB4RkIxRCwgMHhGQjFGLCAweEZCMjAsIDB4RkIyMSwgMHhGQjIyLFxuICAgICAgMHhGQjIzLCAweEZCMjQsIDB4RkIyNSwgMHhGQjI2LCAweEZCMjcsIDB4RkIyOCwgMHhGQjJBLCAweEZCMkIsIDB4RkIyQyxcbiAgICAgIDB4RkIyRCwgMHhGQjJFLCAweEZCMkYsIDB4RkIzMCwgMHhGQjMxLCAweEZCMzIsIDB4RkIzMywgMHhGQjM0LCAweEZCMzUsXG4gICAgICAweEZCMzYsIDB4RkIzOCwgMHhGQjM5LCAweEZCM0EsIDB4RkIzQiwgMHhGQjNDLCAweEZCM0UsIDB4RkI0MCwgMHhGQjQxLFxuICAgICAgMHhGQjQzLCAweEZCNDQsIDB4RkI0NiwgMHhGQjQ3LCAweEZCNDgsIDB4RkI0OSwgMHhGQjRBLCAweEZCNEIsIDB4RkI0QyxcbiAgICAgIDB4RkI0RCwgMHhGQjRFLCAweEZCNEYsIDB4RkI1MCwgMHhGQjUxLCAweEZCNTIsIDB4RkI1MywgMHhGQjU0LCAweEZCNTUsXG4gICAgICAweEZCNTYsIDB4RkI1NywgMHhGQjU4LCAweEZCNTksIDB4RkI1QSwgMHhGQjVCLCAweEZCNUMsIDB4RkI1RCwgMHhGQjVFLFxuICAgICAgMHhGQjVGLCAweEZCNjAsIDB4RkI2MSwgMHhGQjYyLCAweEZCNjMsIDB4RkI2NCwgMHhGQjY1LCAweEZCNjYsIDB4RkI2NyxcbiAgICAgIDB4RkI2OCwgMHhGQjY5LCAweEZCNkEsIDB4RkI2QiwgMHhGQjZDLCAweEZCNkQsIDB4RkI2RSwgMHhGQjZGLCAweEZCNzAsXG4gICAgICAweEZCNzEsIDB4RkI3MiwgMHhGQjczLCAweEZCNzQsIDB4RkI3NSwgMHhGQjc2LCAweEZCNzcsIDB4RkI3OCwgMHhGQjc5LFxuICAgICAgMHhGQjdBLCAweEZCN0IsIDB4RkI3QywgMHhGQjdELCAweEZCN0UsIDB4RkI3RiwgMHhGQjgwLCAweEZCODEsIDB4RkI4MixcbiAgICAgIDB4RkI4MywgMHhGQjg0LCAweEZCODUsIDB4RkI4NiwgMHhGQjg3LCAweEZCODgsIDB4RkI4OSwgMHhGQjhBLCAweEZCOEIsXG4gICAgICAweEZCOEMsIDB4RkI4RCwgMHhGQjhFLCAweEZCOEYsIDB4RkI5MCwgMHhGQjkxLCAweEZCOTIsIDB4RkI5MywgMHhGQjk0LFxuICAgICAgMHhGQjk1LCAweEZCOTYsIDB4RkI5NywgMHhGQjk4LCAweEZCOTksIDB4RkI5QSwgMHhGQjlCLCAweEZCOUMsIDB4RkI5RCxcbiAgICAgIDB4RkI5RSwgMHhGQjlGLCAweEZCQTAsIDB4RkJBMSwgMHhGQkEyLCAweEZCQTMsIDB4RkJBNCwgMHhGQkE1LCAweEZCQTYsXG4gICAgICAweEZCQTcsIDB4RkJBOCwgMHhGQkE5LCAweEZCQUEsIDB4RkJBQiwgMHhGQkFDLCAweEZCQUQsIDB4RkJBRSwgMHhGQkFGLFxuICAgICAgMHhGQkIwLCAweEZCQjEsIDB4RkJCMiwgMHhGQkIzLCAweEZCQjQsIDB4RkJCNSwgMHhGQkI2LCAweEZCQjcsIDB4RkJCOCxcbiAgICAgIDB4RkJCOSwgMHhGQkJBLCAweEZCQkIsIDB4RkJCQywgMHhGQkJELCAweEZCQkUsIDB4RkJCRiwgMHhGQkMwLCAweEZCQzEsXG4gICAgICAweEZCRDMsIDB4RkJENCwgMHhGQkQ1LCAweEZCRDYsIDB4RkJENywgMHhGQkQ4LCAweEZCRDksIDB4RkJEQSwgMHhGQkRCLFxuICAgICAgMHhGQkRDLCAweEZCREQsIDB4RkJERSwgMHhGQkRGLCAweEZCRTAsIDB4RkJFMSwgMHhGQkUyLCAweEZCRTMsIDB4RkJFNCxcbiAgICAgIDB4RkJFNSwgMHhGQkU2LCAweEZCRTcsIDB4RkJFOCwgMHhGQkU5LCAweEZCRUEsIDB4RkJFQiwgMHhGQkVDLCAweEZCRUQsXG4gICAgICAweEZCRUUsIDB4RkJFRiwgMHhGQkYwLCAweEZCRjEsIDB4RkJGMiwgMHhGQkYzLCAweEZCRjQsIDB4RkJGNSwgMHhGQkY2LFxuICAgICAgMHhGQkY3LCAweEZCRjgsIDB4RkJGOSwgMHhGQkZBLCAweEZCRkIsIDB4RkJGQywgMHhGQkZELCAweEZCRkUsIDB4RkJGRixcbiAgICAgIDB4RkMwMCwgMHhGQzAxLCAweEZDMDIsIDB4RkMwMywgMHhGQzA0LCAweEZDMDUsIDB4RkMwNiwgMHhGQzA3LCAweEZDMDgsXG4gICAgICAweEZDMDksIDB4RkMwQSwgMHhGQzBCLCAweEZDMEMsIDB4RkMwRCwgMHhGQzBFLCAweEZDMEYsIDB4RkMxMCwgMHhGQzExLFxuICAgICAgMHhGQzEyLCAweEZDMTMsIDB4RkMxNCwgMHhGQzE1LCAweEZDMTYsIDB4RkMxNywgMHhGQzE4LCAweEZDMTksIDB4RkMxQSxcbiAgICAgIDB4RkMxQiwgMHhGQzFDLCAweEZDMUQsIDB4RkMxRSwgMHhGQzFGLCAweEZDMjAsIDB4RkMyMSwgMHhGQzIyLCAweEZDMjMsXG4gICAgICAweEZDMjQsIDB4RkMyNSwgMHhGQzI2LCAweEZDMjcsIDB4RkMyOCwgMHhGQzI5LCAweEZDMkEsIDB4RkMyQiwgMHhGQzJDLFxuICAgICAgMHhGQzJELCAweEZDMkUsIDB4RkMyRiwgMHhGQzMwLCAweEZDMzEsIDB4RkMzMiwgMHhGQzMzLCAweEZDMzQsIDB4RkMzNSxcbiAgICAgIDB4RkMzNiwgMHhGQzM3LCAweEZDMzgsIDB4RkMzOSwgMHhGQzNBLCAweEZDM0IsIDB4RkMzQywgMHhGQzNELCAweEZDM0UsXG4gICAgICAweEZDM0YsIDB4RkM0MCwgMHhGQzQxLCAweEZDNDIsIDB4RkM0MywgMHhGQzQ0LCAweEZDNDUsIDB4RkM0NiwgMHhGQzQ3LFxuICAgICAgMHhGQzQ4LCAweEZDNDksIDB4RkM0QSwgMHhGQzRCLCAweEZDNEMsIDB4RkM0RCwgMHhGQzRFLCAweEZDNEYsIDB4RkM1MCxcbiAgICAgIDB4RkM1MSwgMHhGQzUyLCAweEZDNTMsIDB4RkM1NCwgMHhGQzU1LCAweEZDNTYsIDB4RkM1NywgMHhGQzU4LCAweEZDNTksXG4gICAgICAweEZDNUEsIDB4RkM1QiwgMHhGQzVDLCAweEZDNUQsIDB4RkM1RSwgMHhGQzVGLCAweEZDNjAsIDB4RkM2MSwgMHhGQzYyLFxuICAgICAgMHhGQzYzLCAweEZDNjQsIDB4RkM2NSwgMHhGQzY2LCAweEZDNjcsIDB4RkM2OCwgMHhGQzY5LCAweEZDNkEsIDB4RkM2QixcbiAgICAgIDB4RkM2QywgMHhGQzZELCAweEZDNkUsIDB4RkM2RiwgMHhGQzcwLCAweEZDNzEsIDB4RkM3MiwgMHhGQzczLCAweEZDNzQsXG4gICAgICAweEZDNzUsIDB4RkM3NiwgMHhGQzc3LCAweEZDNzgsIDB4RkM3OSwgMHhGQzdBLCAweEZDN0IsIDB4RkM3QywgMHhGQzdELFxuICAgICAgMHhGQzdFLCAweEZDN0YsIDB4RkM4MCwgMHhGQzgxLCAweEZDODIsIDB4RkM4MywgMHhGQzg0LCAweEZDODUsIDB4RkM4NixcbiAgICAgIDB4RkM4NywgMHhGQzg4LCAweEZDODksIDB4RkM4QSwgMHhGQzhCLCAweEZDOEMsIDB4RkM4RCwgMHhGQzhFLCAweEZDOEYsXG4gICAgICAweEZDOTAsIDB4RkM5MSwgMHhGQzkyLCAweEZDOTMsIDB4RkM5NCwgMHhGQzk1LCAweEZDOTYsIDB4RkM5NywgMHhGQzk4LFxuICAgICAgMHhGQzk5LCAweEZDOUEsIDB4RkM5QiwgMHhGQzlDLCAweEZDOUQsIDB4RkM5RSwgMHhGQzlGLCAweEZDQTAsIDB4RkNBMSxcbiAgICAgIDB4RkNBMiwgMHhGQ0EzLCAweEZDQTQsIDB4RkNBNSwgMHhGQ0E2LCAweEZDQTcsIDB4RkNBOCwgMHhGQ0E5LCAweEZDQUEsXG4gICAgICAweEZDQUIsIDB4RkNBQywgMHhGQ0FELCAweEZDQUUsIDB4RkNBRiwgMHhGQ0IwLCAweEZDQjEsIDB4RkNCMiwgMHhGQ0IzLFxuICAgICAgMHhGQ0I0LCAweEZDQjUsIDB4RkNCNiwgMHhGQ0I3LCAweEZDQjgsIDB4RkNCOSwgMHhGQ0JBLCAweEZDQkIsIDB4RkNCQyxcbiAgICAgIDB4RkNCRCwgMHhGQ0JFLCAweEZDQkYsIDB4RkNDMCwgMHhGQ0MxLCAweEZDQzIsIDB4RkNDMywgMHhGQ0M0LCAweEZDQzUsXG4gICAgICAweEZDQzYsIDB4RkNDNywgMHhGQ0M4LCAweEZDQzksIDB4RkNDQSwgMHhGQ0NCLCAweEZDQ0MsIDB4RkNDRCwgMHhGQ0NFLFxuICAgICAgMHhGQ0NGLCAweEZDRDAsIDB4RkNEMSwgMHhGQ0QyLCAweEZDRDMsIDB4RkNENCwgMHhGQ0Q1LCAweEZDRDYsIDB4RkNENyxcbiAgICAgIDB4RkNEOCwgMHhGQ0Q5LCAweEZDREEsIDB4RkNEQiwgMHhGQ0RDLCAweEZDREQsIDB4RkNERSwgMHhGQ0RGLCAweEZDRTAsXG4gICAgICAweEZDRTEsIDB4RkNFMiwgMHhGQ0UzLCAweEZDRTQsIDB4RkNFNSwgMHhGQ0U2LCAweEZDRTcsIDB4RkNFOCwgMHhGQ0U5LFxuICAgICAgMHhGQ0VBLCAweEZDRUIsIDB4RkNFQywgMHhGQ0VELCAweEZDRUUsIDB4RkNFRiwgMHhGQ0YwLCAweEZDRjEsIDB4RkNGMixcbiAgICAgIDB4RkNGMywgMHhGQ0Y0LCAweEZDRjUsIDB4RkNGNiwgMHhGQ0Y3LCAweEZDRjgsIDB4RkNGOSwgMHhGQ0ZBLCAweEZDRkIsXG4gICAgICAweEZDRkMsIDB4RkNGRCwgMHhGQ0ZFLCAweEZDRkYsIDB4RkQwMCwgMHhGRDAxLCAweEZEMDIsIDB4RkQwMywgMHhGRDA0LFxuICAgICAgMHhGRDA1LCAweEZEMDYsIDB4RkQwNywgMHhGRDA4LCAweEZEMDksIDB4RkQwQSwgMHhGRDBCLCAweEZEMEMsIDB4RkQwRCxcbiAgICAgIDB4RkQwRSwgMHhGRDBGLCAweEZEMTAsIDB4RkQxMSwgMHhGRDEyLCAweEZEMTMsIDB4RkQxNCwgMHhGRDE1LCAweEZEMTYsXG4gICAgICAweEZEMTcsIDB4RkQxOCwgMHhGRDE5LCAweEZEMUEsIDB4RkQxQiwgMHhGRDFDLCAweEZEMUQsIDB4RkQxRSwgMHhGRDFGLFxuICAgICAgMHhGRDIwLCAweEZEMjEsIDB4RkQyMiwgMHhGRDIzLCAweEZEMjQsIDB4RkQyNSwgMHhGRDI2LCAweEZEMjcsIDB4RkQyOCxcbiAgICAgIDB4RkQyOSwgMHhGRDJBLCAweEZEMkIsIDB4RkQyQywgMHhGRDJELCAweEZEMkUsIDB4RkQyRiwgMHhGRDMwLCAweEZEMzEsXG4gICAgICAweEZEMzIsIDB4RkQzMywgMHhGRDM0LCAweEZEMzUsIDB4RkQzNiwgMHhGRDM3LCAweEZEMzgsIDB4RkQzOSwgMHhGRDNBLFxuICAgICAgMHhGRDNCLCAweEZEM0MsIDB4RkQzRCwgMHhGRDUwLCAweEZENTEsIDB4RkQ1MiwgMHhGRDUzLCAweEZENTQsIDB4RkQ1NSxcbiAgICAgIDB4RkQ1NiwgMHhGRDU3LCAweEZENTgsIDB4RkQ1OSwgMHhGRDVBLCAweEZENUIsIDB4RkQ1QywgMHhGRDVELCAweEZENUUsXG4gICAgICAweEZENUYsIDB4RkQ2MCwgMHhGRDYxLCAweEZENjIsIDB4RkQ2MywgMHhGRDY0LCAweEZENjUsIDB4RkQ2NiwgMHhGRDY3LFxuICAgICAgMHhGRDY4LCAweEZENjksIDB4RkQ2QSwgMHhGRDZCLCAweEZENkMsIDB4RkQ2RCwgMHhGRDZFLCAweEZENkYsIDB4RkQ3MCxcbiAgICAgIDB4RkQ3MSwgMHhGRDcyLCAweEZENzMsIDB4RkQ3NCwgMHhGRDc1LCAweEZENzYsIDB4RkQ3NywgMHhGRDc4LCAweEZENzksXG4gICAgICAweEZEN0EsIDB4RkQ3QiwgMHhGRDdDLCAweEZEN0QsIDB4RkQ3RSwgMHhGRDdGLCAweEZEODAsIDB4RkQ4MSwgMHhGRDgyLFxuICAgICAgMHhGRDgzLCAweEZEODQsIDB4RkQ4NSwgMHhGRDg2LCAweEZEODcsIDB4RkQ4OCwgMHhGRDg5LCAweEZEOEEsIDB4RkQ4QixcbiAgICAgIDB4RkQ4QywgMHhGRDhELCAweEZEOEUsIDB4RkQ4RiwgMHhGRDkyLCAweEZEOTMsIDB4RkQ5NCwgMHhGRDk1LCAweEZEOTYsXG4gICAgICAweEZEOTcsIDB4RkQ5OCwgMHhGRDk5LCAweEZEOUEsIDB4RkQ5QiwgMHhGRDlDLCAweEZEOUQsIDB4RkQ5RSwgMHhGRDlGLFxuICAgICAgMHhGREEwLCAweEZEQTEsIDB4RkRBMiwgMHhGREEzLCAweEZEQTQsIDB4RkRBNSwgMHhGREE2LCAweEZEQTcsIDB4RkRBOCxcbiAgICAgIDB4RkRBOSwgMHhGREFBLCAweEZEQUIsIDB4RkRBQywgMHhGREFELCAweEZEQUUsIDB4RkRBRiwgMHhGREIwLCAweEZEQjEsXG4gICAgICAweEZEQjIsIDB4RkRCMywgMHhGREI0LCAweEZEQjUsIDB4RkRCNiwgMHhGREI3LCAweEZEQjgsIDB4RkRCOSwgMHhGREJBLFxuICAgICAgMHhGREJCLCAweEZEQkMsIDB4RkRCRCwgMHhGREJFLCAweEZEQkYsIDB4RkRDMCwgMHhGREMxLCAweEZEQzIsIDB4RkRDMyxcbiAgICAgIDB4RkRDNCwgMHhGREM1LCAweEZEQzYsIDB4RkRDNywgMHhGREYwLCAweEZERjEsIDB4RkRGMiwgMHhGREYzLCAweEZERjQsXG4gICAgICAweEZERjUsIDB4RkRGNiwgMHhGREY3LCAweEZERjgsIDB4RkRGOSwgMHhGREZBLCAweEZERkIsIDB4RkRGQywgMHhGRTcwLFxuICAgICAgMHhGRTcxLCAweEZFNzIsIDB4RkU3MywgMHhGRTc0LCAweEZFNzYsIDB4RkU3NywgMHhGRTc4LCAweEZFNzksIDB4RkU3QSxcbiAgICAgIDB4RkU3QiwgMHhGRTdDLCAweEZFN0QsIDB4RkU3RSwgMHhGRTdGLCAweEZFODAsIDB4RkU4MSwgMHhGRTgyLCAweEZFODMsXG4gICAgICAweEZFODQsIDB4RkU4NSwgMHhGRTg2LCAweEZFODcsIDB4RkU4OCwgMHhGRTg5LCAweEZFOEEsIDB4RkU4QiwgMHhGRThDLFxuICAgICAgMHhGRThELCAweEZFOEUsIDB4RkU4RiwgMHhGRTkwLCAweEZFOTEsIDB4RkU5MiwgMHhGRTkzLCAweEZFOTQsIDB4RkU5NSxcbiAgICAgIDB4RkU5NiwgMHhGRTk3LCAweEZFOTgsIDB4RkU5OSwgMHhGRTlBLCAweEZFOUIsIDB4RkU5QywgMHhGRTlELCAweEZFOUUsXG4gICAgICAweEZFOUYsIDB4RkVBMCwgMHhGRUExLCAweEZFQTIsIDB4RkVBMywgMHhGRUE0LCAweEZFQTUsIDB4RkVBNiwgMHhGRUE3LFxuICAgICAgMHhGRUE4LCAweEZFQTksIDB4RkVBQSwgMHhGRUFCLCAweEZFQUMsIDB4RkVBRCwgMHhGRUFFLCAweEZFQUYsIDB4RkVCMCxcbiAgICAgIDB4RkVCMSwgMHhGRUIyLCAweEZFQjMsIDB4RkVCNCwgMHhGRUI1LCAweEZFQjYsIDB4RkVCNywgMHhGRUI4LCAweEZFQjksXG4gICAgICAweEZFQkEsIDB4RkVCQiwgMHhGRUJDLCAweEZFQkQsIDB4RkVCRSwgMHhGRUJGLCAweEZFQzAsIDB4RkVDMSwgMHhGRUMyLFxuICAgICAgMHhGRUMzLCAweEZFQzQsIDB4RkVDNSwgMHhGRUM2LCAweEZFQzcsIDB4RkVDOCwgMHhGRUM5LCAweEZFQ0EsIDB4RkVDQixcbiAgICAgIDB4RkVDQywgMHhGRUNELCAweEZFQ0UsIDB4RkVDRiwgMHhGRUQwLCAweEZFRDEsIDB4RkVEMiwgMHhGRUQzLCAweEZFRDQsXG4gICAgICAweEZFRDUsIDB4RkVENiwgMHhGRUQ3LCAweEZFRDgsIDB4RkVEOSwgMHhGRURBLCAweEZFREIsIDB4RkVEQywgMHhGRURELFxuICAgICAgMHhGRURFLCAweEZFREYsIDB4RkVFMCwgMHhGRUUxLCAweEZFRTIsIDB4RkVFMywgMHhGRUU0LCAweEZFRTUsIDB4RkVFNixcbiAgICAgIDB4RkVFNywgMHhGRUU4LCAweEZFRTksIDB4RkVFQSwgMHhGRUVCLCAweEZFRUMsIDB4RkVFRCwgMHhGRUVFLCAweEZFRUYsXG4gICAgICAweEZFRjAsIDB4RkVGMSwgMHhGRUYyLCAweEZFRjMsIDB4RkVGNCwgMHhGRUY1LCAweEZFRjYsIDB4RkVGNywgMHhGRUY4LFxuICAgICAgMHhGRUY5LCAweEZFRkEsIDB4RkVGQiwgMHhGRUZDLCAweDEwODAwLCAweDEwODAxLCAweDEwODAyLCAweDEwODAzLFxuICAgICAgMHgxMDgwNCwgMHgxMDgwNSwgMHgxMDgwOCwgMHgxMDgwQSwgMHgxMDgwQiwgMHgxMDgwQywgMHgxMDgwRCwgMHgxMDgwRSxcbiAgICAgIDB4MTA4MEYsIDB4MTA4MTAsIDB4MTA4MTEsIDB4MTA4MTIsIDB4MTA4MTMsIDB4MTA4MTQsIDB4MTA4MTUsIDB4MTA4MTYsXG4gICAgICAweDEwODE3LCAweDEwODE4LCAweDEwODE5LCAweDEwODFBLCAweDEwODFCLCAweDEwODFDLCAweDEwODFELCAweDEwODFFLFxuICAgICAgMHgxMDgxRiwgMHgxMDgyMCwgMHgxMDgyMSwgMHgxMDgyMiwgMHgxMDgyMywgMHgxMDgyNCwgMHgxMDgyNSwgMHgxMDgyNixcbiAgICAgIDB4MTA4MjcsIDB4MTA4MjgsIDB4MTA4MjksIDB4MTA4MkEsIDB4MTA4MkIsIDB4MTA4MkMsIDB4MTA4MkQsIDB4MTA4MkUsXG4gICAgICAweDEwODJGLCAweDEwODMwLCAweDEwODMxLCAweDEwODMyLCAweDEwODMzLCAweDEwODM0LCAweDEwODM1LCAweDEwODM3LFxuICAgICAgMHgxMDgzOCwgMHgxMDgzQywgMHgxMDgzRiwgMHgxMDg0MCwgMHgxMDg0MSwgMHgxMDg0MiwgMHgxMDg0MywgMHgxMDg0NCxcbiAgICAgIDB4MTA4NDUsIDB4MTA4NDYsIDB4MTA4NDcsIDB4MTA4NDgsIDB4MTA4NDksIDB4MTA4NEEsIDB4MTA4NEIsIDB4MTA4NEMsXG4gICAgICAweDEwODRELCAweDEwODRFLCAweDEwODRGLCAweDEwODUwLCAweDEwODUxLCAweDEwODUyLCAweDEwODUzLCAweDEwODU0LFxuICAgICAgMHgxMDg1NSwgMHgxMDg1NywgMHgxMDg1OCwgMHgxMDg1OSwgMHgxMDg1QSwgMHgxMDg1QiwgMHgxMDg1QywgMHgxMDg1RCxcbiAgICAgIDB4MTA4NUUsIDB4MTA4NUYsIDB4MTA5MDAsIDB4MTA5MDEsIDB4MTA5MDIsIDB4MTA5MDMsIDB4MTA5MDQsIDB4MTA5MDUsXG4gICAgICAweDEwOTA2LCAweDEwOTA3LCAweDEwOTA4LCAweDEwOTA5LCAweDEwOTBBLCAweDEwOTBCLCAweDEwOTBDLCAweDEwOTBELFxuICAgICAgMHgxMDkwRSwgMHgxMDkwRiwgMHgxMDkxMCwgMHgxMDkxMSwgMHgxMDkxMiwgMHgxMDkxMywgMHgxMDkxNCwgMHgxMDkxNSxcbiAgICAgIDB4MTA5MTYsIDB4MTA5MTcsIDB4MTA5MTgsIDB4MTA5MTksIDB4MTA5MUEsIDB4MTA5MUIsIDB4MTA5MjAsIDB4MTA5MjEsXG4gICAgICAweDEwOTIyLCAweDEwOTIzLCAweDEwOTI0LCAweDEwOTI1LCAweDEwOTI2LCAweDEwOTI3LCAweDEwOTI4LCAweDEwOTI5LFxuICAgICAgMHgxMDkyQSwgMHgxMDkyQiwgMHgxMDkyQywgMHgxMDkyRCwgMHgxMDkyRSwgMHgxMDkyRiwgMHgxMDkzMCwgMHgxMDkzMSxcbiAgICAgIDB4MTA5MzIsIDB4MTA5MzMsIDB4MTA5MzQsIDB4MTA5MzUsIDB4MTA5MzYsIDB4MTA5MzcsIDB4MTA5MzgsIDB4MTA5MzksXG4gICAgICAweDEwOTNGLCAweDEwOTgwLCAweDEwOTgxLCAweDEwOTgyLCAweDEwOTgzLCAweDEwOTg0LCAweDEwOTg1LCAweDEwOTg2LFxuICAgICAgMHgxMDk4NywgMHgxMDk4OCwgMHgxMDk4OSwgMHgxMDk4QSwgMHgxMDk4QiwgMHgxMDk4QywgMHgxMDk4RCwgMHgxMDk4RSxcbiAgICAgIDB4MTA5OEYsIDB4MTA5OTAsIDB4MTA5OTEsIDB4MTA5OTIsIDB4MTA5OTMsIDB4MTA5OTQsIDB4MTA5OTUsIDB4MTA5OTYsXG4gICAgICAweDEwOTk3LCAweDEwOTk4LCAweDEwOTk5LCAweDEwOTlBLCAweDEwOTlCLCAweDEwOTlDLCAweDEwOTlELCAweDEwOTlFLFxuICAgICAgMHgxMDk5RiwgMHgxMDlBMCwgMHgxMDlBMSwgMHgxMDlBMiwgMHgxMDlBMywgMHgxMDlBNCwgMHgxMDlBNSwgMHgxMDlBNixcbiAgICAgIDB4MTA5QTcsIDB4MTA5QTgsIDB4MTA5QTksIDB4MTA5QUEsIDB4MTA5QUIsIDB4MTA5QUMsIDB4MTA5QUQsIDB4MTA5QUUsXG4gICAgICAweDEwOUFGLCAweDEwOUIwLCAweDEwOUIxLCAweDEwOUIyLCAweDEwOUIzLCAweDEwOUI0LCAweDEwOUI1LCAweDEwOUI2LFxuICAgICAgMHgxMDlCNywgMHgxMDlCRSwgMHgxMDlCRiwgMHgxMEEwMCwgMHgxMEExMCwgMHgxMEExMSwgMHgxMEExMiwgMHgxMEExMyxcbiAgICAgIDB4MTBBMTUsIDB4MTBBMTYsIDB4MTBBMTcsIDB4MTBBMTksIDB4MTBBMUEsIDB4MTBBMUIsIDB4MTBBMUMsIDB4MTBBMUQsXG4gICAgICAweDEwQTFFLCAweDEwQTFGLCAweDEwQTIwLCAweDEwQTIxLCAweDEwQTIyLCAweDEwQTIzLCAweDEwQTI0LCAweDEwQTI1LFxuICAgICAgMHgxMEEyNiwgMHgxMEEyNywgMHgxMEEyOCwgMHgxMEEyOSwgMHgxMEEyQSwgMHgxMEEyQiwgMHgxMEEyQywgMHgxMEEyRCxcbiAgICAgIDB4MTBBMkUsIDB4MTBBMkYsIDB4MTBBMzAsIDB4MTBBMzEsIDB4MTBBMzIsIDB4MTBBMzMsIDB4MTBBNDAsIDB4MTBBNDEsXG4gICAgICAweDEwQTQyLCAweDEwQTQzLCAweDEwQTQ0LCAweDEwQTQ1LCAweDEwQTQ2LCAweDEwQTQ3LCAweDEwQTUwLCAweDEwQTUxLFxuICAgICAgMHgxMEE1MiwgMHgxMEE1MywgMHgxMEE1NCwgMHgxMEE1NSwgMHgxMEE1NiwgMHgxMEE1NywgMHgxMEE1OCwgMHgxMEE2MCxcbiAgICAgIDB4MTBBNjEsIDB4MTBBNjIsIDB4MTBBNjMsIDB4MTBBNjQsIDB4MTBBNjUsIDB4MTBBNjYsIDB4MTBBNjcsIDB4MTBBNjgsXG4gICAgICAweDEwQTY5LCAweDEwQTZBLCAweDEwQTZCLCAweDEwQTZDLCAweDEwQTZELCAweDEwQTZFLCAweDEwQTZGLCAweDEwQTcwLFxuICAgICAgMHgxMEE3MSwgMHgxMEE3MiwgMHgxMEE3MywgMHgxMEE3NCwgMHgxMEE3NSwgMHgxMEE3NiwgMHgxMEE3NywgMHgxMEE3OCxcbiAgICAgIDB4MTBBNzksIDB4MTBBN0EsIDB4MTBBN0IsIDB4MTBBN0MsIDB4MTBBN0QsIDB4MTBBN0UsIDB4MTBBN0YsIDB4MTBCMDAsXG4gICAgICAweDEwQjAxLCAweDEwQjAyLCAweDEwQjAzLCAweDEwQjA0LCAweDEwQjA1LCAweDEwQjA2LCAweDEwQjA3LCAweDEwQjA4LFxuICAgICAgMHgxMEIwOSwgMHgxMEIwQSwgMHgxMEIwQiwgMHgxMEIwQywgMHgxMEIwRCwgMHgxMEIwRSwgMHgxMEIwRiwgMHgxMEIxMCxcbiAgICAgIDB4MTBCMTEsIDB4MTBCMTIsIDB4MTBCMTMsIDB4MTBCMTQsIDB4MTBCMTUsIDB4MTBCMTYsIDB4MTBCMTcsIDB4MTBCMTgsXG4gICAgICAweDEwQjE5LCAweDEwQjFBLCAweDEwQjFCLCAweDEwQjFDLCAweDEwQjFELCAweDEwQjFFLCAweDEwQjFGLCAweDEwQjIwLFxuICAgICAgMHgxMEIyMSwgMHgxMEIyMiwgMHgxMEIyMywgMHgxMEIyNCwgMHgxMEIyNSwgMHgxMEIyNiwgMHgxMEIyNywgMHgxMEIyOCxcbiAgICAgIDB4MTBCMjksIDB4MTBCMkEsIDB4MTBCMkIsIDB4MTBCMkMsIDB4MTBCMkQsIDB4MTBCMkUsIDB4MTBCMkYsIDB4MTBCMzAsXG4gICAgICAweDEwQjMxLCAweDEwQjMyLCAweDEwQjMzLCAweDEwQjM0LCAweDEwQjM1LCAweDEwQjQwLCAweDEwQjQxLCAweDEwQjQyLFxuICAgICAgMHgxMEI0MywgMHgxMEI0NCwgMHgxMEI0NSwgMHgxMEI0NiwgMHgxMEI0NywgMHgxMEI0OCwgMHgxMEI0OSwgMHgxMEI0QSxcbiAgICAgIDB4MTBCNEIsIDB4MTBCNEMsIDB4MTBCNEQsIDB4MTBCNEUsIDB4MTBCNEYsIDB4MTBCNTAsIDB4MTBCNTEsIDB4MTBCNTIsXG4gICAgICAweDEwQjUzLCAweDEwQjU0LCAweDEwQjU1LCAweDEwQjU4LCAweDEwQjU5LCAweDEwQjVBLCAweDEwQjVCLCAweDEwQjVDLFxuICAgICAgMHgxMEI1RCwgMHgxMEI1RSwgMHgxMEI1RiwgMHgxMEI2MCwgMHgxMEI2MSwgMHgxMEI2MiwgMHgxMEI2MywgMHgxMEI2NCxcbiAgICAgIDB4MTBCNjUsIDB4MTBCNjYsIDB4MTBCNjcsIDB4MTBCNjgsIDB4MTBCNjksIDB4MTBCNkEsIDB4MTBCNkIsIDB4MTBCNkMsXG4gICAgICAweDEwQjZELCAweDEwQjZFLCAweDEwQjZGLCAweDEwQjcwLCAweDEwQjcxLCAweDEwQjcyLCAweDEwQjc4LCAweDEwQjc5LFxuICAgICAgMHgxMEI3QSwgMHgxMEI3QiwgMHgxMEI3QywgMHgxMEI3RCwgMHgxMEI3RSwgMHgxMEI3RiwgMHgxMEMwMCwgMHgxMEMwMSxcbiAgICAgIDB4MTBDMDIsIDB4MTBDMDMsIDB4MTBDMDQsIDB4MTBDMDUsIDB4MTBDMDYsIDB4MTBDMDcsIDB4MTBDMDgsIDB4MTBDMDksXG4gICAgICAweDEwQzBBLCAweDEwQzBCLCAweDEwQzBDLCAweDEwQzBELCAweDEwQzBFLCAweDEwQzBGLCAweDEwQzEwLCAweDEwQzExLFxuICAgICAgMHgxMEMxMiwgMHgxMEMxMywgMHgxMEMxNCwgMHgxMEMxNSwgMHgxMEMxNiwgMHgxMEMxNywgMHgxMEMxOCwgMHgxMEMxOSxcbiAgICAgIDB4MTBDMUEsIDB4MTBDMUIsIDB4MTBDMUMsIDB4MTBDMUQsIDB4MTBDMUUsIDB4MTBDMUYsIDB4MTBDMjAsIDB4MTBDMjEsXG4gICAgICAweDEwQzIyLCAweDEwQzIzLCAweDEwQzI0LCAweDEwQzI1LCAweDEwQzI2LCAweDEwQzI3LCAweDEwQzI4LCAweDEwQzI5LFxuICAgICAgMHgxMEMyQSwgMHgxMEMyQiwgMHgxMEMyQywgMHgxMEMyRCwgMHgxMEMyRSwgMHgxMEMyRiwgMHgxMEMzMCwgMHgxMEMzMSxcbiAgICAgIDB4MTBDMzIsIDB4MTBDMzMsIDB4MTBDMzQsIDB4MTBDMzUsIDB4MTBDMzYsIDB4MTBDMzcsIDB4MTBDMzgsIDB4MTBDMzksXG4gICAgICAweDEwQzNBLCAweDEwQzNCLCAweDEwQzNDLCAweDEwQzNELCAweDEwQzNFLCAweDEwQzNGLCAweDEwQzQwLCAweDEwQzQxLFxuICAgICAgMHgxMEM0MiwgMHgxMEM0MywgMHgxMEM0NCwgMHgxMEM0NSwgMHgxMEM0NiwgMHgxMEM0NywgMHgxMEM0OCwgMHgxRUUwMCxcbiAgICAgIDB4MUVFMDEsIDB4MUVFMDIsIDB4MUVFMDMsIDB4MUVFMDUsIDB4MUVFMDYsIDB4MUVFMDcsIDB4MUVFMDgsIDB4MUVFMDksXG4gICAgICAweDFFRTBBLCAweDFFRTBCLCAweDFFRTBDLCAweDFFRTBELCAweDFFRTBFLCAweDFFRTBGLCAweDFFRTEwLCAweDFFRTExLFxuICAgICAgMHgxRUUxMiwgMHgxRUUxMywgMHgxRUUxNCwgMHgxRUUxNSwgMHgxRUUxNiwgMHgxRUUxNywgMHgxRUUxOCwgMHgxRUUxOSxcbiAgICAgIDB4MUVFMUEsIDB4MUVFMUIsIDB4MUVFMUMsIDB4MUVFMUQsIDB4MUVFMUUsIDB4MUVFMUYsIDB4MUVFMjEsIDB4MUVFMjIsXG4gICAgICAweDFFRTI0LCAweDFFRTI3LCAweDFFRTI5LCAweDFFRTJBLCAweDFFRTJCLCAweDFFRTJDLCAweDFFRTJELCAweDFFRTJFLFxuICAgICAgMHgxRUUyRiwgMHgxRUUzMCwgMHgxRUUzMSwgMHgxRUUzMiwgMHgxRUUzNCwgMHgxRUUzNSwgMHgxRUUzNiwgMHgxRUUzNyxcbiAgICAgIDB4MUVFMzksIDB4MUVFM0IsIDB4MUVFNDIsIDB4MUVFNDcsIDB4MUVFNDksIDB4MUVFNEIsIDB4MUVFNEQsIDB4MUVFNEUsXG4gICAgICAweDFFRTRGLCAweDFFRTUxLCAweDFFRTUyLCAweDFFRTU0LCAweDFFRTU3LCAweDFFRTU5LCAweDFFRTVCLCAweDFFRTVELFxuICAgICAgMHgxRUU1RiwgMHgxRUU2MSwgMHgxRUU2MiwgMHgxRUU2NCwgMHgxRUU2NywgMHgxRUU2OCwgMHgxRUU2OSwgMHgxRUU2QSxcbiAgICAgIDB4MUVFNkMsIDB4MUVFNkQsIDB4MUVFNkUsIDB4MUVFNkYsIDB4MUVFNzAsIDB4MUVFNzEsIDB4MUVFNzIsIDB4MUVFNzQsXG4gICAgICAweDFFRTc1LCAweDFFRTc2LCAweDFFRTc3LCAweDFFRTc5LCAweDFFRTdBLCAweDFFRTdCLCAweDFFRTdDLCAweDFFRTdFLFxuICAgICAgMHgxRUU4MCwgMHgxRUU4MSwgMHgxRUU4MiwgMHgxRUU4MywgMHgxRUU4NCwgMHgxRUU4NSwgMHgxRUU4NiwgMHgxRUU4NyxcbiAgICAgIDB4MUVFODgsIDB4MUVFODksIDB4MUVFOEIsIDB4MUVFOEMsIDB4MUVFOEQsIDB4MUVFOEUsIDB4MUVFOEYsIDB4MUVFOTAsXG4gICAgICAweDFFRTkxLCAweDFFRTkyLCAweDFFRTkzLCAweDFFRTk0LCAweDFFRTk1LCAweDFFRTk2LCAweDFFRTk3LCAweDFFRTk4LFxuICAgICAgMHgxRUU5OSwgMHgxRUU5QSwgMHgxRUU5QiwgMHgxRUVBMSwgMHgxRUVBMiwgMHgxRUVBMywgMHgxRUVBNSwgMHgxRUVBNixcbiAgICAgIDB4MUVFQTcsIDB4MUVFQTgsIDB4MUVFQTksIDB4MUVFQUIsIDB4MUVFQUMsIDB4MUVFQUQsIDB4MUVFQUUsIDB4MUVFQUYsXG4gICAgICAweDFFRUIwLCAweDFFRUIxLCAweDFFRUIyLCAweDFFRUIzLCAweDFFRUI0LCAweDFFRUI1LCAweDFFRUI2LCAweDFFRUI3LFxuICAgICAgMHgxRUVCOCwgMHgxRUVCOSwgMHgxRUVCQSwgMHgxRUVCQiwgMHgxMEZGRkRdO1xuXG4gIGZ1bmN0aW9uIGRldGVybWluZUJpZGkoY3VlRGl2KSB7XG4gICAgdmFyIG5vZGVTdGFjayA9IFtdLFxuICAgICAgICB0ZXh0ID0gXCJcIixcbiAgICAgICAgY2hhckNvZGU7XG5cbiAgICBpZiAoIWN1ZURpdiB8fCAhY3VlRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIHJldHVybiBcImx0clwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hOb2Rlcyhub2RlU3RhY2ssIG5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSB7XG4gICAgICBpZiAoIW5vZGVTdGFjayB8fCAhbm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBub2RlU3RhY2sucG9wKCksXG4gICAgICAgICAgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lclRleHQ7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtYXRjaCBhbGwgdW5pY29kZSB0eXBlIEIgY2hhcmFjdGVycyAocGFyYWdyYXBoXG4gICAgICAgIC8vIHNlcGFyYXRvciBjaGFyYWN0ZXJzKS4gU2VlIGlzc3VlICMxMTUuXG4gICAgICAgIHZhciBtID0gdGV4dC5tYXRjaCgvXi4qKFxcbnxcXHIpLyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgbm9kZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcInJ1YnlcIikge1xuICAgICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICAgIHB1c2hOb2Rlcyhub2RlU3RhY2ssIG5vZGUpO1xuICAgICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaE5vZGVzKG5vZGVTdGFjaywgY3VlRGl2KTtcbiAgICB3aGlsZSAoKHRleHQgPSBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJvbmdSVExDaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChzdHJvbmdSVExDaGFyc1tqXSA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcInJ0bFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJsdHJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVMaW5lUG9zKGN1ZSkge1xuICAgIGlmICh0eXBlb2YgY3VlLmxpbmUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgKGN1ZS5zbmFwVG9MaW5lcyB8fCAoY3VlLmxpbmUgPj0gMCAmJiBjdWUubGluZSA8PSAxMDApKSkge1xuICAgICAgcmV0dXJuIGN1ZS5saW5lO1xuICAgIH1cbiAgICBpZiAoIWN1ZS50cmFjayB8fCAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QgfHxcbiAgICAgICAgIWN1ZS50cmFjay50ZXh0VHJhY2tMaXN0Lm1lZGlhRWxlbWVudCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgdHJhY2sgPSBjdWUudHJhY2ssXG4gICAgICAgIHRyYWNrTGlzdCA9IHRyYWNrLnRleHRUcmFja0xpc3QsXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGggJiYgdHJhY2tMaXN0W2ldICE9PSB0cmFjazsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tMaXN0W2ldLm1vZGUgPT09IFwic2hvd2luZ1wiKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiArK2NvdW50ICogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBTdHlsZUJveCgpIHtcbiAgfVxuXG4gIC8vIEFwcGx5IHN0eWxlcyB0byBhIGRpdi4gSWYgdGhlcmUgaXMgbm8gZGl2IHBhc3NlZCB0aGVuIGl0IGRlZmF1bHRzIHRvIHRoZVxuICAvLyBkaXYgb24gJ3RoaXMnLlxuICBTdHlsZUJveC5wcm90b3R5cGUuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMsIGRpdikge1xuICAgIGRpdiA9IGRpdiB8fCB0aGlzLmRpdjtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xuICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBkaXYuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFN0eWxlQm94LnByb3RvdHlwZS5mb3JtYXRTdHlsZSA9IGZ1bmN0aW9uKHZhbCwgdW5pdCkge1xuICAgIHJldHVybiB2YWwgPT09IDAgPyAwIDogdmFsICsgdW5pdDtcbiAgfTtcblxuICAvLyBDb25zdHJ1Y3RzIHRoZSBjb21wdXRlZCBkaXNwbGF5IHN0YXRlIG9mIHRoZSBjdWUgKGEgZGl2KS4gUGxhY2VzIHRoZSBkaXZcbiAgLy8gaW50byB0aGUgb3ZlcmxheSB3aGljaCBzaG91bGQgYmUgYSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KS5cbiAgZnVuY3Rpb24gQ3VlU3R5bGVCb3god2luZG93LCBjdWUsIHN0eWxlT3B0aW9ucykge1xuICAgIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgY29sb3IgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIjtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDAuOClcIjtcblxuICAgIGlmIChpc0lFOCkge1xuICAgICAgY29sb3IgPSBcInJnYigyNTUsIDI1NSwgMjU1KVwiO1xuICAgICAgYmFja2dyb3VuZENvbG9yID0gXCJyZ2IoMCwgMCwgMClcIjtcbiAgICB9XG5cbiAgICBTdHlsZUJveC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuY3VlID0gY3VlO1xuXG4gICAgLy8gUGFyc2Ugb3VyIGN1ZSdzIHRleHQgaW50byBhIERPTSB0cmVlIHJvb3RlZCBhdCAnY3VlRGl2Jy4gVGhpcyBkaXYgd2lsbFxuICAgIC8vIGhhdmUgaW5saW5lIHBvc2l0aW9uaW5nIGFuZCB3aWxsIGZ1bmN0aW9uIGFzIHRoZSBjdWUgYmFja2dyb3VuZCBib3guXG4gICAgdGhpcy5jdWVEaXYgPSBwYXJzZUNvbnRlbnQod2luZG93LCBjdWUudGV4dCk7XG4gICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGRpc3BsYXk6IFwiaW5saW5lXCJcbiAgICB9O1xuXG4gICAgaWYgKCFpc0lFOCkge1xuICAgICAgc3R5bGVzLndyaXRpbmdNb2RlID0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIjtcbiAgICAgIHN0eWxlcy51bmljb2RlQmlkaSA9IFwicGxhaW50ZXh0XCI7XG4gICAgfVxuICAgIHRoaXMuYXBwbHlTdHlsZXMoc3R5bGVzLCB0aGlzLmN1ZURpdik7XG5cbiAgICAvLyBDcmVhdGUgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGRpdiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwb3NpdGlvbiB0aGUgY3VlXG4gICAgLy8gZGl2LiBOb3RlLCBhbGwgV2ViVlRUIGN1ZS1zZXR0aW5nIGFsaWdubWVudHMgYXJlIGVxdWl2YWxlbnQgdG8gdGhlIENTU1xuICAgIC8vIG1pcnJvcnMgb2YgdGhlbSBleGNlcHQgXCJtaWRkbGVcIiB3aGljaCBpcyBcImNlbnRlclwiIGluIENTUy5cbiAgICB0aGlzLmRpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN0eWxlcyA9IHtcbiAgICAgIHRleHRBbGlnbjogY3VlLmFsaWduID09PSBcIm1pZGRsZVwiID8gXCJjZW50ZXJcIiA6IGN1ZS5hbGlnbixcbiAgICAgIGZvbnQ6IHN0eWxlT3B0aW9ucy5mb250LFxuICAgICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiLFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH07XG5cbiAgICBpZiAoIWlzSUU4KSB7XG4gICAgICBzdHlsZXMuZGlyZWN0aW9uID0gZGV0ZXJtaW5lQmlkaSh0aGlzLmN1ZURpdik7XG4gICAgICBzdHlsZXMud3JpdGluZ01vZGUgPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJ2ZXJ0aWNhbC1ybFwiLlxuICAgICAgc3R5bGVzdW5pY29kZUJpZGkgPSAgXCJwbGFpbnRleHRcIjtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcyk7XG5cbiAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmN1ZURpdik7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHJlZmVyZW5jZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgdGV4dFxuICAgIC8vIHBvc2l0aW9uIG9mIHRoZSBjdWUgYm94LiBUaGUgcmVmZXJlbmNlIGVkZ2Ugd2lsbCBiZSByZXNvbHZlZCBsYXRlciB3aGVuXG4gICAgLy8gdGhlIGJveCBvcmllbnRhdGlvbiBzdHlsZXMgYXJlIGFwcGxpZWQuXG4gICAgdmFyIHRleHRQb3MgPSAwO1xuICAgIHN3aXRjaCAoY3VlLnBvc2l0aW9uQWxpZ24pIHtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gKGN1ZS5zaXplIC8gMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gY3VlLnNpemU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBIb3Jpem9udGFsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZVxuICAgIC8vIGFyZWEgdG8gdGhlIGxlZnQgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgZGlzdGFuY2UgZXh0ZW5kaW5nIHRvXG4gICAgLy8gdGhlIHJpZ2h0IGZyb20gdGhlcmUuXG4gICAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIikge1xuICAgICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICAgIGxlZnQ6ICB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcbiAgICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgLy8gVmVydGljYWwgYm94IG9yaWVudGF0aW9uOyB0ZXh0UG9zIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGVcbiAgICAvLyBhcmVhIHRvIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgaGVpZ2h0IGV4dGVuZGluZ1xuICAgIC8vIGRvd253YXJkcyBmcm9tIHRoZXJlLlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgICAgdG9wOiB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGN1ZS5zaXplLCBcIiVcIilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubW92ZSA9IGZ1bmN0aW9uKGJveCkge1xuICAgICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZShib3gudG9wLCBcInB4XCIpLFxuICAgICAgICBib3R0b206IHRoaXMuZm9ybWF0U3R5bGUoYm94LmJvdHRvbSwgXCJweFwiKSxcbiAgICAgICAgbGVmdDogdGhpcy5mb3JtYXRTdHlsZShib3gubGVmdCwgXCJweFwiKSxcbiAgICAgICAgcmlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnJpZ2h0LCBcInB4XCIpLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoYm94LmhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoYm94LndpZHRoLCBcInB4XCIpXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIEN1ZVN0eWxlQm94LnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoU3R5bGVCb3gucHJvdG90eXBlKTtcbiAgQ3VlU3R5bGVCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3VlU3R5bGVCb3g7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY28tb3JkaW5hdGVzIG9mIGFuIEVsZW1lbnQgaW4gYSB3YXkgdGhhdCB3ZSBjYW4gZWFzaWx5XG4gIC8vIGNvbXB1dGUgdGhpbmdzIHdpdGggc3VjaCBhcyBpZiBpdCBvdmVybGFwcyBvciBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBFbGVtZW50LlxuICAvLyBDYW4gaW5pdGlhbGl6ZSBpdCB3aXRoIGVpdGhlciBhIFN0eWxlQm94IG9yIGFub3RoZXIgQm94UG9zaXRpb24uXG4gIGZ1bmN0aW9uIEJveFBvc2l0aW9uKG9iaikge1xuICAgIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgIC8vIEVpdGhlciBhIEJveFBvc2l0aW9uIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSBpdCwgb3IgYSBTdHlsZUJveFxuICAgIC8vIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSB0aGUgcmVzdWx0cyBvZiAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xuICAgIC8vIGFzIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgcmVhZG9ubHkuIEFsbCBjby1vcmRpbmF0ZSB2YWx1ZXMgYXJlIGluIHJlZmVyZW5jZVxuICAgIC8vIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4gKHRvcCBsZWZ0KS5cbiAgICB2YXIgbGgsIGhlaWdodCwgd2lkdGgsIHRvcDtcbiAgICBpZiAob2JqLmRpdikge1xuICAgICAgaGVpZ2h0ID0gb2JqLmRpdi5vZmZzZXRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9iai5kaXYub2Zmc2V0V2lkdGg7XG4gICAgICB0b3AgPSBvYmouZGl2Lm9mZnNldFRvcDtcblxuICAgICAgdmFyIHJlY3RzID0gKHJlY3RzID0gb2JqLmRpdi5jaGlsZE5vZGVzKSAmJiAocmVjdHMgPSByZWN0c1swXSkgJiZcbiAgICAgICAgICAgICAgICAgIHJlY3RzLmdldENsaWVudFJlY3RzICYmIHJlY3RzLmdldENsaWVudFJlY3RzKCk7XG4gICAgICBvYmogPSBvYmouZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gSW4gY2VydGFpbiBjYXNlcyB0aGUgb3V0dGVyIGRpdiB3aWxsIGJlIHNsaWdodGx5IGxhcmdlciB0aGVuIHRoZSBzdW0gb2ZcbiAgICAgIC8vIHRoZSBpbm5lciBkaXYncyBsaW5lcy4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gYm9sZCB0ZXh0LCBldGMsIG9uIHNvbWUgcGxhdGZvcm1zLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIHNob3VsZCBnZXQgdGhlIGF2ZXJhZ2UgbGluZSBoZWlnaHQgYW5kIHVzZSB0aGF0LiBUaGlzIHdpbGxcbiAgICAgIC8vIHJlc3VsdCBpbiB0aGUgZGVzaXJlZCBiZWhhdmlvdXIuXG4gICAgICBsaCA9IHJlY3RzID8gTWF0aC5tYXgoKHJlY3RzWzBdICYmIHJlY3RzWzBdLmhlaWdodCkgfHwgMCwgb2JqLmhlaWdodCAvIHJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgfVxuICAgIHRoaXMubGVmdCA9IG9iai5sZWZ0O1xuICAgIHRoaXMucmlnaHQgPSBvYmoucmlnaHQ7XG4gICAgdGhpcy50b3AgPSBvYmoudG9wIHx8IHRvcDtcbiAgICB0aGlzLmhlaWdodCA9IG9iai5oZWlnaHQgfHwgaGVpZ2h0O1xuICAgIHRoaXMuYm90dG9tID0gb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSk7XG4gICAgdGhpcy53aWR0aCA9IG9iai53aWR0aCB8fCB3aWR0aDtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaCAhPT0gdW5kZWZpbmVkID8gbGggOiBvYmoubGluZUhlaWdodDtcblxuICAgIGlmIChpc0lFOCAmJiAhdGhpcy5saW5lSGVpZ2h0KSB7XG4gICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxMztcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIHRoZSBib3ggYWxvbmcgYSBwYXJ0aWN1bGFyIGF4aXMuIE9wdGlvbmFsbHkgcGFzcyBpbiBhbiBhbW91bnQgdG8gbW92ZVxuICAvLyB0aGUgYm94LiBJZiBubyBhbW91bnQgaXMgcGFzc2VkIHRoZW4gdGhlIGRlZmF1bHQgaXMgdGhlIGxpbmUgaGVpZ2h0IG9mIHRoZVxuICAvLyBib3guXG4gIEJveFBvc2l0aW9uLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oYXhpcywgdG9Nb3ZlKSB7XG4gICAgdG9Nb3ZlID0gdG9Nb3ZlICE9PSB1bmRlZmluZWQgPyB0b01vdmUgOiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgc3dpdGNoIChheGlzKSB7XG4gICAgY2FzZSBcIit4XCI6XG4gICAgICB0aGlzLmxlZnQgKz0gdG9Nb3ZlO1xuICAgICAgdGhpcy5yaWdodCArPSB0b01vdmU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiLXhcIjpcbiAgICAgIHRoaXMubGVmdCAtPSB0b01vdmU7XG4gICAgICB0aGlzLnJpZ2h0IC09IHRvTW92ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIreVwiOlxuICAgICAgdGhpcy50b3AgKz0gdG9Nb3ZlO1xuICAgICAgdGhpcy5ib3R0b20gKz0gdG9Nb3ZlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIi15XCI6XG4gICAgICB0aGlzLnRvcCAtPSB0b01vdmU7XG4gICAgICB0aGlzLmJvdHRvbSAtPSB0b01vdmU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBib3ggb3ZlcmxhcHMgYW5vdGhlciBib3gsIGIyLlxuICBCb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihiMikge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPCBiMi5yaWdodCAmJlxuICAgICAgICAgICB0aGlzLnJpZ2h0ID4gYjIubGVmdCAmJlxuICAgICAgICAgICB0aGlzLnRvcCA8IGIyLmJvdHRvbSAmJlxuICAgICAgICAgICB0aGlzLmJvdHRvbSA+IGIyLnRvcDtcbiAgfTtcblxuICAvLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbnkgb3RoZXIgYm94ZXMgaW4gYm94ZXMuXG4gIEJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc0FueSA9IGZ1bmN0aW9uKGJveGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMub3ZlcmxhcHMoYm94ZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgd2l0aGluIGFub3RoZXIgYm94LlxuICBCb3hQb3NpdGlvbi5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wID49IGNvbnRhaW5lci50b3AgJiZcbiAgICAgICAgICAgdGhpcy5ib3R0b20gPD0gY29udGFpbmVyLmJvdHRvbSAmJlxuICAgICAgICAgICB0aGlzLmxlZnQgPj0gY29udGFpbmVyLmxlZnQgJiZcbiAgICAgICAgICAgdGhpcy5yaWdodCA8PSBjb250YWluZXIucmlnaHQ7XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgZW50aXJlbHkgd2l0aGluIHRoZSBjb250YWluZXIgb3IgaXQgaXMgb3ZlcmxhcHBpbmdcbiAgLy8gb24gdGhlIGVkZ2Ugb3Bwb3NpdGUgb2YgdGhlIGF4aXMgZGlyZWN0aW9uIHBhc3NlZC4gRm9yIGV4YW1wbGUsIGlmIFwiK3hcIiBpc1xuICAvLyBwYXNzZWQgYW5kIHRoZSBib3ggaXMgb3ZlcmxhcHBpbmcgb24gdGhlIGxlZnQgZWRnZSBvZiB0aGUgY29udGFpbmVyLCB0aGVuXG4gIC8vIHJldHVybiB0cnVlLlxuICBCb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHNPcHBvc2l0ZUF4aXMgPSBmdW5jdGlvbihjb250YWluZXIsIGF4aXMpIHtcbiAgICBzd2l0Y2ggKGF4aXMpIHtcbiAgICBjYXNlIFwiK3hcIjpcbiAgICAgIHJldHVybiB0aGlzLmxlZnQgPCBjb250YWluZXIubGVmdDtcbiAgICBjYXNlIFwiLXhcIjpcbiAgICAgIHJldHVybiB0aGlzLnJpZ2h0ID4gY29udGFpbmVyLnJpZ2h0O1xuICAgIGNhc2UgXCIreVwiOlxuICAgICAgcmV0dXJuIHRoaXMudG9wIDwgY29udGFpbmVyLnRvcDtcbiAgICBjYXNlIFwiLXlcIjpcbiAgICAgIHJldHVybiB0aGlzLmJvdHRvbSA+IGNvbnRhaW5lci5ib3R0b207XG4gICAgfVxuICB9O1xuXG4gIC8vIEZpbmQgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGFyZWEgdGhhdCB0aGlzIGJveCBpcyBvdmVybGFwcGluZyB3aXRoIGFub3RoZXJcbiAgLy8gYm94LlxuICBCb3hQb3NpdGlvbi5wcm90b3R5cGUuaW50ZXJzZWN0UGVyY2VudGFnZSA9IGZ1bmN0aW9uKGIyKSB7XG4gICAgdmFyIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnJpZ2h0LCBiMi5yaWdodCkgLSBNYXRoLm1heCh0aGlzLmxlZnQsIGIyLmxlZnQpKSxcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYm90dG9tLCBiMi5ib3R0b20pIC0gTWF0aC5tYXgodGhpcy50b3AsIGIyLnRvcCkpLFxuICAgICAgICBpbnRlcnNlY3RBcmVhID0geCAqIHk7XG4gICAgcmV0dXJuIGludGVyc2VjdEFyZWEgLyAodGhpcy5oZWlnaHQgKiB0aGlzLndpZHRoKTtcbiAgfTtcblxuICAvLyBDb252ZXJ0IHRoZSBwb3NpdGlvbnMgZnJvbSB0aGlzIGJveCB0byBDU1MgY29tcGF0aWJsZSBwb3NpdGlvbnMgdXNpbmdcbiAgLy8gdGhlIHJlZmVyZW5jZSBjb250YWluZXIncyBwb3NpdGlvbnMuIFRoaXMgaGFzIHRvIGJlIGRvbmUgYmVjYXVzZSB0aGlzXG4gIC8vIGJveCdzIHBvc2l0aW9ucyBhcmUgaW4gcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4sIHdoZXJlYXMsIENTU1xuICAvLyB2YWx1ZXMgYXJlIGluIHJlZmVyZWNuZSB0byB0aGVpciByZXNwZWN0aXZlIGVkZ2VzLlxuICBCb3hQb3NpdGlvbi5wcm90b3R5cGUudG9DU1NDb21wYXRWYWx1ZXMgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0aGlzLnRvcCAtIHJlZmVyZW5jZS50b3AsXG4gICAgICBib3R0b206IHJlZmVyZW5jZS5ib3R0b20gLSB0aGlzLmJvdHRvbSxcbiAgICAgIGxlZnQ6IHRoaXMubGVmdCAtIHJlZmVyZW5jZS5sZWZ0LFxuICAgICAgcmlnaHQ6IHJlZmVyZW5jZS5yaWdodCAtIHRoaXMucmlnaHQsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGhcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdldCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBib3gncyBwb3NpdGlvbiB3aXRob3V0IGFueXRoaW5nIGV4dHJhLlxuICAvLyBDYW4gcGFzcyBhIFN0eWxlQm94LCBIVE1MRWxlbWVudCwgb3IgYW5vdGhlciBCb3hQb3NpdG9uLlxuICBCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBoZWlnaHQgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRIZWlnaHQgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIHZhciB3aWR0aCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldFdpZHRoIDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0V2lkdGggOiAwO1xuICAgIHZhciB0b3AgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRUb3AgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRUb3AgOiAwO1xuXG4gICAgb2JqID0gb2JqLmRpdiA/IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgICAgICAgICAgICAgICAgb2JqLnRhZ05hbWUgPyBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBvYmo7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGxlZnQ6IG9iai5sZWZ0LFxuICAgICAgcmlnaHQ6IG9iai5yaWdodCxcbiAgICAgIHRvcDogb2JqLnRvcCB8fCB0b3AsXG4gICAgICBoZWlnaHQ6IG9iai5oZWlnaHQgfHwgaGVpZ2h0LFxuICAgICAgYm90dG9tOiBvYmouYm90dG9tIHx8ICh0b3AgKyAob2JqLmhlaWdodCB8fCBoZWlnaHQpKSxcbiAgICAgIHdpZHRoOiBvYmoud2lkdGggfHwgd2lkdGhcbiAgICB9O1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLy8gTW92ZSBhIFN0eWxlQm94IHRvIGl0cyBzcGVjaWZpZWQsIG9yIG5leHQgYmVzdCwgcG9zaXRpb24uIFRoZSBjb250YWluZXJCb3hcbiAgLy8gaXMgdGhlIGJveCB0aGF0IGNvbnRhaW5zIHRoZSBTdHlsZUJveCwgc3VjaCBhcyBhIGRpdi4gYm94UG9zaXRpb25zIGFyZVxuICAvLyBhIGxpc3Qgb2Ygb3RoZXIgYm94ZXMgdGhhdCB0aGUgc3R5bGVCb3ggY2FuJ3Qgb3ZlcmxhcCB3aXRoLlxuICBmdW5jdGlvbiBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpIHtcblxuICAgIC8vIEZpbmQgdGhlIGJlc3QgcG9zaXRpb24gZm9yIGEgY3VlIGJveCwgYiwgb24gdGhlIHZpZGVvLiBUaGUgYXhpcyBwYXJhbWV0ZXJcbiAgICAvLyBpcyBhIGxpc3Qgb2YgYXhpcywgdGhlIG9yZGVyIG9mIHdoaWNoLCBpdCB3aWxsIG1vdmUgdGhlIGJveCBhbG9uZy4gRm9yIGV4YW1wbGU6XG4gICAgLy8gUGFzc2luZyBbXCIreFwiLCBcIi14XCJdIHdpbGwgbW92ZSB0aGUgYm94IGZpcnN0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIHBvc2l0aXZlXG4gICAgLy8gZGlyZWN0aW9uLiBJZiBpdCBkb2Vzbid0IGZpbmQgYSBnb29kIHBvc2l0aW9uIGZvciBpdCB0aGVyZSBpdCB3aWxsIHRoZW4gbW92ZVxuICAgIC8vIGl0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbi5cbiAgICBmdW5jdGlvbiBmaW5kQmVzdFBvc2l0aW9uKGIsIGF4aXMpIHtcbiAgICAgIHZhciBiZXN0UG9zaXRpb24sXG4gICAgICAgICAgc3BlY2lmaWVkUG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYiksXG4gICAgICAgICAgcGVyY2VudGFnZSA9IDE7IC8vIEhpZ2hlc3QgcG9zc2libGUgc28gdGhlIGZpcnN0IHRoaW5nIHdlIGdldCBpcyBiZXR0ZXIuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoYi5vdmVybGFwc09wcG9zaXRlQXhpcyhjb250YWluZXJCb3gsIGF4aXNbaV0pIHx8XG4gICAgICAgICAgICAgICAoYi53aXRoaW4oY29udGFpbmVyQm94KSAmJiBiLm92ZXJsYXBzQW55KGJveFBvc2l0aW9ucykpKSB7XG4gICAgICAgICAgYi5tb3ZlKGF4aXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGZvdW5kIGEgc3BvdCB3aGVyZSB3ZSBhcmVuJ3Qgb3ZlcmxhcHBpbmcgYW55dGhpbmcuIFRoaXMgaXMgb3VyXG4gICAgICAgIC8vIGJlc3QgcG9zaXRpb24uXG4gICAgICAgIGlmIChiLndpdGhpbihjb250YWluZXJCb3gpKSB7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBiLmludGVyc2VjdFBlcmNlbnRhZ2UoY29udGFpbmVyQm94KTtcbiAgICAgICAgLy8gSWYgd2UncmUgb3V0c2lkZSB0aGUgY29udGFpbmVyIGJveCBsZXNzIHRoZW4gd2Ugd2VyZSBvbiBvdXIgbGFzdCB0cnlcbiAgICAgICAgLy8gdGhlbiByZW1lbWJlciB0aGlzIHBvc2l0aW9uIGFzIHRoZSBiZXN0IHBvc2l0aW9uLlxuICAgICAgICBpZiAocGVyY2VudGFnZSA+IHApIHtcbiAgICAgICAgICBiZXN0UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYik7XG4gICAgICAgICAgcGVyY2VudGFnZSA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIGJveCBwb3NpdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAgICBiID0gbmV3IEJveFBvc2l0aW9uKHNwZWNpZmllZFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZXN0UG9zaXRpb24gfHwgc3BlY2lmaWVkUG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIGJveFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKHN0eWxlQm94KSxcbiAgICAgICAgY3VlID0gc3R5bGVCb3guY3VlLFxuICAgICAgICBsaW5lUG9zID0gY29tcHV0ZUxpbmVQb3MoY3VlKSxcbiAgICAgICAgYXhpcyA9IFtdO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGxpbmUgbnVtYmVyIHRvIGFsaWduIHRoZSBjdWUgdG8uXG4gICAgaWYgKGN1ZS5zbmFwVG9MaW5lcykge1xuICAgICAgdmFyIHNpemU7XG4gICAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgICAgY2FzZSBcIlwiOlxuICAgICAgICBheGlzID0gWyBcIit5XCIsIFwiLXlcIiBdO1xuICAgICAgICBzaXplID0gXCJoZWlnaHRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmxcIjpcbiAgICAgICAgYXhpcyA9IFsgXCIreFwiLCBcIi14XCIgXTtcbiAgICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibHJcIjpcbiAgICAgICAgYXhpcyA9IFsgXCIteFwiLCBcIit4XCIgXTtcbiAgICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGVwID0gYm94UG9zaXRpb24ubGluZUhlaWdodCxcbiAgICAgICAgICBwb3NpdGlvbiA9IHN0ZXAgKiBNYXRoLnJvdW5kKGxpbmVQb3MpLFxuICAgICAgICAgIG1heFBvc2l0aW9uID0gY29udGFpbmVyQm94W3NpemVdICsgc3RlcCxcbiAgICAgICAgICBpbml0aWFsQXhpcyA9IGF4aXNbMF07XG5cbiAgICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgaW50aWFsIHBvc2l0aW9uIGlzIGdyZWF0ZXIgdGhlbiB0aGUgbWF4IHBvc2l0aW9uIHRoZW5cbiAgICAgIC8vIGNsYW1wIHRoZSBib3ggdG8gdGhlIGFtb3VudCBvZiBzdGVwcyBpdCB3b3VsZCB0YWtlIGZvciB0aGUgYm94IHRvXG4gICAgICAvLyByZWFjaCB0aGUgbWF4IHBvc2l0aW9uLlxuICAgICAgaWYgKE1hdGguYWJzKHBvc2l0aW9uKSA+IG1heFBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPCAwID8gLTEgOiAxO1xuICAgICAgICBwb3NpdGlvbiAqPSBNYXRoLmNlaWwobWF4UG9zaXRpb24gLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGNvbXB1dGVkIGxpbmUgcG9zaXRpb24gcmV0dXJucyBuZWdhdGl2ZSB0aGVuIGxpbmUgbnVtYmVycyBhcmVcbiAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHZpZGVvIGluc3RlYWQgb2YgdGhlIHRvcC4gVGhlcmVmb3JlLCB3ZVxuICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBvdXIgaW5pdGlhbCBwb3NpdGlvbiBieSB0aGUgbGVuZ3RoIG9yIHdpZHRoIG9mIHRoZVxuICAgICAgLy8gdmlkZW8sIGRlcGVuZGluZyBvbiB0aGUgd3JpdGluZyBkaXJlY3Rpb24sIGFuZCByZXZlcnNlIG91ciBheGlzIGRpcmVjdGlvbnMuXG4gICAgICBpZiAobGluZVBvcyA8IDApIHtcbiAgICAgICAgcG9zaXRpb24gKz0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gY29udGFpbmVyQm94LmhlaWdodCA6IGNvbnRhaW5lckJveC53aWR0aDtcbiAgICAgICAgYXhpcyA9IGF4aXMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIHRoZSBib3ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gVGhpcyBtYXkgbm90IGJlIGl0cyBiZXN0XG4gICAgICAvLyBwb3NpdGlvbi5cbiAgICAgIGJveFBvc2l0aW9uLm1vdmUoaW5pdGlhbEF4aXMsIHBvc2l0aW9uKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVyY2VudGFnZSBsaW5lIHZhbHVlIGZvciB0aGUgY3VlLlxuICAgICAgdmFyIGNhbGN1bGF0ZWRQZXJjZW50YWdlID0gKGJveFBvc2l0aW9uLmxpbmVIZWlnaHQgLyBjb250YWluZXJCb3guaGVpZ2h0KSAqIDEwMDtcblxuICAgICAgc3dpdGNoIChjdWUubGluZUFsaWduKSB7XG4gICAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICAgIGxpbmVQb3MgLT0gKGNhbGN1bGF0ZWRQZXJjZW50YWdlIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICBsaW5lUG9zIC09IGNhbGN1bGF0ZWRQZXJjZW50YWdlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgaW5pdGlhbCBsaW5lIHBvc2l0aW9uIHRvIHRoZSBjdWUgYm94LlxuICAgICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICAgIHRvcDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJybFwiOlxuICAgICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgICAgbGVmdDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsclwiOlxuICAgICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgICAgcmlnaHQ6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGF4aXMgPSBbIFwiK3lcIiwgXCIteFwiLCBcIit4XCIsIFwiLXlcIiBdO1xuXG4gICAgICAvLyBHZXQgdGhlIGJveCBwb3NpdGlvbiBhZ2FpbiBhZnRlciB3ZSd2ZSBhcHBsaWVkIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25pbmdcbiAgICAgIC8vIHRvIGl0LlxuICAgICAgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpO1xuICAgIH1cblxuICAgIHZhciBiZXN0UG9zaXRpb24gPSBmaW5kQmVzdFBvc2l0aW9uKGJveFBvc2l0aW9uLCBheGlzKTtcbiAgICBzdHlsZUJveC5tb3ZlKGJlc3RQb3NpdGlvbi50b0NTU0NvbXBhdFZhbHVlcyhjb250YWluZXJCb3gpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFdlYlZUVCgpIHtcbiAgICAvLyBOb3RoaW5nXG4gIH1cblxuICAvLyBIZWxwZXIgdG8gYWxsb3cgc3RyaW5ncyB0byBiZSBkZWNvZGVkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmluYXJ5IHV0ZjggZGF0YS5cbiAgV2ViVlRULlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVjb2RlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlID0gZnVuY3Rpb24od2luZG93LCBjdWV0ZXh0KSB7XG4gICAgaWYgKCF3aW5kb3cgfHwgIWN1ZXRleHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VDb250ZW50KHdpbmRvdywgY3VldGV4dCk7XG4gIH07XG5cbiAgdmFyIEZPTlRfU0laRV9QRVJDRU5UID0gMC4wNTtcbiAgdmFyIEZPTlRfU1RZTEUgPSBcInNhbnMtc2VyaWZcIjtcbiAgdmFyIENVRV9CQUNLR1JPVU5EX1BBRERJTkcgPSBcIjEuNSVcIjtcblxuICAvLyBSdW5zIHRoZSBwcm9jZXNzaW5nIG1vZGVsIG92ZXIgdGhlIGN1ZXMgYW5kIHJlZ2lvbnMgcGFzc2VkIHRvIGl0LlxuICAvLyBAcGFyYW0gb3ZlcmxheSBBIGJsb2NrIGxldmVsIGVsZW1lbnQgKHVzdWFsbHkgYSBkaXYpIHRoYXQgdGhlIGNvbXB1dGVkIGN1ZXNcbiAgLy8gICAgICAgICAgICAgICAgYW5kIHJlZ2lvbnMgd2lsbCBiZSBwbGFjZWQgaW50by5cbiAgV2ViVlRULnByb2Nlc3NDdWVzID0gZnVuY3Rpb24od2luZG93LCBjdWVzLCBvdmVybGF5KSB7XG4gICAgaWYgKCF3aW5kb3cgfHwgIWN1ZXMgfHwgIW92ZXJsYXkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgd2hpbGUgKG92ZXJsYXkuZmlyc3RDaGlsZCkge1xuICAgICAgb3ZlcmxheS5yZW1vdmVDaGlsZChvdmVybGF5LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHZhciBwYWRkZWRPdmVybGF5ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcGFkZGVkT3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBwYWRkZWRPdmVybGF5LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICBwYWRkZWRPdmVybGF5LnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgcGFkZGVkT3ZlcmxheS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICBwYWRkZWRPdmVybGF5LnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgIHBhZGRlZE92ZXJsYXkuc3R5bGUubWFyZ2luID0gQ1VFX0JBQ0tHUk9VTkRfUEFERElORztcbiAgICBvdmVybGF5LmFwcGVuZENoaWxkKHBhZGRlZE92ZXJsYXkpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgZGlzcGxheSBzdGF0ZXMgb2YgdGhlIGN1ZXMuIFRoaXMgY291bGRcbiAgICAvLyBiZSB0aGUgY2FzZSBpZiBhIGN1ZSdzIHN0YXRlIGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY29tcHV0YXRpb24gb3JcbiAgICAvLyBpZiBpdCBoYXMgbm90IGJlZW4gY29tcHV0ZWQgeWV0LlxuICAgIGZ1bmN0aW9uIHNob3VsZENvbXB1dGUoY3Vlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdWVzW2ldLmhhc0JlZW5SZXNldCB8fCAhY3Vlc1tpXS5kaXNwbGF5U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVjb21wdXRlIHRoZSBjdWVzJyBkaXNwbGF5IHN0YXRlcy4gSnVzdCByZXVzZSB0aGVtLlxuICAgIGlmICghc2hvdWxkQ29tcHV0ZShjdWVzKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoY3Vlc1tpXS5kaXNwbGF5U3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib3hQb3NpdGlvbnMgPSBbXSxcbiAgICAgICAgY29udGFpbmVyQm94ID0gQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24ocGFkZGVkT3ZlcmxheSksXG4gICAgICAgIGZvbnRTaXplID0gTWF0aC5yb3VuZChjb250YWluZXJCb3guaGVpZ2h0ICogRk9OVF9TSVpFX1BFUkNFTlQgKiAxMDApIC8gMTAwO1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSB7XG4gICAgICBmb250OiBmb250U2l6ZSArIFwicHggXCIgKyBGT05UX1NUWUxFXG4gICAgfTtcblxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHlsZUJveCwgY3VlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBpbnRpYWwgcG9zaXRpb24gYW5kIHN0eWxlcyBvZiB0aGUgY3VlIGRpdi5cbiAgICAgICAgc3R5bGVCb3ggPSBuZXcgQ3VlU3R5bGVCb3god2luZG93LCBjdWUsIHN0eWxlT3B0aW9ucyk7XG4gICAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoc3R5bGVCb3guZGl2KTtcblxuICAgICAgICAvLyBNb3ZlIHRoZSBjdWUgZGl2IHRvIGl0J3MgY29ycmVjdCBsaW5lIHBvc2l0aW9uLlxuICAgICAgICBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjb21wdXRlZCBkaXYgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBpdCBsYXRlclxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRvby5cbiAgICAgICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHN0eWxlQm94LmRpdjtcblxuICAgICAgICBib3hQb3NpdGlvbnMucHVzaChCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbihzdHlsZUJveCkpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH07XG5cbiAgV2ViVlRULlBhcnNlciA9IGZ1bmN0aW9uKHdpbmRvdywgdnR0anMsIGRlY29kZXIpIHtcbiAgICBpZiAoIWRlY29kZXIpIHtcbiAgICAgIGRlY29kZXIgPSB2dHRqcztcbiAgICAgIHZ0dGpzID0ge307XG4gICAgfVxuICAgIGlmICghdnR0anMpIHtcbiAgICAgIHZ0dGpzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgdGhpcy52dHRqcyA9IHZ0dGpzO1xuICAgIHRoaXMuc3RhdGUgPSBcIklOSVRJQUxcIjtcbiAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgdGhpcy5kZWNvZGVyID0gZGVjb2RlciB8fCBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpO1xuICAgIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xuICB9O1xuXG4gIFdlYlZUVC5QYXJzZXIucHJvdG90eXBlID0ge1xuICAgIC8vIElmIHRoZSBlcnJvciBpcyBhIFBhcnNpbmdFcnJvciB0aGVuIHJlcG9ydCBpdCB0byB0aGUgY29uc3VtZXIgaWZcbiAgICAvLyBwb3NzaWJsZS4gSWYgaXQncyBub3QgYSBQYXJzaW5nRXJyb3IgdGhlbiB0aHJvdyBpdCBsaWtlIG5vcm1hbC5cbiAgICByZXBvcnRPclRocm93RXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIHRoaXMub25wYXJzaW5nZXJyb3IgJiYgdGhpcy5vbnBhcnNpbmdlcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7c3RyZWFtOiB0cnVlfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH1cblxuICAgICAgLy8gMy40IFdlYlZUVCByZWdpb24gYW5kIFdlYlZUVCByZWdpb24gc2V0dGluZ3Mgc3ludGF4XG4gICAgICBmdW5jdGlvbiBwYXJzZVJlZ2lvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibGluZXNcIjpcbiAgICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVnaW9uYW5jaG9yXCI6XG4gICAgICAgICAgY2FzZSBcInZpZXdwb3J0YW5jaG9yXCI6XG4gICAgICAgICAgICB2YXIgeHkgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAoeHkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYWtlIHN1cmUgYm90aCB4IGFuZCB5IHBhcnNlLCBzbyB1c2UgYSB0ZW1wb3JhcnlcbiAgICAgICAgICAgIC8vIHNldHRpbmdzIG9iamVjdCBoZXJlLlxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgICAgICAgYW5jaG9yLnBlcmNlbnQoXCJ4XCIsIHh5WzBdKTtcbiAgICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieVwiLCB4eVsxXSk7XG4gICAgICAgICAgICBpZiAoIWFuY2hvci5oYXMoXCJ4XCIpIHx8ICFhbmNob3IuaGFzKFwieVwiKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJYXCIsIGFuY2hvci5nZXQoXCJ4XCIpKTtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJZXCIsIGFuY2hvci5nZXQoXCJ5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJ1cFwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC89LywgL1xccy8pO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcmVnaW9uLCB1c2luZyBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IHZhbHVlcyB0aGF0IHdlcmUgbm90XG4gICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHNldHRpbmdzLmhhcyhcImlkXCIpKSB7XG4gICAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyAoc2VsZi52dHRqcy5WVFRSZWdpb24gfHwgc2VsZi53aW5kb3cuVlRUUmVnaW9uKSgpO1xuICAgICAgICAgIHJlZ2lvbi53aWR0aCA9IHNldHRpbmdzLmdldChcIndpZHRoXCIsIDEwMCk7XG4gICAgICAgICAgcmVnaW9uLmxpbmVzID0gc2V0dGluZ3MuZ2V0KFwibGluZXNcIiwgMyk7XG4gICAgICAgICAgcmVnaW9uLnJlZ2lvbkFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25hbmNob3JYXCIsIDApO1xuICAgICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWVwiLCAxMDApO1xuICAgICAgICAgIHJlZ2lvbi52aWV3cG9ydEFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJ2aWV3cG9ydGFuY2hvclhcIiwgMCk7XG4gICAgICAgICAgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWSA9IHNldHRpbmdzLmdldChcInZpZXdwb3J0YW5jaG9yWVwiLCAxMDApO1xuICAgICAgICAgIHJlZ2lvbi5zY3JvbGwgPSBzZXR0aW5ncy5nZXQoXCJzY3JvbGxcIiwgXCJcIik7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHJlZ2lvbi5cbiAgICAgICAgICBzZWxmLm9ucmVnaW9uICYmIHNlbGYub25yZWdpb24ocmVnaW9uKTtcbiAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgVlRUUmVnaW9uIGZvciBsYXRlciBpbiBjYXNlIHdlIHBhcnNlIGFueSBWVFRDdWVzIHRoYXRcbiAgICAgICAgICAvLyByZWZlcmVuY2UgaXQuXG4gICAgICAgICAgc2VsZi5yZWdpb25MaXN0LnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNldHRpbmdzLmdldChcImlkXCIpLFxuICAgICAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICBjYXNlIFwiUmVnaW9uXCI6XG4gICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgLzovKTtcbiAgICAgIH1cblxuICAgICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbGluZTtcbiAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XG4gICAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG5cbiAgICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL15XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRTaWduYXR1cmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkhFQURFUlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIFwiSEVBREVSXCI6XG4gICAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJOT1RFXCI6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJJRFwiOlxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIk5PVEVcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdWUgPSBuZXcgKHNlbGYudnR0anMuVlRUQ3VlIHx8IHNlbGYud2luZG93LlZUVEN1ZSkoMCwgMCwgXCJcIik7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVcIjtcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiLS0+XCIpID09PSAtMSkge1xuICAgICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cbiAgICAgICAgICBjYXNlIFwiQ1VFXCI6XG4gICAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQkFEQ1VFXCI7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFVEVYVFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBcIkNVRVRFWFRcIjpcbiAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoXCItLT5cIikgIT09IC0xO1xuICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgIHNlbGYub25jdWUgJiYgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xuICAgICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiQkFEQ1VFXCI6IC8vIEJBRENVRVxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJDVUVURVhUXCIgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiID8gXCJCQURXRUJWVFRcIiA6IFwiQkFEQ1VFXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09IFwiSEVBREVSXCIpIHtcbiAgICAgICAgICBzZWxmLmJ1ZmZlciArPSBcIlxcblxcblwiO1xuICAgICAgICAgIHNlbGYucGFyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gbGluZS5cbiAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYub25mbHVzaCAmJiBzZWxmLm9uZmx1c2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBnbG9iYWwuV2ViVlRUID0gV2ViVlRUO1xuXG59KHRoaXMsICh0aGlzLnZ0dGpzIHx8IHt9KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZpZGVvLmpzL2Rpc3QvdmlkZW8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL2Rpc3QvdmlkZW8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSA0Il0sInNvdXJjZVJvb3QiOiIifQ==